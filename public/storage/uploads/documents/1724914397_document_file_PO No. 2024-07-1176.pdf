         if (parent && parent.kind === 291 /* SyntaxKind.JsxExpression */ && parent.parent &&
              parent.parent.kind === 288 /* SyntaxKind.JsxAttribute */) {
            // Currently we parse JsxOpeningLikeElement as:
            //      JsxOpeningLikeElement
            //          attributes: JsxAttributes
            //             properties: NodeArray<JsxAttributeLike>
            //                  each JsxAttribute can have initializer as JsxExpression
            return parent.parent.parent.parent;
          }
          if (parent && parent.kind === 290 /* SyntaxKind.JsxSpreadAttribute */) {
            // Currently we parse JsxOpeningLikeElement as:
            //      JsxOpeningLikeElement
            //          attributes: JsxAttributes
            //             properties: NodeArray<JsxAttributeLike>
            return parent.parent.parent;
          }
          break;
      }
    }
    return undefined;
  }
  /**
   * @returns true if we are certain that the currently edited location must define a new location; false otherwise.
   */
  function isSolelyIdentifierDefinitionLocation(contextToken) {
    const parent = contextToken.parent;
    const containingNodeKind = parent.kind;
    switch (contextToken.kind) {
      case 27 /* SyntaxKind.CommaToken */:
        return containingNodeKind === 257 /* SyntaxKind.VariableDeclaration */ ||
            isVariableDeclarationListButNotTypeArgument(contextToken) ||
            containingNodeKind === 240 /* SyntaxKind.VariableStatement */ ||
            containingNodeKind === 263 /* SyntaxKind.EnumDeclaration */ ||  // enum a { foo, |
            isFunctionLikeButNotConstructor(containingNodeKind) ||
            containingNodeKind === 261 /* SyntaxKind.InterfaceDeclaration */ ||  // interface A<T, |
            containingNodeKind === 204 /* SyntaxKind.ArrayBindingPattern */ ||   // var [x, y|
            containingNodeKind === 262 /* SyntaxKind.TypeAliasDeclaration */ ||  // type Map, K, |
            // class A<T, |
            // var C = class D<T, |
            (ts.isClassLike(parent) && !!parent.typeParameters && parent.typeParameters.end >= contextToken.pos);
      case 24 /* SyntaxKind.DotToken */:
        return containingNodeKind === 204 /* SyntaxKind.ArrayBindingPattern */;  // var [.|
      case 58 /* SyntaxKind.ColonToken */:
        return containingNodeKind === 205 /* SyntaxKind.BindingElement */;  // var {x :html|
      case 22 /* SyntaxKind.OpenBracketToken */:
        return containingNodeKind === 204 /* SyntaxKind.ArrayBindingPattern */;  // var [x|
      case 20 /* SyntaxKind.OpenParenToken */:
        return containingNodeKind === 295 /* SyntaxKind.CatchClause */ ||
            isFunctionLikeButNotConstructor(containingNodeKind);
      case 18 /* SyntaxKind.OpenBraceToken */:
        return containingNodeKind === 263 /* SyntaxKind.EnumDeclaration */;  // enum a { |
      case 29 /* SyntaxKind.LessThanToken */:
        return containingNodeKind === 260 /* SyntaxKind.ClassDeclaration */ ||   // class A< |
            containingNodeKind === 228 /* SyntaxKind.ClassExpression */ ||       // var C = class D< |
            containingNodeKind === 261 /* SyntaxKind.InterfaceDeclaration */ ||  // interface A< |
            containingNodeKind === 262 /* SyntaxKind.TypeAliasDeclaration */ ||  // type List< |
            ts.isFunctionLikeKind(containingNodeKind);
      case 124 /* SyntaxKind.StaticKeyword */:
        return containingNodeKind === 169 /* SyntaxKind.PropertyDeclaration */ && !ts.isClassLike(parent.parent);
      case 25 /* SyntaxKind.DotDotDotToken */:
        return containingNodeKind === 166 /* SyntaxKind.Parameter */ ||
            (!!parent.parent && parent.parent.kind === 204 /* SyntaxKind.ArrayBindingPattern */);  // var [...z|
      case 123 /* SyntaxKind.PublicKeyword */:
      case 121 /* SyntaxKind.PrivateKeyword */:
      case 122 /* SyntaxKind.ProtectedKeyword */:
        return containingNodeKind === 166 /* SyntaxKind.Parameter */ && !ts.isConstructorDeclaration(parent.parent);
      case 128 /* SyntaxKind.AsKeyword */:
        return containingNodeKind === 273 /* SyntaxKind.ImportSpecifier */ ||
            containingNodeKind === 278 /* SyntaxKind.ExportSpecifier */ ||
            containingNodeKind === 271 /* SyntaxKind.NamespaceImport */;
      case 137 /* SyntaxKind.GetKeyword */:
      case 151 /* SyntaxKind.SetKeyword */:
        return !isFromObjectTypeDeclaration(contextToken);
      case 79 /* SyntaxKind.Identifier */:
        if (containingNodeKind === 273 /* SyntaxKind.ImportSpecifier */ && contextToken === parent.name &&
            contextToken.text === 'type') {
          // import { type | }
          return false;
        }
        break;
      case 84 /* SyntaxKind.ClassKeyword */:
      case 92 /* SyntaxKind.EnumKeyword */:
      case 118 /* SyntaxKind.InterfaceKeyword */:
      case 98 /* SyntaxKind.FunctionKeyword */:
      case 113 /* SyntaxKind.VarKeyword */:
      case 100 /* SyntaxKind.ImportKeyword */:
      case 119 /* SyntaxKind.LetKeyword */:
      case 85 /* SyntaxKind.ConstKeyword */:
      case 138 /* SyntaxKind.InferKeyword */:
        return true;
      case 154 /* SyntaxKind.TypeKeyword */:
        // import { type foo| }
        return containingNodeKind !== 273 /* SyntaxKind.ImportSpecifier */;
      case 41 /* SyntaxKind.AsteriskToken */:
        return ts.isFunctionLike(contextToken.parent) && !ts.isMethodDeclaration(contextToken.parent);
    }
    // If the previous token is keyword corresponding to class member completion keyword
    // there will be completion available here
    if (isClassMemberCompletionKeyword(keywordForNode(contextToken)) && isFromObjectTypeDeclaration(contextToken)) {
      return false;
    }
    if (isConstructorParameterCompletion(contextToken)) {
      // constructor parameter completion is available only if
      // - its modifier of the constructor parameter or
      // - its name of the parameter and not being edited
      // eg. constructor(a |<- this shouldnt show completion
      if (!ts.isIdentifier(contextToken) || ts.isParameterPropertyModifier(keywordForNode(contextToken)) ||
          isCurrentlyEditingNode(contextToken)) {
        return false;
      }
    }
    // Previous token may have been a keyword that was converted to an identifier.
    switch (keywordForNode(contextToken)) {
      case 126 /* SyntaxKind.AbstractKeyword */:
      case 84 /* SyntaxKind.ClassKeyword */:
      case 85 /* SyntaxKind.ConstKeyword */:
      case 136 /* SyntaxKind.DeclareKeyword */:
      case 92 /* SyntaxKind.EnumKeyword */:
      case 98 /* SyntaxKind.FunctionKeyword */:
      case 118 /* SyntaxKind.InterfaceKeyword */:
      case 119 /* SyntaxKind.LetKeyword */:
      case 121 /* SyntaxKind.PrivateKeyword */:
      case 122 /* SyntaxKind.ProtectedKeyword */:
      case 123 /* SyntaxKind.PublicKeyword */:
      case 124 /* SyntaxKind.StaticKeyword */:
      case 113 /* SyntaxKind.VarKeyword */:
        return true;
      case 132 /* SyntaxKind.AsyncKeyword */:
        return ts.isPropertyDeclaration(contextToken.parent);
    }
    // If we are inside a class declaration, and `constructor` is totally not present,
    // but we request a completion manually at a whitespace...
    const ancestorClassLike = ts.findAncestor(contextToken.parent, ts.isClassLike);
    if (ancestorClassLike && contextToken === previousToken &&
        isPreviousPropertyDeclarationTerminated(contextToken, position)) {
      return false;  // Don't block completions.
    }
    const ancestorPropertyDeclaraion = ts.getAncestor(contextToken.parent, 169 /* SyntaxKind.PropertyDeclaration */);
    // If we are inside a class declaration and typing `constructor` after property declaration...
    if (ancestorPropertyDeclaraion && contextToken !== previousToken &&
        ts.isClassLike(previousToken.parent.parent)
        // And the cursor is at the token...
        && position <= previousToken.end) {
      // If we are sure that the previous property declaration is terminated according to newline or semicolon...
      if (isPreviousPropertyDeclarationTerminated(contextToken, previousToken.end)) {
        return false;  // Don't block completions.
      } if (
          contextToken.kind !== 63 /* SyntaxKind.EqualsToken */
          // Should not block: `class C { blah = c/**/ }`
          // But should block: `class C { blah = somewhat c/**/ }` and `class C { blah: SomeType c/**/ }`
          && (ts.isInitializedProperty(ancestorPropertyDeclaraion) || ts.hasType(ancestorPropertyDeclaraion))) {
        return true;
      }
    }
    return ts.isDeclarationName(contextToken) && !ts.isShorthandPropertyAssignment(contextToken.parent) &&
        !ts.isJsxAttribute(contextToken.parent)
        // Don't block completions if we're in `class C /**/`, because we're *past* the end of the identifier and might want to complete `extends`.
        // If `contextToken !== previousToken`, this is `class C ex/**/`.
        && !(ts.isClassLike(contextToken.parent) && (contextToken !== previousToken || position > previousToken.end));
  }
  function isPreviousPropertyDeclarationTerminated(contextToken, position) {
    return contextToken.kind !== 63 /* SyntaxKind.EqualsToken */ &&
        (contextToken.kind === 26 /* SyntaxKind.SemicolonToken */
         || !ts.positionsAreOnSameLine(contextToken.end, position, sourceFile));
  }
  function isFunctionLikeButNotConstructor(kind) {
    return ts.isFunctionLikeKind(kind) && kind !== 173 /* SyntaxKind.Constructor */;
  }
  function isDotOfNumericLiteral(contextToken) {
    if (contextToken.kind === 8 /* SyntaxKind.NumericLiteral */) {
      const text = contextToken.getFullText();
      return text.charAt(text.length - 1) === '.';
    }
    return false;
  }
  function isVariableDeclarationListButNotTypeArgument(node) {
    return node.parent.kind === 258 /* SyntaxKind.VariableDeclarationList */
        && !ts.isPossiblyTypeArgumentPosition(node, sourceFile, typeChecker);
  }
  /**
   * Filters out completion suggestions for named imports or exports.
   *
   * @returns Symbols to be suggested in an object binding pattern or object literal expression, barring those whose declarations
   *          do not occur at the current position and have not otherwise been typed.
   */
  function filterObjectMembersList(contextualMemberSymbols, existingMembers) {
    if (existingMembers.length === 0) {
      return contextualMemberSymbols;
    }
    const membersDeclaredBySpreadAssignment = new ts.Set();
    const existingMemberNames = new ts.Set();
    for (let _i = 0, existingMembers_1 = existingMembers; _i < existingMembers_1.length; _i++) {
      const m = existingMembers_1[_i];
      // Ignore omitted expressions for missing members
      if (m.kind !== 299 /* SyntaxKind.PropertyAssignment */ &&
          m.kind !== 300 /* SyntaxKind.ShorthandPropertyAssignment */ &&
          m.kind !== 205 /* SyntaxKind.BindingElement */ && m.kind !== 171 /* SyntaxKind.MethodDeclaration */ &&
          m.kind !== 174 /* SyntaxKind.GetAccessor */ && m.kind !== 175 /* SyntaxKind.SetAccessor */ &&
          m.kind !== 301 /* SyntaxKind.SpreadAssignment */) {
        continue;
      }
      // If this is the current item we are editing right now, do not filter it out
      if (isCurrentlyEditingNode(m)) {
        continue;
      }
      let existingName = void 0;
      if (ts.isSpreadAssignment(m)) {
        setMembersDeclaredBySpreadAssignment(m, membersDeclaredBySpreadAssignment);
      } else if (ts.isBindingElement(m) && m.propertyName) {
        // include only identifiers in completion list
        if (m.propertyName.kind === 79 /* SyntaxKind.Identifier */) {
          existingName = m.propertyName.escapedText;
        }
      } else {
        // TODO: Account for computed property name
        // NOTE: if one only performs this step when m.name is an identifier,
        // things like '__proto__' are not filtered out.
        const name = ts.getNameOfDeclaration(m);
        existingName =
            name && ts.isPropertyNameLiteral(name) ? ts.getEscapedTextOfIdentifierOrLiteral(name) : undefined;
      }
      if (existingName !== undefined) {
        existingMemberNames.add(existingName);
      }
    }
    const filteredSymbols = contextualMemberSymbols.filter(function(m) {
      return !existingMemberNames.has(m.escapedName);
    });
    setSortTextToMemberDeclaredBySpreadAssignment(membersDeclaredBySpreadAssignment, filteredSymbols);
    return filteredSymbols;
  }
  function setMembersDeclaredBySpreadAssignment(declaration, membersDeclaredBySpreadAssignment) {
    const expression = declaration.expression;
    const symbol = typeChecker.getSymbolAtLocation(expression);
    const type = symbol && typeChecker.getTypeOfSymbolAtLocation(symbol, expression);
    const properties = type && type.properties;
    if (properties) {
      properties.forEach(function(property) {
        membersDeclaredBySpreadAssignment.add(property.name);
      });
    }
  }
  // Set SortText to OptionalMember if it is an optional member
  function setSortTextToOptionalMember() {
    symbols.forEach(function(m) {
      let _a;
      if (m.flags & 16777216 /* SymbolFlags.Optional */) {
        const symbolId = ts.getSymbolId(m);
        symbolToSortTextMap[symbolId] =
            (_a = symbolToSortTextMap[symbolId]) !== null && _a !== void 0 ? _a : Completions.SortText.OptionalMember;
      }
    });
  }
  // Set SortText to MemberDeclaredBySpreadAssignment if it is fulfilled by spread assignment
  function setSortTextToMemberDeclaredBySpreadAssignment(membersDeclaredBySpreadAssignment, contextualMemberSymbols) {
    if (membersDeclaredBySpreadAssignment.size === 0) {
      return;
    }
    for (let _i = 0, contextualMemberSymbols_1 = contextualMemberSymbols; _i < contextualMemberSymbols_1.length; _i++) {
      const contextualMemberSymbol = contextualMemberSymbols_1[_i];
      if (membersDeclaredBySpreadAssignment.has(contextualMemberSymbol.name)) {
        symbolToSortTextMap[ts.getSymbolId(contextualMemberSymbol)] =
            Completions.SortText.MemberDeclaredBySpreadAssignment;
      }
    }
  }
  function transformObjectLiteralMembersSortText(start) {
    let _a;
    for (let i = start; i < symbols.length; i++) {
      const symbol = symbols[i];
      const symbolId = ts.getSymbolId(symbol);
      const origin =
          symbolToOriginInfoMap === null || symbolToOriginInfoMap === void 0 ? void 0 : symbolToOriginInfoMap[i];
      const target = ts.getEmitScriptTarget(compilerOptions);
      const displayName = getCompletionEntryDisplayNameForSymbol(
          symbol, target, origin, 0 /* CompletionKind.ObjectPropertyDeclaration */,
          /* jsxIdentifierExpected*/ false);
      if (displayName) {
        const originalSortText =
            (_a = symbolToSortTextMap[symbolId]) !== null && _a !== void 0 ? _a : Completions.SortText.LocationPriority;
        const name = displayName.name;
        symbolToSortTextMap[symbolId] = Completions.SortText.ObjectLiteralProperty(originalSortText, name);
      }
    }
  }
  /**
   * Filters out completion suggestions for class elements.
   *
   * @returns Symbols to be suggested in an class element depending on existing memebers and symbol flags
   */
  function filterClassMembersList(baseSymbols, existingMembers, currentClassElementModifierFlags) {
    const existingMemberNames = new ts.Set();
    for (let _i = 0, existingMembers_2 = existingMembers; _i < existingMembers_2.length; _i++) {
      const m = existingMembers_2[_i];
      // Ignore omitted expressions for missing members
      if (m.kind !== 169 /* SyntaxKind.PropertyDeclaration */ && m.kind !== 171 /* SyntaxKind.MethodDeclaration */ &&
          m.kind !== 174 /* SyntaxKind.GetAccessor */ && m.kind !== 175 /* SyntaxKind.SetAccessor */) {
        continue;
      }
      // If this is the current item we are editing right now, do not filter it out
      if (isCurrentlyEditingNode(m)) {
        continue;
      }
      // Dont filter member even if the name matches if it is declared private in the list
      if (ts.hasEffectiveModifier(m, 8 /* ModifierFlags.Private */)) {
        continue;
      }
      // do not filter it out if the static presence doesnt match
      if (ts.isStatic(m) !== !!(currentClassElementModifierFlags & 32 /* ModifierFlags.Static */)) {
        continue;
      }
      const existingName = ts.getPropertyNameForPropertyNameNode(m.name);
      if (existingName) {
        existingMemberNames.add(existingName);
      }
    }
    return baseSymbols.filter(function(propertySymbol) {
      return !existingMemberNames.has(propertySymbol.escapedName) && !!propertySymbol.declarations &&
          !(ts.getDeclarationModifierFlagsFromSymbol(propertySymbol) & 8 /* ModifierFlags.Private */) &&
          !(propertySymbol.valueDeclaration &&
            ts.isPrivateIdentifierClassElementDeclaration(propertySymbol.valueDeclaration));
    });
  }
  /**
   * Filters out completion suggestions from 'symbols' according to existing JSX attributes.
   *
   * @returns Symbols to be suggested in a JSX element, barring those whose attributes
   *          do not occur at the current position and have not otherwise been typed.
   */
  function filterJsxAttributes(symbols, attributes) {
    const seenNames = new ts.Set();
    const membersDeclaredBySpreadAssignment = new ts.Set();
    for (let _i = 0, attributes_1 = attributes; _i < attributes_1.length; _i++) {
      const attr = attributes_1[_i];
      // If this is the current item we are editing right now, do not filter it out
      if (isCurrentlyEditingNode(attr)) {
        continue;
      }
      if (attr.kind === 288 /* SyntaxKind.JsxAttribute */) {
        seenNames.add(attr.name.escapedText);
      } else if (ts.isJsxSpreadAttribute(attr)) {
        setMembersDeclaredBySpreadAssignment(attr, membersDeclaredBySpreadAssignment);
      }
    }
    const filteredSymbols = symbols.filter(function(a) {
      return !seenNames.has(a.escapedName);
    });
    setSortTextToMemberDeclaredBySpreadAssignment(membersDeclaredBySpreadAssignment, filteredSymbols);
    return filteredSymbols;
  }
  function isCurrentlyEditingNode(node) {
    return node.getStart(sourceFile) <= position && position <= node.getEnd();
  }
}
/**
 * Returns the immediate owning object literal or binding pattern of a context token,
 * on the condition that one exists and that the context implies completion should be given.
 */
function tryGetObjectLikeCompletionContainer(contextToken) {
  if (contextToken) {
    const parent = contextToken.parent;
    switch (contextToken.kind) {
      case 18 /* SyntaxKind.OpenBraceToken */:  // const x = { |
      case 27 /* SyntaxKind.CommaToken */:      // const x = { a: 0, |
        if (ts.isObjectLiteralExpression(parent) || ts.isObjectBindingPattern(parent)) {
          return parent;
        }
        break;
      case 41 /* SyntaxKind.AsteriskToken */:
        return ts.isMethodDeclaration(parent) ? ts.tryCast(parent.parent, ts.isObjectLiteralExpression) : undefined;
      case 79 /* SyntaxKind.Identifier */:
        return contextToken.text === 'async' && ts.isShorthandPropertyAssignment(contextToken.parent) ?
            contextToken.parent.parent :
            undefined;
    }
  }
  return undefined;
}
function getRelevantTokens(position, sourceFile) {
  const previousToken = ts.findPrecedingToken(position, sourceFile);
  if (previousToken && position <= previousToken.end &&
      (ts.isMemberName(previousToken) || ts.isKeyword(previousToken.kind))) {
    const contextToken =
        ts.findPrecedingToken(previousToken.getFullStart(), sourceFile, /* startNode*/ undefined);  // TODO: GH#18217
    return {contextToken, previousToken};
  }
  return {contextToken: previousToken, previousToken};
}
function getAutoImportSymbolFromCompletionEntryData(name, data, program, host) {
  const containingProgram = data.isPackageJsonImport ? host.getPackageJsonAutoImportProvider() : program;
  const checker = containingProgram.getTypeChecker();
  const moduleSymbol = data.ambientModuleName ?
      checker.tryFindAmbientModule(data.ambientModuleName) :
      data.fileName ?
      checker.getMergedSymbol(ts.Debug.checkDefined(containingProgram.getSourceFile(data.fileName)).symbol) :
      undefined;
  if (!moduleSymbol)
    {return undefined;}
  let symbol = data.exportName === 'export=' /* InternalSymbolName.ExportEquals */
      ?
      checker.resolveExternalModuleSymbol(moduleSymbol) :
      checker.tryGetMemberInModuleExportsAndProperties(data.exportName, moduleSymbol);
  if (!symbol)
    {return undefined;}
  const isDefaultExport = data.exportName === 'default' /* InternalSymbolName.Default */;
  symbol = isDefaultExport && ts.getLocalSymbolForExportDefault(symbol) || symbol;
  return {symbol, origin: completionEntryDataToSymbolOriginInfo(data, name, moduleSymbol)};
}
function getCompletionEntryDisplayNameForSymbol(symbol, target, origin, kind, jsxIdentifierExpected) {
  const name = originIncludesSymbolName(origin) ? origin.symbolName : symbol.name;
  if (name === undefined
      // If the symbol is external module, don't show it in the completion list
      // (i.e declare module "http" { const x; } | // <= request completion here, "http" should not be there)
      || symbol.flags & 1536 /* SymbolFlags.Module */ && ts.isSingleOrDoubleQuote(name.charCodeAt(0))
      // If the symbol is the internal name of an ES symbol, it is not a valid entry. Internal names for ES symbols start with "__@"
      || ts.isKnownSymbol(symbol)) {
    return undefined;
  }
  const validNameResult = {name, needsConvertPropertyAccess: false};
  if (ts.isIdentifierText(
          name, target, jsxIdentifierExpected ? 1 /* LanguageVariant.JSX */ : 0 /* LanguageVariant.Standard */) ||
      symbol.valueDeclaration && ts.isPrivateIdentifierClassElementDeclaration(symbol.valueDeclaration)) {
    return validNameResult;
  }
  switch (kind) {
    case 3 /* CompletionKind.MemberLike */:
      return undefined;
    case 0 /* CompletionKind.ObjectPropertyDeclaration */:
      // TODO: GH#18169
      return {name: JSON.stringify(name), needsConvertPropertyAccess: false};
    case 2 /* CompletionKind.PropertyAccess */:
    case 1 /* CompletionKind.Global */:  // For a 'this.' completion it will be in a global context, but may have a non-identifier name.
      // Don't add a completion for a name starting with a space. See https://github.com/Microsoft/TypeScript/pull/20547
      return name.charCodeAt(0) === 32 /* CharacterCodes.space */ ? undefined :
                                                                    {name, needsConvertPropertyAccess: true};
    case 5 /* CompletionKind.None */:
    case 4 /* CompletionKind.String */:
      return validNameResult;
    default:
      ts.Debug.assertNever(kind);
  }
}
// A cache of completion entries for keywords, these do not change between sessions
const _keywordCompletions = [];
var allKeywordsCompletions = ts.memoize(function() {
  const res = [];
  for (let i = 81 /* SyntaxKind.FirstKeyword */; i <= 162 /* SyntaxKind.LastKeyword */; i++) {
    res.push({
      name: ts.tokenToString(i),
      kind: 'keyword' /* ScriptElementKind.keyword */,
      kindModifiers: '' /* ScriptElementKindModifier.none */,
      sortText: Completions.SortText.GlobalsOrKeywords
    });
  }
  return res;
});
function getKeywordCompletions(keywordFilter, filterOutTsOnlyKeywords) {
  if (!filterOutTsOnlyKeywords)
    {return getTypescriptKeywordCompletions(keywordFilter);}
  const index = keywordFilter + 8 /* KeywordCompletionFilters.Last */ + 1;
  return _keywordCompletions[index] ||
      (_keywordCompletions[index] = getTypescriptKeywordCompletions(keywordFilter).filter(function(entry) {
           return !isTypeScriptOnlyKeyword(ts.stringToToken(entry.name));
         }));
}
function getTypescriptKeywordCompletions(keywordFilter) {
  return _keywordCompletions[keywordFilter] ||
      (_keywordCompletions[keywordFilter] = allKeywordsCompletions().filter(function(entry) {
           const kind = ts.stringToToken(entry.name);
           switch (keywordFilter) {
             case 0 /* KeywordCompletionFilters.None */:
               return false;
             case 1 /* KeywordCompletionFilters.All */:
               return isFunctionLikeBodyKeyword(kind) || kind === 136 /* SyntaxKind.DeclareKeyword */
                   || kind === 142                                    /* SyntaxKind.ModuleKeyword */
                   || kind === 154                                    /* SyntaxKind.TypeKeyword */
                   || kind === 143                                    /* SyntaxKind.NamespaceKeyword */
                   || kind === 126                                    /* SyntaxKind.AbstractKeyword */
                   || ts.isTypeKeyword(kind) && kind !== 155 /* SyntaxKind.UndefinedKeyword */;
             case 5 /* KeywordCompletionFilters.FunctionLikeBodyKeywords */:
               return isFunctionLikeBodyKeyword(kind);
             case 2 /* KeywordCompletionFilters.ClassElementKeywords */:
               return isClassMemberCompletionKeyword(kind);
             case 3 /* KeywordCompletionFilters.InterfaceElementKeywords */:
               return isInterfaceOrTypeLiteralCompletionKeyword(kind);
             case 4 /* KeywordCompletionFilters.ConstructorParameterKeywords */:
               return ts.isParameterPropertyModifier(kind);
             case 6 /* KeywordCompletionFilters.TypeAssertionKeywords */:
               return ts.isTypeKeyword(kind) || kind === 85 /* SyntaxKind.ConstKeyword */;
             case 7 /* KeywordCompletionFilters.TypeKeywords */:
               return ts.isTypeKeyword(kind);
             case 8 /* KeywordCompletionFilters.TypeKeyword */:
               return kind === 154 /* SyntaxKind.TypeKeyword */;
             default:
               return ts.Debug.assertNever(keywordFilter);
           }
         }));
}
function isTypeScriptOnlyKeyword(kind) {
  switch (kind) {
    case 126 /* SyntaxKind.AbstractKeyword */:
    case 131 /* SyntaxKind.AnyKeyword */:
    case 160 /* SyntaxKind.BigIntKeyword */:
    case 134 /* SyntaxKind.BooleanKeyword */:
    case 136 /* SyntaxKind.DeclareKeyword */:
    case 92 /* SyntaxKind.EnumKeyword */:
    case 159 /* SyntaxKind.GlobalKeyword */:
    case 117 /* SyntaxKind.ImplementsKeyword */:
    case 138 /* SyntaxKind.InferKeyword */:
    case 118 /* SyntaxKind.InterfaceKeyword */:
    case 140 /* SyntaxKind.IsKeyword */:
    case 141 /* SyntaxKind.KeyOfKeyword */:
    case 142 /* SyntaxKind.ModuleKeyword */:
    case 143 /* SyntaxKind.NamespaceKeyword */:
    case 144 /* SyntaxKind.NeverKeyword */:
    case 148 /* SyntaxKind.NumberKeyword */:
    case 149 /* SyntaxKind.ObjectKeyword */:
    case 161 /* SyntaxKind.OverrideKeyword */:
    case 121 /* SyntaxKind.PrivateKeyword */:
    case 122 /* SyntaxKind.ProtectedKeyword */:
    case 123 /* SyntaxKind.PublicKeyword */:
    case 146 /* SyntaxKind.ReadonlyKeyword */:
    case 152 /* SyntaxKind.StringKeyword */:
    case 153 /* SyntaxKind.SymbolKeyword */:
    case 154 /* SyntaxKind.TypeKeyword */:
    case 156 /* SyntaxKind.UniqueKeyword */:
    case 157 /* SyntaxKind.UnknownKeyword */:
      return true;
    default:
      return false;
  }
}
function isInterfaceOrTypeLiteralCompletionKeyword(kind) {
  return kind === 146 /* SyntaxKind.ReadonlyKeyword */;
}
function isClassMemberCompletionKeyword(kind) {
  switch (kind) {
    case 126 /* SyntaxKind.AbstractKeyword */:
    case 127 /* SyntaxKind.AccessorKeyword */:
    case 135 /* SyntaxKind.ConstructorKeyword */:
    case 137 /* SyntaxKind.GetKeyword */:
    case 151 /* SyntaxKind.SetKeyword */:
    case 132 /* SyntaxKind.AsyncKeyword */:
    case 136 /* SyntaxKind.DeclareKeyword */:
    case 161 /* SyntaxKind.OverrideKeyword */:
      return true;
    default:
      return ts.isClassMemberModifier(kind);
  }
}
function isFunctionLikeBodyKeyword(kind) {
  return kind === 132 /* SyntaxKind.AsyncKeyword */
      || kind === 133 /* SyntaxKind.AwaitKeyword */
      || kind === 128 /* SyntaxKind.AsKeyword */
      || kind === 150 /* SyntaxKind.SatisfiesKeyword */
      || kind === 154 /* SyntaxKind.TypeKeyword */
      || !ts.isContextualKeyword(kind) && !isClassMemberCompletionKeyword(kind);
}
function keywordForNode(node) {
  return ts.isIdentifier(node) ? node.originalKeywordKind || 0 /* SyntaxKind.Unknown */ : node.kind;
}
function getContextualKeywords(contextToken, position) {
  const entries = [];
  /**
   * An `AssertClause` can come after an import declaration:
   *  import * from "foo" |
   *  import "foo" |
   * or after a re-export declaration that has a module specifier:
   *  export { foo } from "foo" |
   * Source: https://tc39.es/proposal-import-assertions/
   */
  if (contextToken) {
    const file = contextToken.getSourceFile();
    const parent = contextToken.parent;
    const tokenLine = file.getLineAndCharacterOfPosition(contextToken.end).line;
    const currentLine = file.getLineAndCharacterOfPosition(position).line;
    if ((ts.isImportDeclaration(parent) || ts.isExportDeclaration(parent) && parent.moduleSpecifier) &&
        contextToken === parent.moduleSpecifier && tokenLine === currentLine) {
      entries.push({
        name: ts.tokenToString(130 /* SyntaxKind.AssertKeyword */),
        kind: 'keyword' /* ScriptElementKind.keyword */,
        kindModifiers: '' /* ScriptElementKindModifier.none */,
        sortText: Completions.SortText.GlobalsOrKeywords,
      });
    }
  }
  return entries;
}
/** Get the corresponding JSDocTag node if the position is in a jsDoc comment */
function getJsDocTagAtPosition(node, position) {
  return ts.findAncestor(node, function(n) {
    return ts.isJSDocTag(n) && ts.rangeContainsPosition(n, position) ? true : ts.isJSDoc(n) ? 'quit' : false;
  });
}
function getPropertiesForObjectExpression(contextualType, completionsType, obj, checker) {
  const hasCompletionsType = completionsType && completionsType !== contextualType;
  const type = hasCompletionsType && !(completionsType.flags & 3 /* TypeFlags.AnyOrUnknown */) ?
      checker.getUnionType([contextualType, completionsType]) :
      contextualType;
  const properties = getApparentProperties(type, obj, checker);
  return type.isClass() && containsNonPublicProperties(properties) ? [] :
      hasCompletionsType ? ts.filter(properties, hasDeclarationOtherThanSelf) :
                           properties;
  // Filter out members whose only declaration is the object literal itself to avoid
  // self-fulfilling completions like:
  //
  // function f<T>(x: T) {}
  // f({ abc/**/: "" }) // `abc` is a member of `T` but only because it declares itself
  function hasDeclarationOtherThanSelf(member) {
    if (!ts.length(member.declarations))
      {return true;}
    return ts.some(member.declarations, function(decl) {
      return decl.parent !== obj;
    });
  }
}
Completions.getPropertiesForObjectExpression = getPropertiesForObjectExpression;
function getApparentProperties(type, node, checker) {
  if (!type.isUnion())
    {return type.getApparentProperties();}
  return checker.getAllPossiblePropertiesOfTypes(ts.filter(type.types, function(memberType) {
    return !(
        memberType.flags & 131068 /* TypeFlags.Primitive */
        || checker.isArrayLikeType(memberType) || checker.isTypeInvalidDueToUnionDiscriminant(memberType, node) ||
        ts.typeHasCallOrConstructSignatures(memberType, checker) ||
        memberType.isClass() && containsNonPublicProperties(memberType.getApparentProperties()));
  }));
}
function containsNonPublicProperties(props) {
  return ts.some(props, function(p) {
    return !!(ts.getDeclarationModifierFlagsFromSymbol(p) & 24 /* ModifierFlags.NonPublicAccessibilityModifier */);
  });
}
/**
 * Gets all properties on a type, but if that type is a union of several types,
 * excludes array-like types or callable/constructable types.
 */
function getPropertiesForCompletion(type, checker) {
  return type.isUnion() ?
      ts.Debug.checkEachDefined(
          checker.getAllPossiblePropertiesOfTypes(type.types),
          'getAllPossiblePropertiesOfTypes() should all be defined') :
      ts.Debug.checkEachDefined(type.getApparentProperties(), 'getApparentProperties() should all be defined');
}
/**
 * Returns the immediate owning class declaration of a context token,
 * on the condition that one exists and that the context implies completion should be given.
 */
function tryGetObjectTypeDeclarationCompletionContainer(sourceFile, contextToken, location, position) {
  // class c { method() { } | method2() { } }
  switch (location.kind) {
    case 351 /* SyntaxKind.SyntaxList */:
      return ts.tryCast(location.parent, ts.isObjectTypeDeclaration);
    case 1 /* SyntaxKind.EndOfFileToken */:
      var cls = ts.tryCast(
          ts.lastOrUndefined(ts.cast(location.parent, ts.isSourceFile).statements), ts.isObjectTypeDeclaration);
      if (cls && !ts.findChildOfKind(cls, 19 /* SyntaxKind.CloseBraceToken */, sourceFile)) {
        return cls;
      }
      break;
    case 79 /* SyntaxKind.Identifier */: {
      const originalKeywordKind = location.originalKeywordKind;
      if (originalKeywordKind && ts.isKeyword(originalKeywordKind)) {
        return undefined;
      }
      // class c { public prop = c| }
      if (ts.isPropertyDeclaration(location.parent) && location.parent.initializer === location) {
        return undefined;
      }
      // class c extends React.Component { a: () => 1\n compon| }
      if (isFromObjectTypeDeclaration(location)) {
        return ts.findAncestor(location, ts.isObjectTypeDeclaration);
      }
    }
  }
  if (!contextToken)
    {return undefined;}
  // class C { blah; constructor/**/ } and so on
  if (location.kind === 135 /* SyntaxKind.ConstructorKeyword */
      // class C { blah \n constructor/**/ }
      || (ts.isIdentifier(contextToken) && ts.isPropertyDeclaration(contextToken.parent) && ts.isClassLike(location))) {
    return ts.findAncestor(contextToken, ts.isClassLike);
  }
  switch (contextToken.kind) {
    case 63 /* SyntaxKind.EqualsToken */:  // class c { public prop = | /* global completions */ }
      return undefined;
    case 26 /* SyntaxKind.SemicolonToken */:   // class c {getValue(): number; | }
    case 19 /* SyntaxKind.CloseBraceToken */:  // class c { method() { } | }
      // class c { method() { } b| }
      return isFromObjectTypeDeclaration(location) && location.parent.name === location ?
          location.parent.parent :
          ts.tryCast(location, ts.isObjectTypeDeclaration);
    case 18 /* SyntaxKind.OpenBraceToken */:  // class c { |
    case 27 /* SyntaxKind.CommaToken */:      // class c {getValue(): number, | }
      return ts.tryCast(contextToken.parent, ts.isObjectTypeDeclaration);
    default:
      if (!isFromObjectTypeDeclaration(contextToken)) {
        // class c extends React.Component { a: () => 1\n| }
        if (ts.getLineAndCharacterOfPosition(sourceFile, contextToken.getEnd()).line !==
                ts.getLineAndCharacterOfPosition(sourceFile, position).line &&
            ts.isObjectTypeDeclaration(location)) {
          return location;
        }
        return undefined;
      }
      var isValidKeyword = ts.isClassLike(contextToken.parent.parent) ? isClassMemberCompletionKeyword :
                                                                        isInterfaceOrTypeLiteralCompletionKeyword;
      return (isValidKeyword(contextToken.kind) || contextToken.kind === 41 /* SyntaxKind.AsteriskToken */ ||
              ts.isIdentifier(contextToken) && isValidKeyword(ts.stringToToken(contextToken.text)))  // TODO: GH#18217
          ?
          contextToken.parent.parent :
          undefined;
  }
}
function tryGetTypeLiteralNode(node) {
  if (!node)
    {return undefined;}
  const parent = node.parent;
  switch (node.kind) {
    case 18 /* SyntaxKind.OpenBraceToken */:
      if (ts.isTypeLiteralNode(parent)) {
        return parent;
      }
      break;
    case 26 /* SyntaxKind.SemicolonToken */:
    case 27 /* SyntaxKind.CommaToken */:
    case 79 /* SyntaxKind.Identifier */:
      if (parent.kind === 168 /* SyntaxKind.PropertySignature */ && ts.isTypeLiteralNode(parent.parent)) {
        return parent.parent;
      }
      break;
  }
  return undefined;
}
function getConstraintOfTypeArgumentProperty(node, checker) {
  if (!node)
    {return undefined;}
  if (ts.isTypeNode(node) && ts.isTypeReferenceType(node.parent)) {
    return checker.getTypeArgumentConstraint(node);
  }
  const t = getConstraintOfTypeArgumentProperty(node.parent, checker);
  if (!t)
    {return undefined;}
  switch (node.kind) {
    case 168 /* SyntaxKind.PropertySignature */:
      return checker.getTypeOfPropertyOfContextualType(t, node.symbol.escapedName);
    case 190 /* SyntaxKind.IntersectionType */:
    case 184 /* SyntaxKind.TypeLiteral */:
    case 189 /* SyntaxKind.UnionType */:
      return t;
  }
}
// TODO: GH#19856 Would like to return `node is Node & { parent: (ClassElement | TypeElement) & { parent: ObjectTypeDeclaration } }` but then compilation takes > 10 minutes
function isFromObjectTypeDeclaration(node) {
  return node.parent && ts.isClassOrTypeElement(node.parent) && ts.isObjectTypeDeclaration(node.parent.parent);
}
function isValidTrigger(sourceFile, triggerCharacter, contextToken, position) {
  switch (triggerCharacter) {
    case '.':
    case '@':
      return true;
    case '"':
    case '\'':
    case '`':
      // Only automatically bring up completions if this is an opening quote.
      return !!contextToken && ts.isStringLiteralOrTemplate(contextToken) &&
          position === contextToken.getStart(sourceFile) + 1;
    case '#':
      return !!contextToken && ts.isPrivateIdentifier(contextToken) && !!ts.getContainingClass(contextToken);
    case '<':
      // Opening JSX tag
      return !!contextToken && contextToken.kind === 29 /* SyntaxKind.LessThanToken */ &&
          (!ts.isBinaryExpression(contextToken.parent) || binaryExpressionMayBeOpenTag(contextToken.parent));
    case '/':
      return !!contextToken &&
          (ts.isStringLiteralLike(contextToken) ?
               !!ts.tryGetImportFromModuleSpecifier(contextToken) :
               contextToken.kind === 43 /* SyntaxKind.SlashToken */ && ts.isJsxClosingElement(contextToken.parent));
    case ' ':
      return !!contextToken && ts.isImportKeyword(contextToken) &&
          contextToken.parent.kind === 308 /* SyntaxKind.SourceFile */;
    default:
      return ts.Debug.assertNever(triggerCharacter);
  }
}
function binaryExpressionMayBeOpenTag(_a) {
  const left = _a.left;
  return ts.nodeIsMissing(left);
}
/** Determines if a type is exactly the same type resolved by the global 'self', 'global', or 'globalThis'. */
function isProbablyGlobalType(type, sourceFile, checker) {
  // The type of `self` and `window` is the same in lib.dom.d.ts, but `window` does not exist in
  // lib.webworker.d.ts, so checking against `self` is also a check against `window` when it exists.
  const selfSymbol =
      checker.resolveName('self', /* location*/ undefined, 111551 /* SymbolFlags.Value */, /* excludeGlobals*/ false);
  if (selfSymbol && checker.getTypeOfSymbolAtLocation(selfSymbol, sourceFile) === type) {
    return true;
  }
  const globalSymbol =
      checker.resolveName('global', /* location*/ undefined, 111551 /* SymbolFlags.Value */, /* excludeGlobals*/ false);
  if (globalSymbol && checker.getTypeOfSymbolAtLocation(globalSymbol, sourceFile) === type) {
    return true;
  }
  const globalThisSymbol = checker.resolveName(
      'globalThis', /* location*/ undefined, 111551 /* SymbolFlags.Value */, /* excludeGlobals*/ false);
  if (globalThisSymbol && checker.getTypeOfSymbolAtLocation(globalThisSymbol, sourceFile) === type) {
    return true;
  }
  return false;
}
function isStaticProperty(symbol) {
  return !!(
      symbol.valueDeclaration &&
      ts.getEffectiveModifierFlags(symbol.valueDeclaration) & 32 /* ModifierFlags.Static */ &&
      ts.isClassLike(symbol.valueDeclaration.parent));
}
function tryGetObjectLiteralContextualType(node, typeChecker) {
  const type = typeChecker.getContextualType(node);
  if (type) {
    return type;
  }
  const parent = ts.walkUpParenthesizedExpressions(node.parent);
  if (ts.isBinaryExpression(parent) && parent.operatorToken.kind === 63 /* SyntaxKind.EqualsToken */ &&
      node === parent.left) {
    // Object literal is assignment pattern: ({ | } = x)
    return typeChecker.getTypeAtLocation(parent);
  }
  if (ts.isExpression(parent)) {
    // f(() => (({ | })));
    return typeChecker.getContextualType(parent);
  }
  return undefined;
}
function getImportStatementCompletionInfo(contextToken) {
  let _a, _b, _c;
  let keywordCompletion;
  let isKeywordOnlyCompletion = false;
  const candidate = getCandidate();
  return {
    isKeywordOnlyCompletion,
    keywordCompletion,
    isNewIdentifierLocation: !!(candidate || keywordCompletion === 154 /* SyntaxKind.TypeKeyword */),
    isTopLevelTypeOnly: !!((_b = (_a = ts.tryCast(candidate, ts.isImportDeclaration)) === null || _a === void 0 ?
                                void 0 :
                                _a.importClause) === null ||
                                   _b === void 0 ?
                               void 0 :
                               _b.isTypeOnly) ||
        !!((_c = ts.tryCast(candidate, ts.isImportEqualsDeclaration)) === null || _c === void 0 ? void 0 :
                                                                                                  _c.isTypeOnly),
    couldBeTypeOnlyImportSpecifier: !!candidate && couldBeTypeOnlyImportSpecifier(candidate, contextToken),
    replacementSpan: getSingleLineReplacementSpanForImportCompletionNode(candidate),
  };
  function getCandidate() {
    const parent = contextToken.parent;
    if (ts.isImportEqualsDeclaration(parent)) {
      keywordCompletion =
          contextToken.kind === 154 /* SyntaxKind.TypeKeyword */ ? undefined : 154 /* SyntaxKind.TypeKeyword */;
      return isModuleSpecifierMissingOrEmpty(parent.moduleReference) ? parent : undefined;
    }
    if (couldBeTypeOnlyImportSpecifier(parent, contextToken) && canCompleteFromNamedBindings(parent.parent)) {
      return parent;
    }
    if (ts.isNamedImports(parent) || ts.isNamespaceImport(parent)) {
      if (!parent.parent.isTypeOnly &&
          (contextToken.kind === 18 /* SyntaxKind.OpenBraceToken */ ||
           contextToken.kind === 100 /* SyntaxKind.ImportKeyword */ ||
           contextToken.kind === 27 /* SyntaxKind.CommaToken */)) {
        keywordCompletion = 154 /* SyntaxKind.TypeKeyword */;
      }
      if (canCompleteFromNamedBindings(parent)) {
        // At `import { ... } |` or `import * as Foo |`, the only possible completion is `from`
        if (contextToken.kind === 19 /* SyntaxKind.CloseBraceToken */ ||
            contextToken.kind === 79 /* SyntaxKind.Identifier */) {
          isKeywordOnlyCompletion = true;
          keywordCompletion = 158 /* SyntaxKind.FromKeyword */;
        } else {
          return parent.parent.parent;
        }
      }
      return undefined;
    }
    if (ts.isImportKeyword(contextToken) && ts.isSourceFile(parent)) {
      // A lone import keyword with nothing following it does not parse as a statement at all
      keywordCompletion = 154 /* SyntaxKind.TypeKeyword */;
      return contextToken;
    }
    if (ts.isImportKeyword(contextToken) && ts.isImportDeclaration(parent)) {
      // `import s| from`
      keywordCompletion = 154 /* SyntaxKind.TypeKeyword */;
      return isModuleSpecifierMissingOrEmpty(parent.moduleSpecifier) ? parent : undefined;
    }
    return undefined;
  }
}
function getSingleLineReplacementSpanForImportCompletionNode(node) {
  let _a, _b, _c;
  if (!node)
    {return undefined;}
  const top = (_a = ts.findAncestor(node, ts.or(ts.isImportDeclaration, ts.isImportEqualsDeclaration))) !== null &&
          _a !== void 0 ?
      _a :
      node;
  const sourceFile = top.getSourceFile();
  if (ts.rangeIsOnSingleLine(top, sourceFile)) {
    return ts.createTextSpanFromNode(top, sourceFile);
  }
  // ImportKeyword was necessarily on one line; ImportSpecifier was necessarily parented in an ImportDeclaration
  ts.Debug.assert(top.kind !== 100 /* SyntaxKind.ImportKeyword */ && top.kind !== 273 /* SyntaxKind.ImportSpecifier */);
  // Guess which point in the import might actually be a later statement parsed as part of the import
  // during parser recovery - either in the middle of named imports, or the module specifier.
  const potentialSplitPoint = top.kind === 269 /* SyntaxKind.ImportDeclaration */
      ?
      (_c = getPotentiallyInvalidImportSpecifier(
           (_b = top.importClause) === null || _b === void 0 ? void 0 : _b.namedBindings)) !== null &&
              _c !== void 0 ?
      _c :
      top.moduleSpecifier :
      top.moduleReference;
  const withoutModuleSpecifier = {
    pos: top.getFirstToken().getStart(),
    end: potentialSplitPoint.pos,
  };
  // The module specifier/reference was previously found to be missing, empty, or
  // not a string literal - in this last case, it's likely that statement on a following
  // line was parsed as the module specifier of a partially-typed import, e.g.
  //   import Foo|
  //   interface Blah {}
  // This appears to be a multiline-import, and editors can't replace multiple lines.
  // But if everything but the "module specifier" is on one line, by this point we can
  // assume that the "module specifier" is actually just another statement, and return
  // the single-line range of the import excluding that probable statement.
  if (ts.rangeIsOnSingleLine(withoutModuleSpecifier, sourceFile)) {
    return ts.createTextSpanFromRange(withoutModuleSpecifier);
  }
}
// Tries to identify the first named import that is not really a named import, but rather
// just parser recovery for a situation like:
//   import { Foo|
//   interface Bar {}
// in which `Foo`, `interface`, and `Bar` are all parsed as import specifiers. The caller
// will also check if this token is on a separate line from the rest of the import.
function getPotentiallyInvalidImportSpecifier(namedBindings) {
  let _a;
  return ts.find(
      (_a = ts.tryCast(namedBindings, ts.isNamedImports)) === null || _a === void 0 ? void 0 : _a.elements,
      function(e) {
        let _a;
        return !e.propertyName && ts.isStringANonContextualKeyword(e.name.text) &&
            ((_a = ts.findPrecedingToken(e.name.pos, namedBindings.getSourceFile(), namedBindings)) === null ||
                     _a === void 0 ?
                 void 0 :
                 _a.kind) !== 27 /* SyntaxKind.CommaToken */;
      });
}
function couldBeTypeOnlyImportSpecifier(importSpecifier, contextToken) {
  return ts.isImportSpecifier(importSpecifier) &&
      (importSpecifier.isTypeOnly ||
       contextToken === importSpecifier.name && ts.isTypeKeywordTokenOrIdentifier(contextToken));
}
function canCompleteFromNamedBindings(namedBindings) {
  if (!isModuleSpecifierMissingOrEmpty(namedBindings.parent.parent.moduleSpecifier) || namedBindings.parent.name) {
    return false;
  }
  if (ts.isNamedImports(namedBindings)) {
    // We can only complete on named imports if there are no other named imports already,
    // but parser recovery sometimes puts later statements in the named imports list, so
    // we try to only consider the probably-valid ones.
    const invalidNamedImport = getPotentiallyInvalidImportSpecifier(namedBindings);
    const validImports =
        invalidNamedImport ? namedBindings.elements.indexOf(invalidNamedImport) : namedBindings.elements.length;
    return validImports < 2;
  }
  return true;
}
function isModuleSpecifierMissingOrEmpty(specifier) {
  let _a;
  if (ts.nodeIsMissing(specifier))
    {return true;}
  return !(
      (_a = ts.tryCast(
           ts.isExternalModuleReference(specifier) ? specifier.expression : specifier, ts.isStringLiteralLike)) ===
                  null ||
              _a === void 0 ?
          void 0 :
          _a.text);
}
function getVariableDeclaration(property) {
  const variableDeclaration = ts.findAncestor(property, function(node) {
    return ts.isFunctionBlock(node) || isArrowFunctionBody(node) || ts.isBindingPattern(node) ?
        'quit' :
        ts.isVariableDeclaration(node);
  });
  return variableDeclaration;
}
function isArrowFunctionBody(node) {
  return node.parent && ts.isArrowFunction(node.parent) && node.parent.body === node;
}
/** True if symbol is a type or a module containing at least one type. */
function symbolCanBeReferencedAtTypeLocation(symbol, checker, seenModules) {
  if (seenModules === void 0) {
    seenModules = new ts.Map();
  }
  // Since an alias can be merged with a local declaration, we need to test both the alias and its target.
  // This code used to just test the result of `skipAlias`, but that would ignore any locally introduced meanings.
  return nonAliasCanBeReferencedAtTypeLocation(symbol) ||
      nonAliasCanBeReferencedAtTypeLocation(ts.skipAlias(symbol.exportSymbol || symbol, checker));
  function nonAliasCanBeReferencedAtTypeLocation(symbol) {
    return !!(symbol.flags & 788968 /* SymbolFlags.Type */) || checker.isUnknownSymbol(symbol) ||
        !!(symbol.flags & 1536 /* SymbolFlags.Module */) && ts.addToSeen(seenModules, ts.getSymbolId(symbol)) &&
        checker.getExportsOfModule(symbol).some(function(e) {
          return symbolCanBeReferencedAtTypeLocation(e, checker, seenModules);
        });
  }
}
function isDeprecated(symbol, checker) {
  const declarations = ts.skipAlias(symbol, checker).declarations;
  return !!ts.length(declarations) && ts.every(declarations, ts.isDeprecatedDeclaration);
}
/**
 * True if the first character of `lowercaseCharacters` is the first character
 * of some "word" in `identiferString` (where the string is split into "words"
 * by camelCase and snake_case segments), then if the remaining characters of
 * `lowercaseCharacters` appear, in order, in the rest of `identifierString`.
 *
 * True:
 * 'state' in 'useState'
 * 'sae' in 'useState'
 * 'viable' in 'ENVIRONMENT_VARIABLE'
 *
 * False:
 * 'staet' in 'useState'
 * 'tate' in 'useState'
 * 'ment' in 'ENVIRONMENT_VARIABLE'
 */
function charactersFuzzyMatchInString(identifierString, lowercaseCharacters) {
  if (lowercaseCharacters.length === 0) {
    return true;
  }
  let matchedFirstCharacter = false;
  let prevChar;
  let characterIndex = 0;
  const len = identifierString.length;
  for (let strIndex = 0; strIndex < len; strIndex++) {
    const strChar = identifierString.charCodeAt(strIndex);
    const testChar = lowercaseCharacters.charCodeAt(characterIndex);
    if (strChar === testChar || strChar === toUpperCharCode(testChar)) {
      matchedFirstCharacter ||
          (matchedFirstCharacter = prevChar === undefined ||  // Beginning of word
               97 /* CharacterCodes.a */ <= prevChar && prevChar <= 122 /* CharacterCodes.z */ &&
                   65 /* CharacterCodes.A */ <= strChar && strChar <= 90 /* CharacterCodes.Z */
               ||                                                        // camelCase transition
               prevChar === 95 /* CharacterCodes._ */ &&
                   strChar !== 95 /* CharacterCodes._ */);  // snake_case transition
      if (matchedFirstCharacter) {
        characterIndex++;
      }
      if (characterIndex === lowercaseCharacters.length) {
        return true;
      }
    }
    prevChar = strChar;
  }
  // Did not find all characters
  return false;
}
function toUpperCharCode(charCode) {
  if (97 /* CharacterCodes.a */ <= charCode && charCode <= 122 /* CharacterCodes.z */) {
    return charCode - 32;
  }
  return charCode;
}
})(Completions = ts.Completions || (ts.Completions = {}));
})(ts || (ts = {}));
var ts;
(function(ts) {
/* @internal */
let DocumentHighlights;
(function(DocumentHighlights) {
function getDocumentHighlights(program, cancellationToken, sourceFile, position, sourceFilesToSearch) {
  const node = ts.getTouchingPropertyName(sourceFile, position);
  if (node.parent &&
      (ts.isJsxOpeningElement(node.parent) && node.parent.tagName === node || ts.isJsxClosingElement(node.parent))) {
    // For a JSX element, just highlight the matching tag, not all references.
    const _a = node.parent.parent, openingElement = _a.openingElement, closingElement = _a.closingElement;
    const highlightSpans = [openingElement, closingElement].map(function(_a) {
      const tagName = _a.tagName;
      return getHighlightSpanForNode(tagName, sourceFile);
    });
    return [{fileName: sourceFile.fileName, highlightSpans}];
  }
  return getSemanticDocumentHighlights(position, node, program, cancellationToken, sourceFilesToSearch) ||
      getSyntacticDocumentHighlights(node, sourceFile);
}
DocumentHighlights.getDocumentHighlights = getDocumentHighlights;
function getHighlightSpanForNode(node, sourceFile) {
  return {
    fileName: sourceFile.fileName,
    textSpan: ts.createTextSpanFromNode(node, sourceFile),
    kind: 'none' /* HighlightSpanKind.none */
  };
}
function getSemanticDocumentHighlights(position, node, program, cancellationToken, sourceFilesToSearch) {
  const sourceFilesSet = new ts.Set(sourceFilesToSearch.map(function(f) {
    return f.fileName;
  }));
  const referenceEntries = ts.FindAllReferences.getReferenceEntriesForNode(
      position, node, program, sourceFilesToSearch, cancellationToken, /* options*/ undefined, sourceFilesSet);
  if (!referenceEntries)
    {return undefined;}
  const map = ts.arrayToMultiMap(
      referenceEntries.map(ts.FindAllReferences.toHighlightSpan),
      function(e) {
        return e.fileName;
      },
      function(e) {
        return e.span;
      });
  const getCanonicalFileName = ts.createGetCanonicalFileName(program.useCaseSensitiveFileNames());
  return ts.mapDefined(ts.arrayFrom(map.entries()), function(_a) {
    let fileName = _a[0], highlightSpans = _a[1];
    if (!sourceFilesSet.has(fileName)) {
      if (!program.redirectTargetsMap.has(ts.toPath(fileName, program.getCurrentDirectory(), getCanonicalFileName))) {
        return undefined;
      }
      const redirectTarget_1 = program.getSourceFile(fileName);
      const redirect = ts.find(sourceFilesToSearch, function(f) {
        return !!f.redirectInfo && f.redirectInfo.redirectTarget === redirectTarget_1;
      });
      fileName = redirect.fileName;
      ts.Debug.assert(sourceFilesSet.has(fileName));
    }
    return {fileName, highlightSpans};
  });
}
function getSyntacticDocumentHighlights(node, sourceFile) {
  const highlightSpans = getHighlightSpans(node, sourceFile);
  return highlightSpans && [{fileName: sourceFile.fileName, highlightSpans}];
}
function getHighlightSpans(node, sourceFile) {
  switch (node.kind) {
    case 99 /* SyntaxKind.IfKeyword */:
    case 91 /* SyntaxKind.ElseKeyword */:
      return ts.isIfStatement(node.parent) ? getIfElseOccurrences(node.parent, sourceFile) : undefined;
    case 105 /* SyntaxKind.ReturnKeyword */:
      return useParent(node.parent, ts.isReturnStatement, getReturnOccurrences);
    case 109 /* SyntaxKind.ThrowKeyword */:
      return useParent(node.parent, ts.isThrowStatement, getThrowOccurrences);
    case 111 /* SyntaxKind.TryKeyword */:
    case 83 /* SyntaxKind.CatchKeyword */:
    case 96 /* SyntaxKind.FinallyKeyword */:
      var tryStatement = node.kind === 83 /* SyntaxKind.CatchKeyword */ ? node.parent.parent : node.parent;
      return useParent(tryStatement, ts.isTryStatement, getTryCatchFinallyOccurrences);
    case 107 /* SyntaxKind.SwitchKeyword */:
      return useParent(node.parent, ts.isSwitchStatement, getSwitchCaseDefaultOccurrences);
    case 82 /* SyntaxKind.CaseKeyword */:
    case 88 /* SyntaxKind.DefaultKeyword */: {
      if (ts.isDefaultClause(node.parent) || ts.isCaseClause(node.parent)) {
        return useParent(node.parent.parent.parent, ts.isSwitchStatement, getSwitchCaseDefaultOccurrences);
      }
      return undefined;
    }
    case 81 /* SyntaxKind.BreakKeyword */:
    case 86 /* SyntaxKind.ContinueKeyword */:
      return useParent(node.parent, ts.isBreakOrContinueStatement, getBreakOrContinueStatementOccurrences);
    case 97 /* SyntaxKind.ForKeyword */:
    case 115 /* SyntaxKind.WhileKeyword */:
    case 90 /* SyntaxKind.DoKeyword */:
      return useParent(node.parent, function(n) {
        return ts.isIterationStatement(n, /* lookInLabeledStatements*/ true);
      }, getLoopBreakContinueOccurrences);
    case 135 /* SyntaxKind.ConstructorKeyword */:
      return getFromAllDeclarations(ts.isConstructorDeclaration, [135 /* SyntaxKind.ConstructorKeyword */]);
    case 137 /* SyntaxKind.GetKeyword */:
    case 151 /* SyntaxKind.SetKeyword */:
      return getFromAllDeclarations(ts.isAccessor, [137 /* SyntaxKind.GetKeyword */, 151 /* SyntaxKind.SetKeyword */]);
    case 133 /* SyntaxKind.AwaitKeyword */:
      return useParent(node.parent, ts.isAwaitExpression, getAsyncAndAwaitOccurrences);
    case 132 /* SyntaxKind.AsyncKeyword */:
      return highlightSpans(getAsyncAndAwaitOccurrences(node));
    case 125 /* SyntaxKind.YieldKeyword */:
      return highlightSpans(getYieldOccurrences(node));
    case 101 /* SyntaxKind.InKeyword */:
      return undefined;
    default:
      return ts.isModifierKind(node.kind) && (ts.isDeclaration(node.parent) || ts.isVariableStatement(node.parent)) ?
          highlightSpans(getModifierOccurrences(node.kind, node.parent)) :
          undefined;
  }
  function getFromAllDeclarations(nodeTest, keywords) {
    return useParent(node.parent, nodeTest, function(decl) {
      return ts.mapDefined(decl.symbol.declarations, function(d) {
        return nodeTest(d) ? ts.find(d.getChildren(sourceFile), function(c) {
          return ts.contains(keywords, c.kind);
        }) : undefined;
      });
    });
  }
  function useParent(node, nodeTest, getNodes) {
    return nodeTest(node) ? highlightSpans(getNodes(node, sourceFile)) : undefined;
  }
  function highlightSpans(nodes) {
    return nodes && nodes.map(function(node) {
      return getHighlightSpanForNode(node, sourceFile);
    });
  }
}
/**
 * Aggregates all throw-statements within this node *without* crossing
 * into function boundaries and try-blocks with catch-clauses.
 */
function aggregateOwnedThrowStatements(node) {
  if (ts.isThrowStatement(node)) {
    return [node];
  } if (ts.isTryStatement(node)) {
    // Exceptions thrown within a try block lacking a catch clause are "owned" in the current context.
    return ts.concatenate(
        node.catchClause ? aggregateOwnedThrowStatements(node.catchClause) :
                           node.tryBlock && aggregateOwnedThrowStatements(node.tryBlock),
        node.finallyBlock && aggregateOwnedThrowStatements(node.finallyBlock));
  }
  // Do not cross function boundaries.
  return ts.isFunctionLike(node) ? undefined : flatMapChildren(node, aggregateOwnedThrowStatements);
}
/**
 * For lack of a better name, this function takes a throw statement and returns the
 * nearest ancestor that is a try-block (whose try statement has a catch clause),
 * function-block, or source file.
 */
function getThrowStatementOwner(throwStatement) {
  let child = throwStatement;
  while (child.parent) {
    const parent = child.parent;
    if (ts.isFunctionBlock(parent) || parent.kind === 308 /* SyntaxKind.SourceFile */) {
      return parent;
    }
    // A throw-statement is only owned by a try-statement if the try-statement has
    // a catch clause, and if the throw-statement occurs within the try block.
    if (ts.isTryStatement(parent) && parent.tryBlock === child && parent.catchClause) {
      return child;
    }
    child = parent;
  }
  return undefined;
}
function aggregateAllBreakAndContinueStatements(node) {
  return ts.isBreakOrContinueStatement(node) ? [node] :
      ts.isFunctionLike(node)                ? undefined :
                                               flatMapChildren(node, aggregateAllBreakAndContinueStatements);
}
function flatMapChildren(node, cb) {
  const result = [];
  node.forEachChild(function(child) {
    const value = cb(child);
    if (value !== undefined) {
      result.push.apply(result, ts.toArray(value));
    }
  });
  return result;
}
function ownsBreakOrContinueStatement(owner, statement) {
  const actualOwner = getBreakOrContinueOwner(statement);
  return !!actualOwner && actualOwner === owner;
}
function getBreakOrContinueOwner(statement) {
  return ts.findAncestor(statement, function(node) {
    switch (node.kind) {
      case 252 /* SyntaxKind.SwitchStatement */:
        if (statement.kind === 248 /* SyntaxKind.ContinueStatement */) {
          return false;
        }
      // falls through
      case 245 /* SyntaxKind.ForStatement */:
      case 246 /* SyntaxKind.ForInStatement */:
      case 247 /* SyntaxKind.ForOfStatement */:
      case 244 /* SyntaxKind.WhileStatement */:
      case 243 /* SyntaxKind.DoStatement */:
        return !statement.label || isLabeledBy(node, statement.label.escapedText);
      default:
        // Don't cross function boundaries.
        // TODO: GH#20090
        return ts.isFunctionLike(node) && 'quit';
    }
  });
}
function getModifierOccurrences(modifier, declaration) {
  return ts.mapDefined(getNodesToSearchForModifier(declaration, ts.modifierToFlag(modifier)), function(node) {
    return ts.findModifier(node, modifier);
  });
}
function getNodesToSearchForModifier(declaration, modifierFlag) {
  // Types of node whose children might have modifiers.
  const container = declaration.parent;
  switch (container.kind) {
    case 265 /* SyntaxKind.ModuleBlock */:
    case 308 /* SyntaxKind.SourceFile */:
    case 238 /* SyntaxKind.Block */:
    case 292 /* SyntaxKind.CaseClause */:
    case 293 /* SyntaxKind.DefaultClause */:
      // Container is either a class declaration or the declaration is a classDeclaration
      if (modifierFlag & 256 /* ModifierFlags.Abstract */ && ts.isClassDeclaration(declaration)) {
        return __spreadArray(__spreadArray([], declaration.members, true), [declaration], false);
      }
        return container.statements;

    case 173 /* SyntaxKind.Constructor */:
    case 171 /* SyntaxKind.MethodDeclaration */:
    case 259 /* SyntaxKind.FunctionDeclaration */:
      return __spreadArray(
          __spreadArray([], container.parameters, true),
          (ts.isClassLike(container.parent) ? container.parent.members : []), true);
    case 260 /* SyntaxKind.ClassDeclaration */:
    case 228 /* SyntaxKind.ClassExpression */:
    case 261 /* SyntaxKind.InterfaceDeclaration */:
    case 184 /* SyntaxKind.TypeLiteral */:
      var nodes = container.members;
      // If we're an accessibility modifier, we're in an instance member and should search
      // the constructor's parameter list for instance members as well.
      if (modifierFlag & (28 /* ModifierFlags.AccessibilityModifier */ | 64 /* ModifierFlags.Readonly */)) {
        const constructor = ts.find(container.members, ts.isConstructorDeclaration);
        if (constructor) {
          return __spreadArray(__spreadArray([], nodes, true), constructor.parameters, true);
        }
      } else if (modifierFlag & 256 /* ModifierFlags.Abstract */) {
        return __spreadArray(__spreadArray([], nodes, true), [container], false);
      }
      return nodes;
    // Syntactically invalid positions that the parser might produce anyway
    case 207 /* SyntaxKind.ObjectLiteralExpression */:
      return undefined;
    default:
      ts.Debug.assertNever(container, 'Invalid container kind.');
  }
}
function pushKeywordIf(keywordList, token) {
  const expected = [];
  for (let _i = 2; _i < arguments.length; _i++) {
    expected[_i - 2] = arguments[_i];
  }
  if (token && ts.contains(expected, token.kind)) {
    keywordList.push(token);
    return true;
  }
  return false;
}
function getLoopBreakContinueOccurrences(loopNode) {
  const keywords = [];
  if (pushKeywordIf(
          keywords, loopNode.getFirstToken(), 97 /* SyntaxKind.ForKeyword */, 115 /* SyntaxKind.WhileKeyword */,
          90 /* SyntaxKind.DoKeyword */)) {
    // If we succeeded and got a do-while loop, then start looking for a 'while' keyword.
    if (loopNode.kind === 243 /* SyntaxKind.DoStatement */) {
      const loopTokens = loopNode.getChildren();
      for (let i = loopTokens.length - 1; i >= 0; i--) {
        if (pushKeywordIf(keywords, loopTokens[i], 115 /* SyntaxKind.WhileKeyword */)) {
          break;
        }
      }
    }
  }
  ts.forEach(aggregateAllBreakAndContinueStatements(loopNode.statement), function(statement) {
    if (ownsBreakOrContinueStatement(loopNode, statement)) {
      pushKeywordIf(
          keywords, statement.getFirstToken(), 81 /* SyntaxKind.BreakKeyword */, 86 /* SyntaxKind.ContinueKeyword */);
    }
  });
  return keywords;
}
function getBreakOrContinueStatementOccurrences(breakOrContinueStatement) {
  const owner = getBreakOrContinueOwner(breakOrContinueStatement);
  if (owner) {
    switch (owner.kind) {
      case 245 /* SyntaxKind.ForStatement */:
      case 246 /* SyntaxKind.ForInStatement */:
      case 247 /* SyntaxKind.ForOfStatement */:
      case 243 /* SyntaxKind.DoStatement */:
      case 244 /* SyntaxKind.WhileStatement */:
        return getLoopBreakContinueOccurrences(owner);
      case 252 /* SyntaxKind.SwitchStatement */:
        return getSwitchCaseDefaultOccurrences(owner);
    }
  }
  return undefined;
}
function getSwitchCaseDefaultOccurrences(switchStatement) {
  const keywords = [];
  pushKeywordIf(keywords, switchStatement.getFirstToken(), 107 /* SyntaxKind.SwitchKeyword */);
  // Go through each clause in the switch statement, collecting the 'case'/'default' keywords.
  ts.forEach(switchStatement.caseBlock.clauses, function(clause) {
    pushKeywordIf(
        keywords, clause.getFirstToken(), 82 /* SyntaxKind.CaseKeyword */, 88 /* SyntaxKind.DefaultKeyword */);
    ts.forEach(aggregateAllBreakAndContinueStatements(clause), function(statement) {
      if (ownsBreakOrContinueStatement(switchStatement, statement)) {
        pushKeywordIf(keywords, statement.getFirstToken(), 81 /* SyntaxKind.BreakKeyword */);
      }
    });
  });
  return keywords;
}
function getTryCatchFinallyOccurrences(tryStatement, sourceFile) {
  const keywords = [];
  pushKeywordIf(keywords, tryStatement.getFirstToken(), 111 /* SyntaxKind.TryKeyword */);
  if (tryStatement.catchClause) {
    pushKeywordIf(keywords, tryStatement.catchClause.getFirstToken(), 83 /* SyntaxKind.CatchKeyword */);
  }
  if (tryStatement.finallyBlock) {
    const finallyKeyword = ts.findChildOfKind(tryStatement, 96 /* SyntaxKind.FinallyKeyword */, sourceFile);
    pushKeywordIf(keywords, finallyKeyword, 96 /* SyntaxKind.FinallyKeyword */);
  }
  return keywords;
}
function getThrowOccurrences(throwStatement, sourceFile) {
  const owner = getThrowStatementOwner(throwStatement);
  if (!owner) {
    return undefined;
  }
  const keywords = [];
  ts.forEach(aggregateOwnedThrowStatements(owner), function(throwStatement) {
    keywords.push(ts.findChildOfKind(throwStatement, 109 /* SyntaxKind.ThrowKeyword */, sourceFile));
  });
  // If the "owner" is a function, then we equate 'return' and 'throw' statements in their
  // ability to "jump out" of the function, and include occurrences for both.
  if (ts.isFunctionBlock(owner)) {
    ts.forEachReturnStatement(owner, function(returnStatement) {
      keywords.push(ts.findChildOfKind(returnStatement, 105 /* SyntaxKind.ReturnKeyword */, sourceFile));
    });
  }
  return keywords;
}
function getReturnOccurrences(returnStatement, sourceFile) {
  const func = ts.getContainingFunction(returnStatement);
  if (!func) {
    return undefined;
  }
  const keywords = [];
  ts.forEachReturnStatement(ts.cast(func.body, ts.isBlock), function(returnStatement) {
    keywords.push(ts.findChildOfKind(returnStatement, 105 /* SyntaxKind.ReturnKeyword */, sourceFile));
  });
  // Include 'throw' statements that do not occur within a try block.
  ts.forEach(aggregateOwnedThrowStatements(func.body), function(throwStatement) {
    keywords.push(ts.findChildOfKind(throwStatement, 109 /* SyntaxKind.ThrowKeyword */, sourceFile));
  });
  return keywords;
}
function getAsyncAndAwaitOccurrences(node) {
  const func = ts.getContainingFunction(node);
  if (!func) {
    return undefined;
  }
  const keywords = [];
  if (func.modifiers) {
    func.modifiers.forEach(function(modifier) {
      pushKeywordIf(keywords, modifier, 132 /* SyntaxKind.AsyncKeyword */);
    });
  }
  ts.forEachChild(func, function(child) {
    traverseWithoutCrossingFunction(child, function(node) {
      if (ts.isAwaitExpression(node)) {
        pushKeywordIf(keywords, node.getFirstToken(), 133 /* SyntaxKind.AwaitKeyword */);
      }
    });
  });
  return keywords;
}
function getYieldOccurrences(node) {
  const func = ts.getContainingFunction(node);
  if (!func) {
    return undefined;
  }
  const keywords = [];
  ts.forEachChild(func, function(child) {
    traverseWithoutCrossingFunction(child, function(node) {
      if (ts.isYieldExpression(node)) {
        pushKeywordIf(keywords, node.getFirstToken(), 125 /* SyntaxKind.YieldKeyword */);
      }
    });
  });
  return keywords;
}
// Do not cross function/class/interface/module/type boundaries.
function traverseWithoutCrossingFunction(node, cb) {
  cb(node);
  if (!ts.isFunctionLike(node) && !ts.isClassLike(node) && !ts.isInterfaceDeclaration(node) &&
      !ts.isModuleDeclaration(node) && !ts.isTypeAliasDeclaration(node) && !ts.isTypeNode(node)) {
    ts.forEachChild(node, function(child) {
      return traverseWithoutCrossingFunction(child, cb);
    });
  }
}
function getIfElseOccurrences(ifStatement, sourceFile) {
  const keywords = getIfElseKeywords(ifStatement, sourceFile);
  const result = [];
  // We'd like to highlight else/ifs together if they are only separated by whitespace
  // (i.e. the keywords are separated by no comments, no newlines).
  for (let i = 0; i < keywords.length; i++) {
    if (keywords[i].kind === 91 /* SyntaxKind.ElseKeyword */ && i < keywords.length - 1) {
      const elseKeyword = keywords[i];
      const ifKeyword = keywords[i + 1];  // this *should* always be an 'if' keyword.
      let shouldCombineElseAndIf = true;
      // Avoid recalculating getStart() by iterating backwards.
      for (let j = ifKeyword.getStart(sourceFile) - 1; j >= elseKeyword.end; j--) {
        if (!ts.isWhiteSpaceSingleLine(sourceFile.text.charCodeAt(j))) {
          shouldCombineElseAndIf = false;
          break;
        }
      }
      if (shouldCombineElseAndIf) {
        result.push({
          fileName: sourceFile.fileName,
          textSpan: ts.createTextSpanFromBounds(elseKeyword.getStart(), ifKeyword.end),
          kind: 'reference' /* HighlightSpanKind.reference */
        });
        i++;  // skip the next keyword
        continue;
      }
    }
    // Ordinary case: just highlight the keyword.
    result.push(getHighlightSpanForNode(keywords[i], sourceFile));
  }
  return result;
}
function getIfElseKeywords(ifStatement, sourceFile) {
  const keywords = [];
  // Traverse upwards through all parent if-statements linked by their else-branches.
  while (ts.isIfStatement(ifStatement.parent) && ifStatement.parent.elseStatement === ifStatement) {
    ifStatement = ifStatement.parent;
  }
  // Now traverse back down through the else branches, aggregating if/else keywords of if-statements.
  while (true) {
    const children = ifStatement.getChildren(sourceFile);
    pushKeywordIf(keywords, children[0], 99 /* SyntaxKind.IfKeyword */);
    // Generally the 'else' keyword is second-to-last, so we traverse backwards.
    for (let i = children.length - 1; i >= 0; i--) {
      if (pushKeywordIf(keywords, children[i], 91 /* SyntaxKind.ElseKeyword */)) {
        break;
      }
    }
    if (!ifStatement.elseStatement || !ts.isIfStatement(ifStatement.elseStatement)) {
      break;
    }
    ifStatement = ifStatement.elseStatement;
  }
  return keywords;
}
/**
 * Whether or not a 'node' is preceded by a label of the given string.
 * Note: 'node' cannot be a SourceFile.
 */
function isLabeledBy(node, labelName) {
  return !!ts.findAncestor(node.parent, function(owner) {
    return !ts.isLabeledStatement(owner) ? 'quit' : owner.label.escapedText === labelName;
  });
}
})(DocumentHighlights = ts.DocumentHighlights || (ts.DocumentHighlights = {}));
})(ts || (ts = {}));
var ts;
(function(ts) {
function isDocumentRegistryEntry(entry) {
  return !!entry.sourceFile;
}
function createDocumentRegistry(useCaseSensitiveFileNames, currentDirectory) {
  return createDocumentRegistryInternal(useCaseSensitiveFileNames, currentDirectory);
}
ts.createDocumentRegistry = createDocumentRegistry;
/* @internal*/
function createDocumentRegistryInternal(useCaseSensitiveFileNames, currentDirectory, externalCache) {
  if (currentDirectory === void 0) {
    currentDirectory = '';
  }
  // Maps from compiler setting target (ES3, ES5, etc.) to all the cached documents we have
  // for those settings.
  const buckets = new ts.Map();
  const getCanonicalFileName = ts.createGetCanonicalFileName(!!useCaseSensitiveFileNames);
  function reportStats() {
    const bucketInfoArray =
        ts.arrayFrom(buckets.keys())
            .filter(function(name) {
              return name && name.charAt(0) === '_';
            })
            .map(function(name) {
              const entries = buckets.get(name);
              const sourceFiles = [];
              entries.forEach(function(entry, name) {
                if (isDocumentRegistryEntry(entry)) {
                  sourceFiles.push(
                      {name, scriptKind: entry.sourceFile.scriptKind, refCount: entry.languageServiceRefCount});
                } else {
                  entry.forEach(function(value, scriptKind) {
                    return sourceFiles.push(
                        {name, scriptKind, refCount: value.languageServiceRefCount});
                  });
                }
              });
              sourceFiles.sort(function(x, y) {
                return y.refCount - x.refCount;
              });
              return {bucket: name, sourceFiles};
            });
    return JSON.stringify(bucketInfoArray, undefined, 2);
  }
  function getCompilationSettings(settingsOrHost) {
    if (typeof settingsOrHost.getCompilationSettings === 'function') {
      return settingsOrHost.getCompilationSettings();
    }
    return settingsOrHost;
  }
  function acquireDocument(
      fileName, compilationSettings, scriptSnapshot, version, scriptKind, languageVersionOrOptions) {
    const path = ts.toPath(fileName, currentDirectory, getCanonicalFileName);
    const key = getKeyForCompilationSettings(getCompilationSettings(compilationSettings));
    return acquireDocumentWithKey(
        fileName, path, compilationSettings, key, scriptSnapshot, version, scriptKind, languageVersionOrOptions);
  }
  function acquireDocumentWithKey(
      fileName, path, compilationSettings, key, scriptSnapshot, version, scriptKind, languageVersionOrOptions) {
    return acquireOrUpdateDocument(
        fileName, path, compilationSettings, key, scriptSnapshot, version, /* acquiring*/ true, scriptKind,
        languageVersionOrOptions);
  }
  function updateDocument(
      fileName, compilationSettings, scriptSnapshot, version, scriptKind, languageVersionOrOptions) {
    const path = ts.toPath(fileName, currentDirectory, getCanonicalFileName);
    const key = getKeyForCompilationSettings(getCompilationSettings(compilationSettings));
    return updateDocumentWithKey(
        fileName, path, compilationSettings, key, scriptSnapshot, version, scriptKind, languageVersionOrOptions);
  }
  function updateDocumentWithKey(
      fileName, path, compilationSettings, key, scriptSnapshot, version, scriptKind, languageVersionOrOptions) {
    return acquireOrUpdateDocument(
        fileName, path, getCompilationSettings(compilationSettings), key, scriptSnapshot, version, /* acquiring*/ false,
        scriptKind, languageVersionOrOptions);
  }
  function getDocumentRegistryEntry(bucketEntry, scriptKind) {
    const entry = isDocumentRegistryEntry(bucketEntry) ?
        bucketEntry :
        bucketEntry.get(ts.Debug.checkDefined(
            scriptKind,
            'If there are more than one scriptKind\'s for same document the scriptKind should be provided'));
    ts.Debug.assert(
        scriptKind === undefined || !entry || entry.sourceFile.scriptKind === scriptKind,
        'Script kind should match provided ScriptKind:'.concat(scriptKind, ' and sourceFile.scriptKind: ')
            .concat(entry === null || entry === void 0 ? void 0 : entry.sourceFile.scriptKind, ', !entry: ')
            .concat(!entry));
    return entry;
  }
  function acquireOrUpdateDocument(
      fileName, path, compilationSettingsOrHost, key, scriptSnapshot, version, acquiring, scriptKind,
      languageVersionOrOptions) {
    let _a, _b, _c, _d;
    scriptKind = ts.ensureScriptKind(fileName, scriptKind);
    const compilationSettings = getCompilationSettings(compilationSettingsOrHost);
    const host = compilationSettingsOrHost === compilationSettings ? undefined : compilationSettingsOrHost;
    const scriptTarget = scriptKind === 6 /* ScriptKind.JSON */ ? 100 /* ScriptTarget.JSON */ :
                                                                ts.getEmitScriptTarget(compilationSettings);
    const sourceFileOptions = typeof languageVersionOrOptions === 'object' ? languageVersionOrOptions : {
      languageVersion: scriptTarget,
      impliedNodeFormat: host &&
          ts.getImpliedNodeFormatForFile(
              path,
              (_d = (_c = (_b = (_a = host.getCompilerHost) === null || _a === void 0 ? void 0 : _a.call(host)) ===
                                 null ||
                             _b === void 0 ?
                         void 0 :
                         _b.getModuleResolutionCache) === null ||
                       _c === void 0 ?
                   void 0 :
                   _c.call(_b)) === null ||
                      _d === void 0 ?
                  void 0 :
                  _d.getPackageJsonInfoCache(),
              host, compilationSettings),
      setExternalModuleIndicator: ts.getSetExternalModuleIndicator(compilationSettings)
    };
    sourceFileOptions.languageVersion = scriptTarget;
    const oldBucketCount = buckets.size;
    const keyWithMode = getDocumentRegistryBucketKeyWithMode(key, sourceFileOptions.impliedNodeFormat);
    const bucket = ts.getOrUpdate(buckets, keyWithMode, function() {
      return new ts.Map();
    });
    if (ts.tracing) {
      if (buckets.size > oldBucketCount) {
        // It is interesting, but not definitively problematic if a build requires multiple document registry buckets -
        // perhaps they are for two projects that don't have any overlap.
        // Bonus: these events can help us interpret the more interesting event below.
        ts.tracing.instant(
            'session' /* tracing.Phase.Session */, 'createdDocumentRegistryBucket',
            {configFilePath: compilationSettings.configFilePath, key: keyWithMode});
      }
      // It is fairly suspicious to have one path in two buckets - you'd expect dependencies to have similar configurations.
      // If this occurs unexpectedly, the fix is likely to synchronize the project settings.
      // Skip .d.ts files to reduce noise (should also cover most of node_modules).
      const otherBucketKey = !ts.isDeclarationFileName(path) && ts.forEachEntry(buckets, function(bucket, bucketKey) {
        return bucketKey !== keyWithMode && bucket.has(path) && bucketKey;
      });
      if (otherBucketKey) {
        ts.tracing.instant(
            'session' /* tracing.Phase.Session */, 'documentRegistryBucketOverlap',
            {path, key1: otherBucketKey, key2: keyWithMode});
      }
    }
    const bucketEntry = bucket.get(path);
    let entry = bucketEntry && getDocumentRegistryEntry(bucketEntry, scriptKind);
    if (!entry && externalCache) {
      var sourceFile = externalCache.getDocument(keyWithMode, path);
      if (sourceFile) {
        ts.Debug.assert(acquiring);
        entry = {sourceFile, languageServiceRefCount: 0};
        setBucketEntry();
      }
    }
    if (!entry) {
      // Have never seen this file with these settings.  Create a new source file for it.
      var sourceFile = ts.createLanguageServiceSourceFile(
          fileName, scriptSnapshot, sourceFileOptions, version, /* setNodeParents*/ false, scriptKind);
      if (externalCache) {
        externalCache.setDocument(keyWithMode, path, sourceFile);
      }
      entry = {
        sourceFile,
        languageServiceRefCount: 1,
      };
      setBucketEntry();
    } else {
      // We have an entry for this file.  However, it may be for a different version of
      // the script snapshot.  If so, update it appropriately.  Otherwise, we can just
      // return it as is.
      if (entry.sourceFile.version !== version) {
        entry.sourceFile = ts.updateLanguageServiceSourceFile(
            entry.sourceFile, scriptSnapshot, version,
            scriptSnapshot.getChangeRange(entry.sourceFile.scriptSnapshot));  // TODO: GH#18217
        if (externalCache) {
          externalCache.setDocument(keyWithMode, path, entry.sourceFile);
        }
      }
      // If we're acquiring, then this is the first time this LS is asking for this document.
      // Increase our ref count so we know there's another LS using the document.  If we're
      // not acquiring, then that means the LS is 'updating' the file instead, and that means
      // it has already acquired the document previously.  As such, we do not need to increase
      // the ref count.
      if (acquiring) {
        entry.languageServiceRefCount++;
      }
    }
    ts.Debug.assert(entry.languageServiceRefCount !== 0);
    return entry.sourceFile;
    function setBucketEntry() {
      if (!bucketEntry) {
        bucket.set(path, entry);
      } else if (isDocumentRegistryEntry(bucketEntry)) {
        const scriptKindMap = new ts.Map();
        scriptKindMap.set(bucketEntry.sourceFile.scriptKind, bucketEntry);
        scriptKindMap.set(scriptKind, entry);
        bucket.set(path, scriptKindMap);
      } else {
        bucketEntry.set(scriptKind, entry);
      }
    }
  }
  function releaseDocument(fileName, compilationSettings, scriptKind, impliedNodeFormat) {
    const path = ts.toPath(fileName, currentDirectory, getCanonicalFileName);
    const key = getKeyForCompilationSettings(compilationSettings);
    return releaseDocumentWithKey(path, key, scriptKind, impliedNodeFormat);
  }
  function releaseDocumentWithKey(path, key, scriptKind, impliedNodeFormat) {
    const bucket = ts.Debug.checkDefined(buckets.get(getDocumentRegistryBucketKeyWithMode(key, impliedNodeFormat)));
    const bucketEntry = bucket.get(path);
    const entry = getDocumentRegistryEntry(bucketEntry, scriptKind);
    entry.languageServiceRefCount--;
    ts.Debug.assert(entry.languageServiceRefCount >= 0);
    if (entry.languageServiceRefCount === 0) {
      if (isDocumentRegistryEntry(bucketEntry)) {
        bucket.delete(path);
      } else {
        bucketEntry.delete(scriptKind);
        if (bucketEntry.size === 1) {
          bucket.set(path, ts.firstDefinedIterator(bucketEntry.values(), ts.identity));
        }
      }
    }
  }
  function getLanguageServiceRefCounts(path, scriptKind) {
    return ts.arrayFrom(buckets.entries(), function(_a) {
      const key = _a[0], bucket = _a[1];
      const bucketEntry = bucket.get(path);
      const entry = bucketEntry && getDocumentRegistryEntry(bucketEntry, scriptKind);
      return [key, entry && entry.languageServiceRefCount];
    });
  }
  return {
    acquireDocument,
    acquireDocumentWithKey,
    updateDocument,
    updateDocumentWithKey,
    releaseDocument,
    releaseDocumentWithKey,
    getLanguageServiceRefCounts,
    reportStats,
    getKeyForCompilationSettings
  };
}
ts.createDocumentRegistryInternal = createDocumentRegistryInternal;
function compilerOptionValueToString(value) {
  let _a;
  if (value === null || typeof value !== 'object') {  // eslint-disable-line no-null/no-null
    return '' + value;
  }
  if (ts.isArray(value)) {
    return '['.concat((_a = ts.map(value, function(e) {
                        return compilerOptionValueToString(e);
                      })) === null || _a === void 0 ? void 0 : _a.join(','), ']');
  }
  let str = '{';
  for (const key in value) {
    if (ts.hasProperty(value, key)) {
      str += ''.concat(key, ': ').concat(compilerOptionValueToString(value[key]));
    }
  }
  return str + '}';
}
function getKeyForCompilationSettings(settings) {
  return ts.sourceFileAffectingCompilerOptions
             .map(function(option) {
               return compilerOptionValueToString(ts.getCompilerOptionValue(settings, option));
             })
             .join('|') +
      (settings.pathsBasePath ? '|'.concat(settings.pathsBasePath) : undefined);
}
function getDocumentRegistryBucketKeyWithMode(key, mode) {
  return (mode ? ''.concat(key, '|').concat(mode) : key);
}
})(ts || (ts = {}));
/* Code for finding imports of an exported symbol. Used only by FindAllReferences. */
/* @internal */
var ts;
(function(ts) {
let FindAllReferences;
(function(FindAllReferences) {
/** Creates the imports map and returns an ImportTracker that uses it. Call this lazily to avoid calling `getDirectImportsMap` unnecessarily.  */
function createImportTracker(sourceFiles, sourceFilesSet, checker, cancellationToken) {
  const allDirectImports = getDirectImportsMap(sourceFiles, checker, cancellationToken);
  return function(exportSymbol, exportInfo, isForRename) {
    const _a = getImportersForExport(
            sourceFiles, sourceFilesSet, allDirectImports, exportInfo, checker, cancellationToken),
        directImports = _a.directImports, indirectUsers = _a.indirectUsers;
    return __assign(
        {indirectUsers},
        getSearchesFromDirectImports(directImports, exportSymbol, exportInfo.exportKind, checker, isForRename));
  };
}
FindAllReferences.createImportTracker = createImportTracker;
let ExportKind;
(function(ExportKind) {
ExportKind[ExportKind['Named'] = 0] = 'Named';
ExportKind[ExportKind['Default'] = 1] = 'Default';
ExportKind[ExportKind['ExportEquals'] = 2] = 'ExportEquals';
})(ExportKind = FindAllReferences.ExportKind || (FindAllReferences.ExportKind = {}));
let ImportExport;
(function(ImportExport) {
ImportExport[ImportExport['Import'] = 0] = 'Import';
ImportExport[ImportExport['Export'] = 1] = 'Export';
})(ImportExport = FindAllReferences.ImportExport || (FindAllReferences.ImportExport = {}));
/** Returns import statements that directly reference the exporting module, and a list of files that may access the module through a namespace. */
function getImportersForExport(sourceFiles, sourceFilesSet, allDirectImports, _a, checker, cancellationToken) {
  const exportingModuleSymbol = _a.exportingModuleSymbol, exportKind = _a.exportKind;
  const markSeenDirectImport = ts.nodeSeenTracker();
  const markSeenIndirectUser = ts.nodeSeenTracker();
  const directImports = [];
  const isAvailableThroughGlobal = !!exportingModuleSymbol.globalExports;
  const indirectUserDeclarations = isAvailableThroughGlobal ? undefined : [];
  handleDirectImports(exportingModuleSymbol);
  return {directImports, indirectUsers: getIndirectUsers()};
  function getIndirectUsers() {
    if (isAvailableThroughGlobal) {
      // It has `export as namespace`, so anything could potentially use it.
      return sourceFiles;
    }
    // Module augmentations may use this module's exports without importing it.
    if (exportingModuleSymbol.declarations) {
      for (let _i = 0, _a = exportingModuleSymbol.declarations; _i < _a.length; _i++) {
        const decl = _a[_i];
        if (ts.isExternalModuleAugmentation(decl) && sourceFilesSet.has(decl.getSourceFile().fileName)) {
          addIndirectUser(decl);
        }
      }
    }
    // This may return duplicates (if there are multiple module declarations in a single source file, all importing the same thing as a namespace), but `State.markSearchedSymbol` will handle that.
    return indirectUserDeclarations.map(ts.getSourceFileOfNode);
  }
  function handleDirectImports(exportingModuleSymbol) {
    const theseDirectImports = getDirectImports(exportingModuleSymbol);
    if (theseDirectImports) {
      for (let _i = 0, theseDirectImports_1 = theseDirectImports; _i < theseDirectImports_1.length; _i++) {
        const direct = theseDirectImports_1[_i];
        if (!markSeenDirectImport(direct)) {
          continue;
        }
        if (cancellationToken)
          {cancellationToken.throwIfCancellationRequested();}
        switch (direct.kind) {
          case 210 /* SyntaxKind.CallExpression */:
            if (ts.isImportCall(direct)) {
              handleImportCall(direct);
              break;
            }
            if (!isAvailableThroughGlobal) {
              const parent = direct.parent;
              if (exportKind === 2 /* ExportKind.ExportEquals */ &&
                  parent.kind === 257 /* SyntaxKind.VariableDeclaration */) {
                const name = parent.name;
                if (name.kind === 79 /* SyntaxKind.Identifier */) {
                  directImports.push(name);
                  break;
                }
              }
            }
            break;
          case 79 /* SyntaxKind.Identifier */:  // for 'const x = require("y");
            break;                              // TODO: GH#23879
          case 268 /* SyntaxKind.ImportEqualsDeclaration */:
            handleNamespaceImport(
                direct, direct.name, ts.hasSyntacticModifier(direct, 1 /* ModifierFlags.Export */),
                /* alreadyAddedDirect*/ false);
            break;
          case 269 /* SyntaxKind.ImportDeclaration */:
            directImports.push(direct);
            var namedBindings = direct.importClause && direct.importClause.namedBindings;
            if (namedBindings && namedBindings.kind === 271 /* SyntaxKind.NamespaceImport */) {
              handleNamespaceImport(direct, namedBindings.name, /* isReExport*/ false, /* alreadyAddedDirect*/ true);
            } else if (!isAvailableThroughGlobal && ts.isDefaultImport(direct)) {
              addIndirectUser(getSourceFileLikeForImportDeclaration(
                  direct));  // Add a check for indirect uses to handle synthetic default imports
            }
            break;
          case 275 /* SyntaxKind.ExportDeclaration */:
            if (!direct.exportClause) {
              // This is `export * from "foo"`, so imports of this module may import the export too.
              handleDirectImports(getContainingModuleSymbol(direct, checker));
            } else if (direct.exportClause.kind === 277 /* SyntaxKind.NamespaceExport */) {
              // `export * as foo from "foo"` add to indirect uses
              addIndirectUser(getSourceFileLikeForImportDeclaration(direct), /** addTransitiveDependencies */ true);
            } else {
              // This is `export { foo } from "foo"` and creates an alias symbol, so recursive search will get handle re-exports.
              directImports.push(direct);
            }
            break;
          case 202 /* SyntaxKind.ImportType */:
            // Only check for typeof import('xyz')
            if (!isAvailableThroughGlobal && direct.isTypeOf && !direct.qualifier && isExported(direct)) {
              addIndirectUser(direct.getSourceFile(), /** addTransitiveDependencies */ true);
            }
            directImports.push(direct);
            break;
          default:
            ts.Debug.failBadSyntaxKind(direct, 'Unexpected import kind.');
        }
      }
    }
  }
  function handleImportCall(importCall) {
    const top = ts.findAncestor(importCall, isAmbientModuleDeclaration) || importCall.getSourceFile();
    addIndirectUser(top, /** addTransitiveDependencies */ !!isExported(importCall, /** stopAtAmbientModule */ true));
  }
  function isExported(node, stopAtAmbientModule) {
    if (stopAtAmbientModule === void 0) {
      stopAtAmbientModule = false;
    }
    return ts.findAncestor(node, function(node) {
      if (stopAtAmbientModule && isAmbientModuleDeclaration(node))
        {return 'quit';}
      return ts.canHaveModifiers(node) && ts.some(node.modifiers, ts.isExportModifier);
    });
  }
  function handleNamespaceImport(importDeclaration, name, isReExport, alreadyAddedDirect) {
    if (exportKind === 2 /* ExportKind.ExportEquals */) {
      // This is a direct import, not import-as-namespace.
      if (!alreadyAddedDirect)
        {directImports.push(importDeclaration);}
    } else if (!isAvailableThroughGlobal) {
      const sourceFileLike = getSourceFileLikeForImportDeclaration(importDeclaration);
      ts.Debug.assert(
          sourceFileLike.kind === 308 /* SyntaxKind.SourceFile */ ||
          sourceFileLike.kind === 264 /* SyntaxKind.ModuleDeclaration */);
      if (isReExport || findNamespaceReExports(sourceFileLike, name, checker)) {
        addIndirectUser(sourceFileLike, /** addTransitiveDependencies */ true);
      } else {
        addIndirectUser(sourceFileLike);
      }
    }
  }
  /** Adds a module and all of its transitive dependencies as possible indirect users. */
  function addIndirectUser(sourceFileLike, addTransitiveDependencies) {
    if (addTransitiveDependencies === void 0) {
      addTransitiveDependencies = false;
    }
    ts.Debug.assert(!isAvailableThroughGlobal);
    const isNew = markSeenIndirectUser(sourceFileLike);
    if (!isNew)
      {return;}
    indirectUserDeclarations.push(sourceFileLike);  // TODO: GH#18217
    if (!addTransitiveDependencies)
      {return;}
    const moduleSymbol = checker.getMergedSymbol(sourceFileLike.symbol);
    if (!moduleSymbol)
      {return;}
    ts.Debug.assert(!!(moduleSymbol.flags & 1536 /* SymbolFlags.Module */));
    const directImports = getDirectImports(moduleSymbol);
    if (directImports) {
      for (let _i = 0, directImports_1 = directImports; _i < directImports_1.length; _i++) {
        const directImport = directImports_1[_i];
        if (!ts.isImportTypeNode(directImport)) {
          addIndirectUser(getSourceFileLikeForImportDeclaration(directImport), /** addTransitiveDependencies */ true);
        }
      }
    }
  }
  function getDirectImports(moduleSymbol) {
    return allDirectImports.get(ts.getSymbolId(moduleSymbol).toString());
  }
}
/**
 * Given the set of direct imports of a module, we need to find which ones import the particular exported symbol.
 * The returned `importSearches` will result in the entire source file being searched.
 * But re-exports will be placed in 'singleReferences' since they cannot be locally referenced.
 */
function getSearchesFromDirectImports(directImports, exportSymbol, exportKind, checker, isForRename) {
  const importSearches = [];
  const singleReferences = [];
  function addSearch(location, symbol) {
    importSearches.push([location, symbol]);
  }
  if (directImports) {
    for (let _i = 0, directImports_2 = directImports; _i < directImports_2.length; _i++) {
      const decl = directImports_2[_i];
      handleImport(decl);
    }
  }
  return {importSearches, singleReferences};
  function handleImport(decl) {
    if (decl.kind === 268 /* SyntaxKind.ImportEqualsDeclaration */) {
      if (isExternalModuleImportEquals(decl)) {
        handleNamespaceImportLike(decl.name);
      }
      return;
    }
    if (decl.kind === 79 /* SyntaxKind.Identifier */) {
      handleNamespaceImportLike(decl);
      return;
    }
    if (decl.kind === 202 /* SyntaxKind.ImportType */) {
      if (decl.qualifier) {
        const firstIdentifier = ts.getFirstIdentifier(decl.qualifier);
        if (firstIdentifier.escapedText === ts.symbolName(exportSymbol)) {
          singleReferences.push(firstIdentifier);
        }
      } else if (exportKind === 2 /* ExportKind.ExportEquals */) {
        singleReferences.push(decl.argument.literal);
      }
      return;
    }
    // Ignore if there's a grammar error
    if (decl.moduleSpecifier.kind !== 10 /* SyntaxKind.StringLiteral */) {
      return;
    }
    if (decl.kind === 275 /* SyntaxKind.ExportDeclaration */) {
      if (decl.exportClause && ts.isNamedExports(decl.exportClause)) {
        searchForNamedImport(decl.exportClause);
      }
      return;
    }
    const _a = decl.importClause || {name: undefined, namedBindings: undefined}, name = _a.name,
        namedBindings = _a.namedBindings;
    if (namedBindings) {
      switch (namedBindings.kind) {
        case 271 /* SyntaxKind.NamespaceImport */:
          handleNamespaceImportLike(namedBindings.name);
          break;
        case 272 /* SyntaxKind.NamedImports */:
          // 'default' might be accessed as a named import `{ default as foo }`.
          if (exportKind === 0 /* ExportKind.Named */ || exportKind === 1 /* ExportKind.Default */) {
            searchForNamedImport(namedBindings);
          }
          break;
        default:
          ts.Debug.assertNever(namedBindings);
      }
    }
    // `export =` might be imported by a default import if `--allowSyntheticDefaultImports` is on, so this handles both ExportKind.Default and ExportKind.ExportEquals.
    // If a default import has the same name as the default export, allow to rename it.
    // Given `import f` and `export default function f`, we will rename both, but for `import g` we will rename just that.
    if (name && (exportKind === 1 /* ExportKind.Default */ || exportKind === 2 /* ExportKind.ExportEquals */) &&
        (!isForRename || name.escapedText === ts.symbolEscapedNameNoDefault(exportSymbol))) {
      const defaultImportAlias = checker.getSymbolAtLocation(name);
      addSearch(name, defaultImportAlias);
    }
  }
  /**
   * `import x = require("./x")` or `import * as x from "./x"`.
   * An `export =` may be imported by this syntax, so it may be a direct import.
   * If it's not a direct import, it will be in `indirectUsers`, so we don't have to do anything here.
   */
  function handleNamespaceImportLike(importName) {
    // Don't rename an import that already has a different name than the export.
    if (exportKind === 2 /* ExportKind.ExportEquals */ && (!isForRename || isNameMatch(importName.escapedText))) {
      addSearch(importName, checker.getSymbolAtLocation(importName));
    }
  }
  function searchForNamedImport(namedBindings) {
    if (!namedBindings) {
      return;
    }
    for (let _i = 0, _a = namedBindings.elements; _i < _a.length; _i++) {
      const element = _a[_i];
      const name = element.name, propertyName = element.propertyName;
      if (!isNameMatch((propertyName || name).escapedText)) {
        continue;
      }
      if (propertyName) {
        // This is `import { foo as bar } from "./a"` or `export { foo as bar } from "./a"`. `foo` isn't a local in the file, so just add it as a single reference.
        singleReferences.push(propertyName);
        // If renaming `{ foo as bar }`, don't touch `bar`, just `foo`.
        // But do rename `foo` in ` { default as foo }` if that's the original export name.
        if (!isForRename || name.escapedText === exportSymbol.escapedName) {
          // Search locally for `bar`.
          addSearch(name, checker.getSymbolAtLocation(name));
        }
      } else {
        const localSymbol = element.kind === 278 /* SyntaxKind.ExportSpecifier */ && element.propertyName ?
            checker.getExportSpecifierLocalTargetSymbol(
                element)  // For re-exporting under a different name, we want to get the re-exported symbol.
            :
            checker.getSymbolAtLocation(name);
        addSearch(name, localSymbol);
      }
    }
  }
  function isNameMatch(name) {
    // Use name of "default" even in `export =` case because we may have allowSyntheticDefaultImports
    return name === exportSymbol.escapedName ||
        exportKind !== 0 /* ExportKind.Named */ && name === 'default' /* InternalSymbolName.Default */;
  }
}
/** Returns 'true' is the namespace 'name' is re-exported from this module, and 'false' if it is only used locally. */
function findNamespaceReExports(sourceFileLike, name, checker) {
  const namespaceImportSymbol = checker.getSymbolAtLocation(name);
  return !!forEachPossibleImportOrExportStatement(sourceFileLike, function(statement) {
    if (!ts.isExportDeclaration(statement))
      {return;}
    const exportClause = statement.exportClause, moduleSpecifier = statement.moduleSpecifier;
    return !moduleSpecifier && exportClause && ts.isNamedExports(exportClause) &&
        exportClause.elements.some(function(element) {
          return checker.getExportSpecifierLocalTargetSymbol(element) === namespaceImportSymbol;
        });
  });
}
function findModuleReferences(program, sourceFiles, searchModuleSymbol) {
  const refs = [];
  const checker = program.getTypeChecker();
  for (let _i = 0, sourceFiles_1 = sourceFiles; _i < sourceFiles_1.length; _i++) {
    const referencingFile = sourceFiles_1[_i];
    const searchSourceFile = searchModuleSymbol.valueDeclaration;
    if ((searchSourceFile === null || searchSourceFile === void 0 ? void 0 : searchSourceFile.kind) ===
        308 /* SyntaxKind.SourceFile */) {
      for (let _a = 0, _b = referencingFile.referencedFiles; _a < _b.length; _a++) {
        var ref = _b[_a];
        if (program.getSourceFileFromReference(referencingFile, ref) === searchSourceFile) {
          refs.push({kind: 'reference', referencingFile, ref});
        }
      }
      for (let _c = 0, _d = referencingFile.typeReferenceDirectives; _c < _d.length; _c++) {
        var ref = _d[_c];
        const referenced = program.getResolvedTypeReferenceDirectives().get(
            ref.fileName, ref.resolutionMode || referencingFile.impliedNodeFormat);
        if (referenced !== undefined && referenced.resolvedFileName === searchSourceFile.fileName) {
          refs.push({kind: 'reference', referencingFile, ref});
        }
      }
    }
    forEachImport(referencingFile, function(_importDecl, moduleSpecifier) {
      const moduleSymbol = checker.getSymbolAtLocation(moduleSpecifier);
      if (moduleSymbol === searchModuleSymbol) {
        refs.push({kind: 'import', literal: moduleSpecifier});
      }
    });
  }
  return refs;
}
FindAllReferences.findModuleReferences = findModuleReferences;
/** Returns a map from a module symbol Id to all import statements that directly reference the module. */
function getDirectImportsMap(sourceFiles, checker, cancellationToken) {
  const map = new ts.Map();
  for (let _i = 0, sourceFiles_2 = sourceFiles; _i < sourceFiles_2.length; _i++) {
    const sourceFile = sourceFiles_2[_i];
    if (cancellationToken)
      {cancellationToken.throwIfCancellationRequested();}
    forEachImport(sourceFile, function(importDecl, moduleSpecifier) {
      const moduleSymbol = checker.getSymbolAtLocation(moduleSpecifier);
      if (moduleSymbol) {
        const id = ts.getSymbolId(moduleSymbol).toString();
        let imports = map.get(id);
        if (!imports) {
          map.set(id, imports = []);
        }
        imports.push(importDecl);
      }
    });
  }
  return map;
}
/** Iterates over all statements at the top level or in module declarations. Returns the first truthy result. */
function forEachPossibleImportOrExportStatement(sourceFileLike, action) {
  return ts.forEach(
      sourceFileLike.kind === 308 /* SyntaxKind.SourceFile */ ? sourceFileLike.statements :
                                                                sourceFileLike.body.statements,
      function(statement) {
        return action(statement) ||
            (isAmbientModuleDeclaration(statement) && ts.forEach(statement.body && statement.body.statements, action));
      });
}
/** Calls `action` for each import, re-export, or require() in a file. */
function forEachImport(sourceFile, action) {
  if (sourceFile.externalModuleIndicator || sourceFile.imports !== undefined) {
    for (let _i = 0, _a = sourceFile.imports; _i < _a.length; _i++) {
      const i = _a[_i];
      action(ts.importFromModuleSpecifier(i), i);
    }
  } else {
    forEachPossibleImportOrExportStatement(sourceFile, function(statement) {
      switch (statement.kind) {
        case 275 /* SyntaxKind.ExportDeclaration */:
        case 269 /* SyntaxKind.ImportDeclaration */: {
          var decl = statement;
          if (decl.moduleSpecifier && ts.isStringLiteral(decl.moduleSpecifier)) {
            action(decl, decl.moduleSpecifier);
          }
          break;
        }
        case 268 /* SyntaxKind.ImportEqualsDeclaration */: {
          var decl = statement;
          if (isExternalModuleImportEquals(decl)) {
            action(decl, decl.moduleReference.expression);
          }
          break;
        }
      }
    });
  }
}
/**
 * Given a local reference, we might notice that it's an import/export and recursively search for references of that.
 * If at an import, look locally for the symbol it imports.
 * If at an export, look for all imports of it.
 * This doesn't handle export specifiers; that is done in `getReferencesAtExportSpecifier`.
 * @param comingFromExport If we are doing a search for all exports, don't bother looking backwards for the imported symbol, since that's the reason we're here.
 */
function getImportOrExportSymbol(node, symbol, checker, comingFromExport) {
  return comingFromExport ? getExport() : getExport() || getImport();
  function getExport() {
    let _a;
    const parent = node.parent;
    const grandparent = parent.parent;
    if (symbol.exportSymbol) {
      if (parent.kind === 208 /* SyntaxKind.PropertyAccessExpression */) {
        // When accessing an export of a JS module, there's no alias. The symbol will still be flagged as an export even though we're at the use.
        // So check that we are at the declaration.
        return ((_a = symbol.declarations) === null || _a === void 0 ? void 0 : _a.some(function(d) {
                 return d === parent;
               })) &&
                ts.isBinaryExpression(grandparent) ?
            getSpecialPropertyExport(grandparent, /* useLhsSymbol*/ false) :
            undefined;
      }
        return exportInfo(symbol.exportSymbol, getExportKindForDeclaration(parent));

    }
      const exportNode = getExportNode(parent, node);
      if (exportNode && ts.hasSyntacticModifier(exportNode, 1 /* ModifierFlags.Export */)) {
        if (ts.isImportEqualsDeclaration(exportNode) && exportNode.moduleReference === node) {
          // We're at `Y` in `export import X = Y`. This is not the exported symbol, the left-hand-side is. So treat this as an import statement.
          if (comingFromExport) {
            return undefined;
          }
          const lhsSymbol = checker.getSymbolAtLocation(exportNode.name);
          return {kind: 0 /* ImportExport.Import */, symbol: lhsSymbol};
        }
          return exportInfo(symbol, getExportKindForDeclaration(exportNode));

      } if (ts.isNamespaceExport(parent)) {
        return exportInfo(symbol, 0 /* ExportKind.Named */);
      }
      // If we are in `export = a;` or `export default a;`, `parent` is the export assignment.
      if (ts.isExportAssignment(parent)) {
        return getExportAssignmentExport(parent);
      }
      // If we are in `export = class A {};` (or `export = class A {};`) at `A`, `parent.parent` is the export assignment.
      if (ts.isExportAssignment(grandparent)) {
        return getExportAssignmentExport(grandparent);
      }
      // Similar for `module.exports =` and `exports.A =`.
      if (ts.isBinaryExpression(parent)) {
        return getSpecialPropertyExport(parent, /* useLhsSymbol*/ true);
      } if (ts.isBinaryExpression(grandparent)) {
        return getSpecialPropertyExport(grandparent, /* useLhsSymbol*/ true);
      } if (ts.isJSDocTypedefTag(parent)) {
        return exportInfo(symbol, 0 /* ExportKind.Named */);
      }

    function getExportAssignmentExport(ex) {
      // Get the symbol for the `export =` node; its parent is the module it's the export of.
      if (!ex.symbol.parent)
        {return undefined;}
      const exportKind = ex.isExportEquals ? 2 /* ExportKind.ExportEquals */ : 1 /* ExportKind.Default */;
      return {
        kind: 1 /* ImportExport.Export */,
        symbol,
        exportInfo: {exportingModuleSymbol: ex.symbol.parent, exportKind}
      };
    }
    function getSpecialPropertyExport(node, useLhsSymbol) {
      let kind;
      switch (ts.getAssignmentDeclarationKind(node)) {
        case 1 /* AssignmentDeclarationKind.ExportsProperty */:
          kind = 0 /* ExportKind.Named */;
          break;
        case 2 /* AssignmentDeclarationKind.ModuleExports */:
          kind = 2 /* ExportKind.ExportEquals */;
          break;
        default:
          return undefined;
      }
      const sym = useLhsSymbol ?
          checker.getSymbolAtLocation(ts.getNameOfAccessExpression(ts.cast(node.left, ts.isAccessExpression))) :
          symbol;
      return sym && exportInfo(sym, kind);
    }
  }
  function getImport() {
    const isImport = isNodeImport(node);
    if (!isImport)
      {return undefined;}
    // A symbol being imported is always an alias. So get what that aliases to find the local symbol.
    let importedSymbol = checker.getImmediateAliasedSymbol(symbol);
    if (!importedSymbol)
      {return undefined;}
    // Search on the local symbol in the exporting module, not the exported symbol.
    importedSymbol = skipExportSpecifierSymbol(importedSymbol, checker);
    // Similarly, skip past the symbol for 'export ='
    if (importedSymbol.escapedName === 'export=') {
      importedSymbol = getExportEqualsLocalSymbol(importedSymbol, checker);
      if (importedSymbol === undefined)
        {return undefined;}
    }
    // If the import has a different name than the export, do not continue searching.
    // If `importedName` is undefined, do continue searching as the export is anonymous.
    // (All imports returned from this function will be ignored anyway if we are in rename and this is a not a named export.)
    const importedName = ts.symbolEscapedNameNoDefault(importedSymbol);
    if (importedName === undefined || importedName === 'default' /* InternalSymbolName.Default */ ||
        importedName === symbol.escapedName) {
      return {kind: 0 /* ImportExport.Import */, symbol: importedSymbol};
    }
  }
  function exportInfo(symbol, kind) {
    const exportInfo = getExportInfo(symbol, kind, checker);
    return exportInfo && {kind: 1 /* ImportExport.Export */, symbol, exportInfo};
  }
  // Not meant for use with export specifiers or export assignment.
  function getExportKindForDeclaration(node) {
    return ts.hasSyntacticModifier(node, 1024 /* ModifierFlags.Default */) ? 1 /* ExportKind.Default */ :
                                                                             0 /* ExportKind.Named */;
  }
}
FindAllReferences.getImportOrExportSymbol = getImportOrExportSymbol;
function getExportEqualsLocalSymbol(importedSymbol, checker) {
  if (importedSymbol.flags & 2097152 /* SymbolFlags.Alias */) {
    return checker.getImmediateAliasedSymbol(importedSymbol);
  }
  const decl = ts.Debug.checkDefined(importedSymbol.valueDeclaration);
  if (ts.isExportAssignment(decl)) {  // `export = class {}`
    return decl.expression.symbol;
  } if (ts.isBinaryExpression(decl)) {  // `module.exports = class {}`
    return decl.right.symbol;
  } if (ts.isSourceFile(decl)) {  // json module
    return decl.symbol;
  }
  return undefined;
}
// If a reference is a class expression, the exported node would be its parent.
// If a reference is a variable declaration, the exported node would be the variable statement.
function getExportNode(parent, node) {
  const declaration = ts.isVariableDeclaration(parent) ? parent :
      ts.isBindingElement(parent)                    ? ts.walkUpBindingElementsAndPatterns(parent) :
                                                       undefined;
  if (declaration) {
    return parent.name !== node                           ? undefined :
        ts.isCatchClause(declaration.parent)              ? undefined :
        ts.isVariableStatement(declaration.parent.parent) ? declaration.parent.parent :
                                                            undefined;
  }
    return parent;

}
function isNodeImport(node) {
  const parent = node.parent;
  switch (parent.kind) {
    case 268 /* SyntaxKind.ImportEqualsDeclaration */:
      return parent.name === node && isExternalModuleImportEquals(parent);
    case 273 /* SyntaxKind.ImportSpecifier */:
      // For a rename import `{ foo as bar }`, don't search for the imported symbol. Just find local uses of `bar`.
      return !parent.propertyName;
    case 270 /* SyntaxKind.ImportClause */:
    case 271 /* SyntaxKind.NamespaceImport */:
      ts.Debug.assert(parent.name === node);
      return true;
    case 205 /* SyntaxKind.BindingElement */:
      return ts.isInJSFile(node) && ts.isVariableDeclarationInitializedToBareOrAccessedRequire(parent.parent.parent);
    default:
      return false;
  }
}
function getExportInfo(exportSymbol, exportKind, checker) {
  const moduleSymbol = exportSymbol.parent;
  if (!moduleSymbol)
    {return undefined;}  // This can happen if an `export` is not at the top-level (which is a compile error).
  const exportingModuleSymbol =
      checker.getMergedSymbol(moduleSymbol);  // Need to get merged symbol in case there's an augmentation.
  // `export` may appear in a namespace. In that case, just rely on global search.
  return ts.isExternalModuleSymbol(exportingModuleSymbol) ?
      {exportingModuleSymbol, exportKind} :
      undefined;
}
FindAllReferences.getExportInfo = getExportInfo;
/** If at an export specifier, go to the symbol it refers to. */
function skipExportSpecifierSymbol(symbol, checker) {
  // For `export { foo } from './bar", there's nothing to skip, because it does not create a new alias. But `export { foo } does.
  if (symbol.declarations) {
    for (let _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
      const declaration = _a[_i];
      if (ts.isExportSpecifier(declaration) && !declaration.propertyName &&
          !declaration.parent.parent.moduleSpecifier) {
        return checker.getExportSpecifierLocalTargetSymbol(declaration);
      } if (
          ts.isPropertyAccessExpression(declaration) && ts.isModuleExportsAccessExpression(declaration.expression) &&
          !ts.isPrivateIdentifier(declaration.name)) {
        // Export of form 'module.exports.propName = expr';
        return checker.getSymbolAtLocation(declaration);
      } if (
          ts.isShorthandPropertyAssignment(declaration) && ts.isBinaryExpression(declaration.parent.parent) &&
          ts.getAssignmentDeclarationKind(declaration.parent.parent) ===
              2 /* AssignmentDeclarationKind.ModuleExports */) {
        return checker.getExportSpecifierLocalTargetSymbol(declaration.name);
      }
    }
  }
  return symbol;
}
function getContainingModuleSymbol(importer, checker) {
  return checker.getMergedSymbol(getSourceFileLikeForImportDeclaration(importer).symbol);
}
function getSourceFileLikeForImportDeclaration(node) {
  if (node.kind === 210 /* SyntaxKind.CallExpression */) {
    return node.getSourceFile();
  }
  const parent = node.parent;
  if (parent.kind === 308 /* SyntaxKind.SourceFile */) {
    return parent;
  }
  ts.Debug.assert(parent.kind === 265 /* SyntaxKind.ModuleBlock */);
  return ts.cast(parent.parent, isAmbientModuleDeclaration);
}
function isAmbientModuleDeclaration(node) {
  return node.kind === 264 /* SyntaxKind.ModuleDeclaration */ && node.name.kind === 10 /* SyntaxKind.StringLiteral */;
}
function isExternalModuleImportEquals(eq) {
  return eq.moduleReference.kind === 280 /* SyntaxKind.ExternalModuleReference */ &&
      eq.moduleReference.expression.kind === 10 /* SyntaxKind.StringLiteral */;
}
})(FindAllReferences = ts.FindAllReferences || (ts.FindAllReferences = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let FindAllReferences;
(function(FindAllReferences) {
let DefinitionKind;
(function(DefinitionKind) {
DefinitionKind[DefinitionKind['Symbol'] = 0] = 'Symbol';
DefinitionKind[DefinitionKind['Label'] = 1] = 'Label';
DefinitionKind[DefinitionKind['Keyword'] = 2] = 'Keyword';
DefinitionKind[DefinitionKind['This'] = 3] = 'This';
DefinitionKind[DefinitionKind['String'] = 4] = 'String';
DefinitionKind[DefinitionKind['TripleSlashReference'] = 5] = 'TripleSlashReference';
})(DefinitionKind = FindAllReferences.DefinitionKind || (FindAllReferences.DefinitionKind = {}));
let EntryKind;
(function(EntryKind) {
EntryKind[EntryKind['Span'] = 0] = 'Span';
EntryKind[EntryKind['Node'] = 1] = 'Node';
EntryKind[EntryKind['StringLiteral'] = 2] = 'StringLiteral';
EntryKind[EntryKind['SearchedLocalFoundProperty'] = 3] = 'SearchedLocalFoundProperty';
EntryKind[EntryKind['SearchedPropertyFoundLocal'] = 4] = 'SearchedPropertyFoundLocal';
})(EntryKind = FindAllReferences.EntryKind || (FindAllReferences.EntryKind = {}));
function nodeEntry(node, kind) {
  if (kind === void 0) {
    kind = 1 /* EntryKind.Node */;
  }
  return {kind, node: node.name || node, context: getContextNodeForNodeEntry(node)};
}
FindAllReferences.nodeEntry = nodeEntry;
function isContextWithStartAndEndNode(node) {
  return node && node.kind === undefined;
}
FindAllReferences.isContextWithStartAndEndNode = isContextWithStartAndEndNode;
function getContextNodeForNodeEntry(node) {
  if (ts.isDeclaration(node)) {
    return getContextNode(node);
  }
  if (!node.parent)
    {return undefined;}
  if (!ts.isDeclaration(node.parent) && !ts.isExportAssignment(node.parent)) {
    // Special property assignment in javascript
    if (ts.isInJSFile(node)) {
      const binaryExpression = ts.isBinaryExpression(node.parent) ? node.parent :
          ts.isAccessExpression(node.parent) && ts.isBinaryExpression(node.parent.parent) &&
              node.parent.parent.left === node.parent ?
                                                                  node.parent.parent :
                                                                  undefined;
      if (binaryExpression &&
          ts.getAssignmentDeclarationKind(binaryExpression) !== 0 /* AssignmentDeclarationKind.None */) {
        return getContextNode(binaryExpression);
      }
    }
    // Jsx Tags
    if (ts.isJsxOpeningElement(node.parent) || ts.isJsxClosingElement(node.parent)) {
      return node.parent.parent;
    } if (
        ts.isJsxSelfClosingElement(node.parent) || ts.isLabeledStatement(node.parent) ||
        ts.isBreakOrContinueStatement(node.parent)) {
      return node.parent;
    } if (ts.isStringLiteralLike(node)) {
      const validImport = ts.tryGetImportFromModuleSpecifier(node);
      if (validImport) {
        const declOrStatement = ts.findAncestor(validImport, function(node) {
          return ts.isDeclaration(node) || ts.isStatement(node) || ts.isJSDocTag(node);
        });
        return ts.isDeclaration(declOrStatement) ? getContextNode(declOrStatement) : declOrStatement;
      }
    }
    // Handle computed property name
    const propertyName = ts.findAncestor(node, ts.isComputedPropertyName);
    return propertyName ? getContextNode(propertyName.parent) : undefined;
  }
  if (node.parent.name === node ||  // node is name of declaration, use parent
      ts.isConstructorDeclaration(node.parent) || ts.isExportAssignment(node.parent) ||
      // Property name of the import export specifier or binding pattern, use parent
      ((ts.isImportOrExportSpecifier(node.parent) || ts.isBindingElement(node.parent)) &&
       node.parent.propertyName === node) ||
      // Is default export
      (node.kind === 88 /* SyntaxKind.DefaultKeyword */ &&
       ts.hasSyntacticModifier(node.parent, 1025 /* ModifierFlags.ExportDefault */))) {
    return getContextNode(node.parent);
  }
  return undefined;
}
function getContextNode(node) {
  if (!node)
    {return undefined;}
  switch (node.kind) {
    case 257 /* SyntaxKind.VariableDeclaration */:
      return !ts.isVariableDeclarationList(node.parent) || node.parent.declarations.length !== 1 ? node :
          ts.isVariableStatement(node.parent.parent)                                             ? node.parent.parent :
          ts.isForInOrOfStatement(node.parent.parent) ? getContextNode(node.parent.parent) :
                                                        node.parent;
    case 205 /* SyntaxKind.BindingElement */:
      return getContextNode(node.parent.parent);
    case 273 /* SyntaxKind.ImportSpecifier */:
      return node.parent.parent.parent;
    case 278 /* SyntaxKind.ExportSpecifier */:
    case 271 /* SyntaxKind.NamespaceImport */:
      return node.parent.parent;
    case 270 /* SyntaxKind.ImportClause */:
    case 277 /* SyntaxKind.NamespaceExport */:
      return node.parent;
    case 223 /* SyntaxKind.BinaryExpression */:
      return ts.isExpressionStatement(node.parent) ? node.parent : node;
    case 247 /* SyntaxKind.ForOfStatement */:
    case 246 /* SyntaxKind.ForInStatement */:
      return {start: node.initializer, end: node.expression};
    case 299 /* SyntaxKind.PropertyAssignment */:
    case 300 /* SyntaxKind.ShorthandPropertyAssignment */:
      return ts.isArrayLiteralOrObjectLiteralDestructuringPattern(node.parent) ?
          getContextNode(ts.findAncestor(
              node.parent,
              function(node) {
                return ts.isBinaryExpression(node) || ts.isForInOrOfStatement(node);
              })) :
          node;
    default:
      return node;
  }
}
FindAllReferences.getContextNode = getContextNode;
function toContextSpan(textSpan, sourceFile, context) {
  if (!context)
    {return undefined;}
  const contextSpan = isContextWithStartAndEndNode(context) ? getTextSpan(context.start, sourceFile, context.end) :
                                                            getTextSpan(context, sourceFile);
  return contextSpan.start !== textSpan.start || contextSpan.length !== textSpan.length ? {contextSpan} :
                                                                                          undefined;
}
FindAllReferences.toContextSpan = toContextSpan;
let FindReferencesUse;
(function(FindReferencesUse) {
/**
 * When searching for references to a symbol, the location will not be adjusted (this is the default behavior when not specified).
 */
FindReferencesUse[FindReferencesUse['Other'] = 0] = 'Other';
/**
 * When searching for references to a symbol, the location will be adjusted if the cursor was on a keyword.
 */
FindReferencesUse[FindReferencesUse['References'] = 1] = 'References';
/**
 * When searching for references to a symbol, the location will be adjusted if the cursor was on a keyword.
 * Unlike `References`, the location will only be adjusted keyword belonged to a declaration with a valid name.
 * If set, we will find fewer references -- if it is referenced by several different names, we still only find references for the original name.
 */
FindReferencesUse[FindReferencesUse['Rename'] = 2] = 'Rename';
})(FindReferencesUse = FindAllReferences.FindReferencesUse || (FindAllReferences.FindReferencesUse = {}));
function findReferencedSymbols(program, cancellationToken, sourceFiles, sourceFile, position) {
  const node = ts.getTouchingPropertyName(sourceFile, position);
  const options = {use: 1 /* FindReferencesUse.References */};
  const referencedSymbols =
      Core.getReferencedSymbolsForNode(position, node, program, sourceFiles, cancellationToken, options);
  const checker = program.getTypeChecker();
  // Unless the starting node is a declaration (vs e.g. JSDoc), don't attempt to compute isDefinition
  const adjustedNode = Core.getAdjustedNode(node, options);
  const symbol = isDefinitionForReference(adjustedNode) ? checker.getSymbolAtLocation(adjustedNode) : undefined;
  return !referencedSymbols || !referencedSymbols.length ? undefined : ts.mapDefined(referencedSymbols, function(_a) {
    const definition = _a.definition, references = _a.references;
    // Only include referenced symbols that have a valid definition.
    return definition && {
      definition: checker.runWithCancellationToken(
          cancellationToken,
          function(checker) {
            return definitionToReferencedSymbolDefinitionInfo(definition, checker, node);
          }),
      references: references.map(function(r) {
        return toReferencedSymbolEntry(r, symbol);
      })
    };
  });
}
FindAllReferences.findReferencedSymbols = findReferencedSymbols;
function isDefinitionForReference(node) {
  return node.kind === 88 /* SyntaxKind.DefaultKeyword */
      || !!ts.getDeclarationFromName(node) || ts.isLiteralComputedPropertyDeclarationName(node) ||
      (node.kind === 135 /* SyntaxKind.ConstructorKeyword */ && ts.isConstructorDeclaration(node.parent));
}
function getImplementationsAtPosition(program, cancellationToken, sourceFiles, sourceFile, position) {
  const node = ts.getTouchingPropertyName(sourceFile, position);
  let referenceEntries;
  const entries = getImplementationReferenceEntries(program, cancellationToken, sourceFiles, node, position);
  if (node.parent.kind === 208    /* SyntaxKind.PropertyAccessExpression */
      || node.parent.kind === 205 /* SyntaxKind.BindingElement */
      || node.parent.kind === 209 /* SyntaxKind.ElementAccessExpression */
      || node.kind === 106 /* SyntaxKind.SuperKeyword */) {
    referenceEntries = entries && __spreadArray([], entries, true);
  } else if (entries) {
    const queue = ts.createQueue(entries);
    const seenNodes = new ts.Map();
    while (!queue.isEmpty()) {
      const entry = queue.dequeue();
      if (!ts.addToSeen(seenNodes, ts.getNodeId(entry.node))) {
        continue;
      }
      referenceEntries = ts.append(referenceEntries, entry);
      const entries_1 =
          getImplementationReferenceEntries(program, cancellationToken, sourceFiles, entry.node, entry.node.pos);
      if (entries_1) {
        queue.enqueue.apply(queue, entries_1);
      }
    }
  }
  const checker = program.getTypeChecker();
  return ts.map(referenceEntries, function(entry) {
    return toImplementationLocation(entry, checker);
  });
}
FindAllReferences.getImplementationsAtPosition = getImplementationsAtPosition;
function getImplementationReferenceEntries(program, cancellationToken, sourceFiles, node, position) {
  if (node.kind === 308 /* SyntaxKind.SourceFile */) {
    return undefined;
  }
  const checker = program.getTypeChecker();
  // If invoked directly on a shorthand property assignment, then return
  // the declaration of the symbol being assigned (not the symbol being assigned to).
  if (node.parent.kind === 300 /* SyntaxKind.ShorthandPropertyAssignment */) {
    const result_2 = [];
    Core.getReferenceEntriesForShorthandPropertyAssignment(node, checker, function(node) {
      return result_2.push(nodeEntry(node));
    });
    return result_2;
  } if (node.kind === 106 /* SyntaxKind.SuperKeyword */ || ts.isSuperProperty(node.parent)) {
    // References to and accesses on the super keyword only have one possible implementation, so no
    // need to "Find all References"
    const symbol = checker.getSymbolAtLocation(node);
    return symbol.valueDeclaration && [nodeEntry(symbol.valueDeclaration)];
  }
    // Perform "Find all References" and retrieve only those that are implementations
    return getReferenceEntriesForNode(
        position, node, program, sourceFiles, cancellationToken,
        {implementations: true, use: 1 /* FindReferencesUse.References */});

}
function findReferenceOrRenameEntries(program, cancellationToken, sourceFiles, node, position, options, convertEntry) {
  return ts.map(
      flattenEntries(
          Core.getReferencedSymbolsForNode(position, node, program, sourceFiles, cancellationToken, options)),
      function(entry) {
        return convertEntry(entry, node, program.getTypeChecker());
      });
}
FindAllReferences.findReferenceOrRenameEntries = findReferenceOrRenameEntries;
function getReferenceEntriesForNode(position, node, program, sourceFiles, cancellationToken, options, sourceFilesSet) {
  if (options === void 0) {
    options = {};
  }
  if (sourceFilesSet === void 0) {
    sourceFilesSet = new ts.Set(sourceFiles.map(function(f) {
      return f.fileName;
    }));
  }
  return flattenEntries(Core.getReferencedSymbolsForNode(
      position, node, program, sourceFiles, cancellationToken, options, sourceFilesSet));
}
FindAllReferences.getReferenceEntriesForNode = getReferenceEntriesForNode;
function flattenEntries(referenceSymbols) {
  return referenceSymbols && ts.flatMap(referenceSymbols, function(r) {
    return r.references;
  });
}
function definitionToReferencedSymbolDefinitionInfo(def, checker, originalNode) {
  const info = (function() {
    switch (def.type) {
      case 0 /* DefinitionKind.Symbol */: {
        var symbol = def.symbol;
        const _a = getDefinitionKindAndDisplayParts(symbol, checker, originalNode), displayParts_1 = _a.displayParts,
            kind_1 = _a.kind;
        const name_1 = displayParts_1
                         .map(function(p) {
                           return p.text;
                         })
                         .join('');
        const declaration = symbol.declarations && ts.firstOrUndefined(symbol.declarations);
        var node = declaration ? (ts.getNameOfDeclaration(declaration) || declaration) : originalNode;
        return __assign(
            __assign({}, getFileAndTextSpanFromNode(node)),
            {name: name_1, kind: kind_1, displayParts: displayParts_1, context: getContextNode(declaration)});
      }
      case 1 /* DefinitionKind.Label */: {
        var node = def.node;
        return __assign(__assign({}, getFileAndTextSpanFromNode(node)), {
          name: node.text,
          kind: 'label' /* ScriptElementKind.label */,
          displayParts: [ts.displayPart(node.text, ts.SymbolDisplayPartKind.text)]
        });
      }
      case 2 /* DefinitionKind.Keyword */: {
        var node = def.node;
        const name_2 = ts.tokenToString(node.kind);
        return __assign(__assign({}, getFileAndTextSpanFromNode(node)), {
          name: name_2,
          kind: 'keyword' /* ScriptElementKind.keyword */,
          displayParts: [{text: name_2, kind: 'keyword' /* ScriptElementKind.keyword */}]
        });
      }
      case 3 /* DefinitionKind.This */: {
        var node = def.node;
        var symbol = checker.getSymbolAtLocation(node);
        const displayParts_2 = symbol &&
                ts.SymbolDisplay
                    .getSymbolDisplayPartsDocumentationAndSymbolKind(
                        checker, symbol, node.getSourceFile(), ts.getContainerNode(node), node)
                    .displayParts ||
            [ts.textPart('this')];
        return __assign(
            __assign({}, getFileAndTextSpanFromNode(node)),
            {name: 'this', kind: 'var' /* ScriptElementKind.variableElement */, displayParts: displayParts_2});
      }
      case 4 /* DefinitionKind.String */: {
        var node = def.node;
        return __assign(__assign({}, getFileAndTextSpanFromNode(node)), {
          name: node.text,
          kind: 'var' /* ScriptElementKind.variableElement */,
          displayParts: [ts.displayPart(ts.getTextOfNode(node), ts.SymbolDisplayPartKind.stringLiteral)]
        });
      }
      case 5 /* DefinitionKind.TripleSlashReference */: {
        return {
          textSpan: ts.createTextSpanFromRange(def.reference),
          sourceFile: def.file,
          name: def.reference.fileName,
          kind: 'string' /* ScriptElementKind.string */,
          displayParts:
              [ts.displayPart('"'.concat(def.reference.fileName, '"'), ts.SymbolDisplayPartKind.stringLiteral)]
        };
      }
      default:
        return ts.Debug.assertNever(def);
    }
  })();
  const sourceFile = info.sourceFile, textSpan = info.textSpan, name = info.name, kind = info.kind,
      displayParts = info.displayParts, context = info.context;
  return __assign(
      {
        containerKind: '' /* ScriptElementKind.unknown */,
        containerName: '',
        fileName: sourceFile.fileName,
        kind,
        name,
        textSpan,
        displayParts
      },
      toContextSpan(textSpan, sourceFile, context));
}
function getFileAndTextSpanFromNode(node) {
  const sourceFile = node.getSourceFile();
  return {
    sourceFile,
    textSpan: getTextSpan(ts.isComputedPropertyName(node) ? node.expression : node, sourceFile)
  };
}
function getDefinitionKindAndDisplayParts(symbol, checker, node) {
  const meaning = Core.getIntersectingMeaningFromDeclarations(node, symbol);
  const enclosingDeclaration = symbol.declarations && ts.firstOrUndefined(symbol.declarations) || node;
  const _a = ts.SymbolDisplay.getSymbolDisplayPartsDocumentationAndSymbolKind(
          checker, symbol, enclosingDeclaration.getSourceFile(), enclosingDeclaration, enclosingDeclaration, meaning),
      displayParts = _a.displayParts, symbolKind = _a.symbolKind;
  return {displayParts, kind: symbolKind};
}
function toRenameLocation(entry, originalNode, checker, providePrefixAndSuffixText) {
  return __assign(
      __assign({}, entryToDocumentSpan(entry)),
      (providePrefixAndSuffixText && getPrefixAndSuffixText(entry, originalNode, checker)));
}
FindAllReferences.toRenameLocation = toRenameLocation;
function toReferencedSymbolEntry(entry, symbol) {
  const referenceEntry = toReferenceEntry(entry);
  if (!symbol)
    {return referenceEntry;}
  return __assign(
      __assign({}, referenceEntry),
      {isDefinition: entry.kind !== 0 /* EntryKind.Span */ && isDeclarationOfSymbol(entry.node, symbol)});
}
function toReferenceEntry(entry) {
  const documentSpan = entryToDocumentSpan(entry);
  if (entry.kind === 0 /* EntryKind.Span */) {
    return __assign(__assign({}, documentSpan), {isWriteAccess: false});
  }
  const kind = entry.kind, node = entry.node;
  return __assign(__assign({}, documentSpan), {
    isWriteAccess: isWriteAccessForReference(node),
    isInString: kind === 2 /* EntryKind.StringLiteral */ ? true : undefined
  });
}
FindAllReferences.toReferenceEntry = toReferenceEntry;
function entryToDocumentSpan(entry) {
  if (entry.kind === 0 /* EntryKind.Span */) {
    return {textSpan: entry.textSpan, fileName: entry.fileName};
  }
    const sourceFile = entry.node.getSourceFile();
    const textSpan = getTextSpan(entry.node, sourceFile);
    return __assign(
        {textSpan, fileName: sourceFile.fileName}, toContextSpan(textSpan, sourceFile, entry.context));

}
function getPrefixAndSuffixText(entry, originalNode, checker) {
  if (entry.kind !== 0 /* EntryKind.Span */ && ts.isIdentifier(originalNode)) {
    const node = entry.node, kind = entry.kind;
    const parent = node.parent;
    const name = originalNode.text;
    const isShorthandAssignment = ts.isShorthandPropertyAssignment(parent);
    if (isShorthandAssignment ||
        (ts.isObjectBindingElementWithoutPropertyName(parent) && parent.name === node &&
         parent.dotDotDotToken === undefined)) {
      const prefixColon = {prefixText: name + ': '};
      const suffixColon = {suffixText: ': ' + name};
      if (kind === 3 /* EntryKind.SearchedLocalFoundProperty */) {
        return prefixColon;
      }
      if (kind === 4 /* EntryKind.SearchedPropertyFoundLocal */) {
        return suffixColon;
      }
      // In `const o = { x }; o.x`, symbolAtLocation at `x` in `{ x }` is the property symbol.
      // For a binding element `const { x } = o;`, symbolAtLocation at `x` is the property symbol.
      if (isShorthandAssignment) {
        const grandParent = parent.parent;
        if (ts.isObjectLiteralExpression(grandParent) && ts.isBinaryExpression(grandParent.parent) &&
            ts.isModuleExportsAccessExpression(grandParent.parent.left)) {
          return prefixColon;
        }
        return suffixColon;
      }
        return prefixColon;

    } if (ts.isImportSpecifier(parent) && !parent.propertyName) {
      // If the original symbol was using this alias, just rename the alias.
      const originalSymbol = ts.isExportSpecifier(originalNode.parent) ?
          checker.getExportSpecifierLocalTargetSymbol(originalNode.parent) :
          checker.getSymbolAtLocation(originalNode);
      return ts.contains(originalSymbol.declarations, parent) ? {prefixText: name + ' as '} : ts.emptyOptions;
    } if (ts.isExportSpecifier(parent) && !parent.propertyName) {
      // If the symbol for the node is same as declared node symbol use prefix text
      return originalNode === entry.node ||
              checker.getSymbolAtLocation(originalNode) === checker.getSymbolAtLocation(entry.node) ?
          {prefixText: name + ' as '} :
          {suffixText: ' as ' + name};
    }
  }
  return ts.emptyOptions;
}
function toImplementationLocation(entry, checker) {
  const documentSpan = entryToDocumentSpan(entry);
  if (entry.kind !== 0 /* EntryKind.Span */) {
    const node = entry.node;
    return __assign(__assign({}, documentSpan), implementationKindDisplayParts(node, checker));
  }
    return __assign(__assign({}, documentSpan), {kind: '' /* ScriptElementKind.unknown */, displayParts: []});

}
function implementationKindDisplayParts(node, checker) {
  const symbol = checker.getSymbolAtLocation(ts.isDeclaration(node) && node.name ? node.name : node);
  if (symbol) {
    return getDefinitionKindAndDisplayParts(symbol, checker, node);
  } if (node.kind === 207 /* SyntaxKind.ObjectLiteralExpression */) {
    return {
      kind: 'interface' /* ScriptElementKind.interfaceElement */,
      displayParts: [
        ts.punctuationPart(20 /* SyntaxKind.OpenParenToken */), ts.textPart('object literal'),
        ts.punctuationPart(21 /* SyntaxKind.CloseParenToken */)
      ]
    };
  } if (node.kind === 228 /* SyntaxKind.ClassExpression */) {
    return {
      kind: 'local class' /* ScriptElementKind.localClassElement */,
      displayParts: [
        ts.punctuationPart(20 /* SyntaxKind.OpenParenToken */), ts.textPart('anonymous local class'),
        ts.punctuationPart(21 /* SyntaxKind.CloseParenToken */)
      ]
    };
  }
    return {kind: ts.getNodeKind(node), displayParts: []};

}
function toHighlightSpan(entry) {
  const documentSpan = entryToDocumentSpan(entry);
  if (entry.kind === 0 /* EntryKind.Span */) {
    return {
      fileName: documentSpan.fileName,
      span: {
        textSpan: documentSpan.textSpan,
        kind: 'reference' /* HighlightSpanKind.reference */
      }
    };
  }
  const writeAccess = isWriteAccessForReference(entry.node);
  const span = __assign(
      {
        textSpan: documentSpan.textSpan,
        kind: writeAccess ? 'writtenReference' /* HighlightSpanKind.writtenReference */ :
                            'reference' /* HighlightSpanKind.reference */,
        isInString: entry.kind === 2 /* EntryKind.StringLiteral */ ? true : undefined
      },
      documentSpan.contextSpan && {contextSpan: documentSpan.contextSpan});
  return {fileName: documentSpan.fileName, span};
}
FindAllReferences.toHighlightSpan = toHighlightSpan;
function getTextSpan(node, sourceFile, endNode) {
  let start = node.getStart(sourceFile);
  let end = (endNode || node).getEnd();
  if (ts.isStringLiteralLike(node) && (end - start) > 2) {
    ts.Debug.assert(endNode === undefined);
    start += 1;
    end -= 1;
  }
  return ts.createTextSpanFromBounds(start, end);
}
function getTextSpanOfEntry(entry) {
  return entry.kind === 0 /* EntryKind.Span */ ? entry.textSpan : getTextSpan(entry.node, entry.node.getSourceFile());
}
FindAllReferences.getTextSpanOfEntry = getTextSpanOfEntry;
/** A node is considered a writeAccess iff it is a name of a declaration or a target of an assignment */
function isWriteAccessForReference(node) {
  const decl = ts.getDeclarationFromName(node);
  return !!decl && declarationIsWriteAccess(decl) || node.kind === 88 /* SyntaxKind.DefaultKeyword */ ||
      ts.isWriteAccess(node);
}
/** Whether a reference, `node`, is a definition of the `target` symbol */
function isDeclarationOfSymbol(node, target) {
  let _a;
  if (!target)
    {return false;}
  const source = ts.getDeclarationFromName(node) ||
      (node.kind === 88 /* SyntaxKind.DefaultKeyword */      ? node.parent :
           ts.isLiteralComputedPropertyDeclarationName(node) ? node.parent.parent :
           node.kind === 135 /* SyntaxKind.ConstructorKeyword */ && ts.isConstructorDeclaration(node.parent) ?
                                                               node.parent.parent :
                                                               undefined);
  const commonjsSource = source && ts.isBinaryExpression(source) ? source.left : undefined;
  return !!(source && ((_a = target.declarations) === null || _a === void 0 ? void 0 : _a.some(function(d) {
              return d === source || d === commonjsSource;
            })));
}
FindAllReferences.isDeclarationOfSymbol = isDeclarationOfSymbol;
/**
 * True if 'decl' provides a value, as in `function f() {}`;
 * false if 'decl' is just a location for a future write, as in 'let x;'
 */
function declarationIsWriteAccess(decl) {
  // Consider anything in an ambient declaration to be a write access since it may be coming from JS.
  if (!!(decl.flags & 16777216 /* NodeFlags.Ambient */))
    {return true;}
  switch (decl.kind) {
    case 223 /* SyntaxKind.BinaryExpression */:
    case 205 /* SyntaxKind.BindingElement */:
    case 260 /* SyntaxKind.ClassDeclaration */:
    case 228 /* SyntaxKind.ClassExpression */:
    case 88 /* SyntaxKind.DefaultKeyword */:
    case 263 /* SyntaxKind.EnumDeclaration */:
    case 302 /* SyntaxKind.EnumMember */:
    case 278 /* SyntaxKind.ExportSpecifier */:
    case 270 /* SyntaxKind.ImportClause */:  // default import
    case 268 /* SyntaxKind.ImportEqualsDeclaration */:
    case 273 /* SyntaxKind.ImportSpecifier */:
    case 261 /* SyntaxKind.InterfaceDeclaration */:
    case 341 /* SyntaxKind.JSDocCallbackTag */:
    case 348 /* SyntaxKind.JSDocTypedefTag */:
    case 288 /* SyntaxKind.JsxAttribute */:
    case 264 /* SyntaxKind.ModuleDeclaration */:
    case 267 /* SyntaxKind.NamespaceExportDeclaration */:
    case 271 /* SyntaxKind.NamespaceImport */:
    case 277 /* SyntaxKind.NamespaceExport */:
    case 166 /* SyntaxKind.Parameter */:
    case 300 /* SyntaxKind.ShorthandPropertyAssignment */:
    case 262 /* SyntaxKind.TypeAliasDeclaration */:
    case 165 /* SyntaxKind.TypeParameter */:
      return true;
    case 299 /* SyntaxKind.PropertyAssignment */:
      // In `({ x: y } = 0);`, `x` is not a write access. (Won't call this function for `y`.)
      return !ts.isArrayLiteralOrObjectLiteralDestructuringPattern(decl.parent);
    case 259 /* SyntaxKind.FunctionDeclaration */:
    case 215 /* SyntaxKind.FunctionExpression */:
    case 173 /* SyntaxKind.Constructor */:
    case 171 /* SyntaxKind.MethodDeclaration */:
    case 174 /* SyntaxKind.GetAccessor */:
    case 175 /* SyntaxKind.SetAccessor */:
      return !!decl.body;
    case 257 /* SyntaxKind.VariableDeclaration */:
    case 169 /* SyntaxKind.PropertyDeclaration */:
      return !!decl.initializer || ts.isCatchClause(decl.parent);
    case 170 /* SyntaxKind.MethodSignature */:
    case 168 /* SyntaxKind.PropertySignature */:
    case 350 /* SyntaxKind.JSDocPropertyTag */:
    case 343 /* SyntaxKind.JSDocParameterTag */:
      return false;
    default:
      return ts.Debug.failBadSyntaxKind(decl);
  }
}
/** Encapsulates the core find-all-references algorithm. */
let Core;
(function(Core) {
/** Core find-all-references algorithm. Handles special cases before delegating to `getReferencedSymbolsForSymbol`. */
function getReferencedSymbolsForNode(position, node, program, sourceFiles, cancellationToken, options, sourceFilesSet) {
  let _a, _b;
  if (options === void 0) {
    options = {};
  }
  if (sourceFilesSet === void 0) {
    sourceFilesSet = new ts.Set(sourceFiles.map(function(f) {
      return f.fileName;
    }));
  }
  node = getAdjustedNode(node, options);
  if (ts.isSourceFile(node)) {
    const resolvedRef = ts.GoToDefinition.getReferenceAtPosition(node, position, program);
    if (!(resolvedRef === null || resolvedRef === void 0 ? void 0 : resolvedRef.file)) {
      return undefined;
    }
    const moduleSymbol = program.getTypeChecker().getMergedSymbol(resolvedRef.file.symbol);
    if (moduleSymbol) {
      return getReferencedSymbolsForModule(
          program, moduleSymbol, /* excludeImportTypeOfExportEquals*/ false, sourceFiles, sourceFilesSet);
    }
    var fileIncludeReasons = program.getFileIncludeReasons();
    if (!fileIncludeReasons) {
      return undefined;
    }
    return [{
      definition: {type: 5 /* DefinitionKind.TripleSlashReference */, reference: resolvedRef.reference, file: node},
      references: getReferencesForNonModule(resolvedRef.file, fileIncludeReasons, program) || ts.emptyArray
    }];
  }
  if (!options.implementations) {
    const special = getReferencedSymbolsSpecial(node, sourceFiles, cancellationToken);
    if (special) {
      return special;
    }
  }
  const checker = program.getTypeChecker();
  // constructors should use the class symbol, detected by name, if present
  const symbol = checker.getSymbolAtLocation(ts.isConstructorDeclaration(node) && node.parent.name || node);
  // Could not find a symbol e.g. unknown identifier
  if (!symbol) {
    // String literal might be a property (and thus have a symbol), so do this here rather than in getReferencedSymbolsSpecial.
    if (!options.implementations && ts.isStringLiteralLike(node)) {
      if (ts.isModuleSpecifierLike(node)) {
        var fileIncludeReasons = program.getFileIncludeReasons();
        const referencedFileName =
            (_b = (_a = node.getSourceFile().resolvedModules) === null || _a === void 0 ?
                 void 0 :
                 _a.get(node.text, ts.getModeForUsageLocation(node.getSourceFile(), node))) === null ||
                _b === void 0 ?
            void 0 :
            _b.resolvedFileName;
        const referencedFile = referencedFileName ? program.getSourceFile(referencedFileName) : undefined;
        if (referencedFile) {
          return [{
            definition: {type: 4 /* DefinitionKind.String */, node},
            references: getReferencesForNonModule(referencedFile, fileIncludeReasons, program) || ts.emptyArray
          }];
        }
        // Fall through to string literal references. This is not very likely to return
        // anything useful, but I guess it's better than nothing, and there's an existing
        // test that expects this to happen (fourslash/cases/untypedModuleImport.ts).
      }
      return getReferencesForStringLiteral(node, sourceFiles, checker, cancellationToken);
    }
    return undefined;
  }
  if (symbol.escapedName === 'export=' /* InternalSymbolName.ExportEquals */) {
    return getReferencedSymbolsForModule(
        program, symbol.parent, /* excludeImportTypeOfExportEquals*/ false, sourceFiles, sourceFilesSet);
  }
  const moduleReferences = getReferencedSymbolsForModuleIfDeclaredBySourceFile(
      symbol, program, sourceFiles, cancellationToken, options, sourceFilesSet);
  if (moduleReferences && !(symbol.flags & 33554432 /* SymbolFlags.Transient */)) {
    return moduleReferences;
  }
  const aliasedSymbol = getMergedAliasedSymbolOfNamespaceExportDeclaration(node, symbol, checker);
  const moduleReferencesOfExportTarget =
      aliasedSymbol &&
      getReferencedSymbolsForModuleIfDeclaredBySourceFile(
          aliasedSymbol, program, sourceFiles, cancellationToken, options, sourceFilesSet);
  const references =
      getReferencedSymbolsForSymbol(symbol, node, sourceFiles, sourceFilesSet, checker, cancellationToken, options);
  return mergeReferences(program, moduleReferences, references, moduleReferencesOfExportTarget);
}
Core.getReferencedSymbolsForNode = getReferencedSymbolsForNode;
function getAdjustedNode(node, options) {
  if (options.use === 1 /* FindReferencesUse.References */) {
    node = ts.getAdjustedReferenceLocation(node);
  } else if (options.use === 2 /* FindReferencesUse.Rename */) {
    node = ts.getAdjustedRenameLocation(node);
  }
  return node;
}
Core.getAdjustedNode = getAdjustedNode;
function getReferencesForFileName(fileName, program, sourceFiles, sourceFilesSet) {
  let _a, _b;
  if (sourceFilesSet === void 0) {
    sourceFilesSet = new ts.Set(sourceFiles.map(function(f) {
      return f.fileName;
    }));
  }
  const moduleSymbol = (_a = program.getSourceFile(fileName)) === null || _a === void 0 ? void 0 : _a.symbol;
  if (moduleSymbol) {
    return ((_b = getReferencedSymbolsForModule(
                 program, moduleSymbol, /* excludeImportTypeOfExportEquals*/ false, sourceFiles, sourceFilesSet)[0]) ===
                        null ||
                    _b === void 0 ?
                void 0 :
                _b.references) ||
        ts.emptyArray;
  }
  const fileIncludeReasons = program.getFileIncludeReasons();
  const referencedFile = program.getSourceFile(fileName);
  return referencedFile && fileIncludeReasons &&
      getReferencesForNonModule(referencedFile, fileIncludeReasons, program) ||
      ts.emptyArray;
}
Core.getReferencesForFileName = getReferencesForFileName;
function getReferencesForNonModule(referencedFile, refFileMap, program) {
  let entries;
  const references = refFileMap.get(referencedFile.path) || ts.emptyArray;
  for (let _i = 0, references_1 = references; _i < references_1.length; _i++) {
    const ref = references_1[_i];
    if (ts.isReferencedFile(ref)) {
      const referencingFile = program.getSourceFileByPath(ref.file);
      const location = ts.getReferencedFileLocation(program.getSourceFileByPath, ref);
      if (ts.isReferenceFileLocation(location)) {
        entries = ts.append(entries, {
          kind: 0 /* EntryKind.Span */,
          fileName: referencingFile.fileName,
          textSpan: ts.createTextSpanFromRange(location)
        });
      }
    }
  }
  return entries;
}
function getMergedAliasedSymbolOfNamespaceExportDeclaration(node, symbol, checker) {
  if (node.parent && ts.isNamespaceExportDeclaration(node.parent)) {
    const aliasedSymbol = checker.getAliasedSymbol(symbol);
    const targetSymbol = checker.getMergedSymbol(aliasedSymbol);
    if (aliasedSymbol !== targetSymbol) {
      return targetSymbol;
    }
  }
  return undefined;
}
function getReferencedSymbolsForModuleIfDeclaredBySourceFile(
    symbol, program, sourceFiles, cancellationToken, options, sourceFilesSet) {
  const moduleSourceFile = (symbol.flags & 1536 /* SymbolFlags.Module */) && symbol.declarations &&
      ts.find(symbol.declarations, ts.isSourceFile);
  if (!moduleSourceFile)
    {return undefined;}
  const exportEquals = symbol.exports.get('export=' /* InternalSymbolName.ExportEquals */);
  // If !!exportEquals, we're about to add references to `import("mod")` anyway, so don't double-count them.
  const moduleReferences = getReferencedSymbolsForModule(program, symbol, !!exportEquals, sourceFiles, sourceFilesSet);
  if (!exportEquals || !sourceFilesSet.has(moduleSourceFile.fileName))
    {return moduleReferences;}
  // Continue to get references to 'export ='.
  const checker = program.getTypeChecker();
  symbol = ts.skipAlias(exportEquals, checker);
  return mergeReferences(
      program, moduleReferences,
      getReferencedSymbolsForSymbol(
          symbol, /* node*/ undefined, sourceFiles, sourceFilesSet, checker, cancellationToken, options));
}
/**
 * Merges the references by sorting them (by file index in sourceFiles and their location in it) that point to same definition symbol
 */
function mergeReferences(program) {
  const referencesToMerge = [];
  for (let _i = 1; _i < arguments.length; _i++) {
    referencesToMerge[_i - 1] = arguments[_i];
  }
  let result;
  for (let _a = 0, referencesToMerge_1 = referencesToMerge; _a < referencesToMerge_1.length; _a++) {
    const references = referencesToMerge_1[_a];
    if (!references || !references.length)
      {continue;}
    if (!result) {
      result = references;
      continue;
    }
    const _loop_3 = function(entry) {
      if (!entry.definition || entry.definition.type !== 0 /* DefinitionKind.Symbol */) {
        result.push(entry);
        return 'continue';
      }
      const symbol = entry.definition.symbol;
      const refIndex = ts.findIndex(result, function(ref) {
        return !!ref.definition && ref.definition.type === 0 /* DefinitionKind.Symbol */ &&
            ref.definition.symbol === symbol;
      });
      if (refIndex === -1) {
        result.push(entry);
        return 'continue';
      }
      const reference = result[refIndex];
      result[refIndex] = {
        definition: reference.definition,
        references: reference.references.concat(entry.references).sort(function(entry1, entry2) {
          const entry1File = getSourceFileIndexOfEntry(program, entry1);
          const entry2File = getSourceFileIndexOfEntry(program, entry2);
          if (entry1File !== entry2File) {
            return ts.compareValues(entry1File, entry2File);
          }
          const entry1Span = getTextSpanOfEntry(entry1);
          const entry2Span = getTextSpanOfEntry(entry2);
          return entry1Span.start !== entry2Span.start ? ts.compareValues(entry1Span.start, entry2Span.start) :
                                                         ts.compareValues(entry1Span.length, entry2Span.length);
        })
      };
    };
    for (let _b = 0, references_2 = references; _b < references_2.length; _b++) {
      const entry = references_2[_b];
      _loop_3(entry);
    }
  }
  return result;
}
function getSourceFileIndexOfEntry(program, entry) {
  const sourceFile =
      entry.kind === 0 /* EntryKind.Span */ ? program.getSourceFile(entry.fileName) : entry.node.getSourceFile();
  return program.getSourceFiles().indexOf(sourceFile);
}
function getReferencedSymbolsForModule(program, symbol, excludeImportTypeOfExportEquals, sourceFiles, sourceFilesSet) {
  ts.Debug.assert(!!symbol.valueDeclaration);
  const references =
      ts.mapDefined(FindAllReferences.findModuleReferences(program, sourceFiles, symbol), function(reference) {
        if (reference.kind === 'import') {
          const parent = reference.literal.parent;
          if (ts.isLiteralTypeNode(parent)) {
            const importType = ts.cast(parent.parent, ts.isImportTypeNode);
            if (excludeImportTypeOfExportEquals && !importType.qualifier) {
              return undefined;
            }
          }
          // import("foo") with no qualifier will reference the `export =` of the module, which may be referenced anyway.
          return nodeEntry(reference.literal);
        }
          return {
            kind: 0 /* EntryKind.Span */,
            fileName: reference.referencingFile.fileName,
            textSpan: ts.createTextSpanFromRange(reference.ref),
          };

      });
  if (symbol.declarations) {
    for (let _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
      var decl = _a[_i];
      switch (decl.kind) {
        case 308 /* SyntaxKind.SourceFile */:
          // Don't include the source file itself. (This may not be ideal behavior, but awkward to include an entire file as a reference.)
          break;
        case 264 /* SyntaxKind.ModuleDeclaration */:
          if (sourceFilesSet.has(decl.getSourceFile().fileName)) {
            references.push(nodeEntry(decl.name));
          }
          break;
        default:
          // This may be merged with something.
          ts.Debug.assert(
              !!(symbol.flags & 33554432 /* SymbolFlags.Transient */),
              'Expected a module symbol to be declared by a SourceFile or ModuleDeclaration.');
      }
    }
  }
  const exported = symbol.exports.get('export=' /* InternalSymbolName.ExportEquals */);
  if (exported === null || exported === void 0 ? void 0 : exported.declarations) {
    for (let _b = 0, _c = exported.declarations; _b < _c.length; _b++) {
      var decl = _c[_b];
      const sourceFile = decl.getSourceFile();
      if (sourceFilesSet.has(sourceFile.fileName)) {
        // At `module.exports = ...`, reference node is `module`
        const node = ts.isBinaryExpression(decl) && ts.isPropertyAccessExpression(decl.left) ?
            decl.left.expression :
            ts.isExportAssignment(decl) ?
            ts.Debug.checkDefined(ts.findChildOfKind(decl, 93 /* SyntaxKind.ExportKeyword */, sourceFile)) :
            ts.getNameOfDeclaration(decl) || decl;
        references.push(nodeEntry(node));
      }
    }
  }
  return references.length ?
      [{definition: {type: 0 /* DefinitionKind.Symbol */, symbol}, references}] :
      ts.emptyArray;
}
/** As in a `readonly prop: any` or `constructor(readonly prop: any)`, not a `readonly any[]`. */
function isReadonlyTypeOperator(node) {
  return node.kind === 146 /* SyntaxKind.ReadonlyKeyword */
      && ts.isTypeOperatorNode(node.parent) && node.parent.operator === 146 /* SyntaxKind.ReadonlyKeyword */;
}
/** getReferencedSymbols for special node kinds. */
function getReferencedSymbolsSpecial(node, sourceFiles, cancellationToken) {
  if (ts.isTypeKeyword(node.kind)) {
    // A void expression (i.e., `void foo()`) is not special, but the `void` type is.
    if (node.kind === 114 /* SyntaxKind.VoidKeyword */ && ts.isVoidExpression(node.parent)) {
      return undefined;
    }
    // A modifier readonly (like on a property declaration) is not special;
    // a readonly type keyword (like `readonly string[]`) is.
    if (node.kind === 146 /* SyntaxKind.ReadonlyKeyword */ && !isReadonlyTypeOperator(node)) {
      return undefined;
    }
    // Likewise, when we *are* looking for a special keyword, make sure we
    // *dont* include readonly member modifiers.
    return getAllReferencesForKeyword(
        sourceFiles, node.kind, cancellationToken,
        node.kind === 146 /* SyntaxKind.ReadonlyKeyword */ ? isReadonlyTypeOperator : undefined);
  }
  if (ts.isImportMeta(node.parent) && node.parent.name === node) {
    return getAllReferencesForImportMeta(sourceFiles, cancellationToken);
  }
  if (ts.isStaticModifier(node) && ts.isClassStaticBlockDeclaration(node.parent)) {
    return [{definition: {type: 2 /* DefinitionKind.Keyword */, node}, references: [nodeEntry(node)]}];
  }
  // Labels
  if (ts.isJumpStatementTarget(node)) {
    const labelDefinition = ts.getTargetLabel(node.parent, node.text);
    // if we have a label definition, look within its statement for references, if not, then
    // the label is undefined and we have no results..
    return labelDefinition && getLabelReferencesInNode(labelDefinition.parent, labelDefinition);
  } if (ts.isLabelOfLabeledStatement(node)) {
    // it is a label definition and not a target, search within the parent labeledStatement
    return getLabelReferencesInNode(node.parent, node);
  }
  if (ts.isThis(node)) {
    return getReferencesForThisKeyword(node, sourceFiles, cancellationToken);
  }
  if (node.kind === 106 /* SyntaxKind.SuperKeyword */) {
    return getReferencesForSuperKeyword(node);
  }
  return undefined;
}
/** Core find-all-references algorithm for a normal symbol. */
function getReferencedSymbolsForSymbol(
    originalSymbol, node, sourceFiles, sourceFilesSet, checker, cancellationToken, options) {
  const symbol = node &&
          skipPastExportOrImportSpecifierOrUnion(
                   originalSymbol, node, checker,
                   /* useLocalSymbolForExportSpecifier*/ !isForRenameWithPrefixAndSuffixText(options)) ||
      originalSymbol;
  // Compute the meaning from the location and the symbol it references
  const searchMeaning = node ? getIntersectingMeaningFromDeclarations(node, symbol) : 7 /* SemanticMeaning.All */;
  const result = [];
  const state = new State(
      sourceFiles, sourceFilesSet, node ? getSpecialSearchKind(node) : 0 /* SpecialSearchKind.None */, checker,
      cancellationToken, searchMeaning, options, result);
  const exportSpecifier = !isForRenameWithPrefixAndSuffixText(options) || !symbol.declarations ?
      undefined :
      ts.find(symbol.declarations, ts.isExportSpecifier);
  if (exportSpecifier) {
    // When renaming at an export specifier, rename the export and not the thing being exported.
    getReferencesAtExportSpecifier(
        exportSpecifier.name, symbol, exportSpecifier,
        state.createSearch(node, originalSymbol, /* comingFrom*/ undefined), state, /* addReferencesHere*/ true,
        /* alwaysGetReferences*/ true);
  } else if (
      node && node.kind === 88 /* SyntaxKind.DefaultKeyword */ &&
      symbol.escapedName === 'default' /* InternalSymbolName.Default */ && symbol.parent) {
    addReference(node, symbol, state);
    searchForImportsOfExport(
        node, symbol, {exportingModuleSymbol: symbol.parent, exportKind: 1 /* ExportKind.Default */}, state);
  } else {
    const search = state.createSearch(node, symbol, /* comingFrom*/ undefined, {
      allSearchSymbols: node ? populateSearchSymbolSet(
                                   symbol, node, checker, options.use === 2 /* FindReferencesUse.Rename */,
                                   !!options.providePrefixAndSuffixTextForRename, !!options.implementations) :
                               [symbol]
    });
    getReferencesInContainerOrFiles(symbol, state, search);
  }
  return result;
}
function getReferencesInContainerOrFiles(symbol, state, search) {
  // Try to get the smallest valid scope that we can limit our search to;
  // otherwise we'll need to search globally (i.e. include each file).
  const scope = getSymbolScope(symbol);
  if (scope) {
    getReferencesInContainer(
        scope, scope.getSourceFile(), search, state,
        /* addReferencesHere*/ !(ts.isSourceFile(scope) && !ts.contains(state.sourceFiles, scope)));
  } else {
    // Global search
    for (let _i = 0, _a = state.sourceFiles; _i < _a.length; _i++) {
      const sourceFile = _a[_i];
      state.cancellationToken.throwIfCancellationRequested();
      searchForName(sourceFile, search, state);
    }
  }
}
function getSpecialSearchKind(node) {
  switch (node.kind) {
    case 173 /* SyntaxKind.Constructor */:
    case 135 /* SyntaxKind.ConstructorKeyword */:
      return 1 /* SpecialSearchKind.Constructor */;
    case 79 /* SyntaxKind.Identifier */:
      if (ts.isClassLike(node.parent)) {
        ts.Debug.assert(node.parent.name === node);
        return 2 /* SpecialSearchKind.Class */;
      }
    // falls through
    default:
      return 0 /* SpecialSearchKind.None */;
  }
}
/** Handle a few special cases relating to export/import specifiers. */
function skipPastExportOrImportSpecifierOrUnion(symbol, node, checker, useLocalSymbolForExportSpecifier) {
  const parent = node.parent;
  if (ts.isExportSpecifier(parent) && useLocalSymbolForExportSpecifier) {
    return getLocalSymbolForExportSpecifier(node, symbol, parent, checker);
  }
  // If the symbol is declared as part of a declaration like `{ type: "a" } | { type: "b" }`, use the property on the union type to get more references.
  return ts.firstDefined(symbol.declarations, function(decl) {
    if (!decl.parent) {
      // Ignore UMD module and global merge
      if (symbol.flags & 33554432 /* SymbolFlags.Transient */)
        {return undefined;}
      // Assertions for GH#21814. We should be handling SourceFile symbols in `getReferencedSymbolsForModule` instead of getting here.
      ts.Debug.fail('Unexpected symbol at '.concat(ts.Debug.formatSyntaxKind(node.kind), ': ')
                        .concat(ts.Debug.formatSymbol(symbol)));
    }
    return ts.isTypeLiteralNode(decl.parent) && ts.isUnionTypeNode(decl.parent.parent) ?
        checker.getPropertyOfType(checker.getTypeFromTypeNode(decl.parent.parent), symbol.name) :
        undefined;
  });
}
let SpecialSearchKind;
(function(SpecialSearchKind) {
SpecialSearchKind[SpecialSearchKind['None'] = 0] = 'None';
SpecialSearchKind[SpecialSearchKind['Constructor'] = 1] = 'Constructor';
SpecialSearchKind[SpecialSearchKind['Class'] = 2] = 'Class';
})(SpecialSearchKind || (SpecialSearchKind = {}));
function getNonModuleSymbolOfMergedModuleSymbol(symbol) {
  if (!(symbol.flags & (1536 /* SymbolFlags.Module */ | 33554432 /* SymbolFlags.Transient */)))
    {return undefined;}
  const decl = symbol.declarations && ts.find(symbol.declarations, function(d) {
    return !ts.isSourceFile(d) && !ts.isModuleDeclaration(d);
  });
  return decl && decl.symbol;
}
/**
 * Holds all state needed for the finding references.
 * Unlike `Search`, there is only one `State`.
 */
var State = /** @class */ (function() {
  function State(
      sourceFiles, sourceFilesSet, specialSearchKind, checker, cancellationToken, searchMeaning, options, result) {
    this.sourceFiles = sourceFiles;
    this.sourceFilesSet = sourceFilesSet;
    this.specialSearchKind = specialSearchKind;
    this.checker = checker;
    this.cancellationToken = cancellationToken;
    this.searchMeaning = searchMeaning;
    this.options = options;
    this.result = result;
    /** Cache for `explicitlyinheritsFrom`. */
    this.inheritsFromCache = new ts.Map();
    /**
     * Type nodes can contain multiple references to the same type. For example:
     *      let x: Foo & (Foo & Bar) = ...
     * Because we are returning the implementation locations and not the identifier locations,
     * duplicate entries would be returned here as each of the type references is part of
     * the same implementation. For that reason, check before we add a new entry.
     */
    this.markSeenContainingTypeReference = ts.nodeSeenTracker();
    /**
     * It's possible that we will encounter the right side of `export { foo as bar } from "x";` more than once.
     * For example:
     *     // b.ts
     *     export { foo as bar } from "./a";
     *     import { bar } from "./b";
     *
     * Normally at `foo as bar` we directly add `foo` and do not locally search for it (since it doesn't declare a local).
     * But another reference to it may appear in the same source file.
     * See `tests/cases/fourslash/transitiveExportImports3.ts`.
     */
    this.markSeenReExportRHS = ts.nodeSeenTracker();
    this.symbolIdToReferences = [];
    // Source file ID  symbol ID  Whether the symbol has been searched for in the source file.
    this.sourceFileToSeenSymbols = [];
  }
  State.prototype.includesSourceFile = function(sourceFile) {
    return this.sourceFilesSet.has(sourceFile.fileName);
  };
  /** Gets every place to look for references of an exported symbols. See `ImportsResult` in `importTracker.ts` for more documentation. */
  State.prototype.getImportSearches = function(exportSymbol, exportInfo) {
    if (!this.importTracker)
      {this.importTracker = FindAllReferences.createImportTracker(
          this.sourceFiles, this.sourceFilesSet, this.checker, this.cancellationToken);}
    return this.importTracker(exportSymbol, exportInfo, this.options.use === 2 /* FindReferencesUse.Rename */);
  };
  /** @param allSearchSymbols set of additional symbols for use by `includes`. */
  State.prototype.createSearch = function(location, symbol, comingFrom, searchOptions) {
    if (searchOptions === void 0) {
      searchOptions = {};
    }
    // Note: if this is an external module symbol, the name doesn't include quotes.
    // Note: getLocalSymbolForExportDefault handles `export default class C {}`, but not `export default C` or `export { C as default }`.
    // The other two forms seem to be handled downstream (e.g. in `skipPastExportOrImportSpecifier`), so special-casing the first form
    // here appears to be intentional).
    const _a = searchOptions.text,
        text = _a === void 0 ?
        ts.stripQuotes(ts.symbolName(
            ts.getLocalSymbolForExportDefault(symbol) || getNonModuleSymbolOfMergedModuleSymbol(symbol) || symbol)) :
        _a,
        _b = searchOptions.allSearchSymbols, allSearchSymbols = _b === void 0 ? [symbol] : _b;
    const escapedText = ts.escapeLeadingUnderscores(text);
    const parents = this.options.implementations && location ?
        getParentSymbolsOfPropertyAccess(location, symbol, this.checker) :
        undefined;
    return {
      symbol,
      comingFrom,
      text,
      escapedText,
      parents,
      allSearchSymbols,
      includes: function(sym) {
        return ts.contains(allSearchSymbols, sym);
      }
    };
  };
  /**
   * Callback to add references for a particular searched symbol.
   * This initializes a reference group, so only call this if you will add at least one reference.
   */
  State.prototype.referenceAdder = function(searchSymbol) {
    const symbolId = ts.getSymbolId(searchSymbol);
    let references = this.symbolIdToReferences[symbolId];
    if (!references) {
      references = this.symbolIdToReferences[symbolId] = [];
      this.result.push(
          {definition: {type: 0 /* DefinitionKind.Symbol */, symbol: searchSymbol}, references});
    }
    return function(node, kind) {
      return references.push(nodeEntry(node, kind));
    };
  };
  /** Add a reference with no associated definition. */
  State.prototype.addStringOrCommentReference = function(fileName, textSpan) {
    this.result.push(
        {definition: undefined, references: [{kind: 0 /* EntryKind.Span */, fileName, textSpan}]});
  };
  /** Returns `true` the first time we search for a symbol in a file and `false` afterwards. */
  State.prototype.markSearchedSymbols = function(sourceFile, symbols) {
    const sourceId = ts.getNodeId(sourceFile);
    const seenSymbols = this.sourceFileToSeenSymbols[sourceId] || (this.sourceFileToSeenSymbols[sourceId] = new ts.Set());
    let anyNewSymbols = false;
    for (let _i = 0, symbols_1 = symbols; _i < symbols_1.length; _i++) {
      const sym = symbols_1[_i];
      anyNewSymbols = ts.tryAddToSet(seenSymbols, ts.getSymbolId(sym)) || anyNewSymbols;
    }
    return anyNewSymbols;
  };
  return State;
})();
/** Search for all imports of a given exported symbol using `State.getImportSearches`. */
function searchForImportsOfExport(exportLocation, exportSymbol, exportInfo, state) {
  const _a = state.getImportSearches(exportSymbol, exportInfo), importSearches = _a.importSearches,
      singleReferences = _a.singleReferences, indirectUsers = _a.indirectUsers;
  // For `import { foo as bar }` just add the reference to `foo`, and don't otherwise search in the file.
  if (singleReferences.length) {
    const addRef = state.referenceAdder(exportSymbol);
    for (let _i = 0, singleReferences_1 = singleReferences; _i < singleReferences_1.length; _i++) {
      const singleRef = singleReferences_1[_i];
      if (shouldAddSingleReference(singleRef, state))
        {addRef(singleRef);}
    }
  }
  // For each import, find all references to that import in its source file.
  for (let _b = 0, importSearches_1 = importSearches; _b < importSearches_1.length; _b++) {
    const _c = importSearches_1[_b], importLocation = _c[0], importSymbol = _c[1];
    getReferencesInSourceFile(
        importLocation.getSourceFile(), state.createSearch(importLocation, importSymbol, 1 /* ImportExport.Export */),
        state);
  }
  if (indirectUsers.length) {
    let indirectSearch = void 0;
    switch (exportInfo.exportKind) {
      case 0 /* ExportKind.Named */:
        indirectSearch = state.createSearch(exportLocation, exportSymbol, 1 /* ImportExport.Export */);
        break;
      case 1 /* ExportKind.Default */:
        // Search for a property access to '.default'. This can't be renamed.
        indirectSearch = state.options.use === 2 /* FindReferencesUse.Rename */ ?
            undefined :
            state.createSearch(exportLocation, exportSymbol, 1 /* ImportExport.Export */, {text: 'default'});
        break;
      case 2 /* ExportKind.ExportEquals */:
        break;
    }
    if (indirectSearch) {
      for (let _d = 0, indirectUsers_1 = indirectUsers; _d < indirectUsers_1.length; _d++) {
        const indirectUser = indirectUsers_1[_d];
        searchForName(indirectUser, indirectSearch, state);
      }
    }
  }
}
function eachExportReference(
    sourceFiles, checker, cancellationToken, exportSymbol, exportingModuleSymbol, exportName, isDefaultExport, cb) {
  const importTracker = FindAllReferences.createImportTracker(
      sourceFiles, new ts.Set(sourceFiles.map(function(f) {
        return f.fileName;
      })),
      checker, cancellationToken);
  const _a = importTracker(
          exportSymbol, {
            exportKind: isDefaultExport ? 1 /* ExportKind.Default */ : 0 /* ExportKind.Named */,
            exportingModuleSymbol
          },
          /* isForRename*/ false),
      importSearches = _a.importSearches, indirectUsers = _a.indirectUsers, singleReferences = _a.singleReferences;
  for (let _i = 0, importSearches_2 = importSearches; _i < importSearches_2.length; _i++) {
    const importLocation = importSearches_2[_i][0];
    cb(importLocation);
  }
  for (let _b = 0, singleReferences_2 = singleReferences; _b < singleReferences_2.length; _b++) {
    const singleReference = singleReferences_2[_b];
    if (ts.isIdentifier(singleReference) && ts.isImportTypeNode(singleReference.parent)) {
      cb(singleReference);
    }
  }
  for (let _c = 0, indirectUsers_2 = indirectUsers; _c < indirectUsers_2.length; _c++) {
    const indirectUser = indirectUsers_2[_c];
    for (let _d = 0, _e = getPossibleSymbolReferenceNodes(indirectUser, isDefaultExport ? 'default' : exportName);
         _d < _e.length; _d++) {
      const node = _e[_d];
      // Import specifiers should be handled by importSearches
      const symbol = checker.getSymbolAtLocation(node);
      const hasExportAssignmentDeclaration =
          ts.some(symbol === null || symbol === void 0 ? void 0 : symbol.declarations, function(d) {
            return ts.tryCast(d, ts.isExportAssignment) ? true : false;
          });
      if (ts.isIdentifier(node) && !ts.isImportOrExportSpecifier(node.parent) &&
          (symbol === exportSymbol || hasExportAssignmentDeclaration)) {
        cb(node);
      }
    }
  }
}
Core.eachExportReference = eachExportReference;
function shouldAddSingleReference(singleRef, state) {
  if (!hasMatchingMeaning(singleRef, state))
    {return false;}
  if (state.options.use !== 2 /* FindReferencesUse.Rename */)
    {return true;}
  // Don't rename an import type `import("./module-name")` when renaming `name` in `export = name;`
  if (!ts.isIdentifier(singleRef))
    {return false;}
  // At `default` in `import { default as x }` or `export { default as x }`, do add a reference, but do not rename.
  return !(
      ts.isImportOrExportSpecifier(singleRef.parent) &&
      singleRef.escapedText === 'default' /* InternalSymbolName.Default */);
}
// Go to the symbol we imported from and find references for it.
function searchForImportedSymbol(symbol, state) {
  if (!symbol.declarations)
    {return;}
  for (let _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
    const declaration = _a[_i];
    const exportingFile = declaration.getSourceFile();
    // Need to search in the file even if it's not in the search-file set, because it might export the symbol.
    getReferencesInSourceFile(
        exportingFile, state.createSearch(declaration, symbol, 0 /* ImportExport.Import */), state,
        state.includesSourceFile(exportingFile));
  }
}
/** Search for all occurrences of an identifier in a source file (and filter out the ones that match). */
function searchForName(sourceFile, search, state) {
  if (ts.getNameTable(sourceFile).get(search.escapedText) !== undefined) {
    getReferencesInSourceFile(sourceFile, search, state);
  }
}
function getPropertySymbolOfDestructuringAssignment(location, checker) {
  return ts.isArrayLiteralOrObjectLiteralDestructuringPattern(location.parent.parent) ?
      checker.getPropertySymbolOfDestructuringAssignment(location) :
      undefined;
}
/**
 * Determines the smallest scope in which a symbol may have named references.
 * Note that not every construct has been accounted for. This function can
 * probably be improved.
 *
 * @returns undefined if the scope cannot be determined, implying that
 * a reference to a symbol can occur anywhere.
 */
function getSymbolScope(symbol) {
  // If this is the symbol of a named function expression or named class expression,
  // then named references are limited to its own scope.
  const declarations = symbol.declarations, flags = symbol.flags, parent = symbol.parent,
      valueDeclaration = symbol.valueDeclaration;
  if (valueDeclaration &&
      (valueDeclaration.kind === 215 /* SyntaxKind.FunctionExpression */ ||
       valueDeclaration.kind === 228 /* SyntaxKind.ClassExpression */)) {
    return valueDeclaration;
  }
  if (!declarations) {
    return undefined;
  }
  // If this is private property or method, the scope is the containing class
  if (flags & (4 /* SymbolFlags.Property */ | 8192 /* SymbolFlags.Method */)) {
    const privateDeclaration = ts.find(declarations, function(d) {
      return ts.hasEffectiveModifier(d, 8 /* ModifierFlags.Private */) ||
          ts.isPrivateIdentifierClassElementDeclaration(d);
    });
    if (privateDeclaration) {
      return ts.getAncestor(privateDeclaration, 260 /* SyntaxKind.ClassDeclaration */);
    }
    // Else this is a public property and could be accessed from anywhere.
    return undefined;
  }
  // If symbol is of object binding pattern element without property name we would want to
  // look for property too and that could be anywhere
  if (declarations.some(ts.isObjectBindingElementWithoutPropertyName)) {
    return undefined;
  }
  /*
                If the symbol has a parent, it's globally visible unless:
                - It's a private property (handled above).
                - It's a type parameter.
                - The parent is an external module: then we should only search in the module (and recurse on the export later).
                - But if the parent has `export as namespace`, the symbol is globally visible through that namespace.
                */
  const exposedByParent = parent && !(symbol.flags & 262144 /* SymbolFlags.TypeParameter */);
  if (exposedByParent && !(ts.isExternalModuleSymbol(parent) && !parent.globalExports)) {
    return undefined;
  }
  let scope;
  for (let _i = 0, declarations_1 = declarations; _i < declarations_1.length; _i++) {
    const declaration = declarations_1[_i];
    const container = ts.getContainerNode(declaration);
    if (scope && scope !== container) {
      // Different declarations have different containers, bail out
      return undefined;
    }
    if (!container || container.kind === 308 /* SyntaxKind.SourceFile */ && !ts.isExternalOrCommonJsModule(container)) {
      // This is a global variable and not an external module, any declaration defined
      // within this scope is visible outside the file
      return undefined;
    }
    scope = container;
    if (ts.isFunctionExpression(scope)) {
      let next = void 0;
      while (next = ts.getNextJSDocCommentLocation(scope)) {
        scope = next;
      }
    }
  }
  // If symbol.parent, this means we are in an export of an external module. (Otherwise we would have returned `undefined` above.)
  // For an export of a module, we may be in a declaration file, and it may be accessed elsewhere. E.g.:
  //     declare module "a" { export type T = number; }
  //     declare module "b" { import { T } from "a"; export const x: T; }
  // So we must search the whole source file. (Because we will mark the source file as seen, we we won't return to it when searching for imports.)
  return exposedByParent ? scope.getSourceFile() : scope;  // TODO: GH#18217
}
/** Used as a quick check for whether a symbol is used at all in a file (besides its definition). */
function isSymbolReferencedInFile(definition, checker, sourceFile, searchContainer) {
  if (searchContainer === void 0) {
    searchContainer = sourceFile;
  }
  return eachSymbolReferenceInFile(definition, checker, sourceFile, function() {
           return true;
         }, searchContainer) || false;
}
Core.isSymbolReferencedInFile = isSymbolReferencedInFile;
function eachSymbolReferenceInFile(definition, checker, sourceFile, cb, searchContainer) {
  if (searchContainer === void 0) {
    searchContainer = sourceFile;
  }
  const symbol = ts.isParameterPropertyDeclaration(definition.parent, definition.parent.parent) ?
      ts.first(checker.getSymbolsOfParameterPropertyDeclaration(definition.parent, definition.text)) :
      checker.getSymbolAtLocation(definition);
  if (!symbol)
    {return undefined;}
  for (let _i = 0, _a = getPossibleSymbolReferenceNodes(sourceFile, symbol.name, searchContainer); _i < _a.length;
       _i++) {
    const token = _a[_i];
    if (!ts.isIdentifier(token) || token === definition || token.escapedText !== definition.escapedText)
      {continue;}
    const referenceSymbol = checker.getSymbolAtLocation(token);
    if (referenceSymbol === symbol || checker.getShorthandAssignmentValueSymbol(token.parent) === symbol ||
        ts.isExportSpecifier(token.parent) &&
            getLocalSymbolForExportSpecifier(token, referenceSymbol, token.parent, checker) === symbol) {
      const res = cb(token);
      if (res)
        {return res;}
    }
  }
}
Core.eachSymbolReferenceInFile = eachSymbolReferenceInFile;
function getTopMostDeclarationNamesInFile(declarationName, sourceFile) {
  const candidates = ts.filter(getPossibleSymbolReferenceNodes(sourceFile, declarationName), function(name) {
    return !!ts.getDeclarationFromName(name);
  });
  return candidates
      .reduce(
          function(topMost, decl) {
            const depth = getDepth(decl);
            if (!ts.some(topMost.declarationNames) || depth === topMost.depth) {
              topMost.declarationNames.push(decl);
              topMost.depth = depth;
            } else if (depth < topMost.depth) {
              topMost.declarationNames = [decl];
              topMost.depth = depth;
            }
            return topMost;
          },
          {depth: Infinity, declarationNames: []})
      .declarationNames;
  function getDepth(declaration) {
    let depth = 0;
    while (declaration) {
      declaration = ts.getContainerNode(declaration);
      depth++;
    }
    return depth;
  }
}
Core.getTopMostDeclarationNamesInFile = getTopMostDeclarationNamesInFile;
function someSignatureUsage(signature, sourceFiles, checker, cb) {
  if (!signature.name || !ts.isIdentifier(signature.name))
    {return false;}
  const symbol = ts.Debug.checkDefined(checker.getSymbolAtLocation(signature.name));
  for (let _i = 0, sourceFiles_3 = sourceFiles; _i < sourceFiles_3.length; _i++) {
    const sourceFile = sourceFiles_3[_i];
    for (let _a = 0, _b = getPossibleSymbolReferenceNodes(sourceFile, symbol.name); _a < _b.length; _a++) {
      const name = _b[_a];
      if (!ts.isIdentifier(name) || name === signature.name || name.escapedText !== signature.name.escapedText)
        {continue;}
      const called = ts.climbPastPropertyAccess(name);
      const call = ts.isCallExpression(called.parent) && called.parent.expression === called ? called.parent : undefined;
      const referenceSymbol = checker.getSymbolAtLocation(name);
      if (referenceSymbol && checker.getRootSymbols(referenceSymbol).some(function(s) {
            return s === symbol;
          })) {
        if (cb(name, call)) {
          return true;
        }
      }
    }
  }
  return false;
}
Core.someSignatureUsage = someSignatureUsage;
function getPossibleSymbolReferenceNodes(sourceFile, symbolName, container) {
  if (container === void 0) {
    container = sourceFile;
  }
  return getPossibleSymbolReferencePositions(sourceFile, symbolName, container).map(function(pos) {
    return ts.getTouchingPropertyName(sourceFile, pos);
  });
}
function getPossibleSymbolReferencePositions(sourceFile, symbolName, container) {
  if (container === void 0) {
    container = sourceFile;
  }
  const positions = [];
  // / TODO: Cache symbol existence for files to save text search
  // Also, need to make this work for unicode escapes.
  // Be resilient in the face of a symbol with no name or zero length name
  if (!symbolName || !symbolName.length) {
    return positions;
  }
  const text = sourceFile.text;
  const sourceLength = text.length;
  const symbolNameLength = symbolName.length;
  let position = text.indexOf(symbolName, container.pos);
  while (position >= 0) {
    // If we are past the end, stop looking
    if (position > container.end)
      {break;}
    // We found a match.  Make sure it's not part of a larger word (i.e. the char
    // before and after it have to be a non-identifier char).
    const endPosition = position + symbolNameLength;
    if ((position === 0 || !ts.isIdentifierPart(text.charCodeAt(position - 1), 99 /* ScriptTarget.Latest */)) &&
        (endPosition === sourceLength ||
         !ts.isIdentifierPart(text.charCodeAt(endPosition), 99 /* ScriptTarget.Latest */))) {
      // Found a real match.  Keep searching.
      positions.push(position);
    }
    position = text.indexOf(symbolName, position + symbolNameLength + 1);
  }
  return positions;
}
function getLabelReferencesInNode(container, targetLabel) {
  const sourceFile = container.getSourceFile();
  const labelName = targetLabel.text;
  const references = ts.mapDefined(getPossibleSymbolReferenceNodes(sourceFile, labelName, container), function(node) {
    // Only pick labels that are either the target label, or have a target that is the target label
    return node === targetLabel ||
            (ts.isJumpStatementTarget(node) && ts.getTargetLabel(node, labelName) === targetLabel) ?
        nodeEntry(node) :
        undefined;
  });
  return [{definition: {type: 1 /* DefinitionKind.Label */, node: targetLabel}, references}];
}
function isValidReferencePosition(node, searchSymbolName) {
  // Compare the length so we filter out strict superstrings of the symbol we are looking for
  switch (node.kind) {
    case 80 /* SyntaxKind.PrivateIdentifier */:
      if (ts.isJSDocMemberName(node.parent)) {
        return true;
      }
    // falls through I guess
    case 79 /* SyntaxKind.Identifier */:
      return node.text.length === searchSymbolName.length;
    case 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */:
    case 10 /* SyntaxKind.StringLiteral */: {
      const str = node;
      return (ts.isLiteralNameOfPropertyDeclarationOrIndexAccess(str) || ts.isNameOfModuleDeclaration(node) ||
              ts.isExpressionOfExternalModuleImportEqualsDeclaration(node) ||
              (ts.isCallExpression(node.parent) && ts.isBindableObjectDefinePropertyCall(node.parent) &&
               node.parent.arguments[1] === node)) &&
          str.text.length === searchSymbolName.length;
    }
    case 8 /* SyntaxKind.NumericLiteral */:
      return ts.isLiteralNameOfPropertyDeclarationOrIndexAccess(node) && node.text.length === searchSymbolName.length;
    case 88 /* SyntaxKind.DefaultKeyword */:
      return 'default'.length === searchSymbolName.length;
    default:
      return false;
  }
}
function getAllReferencesForImportMeta(sourceFiles, cancellationToken) {
  const references = ts.flatMap(sourceFiles, function(sourceFile) {
    cancellationToken.throwIfCancellationRequested();
    return ts.mapDefined(getPossibleSymbolReferenceNodes(sourceFile, 'meta', sourceFile), function(node) {
      const parent = node.parent;
      if (ts.isImportMeta(parent)) {
        return nodeEntry(parent);
      }
    });
  });
  return references.length ?
      [{definition: {type: 2 /* DefinitionKind.Keyword */, node: references[0].node}, references}] :
      undefined;
}
function getAllReferencesForKeyword(sourceFiles, keywordKind, cancellationToken, filter) {
  const references = ts.flatMap(sourceFiles, function(sourceFile) {
    cancellationToken.throwIfCancellationRequested();
    return ts.mapDefined(
        getPossibleSymbolReferenceNodes(sourceFile, ts.tokenToString(keywordKind), sourceFile),
        function(referenceLocation) {
          if (referenceLocation.kind === keywordKind && (!filter || filter(referenceLocation))) {
            return nodeEntry(referenceLocation);
          }
        });
  });
  return references.length ?
      [{definition: {type: 2 /* DefinitionKind.Keyword */, node: references[0].node}, references}] :
      undefined;
}
function getReferencesInSourceFile(sourceFile, search, state, addReferencesHere) {
  if (addReferencesHere === void 0) {
    addReferencesHere = true;
  }
  state.cancellationToken.throwIfCancellationRequested();
  return getReferencesInContainer(sourceFile, sourceFile, search, state, addReferencesHere);
}
/**
 * Search within node "container" for references for a search value, where the search value is defined as a
 * tuple of(searchSymbol, searchText, searchLocation, and searchMeaning).
 * searchLocation: a node where the search value
 */
function getReferencesInContainer(container, sourceFile, search, state, addReferencesHere) {
  if (!state.markSearchedSymbols(sourceFile, search.allSearchSymbols)) {
    return;
  }
  for (let _i = 0, _a = getPossibleSymbolReferencePositions(sourceFile, search.text, container); _i < _a.length; _i++) {
    const position = _a[_i];
    getReferencesAtLocation(sourceFile, position, search, state, addReferencesHere);
  }
}
function hasMatchingMeaning(referenceLocation, state) {
  return !!(ts.getMeaningFromLocation(referenceLocation) & state.searchMeaning);
}
function getReferencesAtLocation(sourceFile, position, search, state, addReferencesHere) {
  const referenceLocation = ts.getTouchingPropertyName(sourceFile, position);
  if (!isValidReferencePosition(referenceLocation, search.text)) {
    // This wasn't the start of a token.  Check to see if it might be a
    // match in a comment or string if that's what the caller is asking
    // for.
    if (!state.options.implementations &&
        (state.options.findInStrings && ts.isInString(sourceFile, position) ||
         state.options.findInComments && ts.isInNonReferenceComment(sourceFile, position))) {
      // In the case where we're looking inside comments/strings, we don't have
      // an actual definition.  So just use 'undefined' here.  Features like
      // 'Rename' won't care (as they ignore the definitions), and features like
      // 'FindReferences' will just filter out these results.
      state.addStringOrCommentReference(sourceFile.fileName, ts.createTextSpan(position, search.text.length));
    }
    return;
  }
  if (!hasMatchingMeaning(referenceLocation, state))
    {return;}
  let referenceSymbol = state.checker.getSymbolAtLocation(referenceLocation);
  if (!referenceSymbol) {
    return;
  }
  const parent = referenceLocation.parent;
  if (ts.isImportSpecifier(parent) && parent.propertyName === referenceLocation) {
    // This is added through `singleReferences` in ImportsResult. If we happen to see it again, don't add it again.
    return;
  }
  if (ts.isExportSpecifier(parent)) {
    ts.Debug.assert(referenceLocation.kind === 79 /* SyntaxKind.Identifier */);
    getReferencesAtExportSpecifier(referenceLocation, referenceSymbol, parent, search, state, addReferencesHere);
    return;
  }
  const relatedSymbol = getRelatedSymbol(search, referenceSymbol, referenceLocation, state);
  if (!relatedSymbol) {
    getReferenceForShorthandProperty(referenceSymbol, search, state);
    return;
  }
  switch (state.specialSearchKind) {
    case 0 /* SpecialSearchKind.None */:
      if (addReferencesHere)
        {addReference(referenceLocation, relatedSymbol, state);}
      break;
    case 1 /* SpecialSearchKind.Constructor */:
      addConstructorReferences(referenceLocation, sourceFile, search, state);
      break;
    case 2 /* SpecialSearchKind.Class */:
      addClassStaticThisReferences(referenceLocation, search, state);
      break;
    default:
      ts.Debug.assertNever(state.specialSearchKind);
  }
  // Use the parent symbol if the location is commonjs require syntax on javascript files only.
  if (ts.isInJSFile(referenceLocation) && referenceLocation.parent.kind === 205 /* SyntaxKind.BindingElement */
      && ts.isVariableDeclarationInitializedToBareOrAccessedRequire(referenceLocation.parent.parent.parent)) {
    referenceSymbol = referenceLocation.parent.symbol;
    // The parent will not have a symbol if it's an ObjectBindingPattern (when destructuring is used).  In
    // this case, just skip it, since the bound identifiers are not an alias of the import.
    if (!referenceSymbol)
      {return;}
  }
  getImportOrExportReferences(referenceLocation, referenceSymbol, search, state);
}
function getReferencesAtExportSpecifier(
    referenceLocation, referenceSymbol, exportSpecifier, search, state, addReferencesHere, alwaysGetReferences) {
  ts.Debug.assert(
      !alwaysGetReferences || !!state.options.providePrefixAndSuffixTextForRename,
      'If alwaysGetReferences is true, then prefix/suffix text must be enabled');
  const parent = exportSpecifier.parent, propertyName = exportSpecifier.propertyName, name = exportSpecifier.name;
  const exportDeclaration = parent.parent;
  const localSymbol =
      getLocalSymbolForExportSpecifier(referenceLocation, referenceSymbol, exportSpecifier, state.checker);
  if (!alwaysGetReferences && !search.includes(localSymbol)) {
    return;
  }
  if (!propertyName) {
    // Don't rename at `export { default } from "m";`. (but do continue to search for imports of the re-export)
    if (!(state.options.use === 2 /* FindReferencesUse.Rename */ &&
          (name.escapedText === 'default' /* InternalSymbolName.Default */))) {
      addRef();
    }
  } else if (referenceLocation === propertyName) {
    // For `export { foo as bar } from "baz"`, "`foo`" will be added from the singleReferences for import searches of the original export.
    // For `export { foo as bar };`, where `foo` is a local, so add it now.
    if (!exportDeclaration.moduleSpecifier) {
      addRef();
    }
    if (addReferencesHere && state.options.use !== 2 /* FindReferencesUse.Rename */ &&
        state.markSeenReExportRHS(name)) {
      addReference(name, ts.Debug.checkDefined(exportSpecifier.symbol), state);
    }
  } else {
    if (state.markSeenReExportRHS(referenceLocation)) {
      addRef();
    }
  }
  // For `export { foo as bar }`, rename `foo`, but not `bar`.
  if (!isForRenameWithPrefixAndSuffixText(state.options) || alwaysGetReferences) {
    const isDefaultExport = referenceLocation.originalKeywordKind === 88 /* SyntaxKind.DefaultKeyword */
        || exportSpecifier.name.originalKeywordKind === 88 /* SyntaxKind.DefaultKeyword */;
    const exportKind = isDefaultExport ? 1 /* ExportKind.Default */ : 0 /* ExportKind.Named */;
    const exportSymbol = ts.Debug.checkDefined(exportSpecifier.symbol);
    const exportInfo = FindAllReferences.getExportInfo(exportSymbol, exportKind, state.checker);
    if (exportInfo) {
      searchForImportsOfExport(referenceLocation, exportSymbol, exportInfo, state);
    }
  }
  // At `export { x } from "foo"`, also search for the imported symbol `"foo".x`.
  if (search.comingFrom !== 1 /* ImportExport.Export */ && exportDeclaration.moduleSpecifier && !propertyName &&
      !isForRenameWithPrefixAndSuffixText(state.options)) {
    const imported = state.checker.getExportSpecifierLocalTargetSymbol(exportSpecifier);
    if (imported)
      {searchForImportedSymbol(imported, state);}
  }
  function addRef() {
    if (addReferencesHere)
      {addReference(referenceLocation, localSymbol, state);}
  }
}
function getLocalSymbolForExportSpecifier(referenceLocation, referenceSymbol, exportSpecifier, checker) {
  return isExportSpecifierAlias(referenceLocation, exportSpecifier) &&
      checker.getExportSpecifierLocalTargetSymbol(exportSpecifier) ||
      referenceSymbol;
}
function isExportSpecifierAlias(referenceLocation, exportSpecifier) {
  const parent = exportSpecifier.parent, propertyName = exportSpecifier.propertyName, 