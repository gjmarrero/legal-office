Start());
        // write separator and leading trivia of the next element as suffix
        const suffix =
            ''.concat(ts.tokenToString(nextToken.kind)).concat(sourceFile.text.substring(nextToken.end, startPos));
        this.insertNodesAt(sourceFile, startPos, [newNode], {suffix});
      }
    } else {
      const afterStart = after.getStart(sourceFile);
      const afterStartLinePosition = ts.getLineStartPositionForPosition(afterStart, sourceFile);
      let separator = void 0;
      let multilineList = false;
      // insert element after the last element in the list that has more than one item
      // pick the element preceding the after element to:
      // - pick the separator
      // - determine if list is a multiline
      if (containingList.length === 1) {
        // if list has only one element then we'll format is as multiline if node has comment in trailing trivia, or as singleline otherwise
        // i.e. var x = 1 // this is x
        //     | new element will be inserted at this position
        separator = 27 /* SyntaxKind.CommaToken */;
      } else {
        // element has more than one element, pick separator from the list
        const tokenBeforeInsertPosition = ts.findPrecedingToken(after.pos, sourceFile);
        separator = isSeparator(after, tokenBeforeInsertPosition) ? tokenBeforeInsertPosition.kind :
                                                                    27 /* SyntaxKind.CommaToken */;
        // determine if list is multiline by checking lines of after element and element that precedes it.
        const afterMinusOneStartLinePosition =
            ts.getLineStartPositionForPosition(containingList[index - 1].getStart(sourceFile), sourceFile);
        multilineList = afterMinusOneStartLinePosition !== afterStartLinePosition;
      }
      if (hasCommentsBeforeLineBreak(sourceFile.text, after.end)) {
        // in this case we'll always treat containing list as multiline
        multilineList = true;
      }
      if (multilineList) {
        // insert separator immediately following the 'after' node to preserve comments in trailing trivia
        this.replaceRange(sourceFile, ts.createRange(end), ts.factory.createToken(separator));
        // use the same indentation as 'after' item
        const indentation = ts.formatting.SmartIndenter.findFirstNonWhitespaceColumn(
            afterStartLinePosition, afterStart, sourceFile, this.formatContext.options);
        // insert element before the line break on the line that contains 'after' element
        let insertPos = ts.skipTrivia(sourceFile.text, end, /* stopAfterLineBreak*/ true, /* stopAtComments*/ false);
        // find position before "\n" or "\r\n"
        while (insertPos !== end && ts.isLineBreak(sourceFile.text.charCodeAt(insertPos - 1))) {
          insertPos--;
        }
        this.replaceRange(
            sourceFile, ts.createRange(insertPos), newNode, {indentation, prefix: this.newLineCharacter});
      } else {
        this.replaceRange(
            sourceFile, ts.createRange(end), newNode, {prefix: ''.concat(ts.tokenToString(separator), ' ')});
      }
    }
  };
  ChangeTracker.prototype.parenthesizeExpression = function(sourceFile, expression) {
    this.replaceRange(sourceFile, ts.rangeOfNode(expression), ts.factory.createParenthesizedExpression(expression));
  };
  ChangeTracker.prototype.finishClassesWithNodesInsertedAtStart = function() {
    const _this = this;
    this.classesWithNodesInsertedAtStart.forEach(function(_a) {
      const node = _a.node, sourceFile = _a.sourceFile;
      const _b = getClassOrObjectBraceEnds(node, sourceFile), openBraceEnd = _b[0], closeBraceEnd = _b[1];
      if (openBraceEnd !== undefined && closeBraceEnd !== undefined) {
        const isEmpty = getMembersOrProperties(node).length === 0;
        const isSingleLine = ts.positionsAreOnSameLine(openBraceEnd, closeBraceEnd, sourceFile);
        if (isEmpty && isSingleLine && openBraceEnd !== closeBraceEnd - 1) {
          // For `class C { }` remove the whitespace inside the braces.
          _this.deleteRange(sourceFile, ts.createRange(openBraceEnd, closeBraceEnd - 1));
        }
        if (isSingleLine) {
          _this.insertText(sourceFile, closeBraceEnd - 1, _this.newLineCharacter);
        }
      }
    });
  };
  ChangeTracker.prototype.finishDeleteDeclarations = function() {
    const _this = this;
    const deletedNodesInLists =
        new ts.Set();  // Stores nodes in lists that we already deleted. Used to avoid deleting `, ` twice in `a, b`.
    const _loop_9 = function(sourceFile, node) {
      if (!this_1.deletedNodes.some(function(d) {
            return d.sourceFile === sourceFile && ts.rangeContainsRangeExclusive(d.node, node);
          })) {
        if (ts.isArray(node)) {
          this_1.deleteRange(sourceFile, ts.rangeOfTypeParameters(sourceFile, node));
        } else {
          deleteDeclaration.deleteDeclaration(this_1, deletedNodesInLists, sourceFile, node);
        }
      }
    };
    var this_1 = this;
    for (let _i = 0, _a = this.deletedNodes; _i < _a.length; _i++) {
      const _b = _a[_i], sourceFile = _b.sourceFile, node = _b.node;
      _loop_9(sourceFile, node);
    }
    deletedNodesInLists.forEach(function(node) {
      const sourceFile = node.getSourceFile();
      const list = ts.formatting.SmartIndenter.getContainingList(node, sourceFile);
      if (node !== ts.last(list))
        {return;}
      const lastNonDeletedIndex = ts.findLastIndex(list, function(n) {
        return !deletedNodesInLists.has(n);
      }, list.length - 2);
      if (lastNonDeletedIndex !== -1) {
        _this.deleteRange(sourceFile, {
          pos: list[lastNonDeletedIndex].end,
          end: startPositionToDeleteNodeInList(sourceFile, list[lastNonDeletedIndex + 1])
        });
      }
    });
  };
  /**
   * Note: after calling this, the TextChanges object must be discarded!
   * @param validate only for tests
   *    The reason we must validate as part of this method is that `getNonFormattedText` changes the node's positions,
   *    so we can only call this once and can't get the non-formatted text separately.
   */
  ChangeTracker.prototype.getChanges = function(validate) {
    this.finishDeleteDeclarations();
    this.finishClassesWithNodesInsertedAtStart();
    const changes =
        changesToText.getTextChangesFromChanges(this.changes, this.newLineCharacter, this.formatContext, validate);
    for (let _i = 0, _a = this.newFiles; _i < _a.length; _i++) {
      const _b = _a[_i], oldFile = _b.oldFile, fileName = _b.fileName, statements = _b.statements;
      changes.push(
          changesToText.newFileChanges(oldFile, fileName, statements, this.newLineCharacter, this.formatContext));
    }
    return changes;
  };
  ChangeTracker.prototype.createNewFile = function(oldFile, fileName, statements) {
    this.newFiles.push({oldFile, fileName, statements});
  };
  return ChangeTracker;
})();
textChanges_3.ChangeTracker = ChangeTracker;
function updateJSDocHost(parent) {
  if (parent.kind !== 216 /* SyntaxKind.ArrowFunction */) {
    return parent;
  }
  const jsDocNode =
      parent.parent.kind === 169 /* SyntaxKind.PropertyDeclaration */ ? parent.parent : parent.parent.parent;
  jsDocNode.jsDoc = parent.jsDoc;
  jsDocNode.jsDocCache = parent.jsDocCache;
  return jsDocNode;
}
function tryMergeJsdocTags(oldTag, newTag) {
  if (oldTag.kind !== newTag.kind) {
    return undefined;
  }
  switch (oldTag.kind) {
    case 343 /* SyntaxKind.JSDocParameterTag */: {
      const oldParam = oldTag;
      const newParam = newTag;
      return ts.isIdentifier(oldParam.name) && ts.isIdentifier(newParam.name) &&
              oldParam.name.escapedText === newParam.name.escapedText ?
          ts.factory.createJSDocParameterTag(/* tagName*/ undefined, newParam.name, /* isBracketed*/ false,
                                             newParam.typeExpression, newParam.isNameFirst, oldParam.comment) :
          undefined;
    }
    case 344 /* SyntaxKind.JSDocReturnTag */:
      return ts.factory.createJSDocReturnTag(/* tagName*/ undefined, newTag.typeExpression, oldTag.comment);
    case 346 /* SyntaxKind.JSDocTypeTag */:
      return ts.factory.createJSDocTypeTag(/* tagName*/ undefined, newTag.typeExpression, oldTag.comment);
  }
}
// find first non-whitespace position in the leading trivia of the node
function startPositionToDeleteNodeInList(sourceFile, node) {
  return ts.skipTrivia(
      sourceFile.text,
      getAdjustedStartPosition(sourceFile, node, {leadingTriviaOption: LeadingTriviaOption.IncludeAll}),
      /* stopAfterLineBreak*/ false, /* stopAtComments*/ true);
}
function endPositionToDeleteNodeInList(sourceFile, node, prevNode, nextNode) {
  const end = startPositionToDeleteNodeInList(sourceFile, nextNode);
  if (prevNode === undefined ||
      ts.positionsAreOnSameLine(getAdjustedEndPosition(sourceFile, node, {}), end, sourceFile)) {
    return end;
  }
  const token = ts.findPrecedingToken(nextNode.getStart(sourceFile), sourceFile);
  if (isSeparator(node, token)) {
    const prevToken = ts.findPrecedingToken(node.getStart(sourceFile), sourceFile);
    if (isSeparator(prevNode, prevToken)) {
      const pos = ts.skipTrivia(sourceFile.text, token.getEnd(), /* stopAfterLineBreak*/ true, /* stopAtComments*/ true);
      if (ts.positionsAreOnSameLine(prevToken.getStart(sourceFile), token.getStart(sourceFile), sourceFile)) {
        return ts.isLineBreak(sourceFile.text.charCodeAt(pos - 1)) ? pos - 1 : pos;
      }
      if (ts.isLineBreak(sourceFile.text.charCodeAt(pos))) {
        return pos;
      }
    }
  }
  return end;
}
function getClassOrObjectBraceEnds(cls, sourceFile) {
  const open = ts.findChildOfKind(cls, 18 /* SyntaxKind.OpenBraceToken */, sourceFile);
  const close = ts.findChildOfKind(cls, 19 /* SyntaxKind.CloseBraceToken */, sourceFile);
  return [
    open === null || open === void 0 ? void 0 : open.end, close === null || close === void 0 ? void 0 : close.end
  ];
}
function getMembersOrProperties(node) {
  return ts.isObjectLiteralExpression(node) ? node.properties : node.members;
}
function getNewFileText(statements, scriptKind, newLineCharacter, formatContext) {
  return changesToText.newFileChangesWorker(/* oldFile*/ undefined, scriptKind, statements, newLineCharacter,
                                            formatContext);
}
textChanges_3.getNewFileText = getNewFileText;
let changesToText;
(function(changesToText) {
function getTextChangesFromChanges(changes, newLineCharacter, formatContext, validate) {
  return ts.mapDefined(ts.group(changes, function(c) {
    return c.sourceFile.path;
  }), function(changesInFile) {
    const sourceFile = changesInFile[0].sourceFile;
    // order changes by start position
    // If the start position is the same, put the shorter range first, since an empty range (x, x) may precede (x, y) but not vice-versa.
    const normalized = ts.stableSort(changesInFile, function(a, b) {
      return (a.range.pos - b.range.pos) || (a.range.end - b.range.end);
    });
    const _loop_10 = function(i) {
      ts.Debug.assert(normalized[i].range.end <= normalized[i + 1].range.pos, 'Changes overlap', function() {
        return ''.concat(JSON.stringify(normalized[i].range), ' and ').concat(JSON.stringify(normalized[i + 1].range));
      });
    };
    // verify that change intervals do not overlap, except possibly at end points.
    for (let i = 0; i < normalized.length - 1; i++) {
      _loop_10(i);
    }
    const textChanges = ts.mapDefined(normalized, function(c) {
      const span = ts.createTextSpanFromRange(c.range);
      const newText = computeNewText(c, sourceFile, newLineCharacter, formatContext, validate);
      // Filter out redundant changes.
      if (span.length === newText.length && ts.stringContainsAt(sourceFile.text, newText, span.start)) {
        return undefined;
      }
      return ts.createTextChange(span, newText);
    });
    return textChanges.length > 0 ? {fileName: sourceFile.fileName, textChanges} : undefined;
  });
}
changesToText.getTextChangesFromChanges = getTextChangesFromChanges;
function newFileChanges(oldFile, fileName, statements, newLineCharacter, formatContext) {
  const text = newFileChangesWorker(
      oldFile, ts.getScriptKindFromFileName(fileName), statements, newLineCharacter, formatContext);
  return {fileName, textChanges: [ts.createTextChange(ts.createTextSpan(0, 0), text)], isNewFile: true};
}
changesToText.newFileChanges = newFileChanges;
function newFileChangesWorker(oldFile, scriptKind, statements, newLineCharacter, formatContext) {
  // TODO: this emits the file, parses it back, then formats it that -- may be a less roundabout way to do this
  const nonFormattedText =
      statements
          .map(function(s) {
            return s === 4 /* SyntaxKind.NewLineTrivia */ ? '' : getNonformattedText(s, oldFile, newLineCharacter).text;
          })
          .join(newLineCharacter);
  const sourceFile = ts.createSourceFile(
      'any file name', nonFormattedText, 99 /* ScriptTarget.ESNext */, /* setParentNodes*/ true, scriptKind);
  const changes = ts.formatting.formatDocument(sourceFile, formatContext);
  return applyChanges(nonFormattedText, changes) + newLineCharacter;
}
changesToText.newFileChangesWorker = newFileChangesWorker;
function computeNewText(change, sourceFile, newLineCharacter, formatContext, validate) {
  let _a;
  if (change.kind === ChangeKind.Remove) {
    return '';
  }
  if (change.kind === ChangeKind.Text) {
    return change.text;
  }
  const _b = change.options, options = _b === void 0 ? {} : _b, pos = change.range.pos;
  const format = function(n) {
    return getFormattedTextOfNode(n, sourceFile, pos, options, newLineCharacter, formatContext, validate);
  };
  const text = change.kind === ChangeKind.ReplaceWithMultipleNodes ?
      change.nodes
          .map(function(n) {
            return ts.removeSuffix(format(n), newLineCharacter);
          })
          .join(((_a = change.options) === null || _a === void 0 ? void 0 : _a.joiner) || newLineCharacter) :
      format(change.node);
  // strip initial indentation (spaces or tabs) if text will be inserted in the middle of the line
  const noIndent = (options.indentation !== undefined || ts.getLineStartPositionForPosition(pos, sourceFile) === pos) ?
      text :
      text.replace(/^\s+/, '');
  return (options.prefix || '') + noIndent +
      ((!options.suffix || ts.endsWith(noIndent, options.suffix)) ? '' : options.suffix);
}
/** Note: this may mutate `nodeIn`. */
function getFormattedTextOfNode(nodeIn, sourceFile, pos, _a, newLineCharacter, formatContext, validate) {
  let indentation = _a.indentation, prefix = _a.prefix, delta = _a.delta;
  const _b = getNonformattedText(nodeIn, sourceFile, newLineCharacter), node = _b.node, text = _b.text;
  if (validate)
    {validate(node, text);}
  const formatOptions = ts.getFormatCodeSettingsForWriting(formatContext, sourceFile);
  const initialIndentation = indentation !== undefined ?
      indentation :
      ts.formatting.SmartIndenter.getIndentation(
          pos, sourceFile, formatOptions,
          prefix === newLineCharacter || ts.getLineStartPositionForPosition(pos, sourceFile) === pos);
  if (delta === undefined) {
    delta =
        ts.formatting.SmartIndenter.shouldIndentChildNode(formatOptions, nodeIn) ? (formatOptions.indentSize || 0) : 0;
  }
  const file = {
    text,
    getLineAndCharacterOfPosition: function(pos) {
      return ts.getLineAndCharacterOfPosition(this, pos);
    }
  };
  const changes = ts.formatting.formatNodeGivenIndentation(
      node, file, sourceFile.languageVariant, initialIndentation, delta,
      __assign(__assign({}, formatContext), {options: formatOptions}));
  return applyChanges(text, changes);
}
/** Note: output node may be mutated input node. */
function getNonformattedText(node, sourceFile, newLineCharacter) {
  const writer = createWriter(newLineCharacter);
  const newLine = ts.getNewLineKind(newLineCharacter);
  ts.createPrinter(
        {newLine, neverAsciiEscape: true, preserveSourceNewlines: true, terminateUnterminatedLiterals: true},
        writer)
      .writeNode(4 /* EmitHint.Unspecified */, node, sourceFile, writer);
  return {text: writer.getText(), node: assignPositionsToNode(node)};
}
changesToText.getNonformattedText = getNonformattedText;
})(changesToText || (changesToText = {}));
function applyChanges(text, changes) {
  for (let i = changes.length - 1; i >= 0; i--) {
    const _a = changes[i], span = _a.span, newText = _a.newText;
    text = ''.concat(text.substring(0, span.start)).concat(newText).concat(text.substring(ts.textSpanEnd(span)));
  }
  return text;
}
textChanges_3.applyChanges = applyChanges;
function isTrivia(s) {
  return ts.skipTrivia(s, 0) === s.length;
}
// A transformation context that won't perform parenthesization, as some parenthesization rules
// are more aggressive than is strictly necessary.
const textChangesTransformationContext = __assign(__assign({}, ts.nullTransformationContext), {
  factory: ts.createNodeFactory(
      ts.nullTransformationContext.factory.flags | 1 /* NodeFactoryFlags.NoParenthesizerRules */,
      ts.nullTransformationContext.factory.baseFactory)
});
function assignPositionsToNode(node) {
  const visited = ts.visitEachChild(
      node, assignPositionsToNode, textChangesTransformationContext, assignPositionsToNodeArray, assignPositionsToNode);
  // create proxy node for non synthesized nodes
  const newNode = ts.nodeIsSynthesized(visited) ? visited : Object.create(visited);
  ts.setTextRangePosEnd(newNode, getPos(node), getEnd(node));
  return newNode;
}
textChanges_3.assignPositionsToNode = assignPositionsToNode;
function assignPositionsToNodeArray(nodes, visitor, test, start, count) {
  const visited = ts.visitNodes(nodes, visitor, test, start, count);
  if (!visited) {
    return visited;
  }
  // clone nodearray if necessary
  const nodeArray = visited === nodes ? ts.factory.createNodeArray(visited.slice(0)) : visited;
  ts.setTextRangePosEnd(nodeArray, getPos(nodes), getEnd(nodes));
  return nodeArray;
}
function createWriter(newLine) {
  let lastNonTriviaPosition = 0;
  const writer = ts.createTextWriter(newLine);
  const onBeforeEmitNode = function(node) {
    if (node) {
      setPos(node, lastNonTriviaPosition);
    }
  };
  const onAfterEmitNode = function(node) {
    if (node) {
      setEnd(node, lastNonTriviaPosition);
    }
  };
  const onBeforeEmitNodeArray = function(nodes) {
    if (nodes) {
      setPos(nodes, lastNonTriviaPosition);
    }
  };
  const onAfterEmitNodeArray = function(nodes) {
    if (nodes) {
      setEnd(nodes, lastNonTriviaPosition);
    }
  };
  const onBeforeEmitToken = function(node) {
    if (node) {
      setPos(node, lastNonTriviaPosition);
    }
  };
  const onAfterEmitToken = function(node) {
    if (node) {
      setEnd(node, lastNonTriviaPosition);
    }
  };
  function setLastNonTriviaPosition(s, force) {
    if (force || !isTrivia(s)) {
      lastNonTriviaPosition = writer.getTextPos();
      let i = 0;
      while (ts.isWhiteSpaceLike(s.charCodeAt(s.length - i - 1))) {
        i++;
      }
      // trim trailing whitespaces
      lastNonTriviaPosition -= i;
    }
  }
  function write(s) {
    writer.write(s);
    setLastNonTriviaPosition(s, /* force*/ false);
  }
  function writeComment(s) {
    writer.writeComment(s);
  }
  function writeKeyword(s) {
    writer.writeKeyword(s);
    setLastNonTriviaPosition(s, /* force*/ false);
  }
  function writeOperator(s) {
    writer.writeOperator(s);
    setLastNonTriviaPosition(s, /* force*/ false);
  }
  function writePunctuation(s) {
    writer.writePunctuation(s);
    setLastNonTriviaPosition(s, /* force*/ false);
  }
  function writeTrailingSemicolon(s) {
    writer.writeTrailingSemicolon(s);
    setLastNonTriviaPosition(s, /* force*/ false);
  }
  function writeParameter(s) {
    writer.writeParameter(s);
    setLastNonTriviaPosition(s, /* force*/ false);
  }
  function writeProperty(s) {
    writer.writeProperty(s);
    setLastNonTriviaPosition(s, /* force*/ false);
  }
  function writeSpace(s) {
    writer.writeSpace(s);
    setLastNonTriviaPosition(s, /* force*/ false);
  }
  function writeStringLiteral(s) {
    writer.writeStringLiteral(s);
    setLastNonTriviaPosition(s, /* force*/ false);
  }
  function writeSymbol(s, sym) {
    writer.writeSymbol(s, sym);
    setLastNonTriviaPosition(s, /* force*/ false);
  }
  function writeLine(force) {
    writer.writeLine(force);
  }
  function increaseIndent() {
    writer.increaseIndent();
  }
  function decreaseIndent() {
    writer.decreaseIndent();
  }
  function getText() {
    return writer.getText();
  }
  function rawWrite(s) {
    writer.rawWrite(s);
    setLastNonTriviaPosition(s, /* force*/ false);
  }
  function writeLiteral(s) {
    writer.writeLiteral(s);
    setLastNonTriviaPosition(s, /* force*/ true);
  }
  function getTextPos() {
    return writer.getTextPos();
  }
  function getLine() {
    return writer.getLine();
  }
  function getColumn() {
    return writer.getColumn();
  }
  function getIndent() {
    return writer.getIndent();
  }
  function isAtStartOfLine() {
    return writer.isAtStartOfLine();
  }
  function clear() {
    writer.clear();
    lastNonTriviaPosition = 0;
  }
  return {
    onBeforeEmitNode,
    onAfterEmitNode,
    onBeforeEmitNodeArray,
    onAfterEmitNodeArray,
    onBeforeEmitToken,
    onAfterEmitToken,
    write,
    writeComment,
    writeKeyword,
    writeOperator,
    writePunctuation,
    writeTrailingSemicolon,
    writeParameter,
    writeProperty,
    writeSpace,
    writeStringLiteral,
    writeSymbol,
    writeLine,
    increaseIndent,
    decreaseIndent,
    getText,
    rawWrite,
    writeLiteral,
    getTextPos,
    getLine,
    getColumn,
    getIndent,
    isAtStartOfLine,
    hasTrailingComment: function() {
      return writer.hasTrailingComment();
    },
    hasTrailingWhitespace: function() {
      return writer.hasTrailingWhitespace();
    },
    clear
  };
}
textChanges_3.createWriter = createWriter;
function getInsertionPositionAtSourceFileTop(sourceFile) {
  let lastPrologue;
  for (let _i = 0, _a = sourceFile.statements; _i < _a.length; _i++) {
    const node = _a[_i];
    if (ts.isPrologueDirective(node)) {
      lastPrologue = node;
    } else {
      break;
    }
  }
  let position = 0;
  const text = sourceFile.text;
  if (lastPrologue) {
    position = lastPrologue.end;
    advancePastLineBreak();
    return position;
  }
  const shebang = ts.getShebang(text);
  if (shebang !== undefined) {
    position = shebang.length;
    advancePastLineBreak();
  }
  const ranges = ts.getLeadingCommentRanges(text, position);
  if (!ranges)
    {return position;}
  // Find the first attached comment to the first node and add before it
  let lastComment;
  let firstNodeLine;
  for (let _b = 0, ranges_1 = ranges; _b < ranges_1.length; _b++) {
    const range = ranges_1[_b];
    if (range.kind === 3 /* SyntaxKind.MultiLineCommentTrivia */) {
      if (ts.isPinnedComment(text, range.pos)) {
        lastComment = {range, pinnedOrTripleSlash: true};
        continue;
      }
    } else if (ts.isRecognizedTripleSlashComment(text, range.pos, range.end)) {
      lastComment = {range, pinnedOrTripleSlash: true};
      continue;
    }
    if (lastComment) {
      // Always insert after pinned or triple slash comments
      if (lastComment.pinnedOrTripleSlash)
        {break;}
      // There was a blank line between the last comment and this comment.
      // This comment is not part of the copyright comments
      const commentLine = sourceFile.getLineAndCharacterOfPosition(range.pos).line;
      const lastCommentEndLine = sourceFile.getLineAndCharacterOfPosition(lastComment.range.end).line;
      if (commentLine >= lastCommentEndLine + 2)
        {break;}
    }
    if (sourceFile.statements.length) {
      if (firstNodeLine === undefined)
        {firstNodeLine = sourceFile.getLineAndCharacterOfPosition(sourceFile.statements[0].getStart()).line;}
      const commentEndLine = sourceFile.getLineAndCharacterOfPosition(range.end).line;
      if (firstNodeLine < commentEndLine + 2)
        {break;}
    }
    lastComment = {range, pinnedOrTripleSlash: false};
  }
  if (lastComment) {
    position = lastComment.range.end;
    advancePastLineBreak();
  }
  return position;
  function advancePastLineBreak() {
    if (position < text.length) {
      const charCode = text.charCodeAt(position);
      if (ts.isLineBreak(charCode)) {
        position++;
        if (position < text.length && charCode === 13 /* CharacterCodes.carriageReturn */ &&
            text.charCodeAt(position) === 10 /* CharacterCodes.lineFeed */) {
          position++;
        }
      }
    }
  }
}
function isValidLocationToAddComment(sourceFile, position) {
  return !ts.isInComment(sourceFile, position) && !ts.isInString(sourceFile, position) &&
      !ts.isInTemplateString(sourceFile, position) && !ts.isInJSXText(sourceFile, position);
}
textChanges_3.isValidLocationToAddComment = isValidLocationToAddComment;
function needSemicolonBetween(a, b) {
  return (ts.isPropertySignature(a) || ts.isPropertyDeclaration(a)) && ts.isClassOrTypeElement(b) &&
      b.name.kind === 164 /* SyntaxKind.ComputedPropertyName */
      || ts.isStatementButNotDeclaration(a) &&
      ts.isStatementButNotDeclaration(b);  // TODO: only if b would start with a `(` or `[`
}
let deleteDeclaration;
(function(deleteDeclaration_1) {
function deleteDeclaration(changes, deletedNodesInLists, sourceFile, node) {
  switch (node.kind) {
    case 166 /* SyntaxKind.Parameter */: {
      const oldFunction = node.parent;
      if (ts.isArrowFunction(oldFunction) && oldFunction.parameters.length === 1 &&
          !ts.findChildOfKind(oldFunction, 20 /* SyntaxKind.OpenParenToken */, sourceFile)) {
        // Lambdas with exactly one parameter are special because, after removal, there
        // must be an empty parameter list (i.e. `()`) and this won't necessarily be the
        // case if the parameter is simply removed (e.g. in `x => 1`).
        changes.replaceNodeWithText(sourceFile, node, '()');
      } else {
        deleteNodeInList(changes, deletedNodesInLists, sourceFile, node);
      }
      break;
    }
    case 269 /* SyntaxKind.ImportDeclaration */:
    case 268 /* SyntaxKind.ImportEqualsDeclaration */:
      var isFirstImport = sourceFile.imports.length && node === ts.first(sourceFile.imports).parent ||
          node === ts.find(sourceFile.statements, ts.isAnyImportSyntax);
      // For first import, leave header comment in place, otherwise only delete JSDoc comments
      deleteNode(changes, sourceFile, node, {
        leadingTriviaOption: isFirstImport ? LeadingTriviaOption.Exclude :
            ts.hasJSDocNodes(node)         ? LeadingTriviaOption.JSDoc :
                                             LeadingTriviaOption.StartLine,
      });
      break;
    case 205 /* SyntaxKind.BindingElement */:
      var pattern = node.parent;
      var preserveComma =
          pattern.kind === 204 /* SyntaxKind.ArrayBindingPattern */ && node !== ts.last(pattern.elements);
      if (preserveComma) {
        deleteNode(changes, sourceFile, node);
      } else {
        deleteNodeInList(changes, deletedNodesInLists, sourceFile, node);
      }
      break;
    case 257 /* SyntaxKind.VariableDeclaration */:
      deleteVariableDeclaration(changes, deletedNodesInLists, sourceFile, node);
      break;
    case 165 /* SyntaxKind.TypeParameter */:
      deleteNodeInList(changes, deletedNodesInLists, sourceFile, node);
      break;
    case 273 /* SyntaxKind.ImportSpecifier */:
      var namedImports = node.parent;
      if (namedImports.elements.length === 1) {
        deleteImportBinding(changes, sourceFile, namedImports);
      } else {
        deleteNodeInList(changes, deletedNodesInLists, sourceFile, node);
      }
      break;
    case 271 /* SyntaxKind.NamespaceImport */:
      deleteImportBinding(changes, sourceFile, node);
      break;
    case 26 /* SyntaxKind.SemicolonToken */:
      deleteNode(changes, sourceFile, node, {trailingTriviaOption: TrailingTriviaOption.Exclude});
      break;
    case 98 /* SyntaxKind.FunctionKeyword */:
      deleteNode(changes, sourceFile, node, {leadingTriviaOption: LeadingTriviaOption.Exclude});
      break;
    case 260 /* SyntaxKind.ClassDeclaration */:
    case 259 /* SyntaxKind.FunctionDeclaration */:
      deleteNode(
          changes, sourceFile, node,
          {leadingTriviaOption: ts.hasJSDocNodes(node) ? LeadingTriviaOption.JSDoc : LeadingTriviaOption.StartLine});
      break;
    default:
      if (!node.parent) {
        // a misbehaving client can reach here with the SourceFile node
        deleteNode(changes, sourceFile, node);
      } else if (ts.isImportClause(node.parent) && node.parent.name === node) {
        deleteDefaultImport(changes, sourceFile, node.parent);
      } else if (ts.isCallExpression(node.parent) && ts.contains(node.parent.arguments, node)) {
        deleteNodeInList(changes, deletedNodesInLists, sourceFile, node);
      } else {
        deleteNode(changes, sourceFile, node);
      }
  }
}
deleteDeclaration_1.deleteDeclaration = deleteDeclaration;
function deleteDefaultImport(changes, sourceFile, importClause) {
  if (!importClause.namedBindings) {
    // Delete the whole import
    deleteNode(changes, sourceFile, importClause.parent);
  } else {
    // import |d,| * as ns from './file'
    const start = importClause.name.getStart(sourceFile);
    const nextToken = ts.getTokenAtPosition(sourceFile, importClause.name.end);
    if (nextToken && nextToken.kind === 27 /* SyntaxKind.CommaToken */) {
      // shift first non-whitespace position after comma to the start position of the node
      const end = ts.skipTrivia(sourceFile.text, nextToken.end, /* stopAfterLineBreaks*/ false, /* stopAtComments*/ true);
      changes.deleteRange(sourceFile, {pos: start, end});
    } else {
      deleteNode(changes, sourceFile, importClause.name);
    }
  }
}
function deleteImportBinding(changes, sourceFile, node) {
  if (node.parent.name) {
    // Delete named imports while preserving the default import
    // import d|, * as ns| from './file'
    // import d|, { a }| from './file'
    const previousToken = ts.Debug.checkDefined(ts.getTokenAtPosition(sourceFile, node.pos - 1));
    changes.deleteRange(sourceFile, {pos: previousToken.getStart(sourceFile), end: node.end});
  } else {
    // Delete the entire import declaration
    // |import * as ns from './file'|
    // |import { a } from './file'|
    const importDecl = ts.getAncestor(node, 269 /* SyntaxKind.ImportDeclaration */);
    deleteNode(changes, sourceFile, importDecl);
  }
}
function deleteVariableDeclaration(changes, deletedNodesInLists, sourceFile, node) {
  const parent = node.parent;
  if (parent.kind === 295 /* SyntaxKind.CatchClause */) {
    // TODO: There's currently no unused diagnostic for this, could be a suggestion
    changes.deleteNodeRange(
        sourceFile, ts.findChildOfKind(parent, 20 /* SyntaxKind.OpenParenToken */, sourceFile),
        ts.findChildOfKind(parent, 21 /* SyntaxKind.CloseParenToken */, sourceFile));
    return;
  }
  if (parent.declarations.length !== 1) {
    deleteNodeInList(changes, deletedNodesInLists, sourceFile, node);
    return;
  }
  const gp = parent.parent;
  switch (gp.kind) {
    case 247 /* SyntaxKind.ForOfStatement */:
    case 246 /* SyntaxKind.ForInStatement */:
      changes.replaceNode(sourceFile, node, ts.factory.createObjectLiteralExpression());
      break;
    case 245 /* SyntaxKind.ForStatement */:
      deleteNode(changes, sourceFile, parent);
      break;
    case 240 /* SyntaxKind.VariableStatement */:
      deleteNode(
          changes, sourceFile, gp,
          {leadingTriviaOption: ts.hasJSDocNodes(gp) ? LeadingTriviaOption.JSDoc : LeadingTriviaOption.StartLine});
      break;
    default:
      ts.Debug.assertNever(gp);
  }
}
})(deleteDeclaration || (deleteDeclaration = {}));
/** Warning: This deletes comments too. See `copyComments` in `convertFunctionToEs6Class`. */
// Exported for tests only! (TODO: improve tests to not need this)
function deleteNode(changes, sourceFile, node, options) {
  if (options === void 0) {
    options = {leadingTriviaOption: LeadingTriviaOption.IncludeAll};
  }
  const startPosition = getAdjustedStartPosition(sourceFile, node, options);
  const endPosition = getAdjustedEndPosition(sourceFile, node, options);
  changes.deleteRange(sourceFile, {pos: startPosition, end: endPosition});
}
textChanges_3.deleteNode = deleteNode;
function deleteNodeInList(changes, deletedNodesInLists, sourceFile, node) {
  const containingList = ts.Debug.checkDefined(ts.formatting.SmartIndenter.getContainingList(node, sourceFile));
  const index = ts.indexOfNode(containingList, node);
  ts.Debug.assert(index !== -1);
  if (containingList.length === 1) {
    deleteNode(changes, sourceFile, node);
    return;
  }
  // Note: We will only delete a comma *after* a node. This will leave a trailing comma if we delete the last node.
  // That's handled in the end by `finishTrailingCommaAfterDeletingNodesInList`.
  ts.Debug.assert(!deletedNodesInLists.has(node), 'Deleting a node twice');
  deletedNodesInLists.add(node);
  changes.deleteRange(sourceFile, {
    pos: startPositionToDeleteNodeInList(sourceFile, node),
    end: index === containingList.length - 1 ?
        getAdjustedEndPosition(sourceFile, node, {}) :
        endPositionToDeleteNodeInList(sourceFile, node, containingList[index - 1], containingList[index + 1]),
  });
}
})(textChanges = ts.textChanges || (ts.textChanges = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let codefix;
(function(codefix) {
const errorCodeToFixes = ts.createMultiMap();
const fixIdToRegistration = new ts.Map();
function createCodeFixActionWithoutFixAll(fixName, changes, description) {
  return createCodeFixActionWorker(
      fixName, ts.diagnosticToString(description), changes, /* fixId*/ undefined, /* fixAllDescription*/ undefined);
}
codefix.createCodeFixActionWithoutFixAll = createCodeFixActionWithoutFixAll;
function createCodeFixAction(fixName, changes, description, fixId, fixAllDescription, command) {
  return createCodeFixActionWorker(
      fixName, ts.diagnosticToString(description), changes, fixId, ts.diagnosticToString(fixAllDescription), command);
}
codefix.createCodeFixAction = createCodeFixAction;
function createCodeFixActionMaybeFixAll(fixName, changes, description, fixId, fixAllDescription, command) {
  return createCodeFixActionWorker(
      fixName, ts.diagnosticToString(description), changes, fixId,
      fixAllDescription && ts.diagnosticToString(fixAllDescription), command);
}
codefix.createCodeFixActionMaybeFixAll = createCodeFixActionMaybeFixAll;
function createCodeFixActionWorker(fixName, description, changes, fixId, fixAllDescription, command) {
  return {
    fixName,
    description,
    changes,
    fixId,
    fixAllDescription,
    commands: command ? [command] : undefined
  };
}
function registerCodeFix(reg) {
  for (let _i = 0, _a = reg.errorCodes; _i < _a.length; _i++) {
    const error = _a[_i];
    errorCodeToFixes.add(String(error), reg);
  }
  if (reg.fixIds) {
    for (let _b = 0, _c = reg.fixIds; _b < _c.length; _b++) {
      const fixId = _c[_b];
      ts.Debug.assert(!fixIdToRegistration.has(fixId));
      fixIdToRegistration.set(fixId, reg);
    }
  }
}
codefix.registerCodeFix = registerCodeFix;
function getSupportedErrorCodes() {
  return ts.arrayFrom(errorCodeToFixes.keys());
}
codefix.getSupportedErrorCodes = getSupportedErrorCodes;
function removeFixIdIfFixAllUnavailable(registration, diagnostics) {
  const errorCodes = registration.errorCodes;
  let maybeFixableDiagnostics = 0;
  for (let _i = 0, diagnostics_1 = diagnostics; _i < diagnostics_1.length; _i++) {
    const diag = diagnostics_1[_i];
    if (ts.contains(errorCodes, diag.code))
      {maybeFixableDiagnostics++;}
    if (maybeFixableDiagnostics > 1)
      {break;}
  }
  const fixAllUnavailable = maybeFixableDiagnostics < 2;
  return function(_a) {
    const fixId = _a.fixId, fixAllDescription = _a.fixAllDescription, action = __rest(_a, ['fixId', 'fixAllDescription']);
    return fixAllUnavailable ? action :
                               __assign(__assign({}, action), {fixId, fixAllDescription});
  };
}
function getFixes(context) {
  const diagnostics = getDiagnostics(context);
  const registrations = errorCodeToFixes.get(String(context.errorCode));
  return ts.flatMap(registrations, function(f) {
    return ts.map(f.getCodeActions(context), removeFixIdIfFixAllUnavailable(f, diagnostics));
  });
}
codefix.getFixes = getFixes;
function getAllFixes(context) {
  // Currently fixId is always a string.
  return fixIdToRegistration.get(ts.cast(context.fixId, ts.isString)).getAllCodeActions(context);
}
codefix.getAllFixes = getAllFixes;
function createCombinedCodeActions(changes, commands) {
  return {changes, commands};
}
codefix.createCombinedCodeActions = createCombinedCodeActions;
function createFileTextChanges(fileName, textChanges) {
  return {fileName, textChanges};
}
codefix.createFileTextChanges = createFileTextChanges;
function codeFixAll(context, errorCodes, use) {
  const commands = [];
  const changes = ts.textChanges.ChangeTracker.with(context, function(t) {
    return eachDiagnostic(context, errorCodes, function(diag) {
      return use(t, diag, commands);
    });
  });
  return createCombinedCodeActions(changes, commands.length === 0 ? undefined : commands);
}
codefix.codeFixAll = codeFixAll;
function eachDiagnostic(context, errorCodes, cb) {
  for (let _i = 0, _a = getDiagnostics(context); _i < _a.length; _i++) {
    const diag = _a[_i];
    if (ts.contains(errorCodes, diag.code)) {
      cb(diag);
    }
  }
}
codefix.eachDiagnostic = eachDiagnostic;
function getDiagnostics(_a) {
  const program = _a.program, sourceFile = _a.sourceFile, cancellationToken = _a.cancellationToken;
  return __spreadArray(
      __spreadArray(
          __spreadArray([], program.getSemanticDiagnostics(sourceFile, cancellationToken), true),
          program.getSyntacticDiagnostics(sourceFile, cancellationToken), true),
      ts.computeSuggestionDiagnostics(sourceFile, program, cancellationToken), true);
}
})(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let refactor;
(function(refactor_1) {
// A map with the refactor code as key, the refactor itself as value
// e.g.  nonSuggestableRefactors[refactorCode] -> the refactor you want
const refactors = new ts.Map();
/** @param name An unique code associated with each refactor. Does not have to be human-readable. */
function registerRefactor(name, refactor) {
  refactors.set(name, refactor);
}
refactor_1.registerRefactor = registerRefactor;
function getApplicableRefactors(context) {
  return ts.arrayFrom(ts.flatMapIterator(refactors.values(), function(refactor) {
    let _a;
    return context.cancellationToken && context.cancellationToken.isCancellationRequested() ||
            !((_a = refactor.kinds) === null || _a === void 0 ? void 0 : _a.some(function(kind) {
              return refactor_1.refactorKindBeginsWith(kind, context.kind);
            })) ?
        undefined :
        refactor.getAvailableActions(context);
  }));
}
refactor_1.getApplicableRefactors = getApplicableRefactors;
function getEditsForRefactor(context, refactorName, actionName) {
  const refactor = refactors.get(refactorName);
  return refactor && refactor.getEditsForAction(context, actionName);
}
refactor_1.getEditsForRefactor = getEditsForRefactor;
})(refactor = ts.refactor || (ts.refactor = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let codefix;
(function(codefix) {
const fixId = 'addConvertToUnknownForNonOverlappingTypes';
const errorCodes = [
  ts.Diagnostics
      .Conversion_of_type_0_to_type_1_may_be_a_mistake_because_neither_type_sufficiently_overlaps_with_the_other_If_this_was_intentional_convert_the_expression_to_unknown_first
      .code
];
codefix.registerCodeFix({
  errorCodes,
  getCodeActions: function getCodeActionsToAddConvertToUnknownForNonOverlappingTypes(context) {
    const assertion = getAssertion(context.sourceFile, context.span.start);
    if (assertion === undefined)
      {return undefined;}
    const changes = ts.textChanges.ChangeTracker.with(context, function(t) {
      return makeChange(t, context.sourceFile, assertion);
    });
    return [codefix.createCodeFixAction(
        fixId, changes, ts.Diagnostics.Add_unknown_conversion_for_non_overlapping_types, fixId,
        ts.Diagnostics.Add_unknown_to_all_conversions_of_non_overlapping_types)];
  },
  fixIds: [fixId],
  getAllCodeActions: function(context) {
    return codefix.codeFixAll(context, errorCodes, function(changes, diag) {
      const assertion = getAssertion(diag.file, diag.start);
      if (assertion) {
        makeChange(changes, diag.file, assertion);
      }
    });
  },
});
function makeChange(changeTracker, sourceFile, assertion) {
  const replacement = ts.isAsExpression(assertion) ?
      ts.factory.createAsExpression(
          assertion.expression, ts.factory.createKeywordTypeNode(157 /* SyntaxKind.UnknownKeyword */)) :
      ts.factory.createTypeAssertion(
          ts.factory.createKeywordTypeNode(157 /* SyntaxKind.UnknownKeyword */), assertion.expression);
  changeTracker.replaceNode(sourceFile, assertion.expression, replacement);
}
function getAssertion(sourceFile, pos) {
  if (ts.isInJSFile(sourceFile))
    {return undefined;}
  return ts.findAncestor(ts.getTokenAtPosition(sourceFile, pos), function(n) {
    return ts.isAsExpression(n) || ts.isTypeAssertionExpression(n);
  });
}
})(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let codefix;
(function(codefix) {
codefix.registerCodeFix({
  errorCodes: [
    ts.Diagnostics
        .await_expressions_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_Consider_adding_an_empty_export_to_make_this_file_a_module
        .code,
    ts.Diagnostics
        .for_await_loops_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_Consider_adding_an_empty_export_to_make_this_file_a_module
        .code,
  ],
  getCodeActions: function getCodeActionsToAddEmptyExportDeclaration(context) {
    const sourceFile = context.sourceFile;
    const changes = ts.textChanges.ChangeTracker.with(context, function(changes) {
      const exportDeclaration = ts.factory.createExportDeclaration(
          /* modifiers*/ undefined,
          /* isTypeOnly*/ false, ts.factory.createNamedExports([]),
          /* moduleSpecifier*/ undefined);
      changes.insertNodeAtEndOfScope(sourceFile, sourceFile, exportDeclaration);
    });
    return [codefix.createCodeFixActionWithoutFixAll(
        'addEmptyExportDeclaration', changes, ts.Diagnostics.Add_export_to_make_this_file_into_a_module)];
  },
});
})(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let codefix;
(function(codefix) {
const fixId = 'addMissingAsync';
const errorCodes = [
  ts.Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1.code,
  ts.Diagnostics.Type_0_is_not_assignable_to_type_1.code, ts.Diagnostics.Type_0_is_not_comparable_to_type_1.code
];
codefix.registerCodeFix({
  fixIds: [fixId],
  errorCodes,
  getCodeActions: function getCodeActionsToAddMissingAsync(context) {
    const sourceFile = context.sourceFile, errorCode = context.errorCode, cancellationToken = context.cancellationToken,
        program = context.program, span = context.span;
    const diagnostic = ts.find(
        program.getTypeChecker().getDiagnostics(sourceFile, cancellationToken),
        getIsMatchingAsyncError(span, errorCode));
    const directSpan = diagnostic && diagnostic.relatedInformation && ts.find(diagnostic.relatedInformation, function(r) {
      return r.code === ts.Diagnostics.Did_you_mean_to_mark_this_function_as_async.code;
    });
    const decl = getFixableErrorSpanDeclaration(sourceFile, directSpan);
    if (!decl) {
      return;
    }
    const trackChanges = function(cb) {
      return ts.textChanges.ChangeTracker.with(context, cb);
    };
    return [getFix(context, decl, trackChanges)];
  },
  getAllCodeActions: function(context) {
    const sourceFile = context.sourceFile;
    const fixedDeclarations = new ts.Set();
    return codefix.codeFixAll(context, errorCodes, function(t, diagnostic) {
      const span = diagnostic.relatedInformation && ts.find(diagnostic.relatedInformation, function(r) {
        return r.code === ts.Diagnostics.Did_you_mean_to_mark_this_function_as_async.code;
      });
      const decl = getFixableErrorSpanDeclaration(sourceFile, span);
      if (!decl) {
        return;
      }
      const trackChanges = function(cb) {
        return (cb(t), []);
      };
      return getFix(context, decl, trackChanges, fixedDeclarations);
    });
  },
});
function getFix(context, decl, trackChanges, fixedDeclarations) {
  const changes = trackChanges(function(t) {
    return makeChange(t, context.sourceFile, decl, fixedDeclarations);
  });
  return codefix.createCodeFixAction(
      fixId, changes, ts.Diagnostics.Add_async_modifier_to_containing_function, fixId,
      ts.Diagnostics.Add_all_missing_async_modifiers);
}
function makeChange(changeTracker, sourceFile, insertionSite, fixedDeclarations) {
  if (fixedDeclarations) {
    if (fixedDeclarations.has(ts.getNodeId(insertionSite))) {
      return;
    }
  }
  fixedDeclarations === null || fixedDeclarations === void 0 ? void 0 :
                                                               fixedDeclarations.add(ts.getNodeId(insertionSite));
  const cloneWithModifier = ts.factory.updateModifiers(
      ts.getSynthesizedDeepClone(insertionSite, /* includeTrivia*/ true),
      ts.factory.createNodeArray(ts.factory.createModifiersFromModifierFlags(
          ts.getSyntacticModifierFlags(insertionSite) | 512 /* ModifierFlags.Async */)));
  changeTracker.replaceNode(sourceFile, insertionSite, cloneWithModifier);
}
function getFixableErrorSpanDeclaration(sourceFile, span) {
  if (!span)
    {return undefined;}
  const token = ts.getTokenAtPosition(sourceFile, span.start);
  // Checker has already done work to determine that async might be possible, and has attached
  // related info to the node, so start by finding the signature that exactly matches up
  // with the diagnostic range.
  const decl = ts.findAncestor(token, function(node) {
    if (node.getStart(sourceFile) < span.start || node.getEnd() > ts.textSpanEnd(span)) {
      return 'quit';
    }
    return (ts.isArrowFunction(node) || ts.isMethodDeclaration(node) || ts.isFunctionExpression(node) ||
            ts.isFunctionDeclaration(node)) &&
        ts.textSpansEqual(span, ts.createTextSpanFromNode(node, sourceFile));
  });
  return decl;
}
function getIsMatchingAsyncError(span, errorCode) {
  return function(_a) {
    const start = _a.start, length = _a.length, relatedInformation = _a.relatedInformation, code = _a.code;
    return ts.isNumber(start) && ts.isNumber(length) && ts.textSpansEqual({start, length}, span) &&
        code === errorCode && !!relatedInformation && ts.some(relatedInformation, function(related) {
          return related.code === ts.Diagnostics.Did_you_mean_to_mark_this_function_as_async.code;
        });
  };
}
})(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let codefix;
(function(codefix) {
const fixId = 'addMissingAwait';
const propertyAccessCode = ts.Diagnostics.Property_0_does_not_exist_on_type_1.code;
const callableConstructableErrorCodes = [
  ts.Diagnostics.This_expression_is_not_callable.code,
  ts.Diagnostics.This_expression_is_not_constructable.code,
];
const errorCodes = __spreadArray(
    [
      ts.Diagnostics.An_arithmetic_operand_must_be_of_type_any_number_bigint_or_an_enum_type.code,
      ts.Diagnostics.The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type
          .code,
      ts.Diagnostics.The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type
          .code,
      ts.Diagnostics.Operator_0_cannot_be_applied_to_type_1.code,
      ts.Diagnostics.Operator_0_cannot_be_applied_to_types_1_and_2.code,
      ts.Diagnostics.This_comparison_appears_to_be_unintentional_because_the_types_0_and_1_have_no_overlap.code,
      ts.Diagnostics.This_condition_will_always_return_true_since_this_0_is_always_defined.code,
      ts.Diagnostics.Type_0_is_not_an_array_type.code, ts.Diagnostics.Type_0_is_not_an_array_type_or_a_string_type.code,
      ts.Diagnostics
          .Type_0_can_only_be_iterated_through_when_using_the_downlevelIteration_flag_or_with_a_target_of_es2015_or_higher
          .code,
      ts.Diagnostics
          .Type_0_is_not_an_array_type_or_a_string_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator
          .code,
      ts.Diagnostics.Type_0_is_not_an_array_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator
          .code,
      ts.Diagnostics.Type_0_must_have_a_Symbol_iterator_method_that_returns_an_iterator.code,
      ts.Diagnostics.Type_0_must_have_a_Symbol_asyncIterator_method_that_returns_an_async_iterator.code,
      ts.Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1.code, propertyAccessCode
    ],
    callableConstructableErrorCodes, true);
codefix.registerCodeFix({
  fixIds: [fixId],
  errorCodes,
  getCodeActions: function getCodeActionsToAddMissingAwait(context) {
    const sourceFile = context.sourceFile, errorCode = context.errorCode, span = context.span,
        cancellationToken = context.cancellationToken, program = context.program;
    const expression = getAwaitErrorSpanExpression(sourceFile, errorCode, span, cancellationToken, program);
    if (!expression) {
      return;
    }
    const checker = context.program.getTypeChecker();
    const trackChanges = function(cb) {
      return ts.textChanges.ChangeTracker.with(context, cb);
    };
    return ts.compact([
      getDeclarationSiteFix(context, expression, errorCode, checker, trackChanges),
      getUseSiteFix(context, expression, errorCode, checker, trackChanges)
    ]);
  },
  getAllCodeActions: function(context) {
    const sourceFile = context.sourceFile, program = context.program, cancellationToken = context.cancellationToken;
    const checker = context.program.getTypeChecker();
    const fixedDeclarations = new ts.Set();
    return codefix.codeFixAll(context, errorCodes, function(t, diagnostic) {
      const expression = getAwaitErrorSpanExpression(sourceFile, diagnostic.code, diagnostic, cancellationToken, program);
      if (!expression) {
        return;
      }
      const trackChanges = function(cb) {
        return (cb(t), []);
      };
      return getDeclarationSiteFix(context, expression, diagnostic.code, checker, trackChanges, fixedDeclarations) ||
          getUseSiteFix(context, expression, diagnostic.code, checker, trackChanges, fixedDeclarations);
    });
  },
});
function getAwaitErrorSpanExpression(sourceFile, errorCode, span, cancellationToken, program) {
  const expression = ts.getFixableErrorSpanExpression(sourceFile, span);
  return expression && isMissingAwaitError(sourceFile, errorCode, span, cancellationToken, program) &&
          isInsideAwaitableBody(expression) ?
      expression :
      undefined;
}
function getDeclarationSiteFix(context, expression, errorCode, checker, trackChanges, fixedDeclarations) {
  const sourceFile = context.sourceFile, program = context.program, cancellationToken = context.cancellationToken;
  const awaitableInitializers = findAwaitableInitializers(expression, sourceFile, cancellationToken, program, checker);
  if (awaitableInitializers) {
    const initializerChanges = trackChanges(function(t) {
      ts.forEach(awaitableInitializers.initializers, function(_a) {
        const expression = _a.expression;
        return makeChange(t, errorCode, sourceFile, checker, expression, fixedDeclarations);
      });
      if (fixedDeclarations && awaitableInitializers.needsSecondPassForFixAll) {
        makeChange(t, errorCode, sourceFile, checker, expression, fixedDeclarations);
      }
    });
    // No fix-all because it will already be included once with the use site fix,
    // and for simplicity the fix-all doesnt let the user choose between use-site and declaration-site fixes.
    return codefix.createCodeFixActionWithoutFixAll(
        'addMissingAwaitToInitializer', initializerChanges,
        awaitableInitializers.initializers.length === 1 ?
            [
              ts.Diagnostics.Add_await_to_initializer_for_0,
              awaitableInitializers.initializers[0].declarationSymbol.name
            ] :
            ts.Diagnostics.Add_await_to_initializers);
  }
}
function getUseSiteFix(context, expression, errorCode, checker, trackChanges, fixedDeclarations) {
  const changes = trackChanges(function(t) {
    return makeChange(t, errorCode, context.sourceFile, checker, expression, fixedDeclarations);
  });
  return codefix.createCodeFixAction(
      fixId, changes, ts.Diagnostics.Add_await, fixId, ts.Diagnostics.Fix_all_expressions_possibly_missing_await);
}
function isMissingAwaitError(sourceFile, errorCode, span, cancellationToken, program) {
  const checker = program.getTypeChecker();
  const diagnostics = checker.getDiagnostics(sourceFile, cancellationToken);
  return ts.some(diagnostics, function(_a) {
    const start = _a.start, length = _a.length, relatedInformation = _a.relatedInformation, code = _a.code;
    return ts.isNumber(start) && ts.isNumber(length) && ts.textSpansEqual({start, length}, span) &&
        code === errorCode && !!relatedInformation && ts.some(relatedInformation, function(related) {
          return related.code === ts.Diagnostics.Did_you_forget_to_use_await.code;
        });
  });
}
function findAwaitableInitializers(expression, sourceFile, cancellationToken, program, checker) {
  const identifiers = getIdentifiersFromErrorSpanExpression(expression, checker);
  if (!identifiers) {
    return;
  }
  let isCompleteFix = identifiers.isCompleteFix;
  let initializers;
  const _loop_11 = function(identifier) {
    const symbol = checker.getSymbolAtLocation(identifier);
    if (!symbol) {
      return 'continue';
    }
    const declaration = ts.tryCast(symbol.valueDeclaration, ts.isVariableDeclaration);
    const variableName = declaration && ts.tryCast(declaration.name, ts.isIdentifier);
    const variableStatement = ts.getAncestor(declaration, 240 /* SyntaxKind.VariableStatement */);
    if (!declaration || !variableStatement || declaration.type || !declaration.initializer ||
        variableStatement.getSourceFile() !== sourceFile ||
        ts.hasSyntacticModifier(variableStatement, 1 /* ModifierFlags.Export */) || !variableName ||
        !isInsideAwaitableBody(declaration.initializer)) {
      isCompleteFix = false;
      return 'continue';
    }
    const diagnostics = program.getSemanticDiagnostics(sourceFile, cancellationToken);
    const isUsedElsewhere =
        ts.FindAllReferences.Core.eachSymbolReferenceInFile(variableName, checker, sourceFile, function(reference) {
          return identifier !== reference &&
              !symbolReferenceIsAlsoMissingAwait(reference, diagnostics, sourceFile, checker);
        });
    if (isUsedElsewhere) {
      isCompleteFix = false;
      return 'continue';
    }
    (initializers || (initializers = [])).push({
      expression: declaration.initializer,
      declarationSymbol: symbol,
    });
  };
  for (let _i = 0, _a = identifiers.identifiers; _i < _a.length; _i++) {
    const identifier = _a[_i];
    _loop_11(identifier);
  }
  return initializers && {
    initializers,
    needsSecondPassForFixAll: !isCompleteFix,
  };
}
function getIdentifiersFromErrorSpanExpression(expression, checker) {
  if (ts.isPropertyAccessExpression(expression.parent) && ts.isIdentifier(expression.parent.expression)) {
    return {identifiers: [expression.parent.expression], isCompleteFix: true};
  }
  if (ts.isIdentifier(expression)) {
    return {identifiers: [expression], isCompleteFix: true};
  }
  if (ts.isBinaryExpression(expression)) {
    let sides = void 0;
    let isCompleteFix = true;
    for (let _i = 0, _a = [expression.left, expression.right]; _i < _a.length; _i++) {
      const side = _a[_i];
      const type = checker.getTypeAtLocation(side);
      if (checker.getPromisedTypeOfPromise(type)) {
        if (!ts.isIdentifier(side)) {
          isCompleteFix = false;
          continue;
        }
        (sides || (sides = [])).push(side);
      }
    }
    return sides && {identifiers: sides, isCompleteFix};
  }
}
function symbolReferenceIsAlsoMissingAwait(reference, diagnostics, sourceFile, checker) {
  const errorNode = ts.isPropertyAccessExpression(reference.parent) ? reference.parent.name :
      ts.isBinaryExpression(reference.parent)                     ? reference.parent :
                                                                    reference;
  const diagnostic = ts.find(diagnostics, function(diagnostic) {
    return diagnostic.start === errorNode.getStart(sourceFile) &&
        (diagnostic.start + diagnostic.length) === errorNode.getEnd();
  });
  return diagnostic && ts.contains(errorCodes, diagnostic.code) ||
      // A Promise is usually not correct in a binary expression (its not valid
      // in an arithmetic expression and an equality comparison seems unusual),
      // but if the other side of the binary expression has an error, the side
      // is typed `any` which will squash the error that would identify this
      // Promise as an invalid operand. So if the whole binary expression is
      // typed `any` as a result, there is a strong likelihood that this Promise
      // is accidentally missing `await`.
      checker.getTypeAtLocation(errorNode).flags & 1 /* TypeFlags.Any */;
}
function isInsideAwaitableBody(node) {
  return node.kind & 32768 /* NodeFlags.AwaitContext */ || !!ts.findAncestor(node, function(ancestor) {
    return ancestor.parent && ts.isArrowFunction(ancestor.parent) && ancestor.parent.body === ancestor ||
        ts.isBlock(ancestor) &&
        (ancestor.parent.kind === 259 /* SyntaxKind.FunctionDeclaration */ ||
         ancestor.parent.kind === 215 /* SyntaxKind.FunctionExpression */ ||
         ancestor.parent.kind === 216 /* SyntaxKind.ArrowFunction */ ||
         ancestor.parent.kind === 171 /* SyntaxKind.MethodDeclaration */);
  });
}
function makeChange(changeTracker, errorCode, sourceFile, checker, insertionSite, fixedDeclarations) {
  if (ts.isForOfStatement(insertionSite.parent) && !insertionSite.parent.awaitModifier) {
    const exprType = checker.getTypeAtLocation(insertionSite);
    const asyncIter = checker.getAsyncIterableType();
    if (asyncIter && checker.isTypeAssignableTo(exprType, asyncIter)) {
      const forOf = insertionSite.parent;
      changeTracker.replaceNode(
          sourceFile, forOf,
          ts.factory.updateForOfStatement(
              forOf, ts.factory.createToken(133 /* SyntaxKind.AwaitKeyword */), forOf.initializer, forOf.expression,
              forOf.statement));
      return;
    }
  }
  if (ts.isBinaryExpression(insertionSite)) {
    for (let _i = 0, _a = [insertionSite.left, insertionSite.right]; _i < _a.length; _i++) {
      const side = _a[_i];
      if (fixedDeclarations && ts.isIdentifier(side)) {
        var symbol = checker.getSymbolAtLocation(side);
        if (symbol && fixedDeclarations.has(ts.getSymbolId(symbol))) {
          continue;
        }
      }
      const type = checker.getTypeAtLocation(side);
      const newNode = checker.getPromisedTypeOfPromise(type) ? ts.factory.createAwaitExpression(side) : side;
      changeTracker.replaceNode(sourceFile, side, newNode);
    }
  } else if (errorCode === propertyAccessCode && ts.isPropertyAccessExpression(insertionSite.parent)) {
    if (fixedDeclarations && ts.isIdentifier(insertionSite.parent.expression)) {
      var symbol = checker.getSymbolAtLocation(insertionSite.parent.expression);
      if (symbol && fixedDeclarations.has(ts.getSymbolId(symbol))) {
        return;
      }
    }
    changeTracker.replaceNode(
        sourceFile, insertionSite.parent.expression,
        ts.factory.createParenthesizedExpression(ts.factory.createAwaitExpression(insertionSite.parent.expression)));
    insertLeadingSemicolonIfNeeded(changeTracker, insertionSite.parent.expression, sourceFile);
  } else if (
      ts.contains(callableConstructableErrorCodes, errorCode) && ts.isCallOrNewExpression(insertionSite.parent)) {
    if (fixedDeclarations && ts.isIdentifier(insertionSite)) {
      var symbol = checker.getSymbolAtLocation(insertionSite);
      if (symbol && fixedDeclarations.has(ts.getSymbolId(symbol))) {
        return;
      }
    }
    changeTracker.replaceNode(
        sourceFile, insertionSite,
        ts.factory.createParenthesizedExpression(ts.factory.createAwaitExpression(insertionSite)));
    insertLeadingSemicolonIfNeeded(changeTracker, insertionSite, sourceFile);
  } else {
    if (fixedDeclarations && ts.isVariableDeclaration(insertionSite.parent) &&
        ts.isIdentifier(insertionSite.parent.name)) {
      var symbol = checker.getSymbolAtLocation(insertionSite.parent.name);
      if (symbol && !ts.tryAddToSet(fixedDeclarations, ts.getSymbolId(symbol))) {
        return;
      }
    }
    changeTracker.replaceNode(sourceFile, insertionSite, ts.factory.createAwaitExpression(insertionSite));
  }
}
function insertLeadingSemicolonIfNeeded(changeTracker, beforeNode, sourceFile) {
  const precedingToken = ts.findPrecedingToken(beforeNode.pos, sourceFile);
  if (precedingToken && ts.positionIsASICandidate(precedingToken.end, precedingToken.parent, sourceFile)) {
    changeTracker.insertText(sourceFile, beforeNode.getStart(sourceFile), ';');
  }
}
})(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let codefix;
(function(codefix) {
const fixId = 'addMissingConst';
const errorCodes = [
  ts.Diagnostics.Cannot_find_name_0.code,
  ts.Diagnostics.No_value_exists_in_scope_for_the_shorthand_property_0_Either_declare_one_or_provide_an_initializer.code
];
codefix.registerCodeFix({
  errorCodes,
  getCodeActions: function getCodeActionsToAddMissingConst(context) {
    const changes = ts.textChanges.ChangeTracker.with(context, function(t) {
      return makeChange(t, context.sourceFile, context.span.start, context.program);
    });
    if (changes.length > 0) {
      return [codefix.createCodeFixAction(
          fixId, changes, ts.Diagnostics.Add_const_to_unresolved_variable, fixId,
          ts.Diagnostics.Add_const_to_all_unresolved_variables)];
    }
  },
  fixIds: [fixId],
  getAllCodeActions: function(context) {
    const fixedNodes = new ts.Set();
    return codefix.codeFixAll(context, errorCodes, function(changes, diag) {
      return makeChange(changes, diag.file, diag.start, context.program, fixedNodes);
    });
  },
});
function makeChange(changeTracker, sourceFile, pos, program, fixedNodes) {
  const token = ts.getTokenAtPosition(sourceFile, pos);
  const forInitializer = ts.findAncestor(token, function(node) {
    return ts.isForInOrOfStatement(node.parent) ? node.parent.initializer === node :
        isPossiblyPartOfDestructuring(node)     ? false :
                                                  'quit';
  });
  if (forInitializer)
    {return applyChange(changeTracker, forInitializer, sourceFile, fixedNodes);}
  const parent = token.parent;
  if (ts.isBinaryExpression(parent) && parent.operatorToken.kind === 63 /* SyntaxKind.EqualsToken */ &&
      ts.isExpressionStatement(parent.parent)) {
    return applyChange(changeTracker, token, sourceFile, fixedNodes);
  }
  if (ts.isArrayLiteralExpression(parent)) {
    const checker_1 = program.getTypeChecker();
    if (!ts.every(parent.elements, function(element) {
          return arrayElementCouldBeVariableDeclaration(element, checker_1);
        })) {
      return;
    }
    return applyChange(changeTracker, parent, sourceFile, fixedNodes);
  }
  const commaExpression = ts.findAncestor(token, function(node) {
    return ts.isExpressionStatement(node.parent)        ? true :
        isPossiblyPartOfCommaSeperatedInitializer(node) ? false :
                                                          'quit';
  });
  if (commaExpression) {
    const checker = program.getTypeChecker();
    if (!expressionCouldBeVariableDeclaration(commaExpression, checker)) {
      return;
    }
    return applyChange(changeTracker, commaExpression, sourceFile, fixedNodes);
  }
}
function applyChange(changeTracker, initializer, sourceFile, fixedNodes) {
  if (!fixedNodes || ts.tryAddToSet(fixedNodes, initializer)) {
    changeTracker.insertModifierBefore(sourceFile, 85 /* SyntaxKind.ConstKeyword */, initializer);
  }
}
function isPossiblyPartOfDestructuring(node) {
  switch (node.kind) {
    case 79 /* SyntaxKind.Identifier */:
    case 206 /* SyntaxKind.ArrayLiteralExpression */:
    case 207 /* SyntaxKind.ObjectLiteralExpression */:
    case 299 /* SyntaxKind.PropertyAssignment */:
    case 300 /* SyntaxKind.ShorthandPropertyAssignment */:
      return true;
    default:
      return false;
  }
}
function arrayElementCouldBeVariableDeclaration(expression, checker) {
  const identifier = ts.isIdentifier(expression) ? expression :
      ts.isAssignmentExpression(expression, /* excludeCompoundAssignment*/ true) && ts.isIdentifier(expression.left) ?
                                                 expression.left :
                                                 undefined;
  return !!identifier && !checker.getSymbolAtLocation(identifier);
}
function isPossiblyPartOfCommaSeperatedInitializer(node) {
  switch (node.kind) {
    case 79 /* SyntaxKind.Identifier */:
    case 223 /* SyntaxKind.BinaryExpression */:
    case 27 /* SyntaxKind.CommaToken */:
      return true;
    default:
      return false;
  }
}
function expressionCouldBeVariableDeclaration(expression, checker) {
  if (!ts.isBinaryExpression(expression)) {
    return false;
  }
  if (expression.operatorToken.kind === 27 /* SyntaxKind.CommaToken */) {
    return ts.every([expression.left, expression.right], function(expression) {
      return expressionCouldBeVariableDeclaration(expression, checker);
    });
  }
  return expression.operatorToken.kind === 63 /* SyntaxKind.EqualsToken */
      && ts.isIdentifier(expression.left) && !checker.getSymbolAtLocation(expression.left);
}
})(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let codefix;
(function(codefix) {
const fixId = 'addMissingDeclareProperty';
const errorCodes = [
  ts.Diagnostics
      .Property_0_will_overwrite_the_base_property_in_1_If_this_is_intentional_add_an_initializer_Otherwise_add_a_declare_modifier_or_remove_the_redundant_declaration
      .code,
];
codefix.registerCodeFix({
  errorCodes,
  getCodeActions: function getCodeActionsToAddMissingDeclareOnProperty(context) {
    const changes = ts.textChanges.ChangeTracker.with(context, function(t) {
      return makeChange(t, context.sourceFile, context.span.start);
    });
    if (changes.length > 0) {
      return [codefix.createCodeFixAction(
          fixId, changes, ts.Diagnostics.Prefix_with_declare, fixId,
          ts.Diagnostics.Prefix_all_incorrect_property_declarations_with_declare)];
    }
  },
  fixIds: [fixId],
  getAllCodeActions: function(context) {
    const fixedNodes = new ts.Set();
    return codefix.codeFixAll(context, errorCodes, function(changes, diag) {
      return makeChange(changes, diag.file, diag.start, fixedNodes);
    });
  },
});
function makeChange(changeTracker, sourceFile, pos, fixedNodes) {
  const token = ts.getTokenAtPosition(sourceFile, pos);
  if (!ts.isIdentifier(token)) {
    return;
  }
  const declaration = token.parent;
  if (declaration.kind === 169 /* SyntaxKind.PropertyDeclaration */ &&
      (!fixedNodes || ts.tryAddToSet(fixedNodes, declaration))) {
    changeTracker.insertModifierBefore(sourceFile, 136 /* SyntaxKind.DeclareKeyword */, declaration);
  }
}
})(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let codefix;
(function(codefix) {
const fixId = 'addMissingInvocationForDecorator';
const errorCodes =
    [ts.Diagnostics
         ._0_accepts_too_few_arguments_to_be_used_as_a_decorator_here_Did_you_mean_to_call_it_first_and_write_0.code];
codefix.registerCodeFix({
  errorCodes,
  getCodeActions: function getCodeActionsToAddMissingInvocationForDecorator(context) {
    const changes = ts.textChanges.ChangeTracker.with(context, function(t) {
      return makeChange(t, context.sourceFile, context.span.start);
    });
    return [codefix.createCodeFixAction(
        fixId, changes, ts.Diagnostics.Call_decorator_expression, fixId,
        ts.Diagnostics.Add_to_all_uncalled_decorators)];
  },
  fixIds: [fixId],
  getAllCodeActions: function(context) {
    return codefix.codeFixAll(context, errorCodes, function(changes, diag) {
      return makeChange(changes, diag.file, diag.start);
    });
  },
});
function makeChange(changeTracker, sourceFile, pos) {
  const token = ts.getTokenAtPosition(sourceFile, pos);
  const decorator = ts.findAncestor(token, ts.isDecorator);
  ts.Debug.assert(!!decorator, 'Expected position to be owned by a decorator.');
  const replacement =
      ts.factory.createCallExpression(decorator.expression, /* typeArguments*/ undefined, /* argumentsArray*/ undefined);
  changeTracker.replaceNode(sourceFile, decorator.expression, replacement);
}
})(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let codefix;
(function(codefix) {
const fixId = 'addNameToNamelessParameter';
const errorCodes = [ts.Diagnostics.Parameter_has_a_name_but_no_type_Did_you_mean_0_Colon_1.code];
codefix.registerCodeFix({
  errorCodes,
  getCodeActions: function getCodeActionsToAddNameToNamelessParameter(context) {
    const changes = ts.textChanges.ChangeTracker.with(context, function(t) {
      return makeChange(t, context.sourceFile, context.span.start);
    });
    return [codefix.createCodeFixAction(
        fixId, changes, ts.Diagnostics.Add_parameter_name, fixId,
        ts.Diagnostics.Add_names_to_all_parameters_without_names)];
  },
  fixIds: [fixId],
  getAllCodeActions: function(context) {
    return codefix.codeFixAll(context, errorCodes, function(changes, diag) {
      return makeChange(changes, diag.file, diag.start);
    });
  },
});
function makeChange(changeTracker, sourceFile, pos) {
  const token = ts.getTokenAtPosition(sourceFile, pos);
  const param = token.parent;
  if (!ts.isParameter(param)) {
    return ts.Debug.fail('Tried to add a parameter name to a non-parameter: ' + ts.Debug.formatSyntaxKind(token.kind));
  }
  const i = param.parent.parameters.indexOf(param);
  ts.Debug.assert(!param.type, 'Tried to add a parameter name to a parameter that already had one.');
  ts.Debug.assert(i > -1, 'Parameter not found in parent parameter list.');
  const typeNode = ts.factory.createTypeReferenceNode(param.name, /* typeArguments*/ undefined);
  const replacement = ts.factory.createParameterDeclaration(
      param.modifiers, param.dotDotDotToken, 'arg' + i, param.questionToken,
      param.dotDotDotToken ? ts.factory.createArrayTypeNode(typeNode) : typeNode, param.initializer);
  changeTracker.replaceNode(sourceFile, param, replacement);
}
})(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let codefix;
(function(codefix) {
const addOptionalPropertyUndefined = 'addOptionalPropertyUndefined';
const errorCodes = [
  ts.Diagnostics
      .Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_type_of_the_target
      .code,
  ts.Diagnostics
      .Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_types_of_the_target_s_properties
      .code,
  ts.Diagnostics
      .Argument_of_type_0_is_not_assignable_to_parameter_of_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_types_of_the_target_s_properties
      .code,
];
codefix.registerCodeFix({
  errorCodes,
  getCodeActions: function(context) {
    const typeChecker = context.program.getTypeChecker();
    const toAdd = getPropertiesToAdd(context.sourceFile, context.span, typeChecker);
    if (!toAdd.length) {
      return undefined;
    }
    const changes = ts.textChanges.ChangeTracker.with(context, function(t) {
      return addUndefinedToOptionalProperty(t, toAdd);
    });
    return [codefix.createCodeFixActionWithoutFixAll(
        addOptionalPropertyUndefined, changes, ts.Diagnostics.Add_undefined_to_optional_property_type)];
  },
  fixIds: [addOptionalPropertyUndefined],
});
function getPropertiesToAdd(file, span, checker) {
  let _a, _b;
  const sourceTarget = getSourceTarget(ts.getFixableErrorSpanExpression(file, span), checker);
  if (!sourceTarget) {
    return ts.emptyArray;
  }
  const sourceNode = sourceTarget.source, targetNode = sourceTarget.target;
  const target = shouldUseParentTypeOfProperty(sourceNode, targetNode, checker) ?
      checker.getTypeAtLocation(targetNode.expression) :
      checker.getTypeAtLocation(targetNode);
  if ((_b = (_a = target.symbol) === null || _a === void 0 ? void 0 : _a.declarations) === null || _b === void 0 ?
          void 0 :
          _b.some(function(d) {
            return ts.getSourceFileOfNode(d).fileName.match(/\.d\.ts$/);
          })) {
    return ts.emptyArray;
  }
  return checker.getExactOptionalProperties(target);
}
function shouldUseParentTypeOfProperty(sourceNode, targetNode, checker) {
  return ts.isPropertyAccessExpression(targetNode) &&
      !!checker.getExactOptionalProperties(checker.getTypeAtLocation(targetNode.expression)).length &&
      checker.getTypeAtLocation(sourceNode) === checker.getUndefinedType();
}
/**
 * Find the source and target of the incorrect assignment.
 * The call is recursive for property assignments.
 */
function getSourceTarget(errorNode, checker) {
  let _a;
  if (!errorNode) {
    return undefined;
  } if (
      ts.isBinaryExpression(errorNode.parent) &&
      errorNode.parent.operatorToken.kind === 63 /* SyntaxKind.EqualsToken */) {
    return {source: errorNode.parent.right, target: errorNode.parent.left};
  } if (ts.isVariableDeclaration(errorNode.parent) && errorNode.parent.initializer) {
    return {source: errorNode.parent.initializer, target: errorNode.parent.name};
  } if (ts.isCallExpression(errorNode.parent)) {
    const n = checker.getSymbolAtLocation(errorNode.parent.expression);
    if (!(n === null || n === void 0 ? void 0 : n.valueDeclaration) || !ts.isFunctionLikeKind(n.valueDeclaration.kind))
      {return undefined;}
    if (!ts.isExpression(errorNode))
      {return undefined;}
    const i = errorNode.parent.arguments.indexOf(errorNode);
    if (i === -1)
      {return undefined;}
    const name = n.valueDeclaration.parameters[i].name;
    if (ts.isIdentifier(name))
      {return {source: errorNode, target: name};}
  } else if (
      ts.isPropertyAssignment(errorNode.parent) && ts.isIdentifier(errorNode.parent.name) ||
      ts.isShorthandPropertyAssignment(errorNode.parent)) {
    const parentTarget = getSourceTarget(errorNode.parent.parent, checker);
    if (!parentTarget)
      {return undefined;}
    const prop = checker.getPropertyOfType(checker.getTypeAtLocation(parentTarget.target), errorNode.parent.name.text);
    const declaration =
        (_a = prop === null || prop === void 0 ? void 0 : prop.declarations) === null || _a === void 0 ? void 0 : _a[0];
    if (!declaration)
      {return undefined;}
    return {
      source: ts.isPropertyAssignment(errorNode.parent) ? errorNode.parent.initializer : errorNode.parent.name,
      target: declaration
    };
  }
  return undefined;
}
function addUndefinedToOptionalProperty(changes, toAdd) {
  for (let _i = 0, toAdd_1 = toAdd; _i < toAdd_1.length; _i++) {
    const add = toAdd_1[_i];
    const d = add.valueDeclaration;
    if (d && (ts.isPropertySignature(d) || ts.isPropertyDeclaration(d)) && d.type) {
      const t = ts.factory.createUnionTypeNode(__spreadArray(
          __spreadArray([], d.type.kind === 189 /* SyntaxKind.UnionType */ ? d.type.types : [d.type], true),
          [ts.factory.createTypeReferenceNode('undefined')], false));
      changes.replaceNode(d.getSourceFile(), d.type, t);
    }
  }
}
})(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let codefix;
(function(codefix) {
const fixId = 'annotateWithTypeFromJSDoc';
const errorCodes = [ts.Diagnostics.JSDoc_types_may_be_moved_to_TypeScript_types.code];
codefix.registerCodeFix({
  errorCodes,
  getCodeActions: function(context) {
    const decl = getDeclaration(context.sourceFile, context.span.start);
    if (!decl)
      {return;}
    const changes = ts.textChanges.ChangeTracker.with(context, function(t) {
      return doChange(t, context.sourceFile, decl);
    });
    return [codefix.createCodeFixAction(
        fixId, changes, ts.Diagnostics.Annotate_with_type_from_JSDoc, fixId,
        ts.Diagnostics.Annotate_everything_with_types_from_JSDoc)];
  },
  fixIds: [fixId],
  getAllCodeActions: function(context) {
    return codefix.codeFixAll(context, errorCodes, function(changes, diag) {
      const decl = getDeclaration(diag.file, diag.start);
      if (decl)
        {doChange(changes, diag.file, decl);}
    });
  },
});
function getDeclaration(file, pos) {
  const name = ts.getTokenAtPosition(file, pos);
  // For an arrow function with no name, 'name' lands on the first parameter.
  return ts.tryCast(ts.isParameter(name.parent) ? name.parent.parent : name.parent, parameterShouldGetTypeFromJSDoc);
}
function parameterShouldGetTypeFromJSDoc(node) {
  return isDeclarationWithType(node) && hasUsableJSDoc(node);
}
codefix.parameterShouldGetTypeFromJSDoc = parameterShouldGetTypeFromJSDoc;
function hasUsableJSDoc(decl) {
  return ts.isFunctionLikeDeclaration(decl) ?
      decl.parameters.some(hasUsableJSDoc) || (!decl.type && !!ts.getJSDocReturnType(decl)) :
      !decl.type && !!ts.getJSDocType(decl);
}
function doChange(changes, sourceFile, decl) {
  if (ts.isFunctionLikeDeclaration(decl) && (ts.getJSDocReturnType(decl) || decl.parameters.some(function(p) {
        return !!ts.getJSDocType(p);
      }))) {
    if (!decl.typeParameters) {
      const typeParameters = ts.getJSDocTypeParameterDeclarations(decl);
      if (typeParameters.length)
        {changes.insertTypeParameters(sourceFile, decl, typeParameters);}
    }
    const needParens =
        ts.isArrowFunction(decl) && !ts.findChildOfKind(decl, 20 /* SyntaxKind.OpenParenToken */, sourceFile);
    if (needParens)
      {changes.insertNodeBefore(
          sourceFile, ts.first(decl.parameters), ts.factory.createToken(20 /* SyntaxKind.OpenParenToken */));}
    for (let _i = 0, _a = decl.parameters; _i < _a.length; _i++) {
      const param = _a[_i];
      if (!param.type) {
        const paramType = ts.getJSDocType(param);
        if (paramType)
          {changes.tryInsertTypeAnnotation(sourceFile, param, transformJSDocType(paramType));}
      }
    }
    if (needParens)
      {changes.insertNodeAfter(
          sourceFile, ts.last(decl.parameters), ts.factory.createToken(21 /* SyntaxKind.CloseParenToken */));}
    if (!decl.type) {
      const returnType = ts.getJSDocReturnType(decl);
      if (returnType)
        {changes.tryInsertTypeAnnotation(sourceFile, decl, transformJSDocType(returnType));}
    }
  } else {
    const jsdocType = ts.Debug.checkDefined(
        ts.getJSDocType(decl),
        'A JSDocType for this declaration should exist');  // If not defined, shouldn't have been an error to fix
    ts.Debug.assert(
        !decl.type, 'The JSDocType decl should have a type');  // If defined, shouldn't have been an error to fix.
    changes.tryInsertTypeAnnotation(sourceFile, decl, transformJSDocType(jsdocType));
  }
}
function isDeclarationWithType(node) {
  return ts.isFunctionLikeDeclaration(node) || node.kind === 257 /* SyntaxKind.VariableDeclaration */ ||
      node.kind === 168 /* SyntaxKind.PropertySignature */ || node.kind === 169 /* SyntaxKind.PropertyDeclaration */;
}
function transformJSDocType(node) {
  switch (node.kind) {
    case 315 /* SyntaxKind.JSDocAllType */:
    case 316 /* SyntaxKind.JSDocUnknownType */:
      return ts.factory.createTypeReferenceNode('any', ts.emptyArray);
    case 319 /* SyntaxKind.JSDocOptionalType */:
      return transformJSDocOptionalType(node);
    case 318 /* SyntaxKind.JSDocNonNullableType */:
      return transformJSDocType(node.type);
    case 317 /* SyntaxKind.JSDocNullableType */:
      return transformJSDocNullableType(node);
    case 321 /* SyntaxKind.JSDocVariadicType */:
      return transformJSDocVariadicType(node);
    case 320 /* SyntaxKind.JSDocFunctionType */:
      return transformJSDocFunctionType(node);
    case 180 /* SyntaxKind.TypeReference */:
      return transformJSDocTypeReference(node);
    default:
      var visited = ts.visitEachChild(node, transformJSDocType, ts.nullTransformationContext);
      ts.setEmitFlags(visited, 1 /* EmitFlags.SingleLine */);
      return visited;
  }
}
function transformJSDocOptionalType(node) {
  return ts.factory.createUnionTypeNode(
      [ts.visitNode(node.type, transformJSDocType), ts.factory.createTypeReferenceNode('undefined', ts.emptyArray)]);
}
function transformJSDocNullableType(node) {
  return ts.factory.createUnionTypeNode(
      [ts.visitNode(node.type, transformJSDocType), ts.factory.createTypeReferenceNode('null', ts.emptyArray)]);
}
function transformJSDocVariadicType(node) {
  return ts.factory.createArrayTypeNode(ts.visitNode(node.type, transformJSDocType));
}
function transformJSDocFunctionType(node) {
  let _a;
  // TODO: This does not properly handle `function(new:C, string)` per https://github.com/google/closure-compiler/wiki/Types-in-the-Closure-Type-System#the-javascript-type-language
  //       however we do handle it correctly in `serializeTypeForDeclaration` in checker.ts
  return ts.factory.createFunctionTypeNode(
      ts.emptyArray, node.parameters.map(transformJSDocParameter),
      (_a = node.type) !== null && _a !== void 0 ? _a :
                                                   ts.factory.createKeywordTypeNode(131 /* SyntaxKind.AnyKeyword */));
}
function transformJSDocParameter(node) {
  const index = node.parent.parameters.indexOf(node);
  const isRest = node.type.kind === 321 /* SyntaxKind.JSDocVariadicType */ &&
      index === node.parent.parameters.length - 1;  // TODO: GH#18217
  const name = node.name || (isRest ? 'rest' : 'arg' + index);
  const dotdotdot = isRest ? ts.factory.createToken(25 /* SyntaxKind.DotDotDotToken */) : node.dotDotDotToken;
  return ts.factory.createParameterDeclaration(
      node.modifiers, dotdotdot, name, node.questionToken, ts.visitNode(node.type, transformJSDocType),
      node.initializer);
}
function transformJSDocTypeReference(node) {
  let name = node.typeName;
  let args = node.typeArguments;
  if (ts.isIdentifier(node.typeName)) {
    if (ts.isJSDocIndexSignature(node)) {
      return transformJSDocIndexSignature(node);
    }
    let text = node.typeName.text;
    switch (node.typeName.text) {
      case 'String':
      case 'Boolean':
      case 'Object':
      case 'Number':
        text = text.toLowerCase();
        break;
      case 'array':
      case 'date':
      case 'promise':
        text = text[0].toUpperCase() + text.slice(1);
        break;
    }
    name = ts.factory.createIdentifier(text);
    if ((text === 'Array' || text === 'Promise') && !node.typeArguments) {
      args = ts.factory.createNodeArray([ts.factory.createTypeReferenceNode('any', ts.emptyArray)]);
    } else {
      args = ts.visitNodes(node.typeArguments, transformJSDocType);
    }
  }
  return ts.factory.createTypeReferenceNode(name, args);
}
function transformJSDocIndexSignature(node) {
  const index = ts.factory.createParameterDeclaration(
      /* modifiers*/ undefined,
      /* dotDotDotToken*/ undefined, node.typeArguments[0].kind === 148 /* SyntaxKind.NumberKeyword */ ? 'n' : 's',
      /* questionToken*/ undefined,
      ts.factory.createTypeReferenceNode(
          node.typeArguments[0].kind === 148 /* SyntaxKind.NumberKeyword */ ? 'number' : 'string', []),
      /* initializer*/ undefined);
  const indexSignature = ts.factory.createTypeLiteralNode(
      [ts.factory.createIndexSignature(/* modifiers*/ undefined, [index], node.typeArguments[1])]);
  ts.setEmitFlags(indexSignature, 1 /* EmitFlags.SingleLine */);
  return indexSignature;
}
})(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let codefix;
(function(codefix) {
const fixId = 'convertFunctionToEs6Class';
const errorCodes = [ts.Diagnostics.This_constructor_function_may_be_converted_to_a_class_declaration.code];
codefix.registerCodeFix({
  errorCodes,
  getCodeActions: function(context) {
    const changes = ts.textChanges.ChangeTracker.with(context, function(t) {
      return doChange(
          t, context.sourceFile, context.span.start, context.program.getTypeChecker(), context.preferences,
          context.program.getCompilerOptions());
    });
    return [codefix.createCodeFixAction(
        fixId, changes, ts.Diagnostics.Convert_function_to_an_ES2015_class, fixId,
        ts.Diagnostics.Convert_all_constructor_functions_to_classes)];
  },
  fixIds: [fixId],
  getAllCodeActions: function(context) {
    return codefix.codeFixAll(context, errorCodes, function(changes, err) {
      return doChange(
          changes, err.file, err.start, context.program.getTypeChecker(), context.preferences,
          context.program.getCompilerOptions());
    });
  },
});
function doChange(changes, sourceFile, position, checker, preferences, compilerOptions) {
  const ctorSymbol = checker.getSymbolAtLocation(ts.getTokenAtPosition(sourceFile, position));
  if (!ctorSymbol || !ctorSymbol.valueDeclaration ||
      !(ctorSymbol.flags & (16 /* SymbolFlags.Function */ | 3 /* SymbolFlags.Variable */))) {
    // Bad input
    return undefined;
  }
  const ctorDeclaration = ctorSymbol.valueDeclaration;
  if (ts.isFunctionDeclaration(ctorDeclaration) || ts.isFunctionExpression(ctorDeclaration)) {
    changes.replaceNode(sourceFile, ctorDeclaration, createClassFromFunction(ctorDeclaration));
  } else if (ts.isVariableDeclaration(ctorDeclaration)) {
    const classDeclaration = createClassFromVariableDeclaration(ctorDeclaration);
    if (!classDeclaration) {
      return undefined;
    }
    const ancestor = ctorDeclaration.parent.parent;
    if (ts.isVariableDeclarationList(ctorDeclaration.parent) && ctorDeclaration.parent.declarations.length > 1) {
      changes.delete(sourceFile, ctorDeclaration);
      changes.insertNodeAfter(sourceFile, ancestor, classDeclaration);
    } else {
      changes.replaceNode(sourceFile, ancestor, classDeclaration);
    }
  }
  function createClassElementsFromSymbol(symbol) {
    const memberElements = [];
    // all static members are stored in the "exports" array of symbol
    if (symbol.exports) {
      symbol.exports.forEach(function(member) {
        if (member.name === 'prototype' && member.declarations) {
          const firstDeclaration = member.declarations[0];
          // only one "x.prototype = { ... }" will pass
          if (member.declarations.length === 1 && ts.isPropertyAccessExpression(firstDeclaration) &&
              ts.isBinaryExpression(firstDeclaration.parent) &&
              firstDeclaration.parent.operatorToken.kind === 63 /* SyntaxKind.EqualsToken */ &&
              ts.isObjectLiteralExpression(firstDeclaration.parent.right)) {
            const prototypes = firstDeclaration.parent.right;
            createClassElement(prototypes.symbol, /** modifiers */ undefined, memberElements);
          }
        } else {
          createClassElement(member, [ts.factory.createToken(124 /* SyntaxKind.StaticKeyword */)], memberElements);
        }
      });
    }
    // all instance members are stored in the "member" array of symbol (done last so instance members pulled from prototype assignments have priority)
    if (symbol.members) {
      symbol.members.forEach(function(member, key) {
        let _a, _b, _c, _d;
        if (key === 'constructor' && member.valueDeclaration) {
          const prototypeAssignment =
              (_d = (_c = (_b = (_a = symbol.exports) === null || _a === void 0 ? void 0 : _a.get('prototype')) ===
                                 null ||
                             _b === void 0 ?
                         void 0 :
                         _b.declarations) === null ||
                       _c === void 0 ?
                   void 0 :
                   _c[0]) === null ||
                  _d === void 0 ?
              void 0 :
              _d.parent;
          if (prototypeAssignment && ts.isBinaryExpression(prototypeAssignment) &&
              ts.isObjectLiteralExpression(prototypeAssignment.right) &&
              ts.some(prototypeAssignment.right.properties, isConstructorAssignment)) {
            // fn.prototype = { constructor: fn }
            // Already deleted in `createClassElement` in first pass
          } else {
            // fn.prototype.constructor = fn
            changes.delete(sourceFile, member.valueDeclaration.parent);
          }
          return;
        }
        createClassElement(member, /* modifiers*/ undefined, memberElements);
      });
    }
    return memberElements;
    function shouldConvertDeclaration(_target, source) {
      // Right now the only thing we can convert are function expressions, get/set accessors and methods
      // other values like normal value fields ({a: 1}) shouldn't get transformed.
      // We can update this once ES public class properties are available.
      if (ts.isAccessExpression(_target)) {
        if (ts.isPropertyAccessExpression(_target) && isConstructorAssignment(_target))
          {return true;}
        return ts.isFunctionLike(source);
      }
        return ts.every(_target.properties, function(property) {
          // a() {}
          if (ts.isMethodDeclaration(property) || ts.isGetOrSetAccessorDeclaration(property))
            {return true;}
          // a: function() {}
          if (ts.isPropertyAssignment(property) && ts.isFunctionExpression(property.initializer) && !!property.name)
            {return true;}
          // x.prototype.constructor = fn
          if (isConstructorAssignment(property))
            {return true;}
          return false;
        });

    }
    function createClassElement(symbol, modifiers, members) {
      // Right now the only thing we can convert are function expressions, which are marked as methods
      // or { x: y } type prototype assignments, which are marked as ObjectLiteral
      if (!(symbol.flags & 8192 /* SymbolFlags.Method */) && !(symbol.flags & 4096 /* SymbolFlags.ObjectLiteral */)) {
        return;
      }
      const memberDeclaration = symbol.valueDeclaration;
      const assignmentBinaryExpression = memberDeclaration.parent;
      const assignmentExpr = assignmentBinaryExpression.right;
      if (!shouldConvertDeclaration(memberDeclaration, assignmentExpr)) {
        return;
      }
      if (ts.some(members, function(m) {
            const name = ts.getNameOfDeclaration(m);
            if (name && ts.isIdentifier(name) && ts.idText(name) === ts.symbolName(symbol)) {
              return true;  // class member already made for this name
            }
            return false;
          })) {
        return;
      }
      // delete the entire statement if this expression is the sole expression to take care of the semicolon at the end
      const nodeToDelete = assignmentBinaryExpression.parent &&
              assignmentBinaryExpression.parent.kind === 241 /* SyntaxKind.ExpressionStatement */
          ?
          assignmentBinaryExpression.parent :
          assignmentBinaryExpression;
      changes.delete(sourceFile, nodeToDelete);
      if (!assignmentExpr) {
        members.push(ts.factory.createPropertyDeclaration(
            modifiers, symbol.name, /* questionToken*/ undefined,
            /* type*/ undefined, /* initializer*/ undefined));
        return;
      }
      // f.x = expr
      if (ts.isAccessExpression(memberDeclaration) &&
          (ts.isFunctionExpression(assignmentExpr) || ts.isArrowFunction(assignmentExpr))) {
        const quotePreference = ts.getQuotePreference(sourceFile, preferences);
        const name = tryGetPropertyName(memberDeclaration, compilerOptions, quotePreference);
        if (name) {
          createFunctionLikeExpressionMember(members, assignmentExpr, name);
        }
        return;
      }
      // f.prototype = { ... }
      if (ts.isObjectLiteralExpression(assignmentExpr)) {
        ts.forEach(assignmentExpr.properties, function(property) {
          if (ts.isMethodDeclaration(property) || ts.isGetOrSetAccessorDeclaration(property)) {
            // MethodDeclaration and AccessorDeclaration can appear in a class directly
            members.push(property);
          }
          if (ts.isPropertyAssignment(property) && ts.isFunctionExpression(property.initializer)) {
            createFunctionLikeExpressionMember(members, property.initializer, property.name);
          }
          // Drop constructor assignments
          if (isConstructorAssignment(property))
            {return;}
          return;
        });
        return;
      }
        // Don't try to declare members in JavaScript files
        if (ts.isSourceFileJS(sourceFile))
          {return;}
        if (!ts.isPropertyAccessExpression(memberDeclaration))
          {return;}
        const prop = ts.factory.createPropertyDeclaration(
            modifiers, memberDeclaration.name, /* questionToken*/ undefined, /* type*/ undefined, assignmentExpr);
        ts.copyLeadingComments(assignmentBinaryExpression.parent, prop, sourceFile);
        members.push(prop);
        return;

      function createFunctionLikeExpressionMember(members, expression, name) {
        if (ts.isFunctionExpression(expression))
          {return createFunctionExpressionMember(members, expression, name);}
        return createArrowFunctionExpressionMember(members, expression, name);
      }
      function createFunctionExpressionMember(members, functionExpression, name) {
        const fullModifiers =
            ts.concatenate(modifiers, getModifierKindFromSource(functionExpression, 132 /* SyntaxKind.AsyncKeyword */));
        const method = ts.factory.createMethodDeclaration(
            fullModifiers, /* asteriskToken*/ undefined, name, /* questionToken*/ undefined,
            /* typeParameters*/ undefined, functionExpression.parameters, /* type*/ undefined, functionExpression.body);
        ts.copyLeadingComments(assignmentBinaryExpression, method, sourceFile);
        members.push(method);
        return;
      }
      function createArrowFunctionExpressionMember(members, arrowFunction, name) {
        const arrowFunctionBody = arrowFunction.body;
        let bodyBlock;
        // case 1: () => { return [1,2,3] }
        if (arrowFunctionBody.kind === 238 /* SyntaxKind.Block */) {
          bodyBlock = arrowFunctionBody;
        }
        // case 2: () => [1,2,3]
        else {
          bodyBlock = ts.factory.createBlock([ts.factory.createReturnStatement(arrowFunctionBody)]);
        }
        const fullModifiers =
            ts.concatenate(modifiers, getModifierKindFromSource(arrowFunction, 132 /* SyntaxKind.AsyncKeyword */));
        const method = ts.factory.createMethodDeclaration(
            fullModifiers, /* asteriskToken*/ undefined, name, /* questionToken*/ undefined,
            /* typeParameters*/ undefined, arrowFunction.parameters, /* type*/ undefined, bodyBlock);
        ts.copyLeadingComments(assignmentBinaryExpression, method, sourceFile);
        members.push(method);
      }
    }
  }
  function createClassFromVariableDeclaration(node) {
    const initializer = node.initializer;
    if (!initializer || !ts.isFunctionExpression(initializer) || !ts.isIdentifier(node.name)) {
      return undefined;
    }
    const memberElements = createClassElementsFromSymbol(node.symbol);
    if (initializer.body) {
      memberElements.unshift(
          ts.factory.createConstructorDeclaration(/* modifiers*/ undefined, initializer.parameters, initializer.body));
    }
    const modifiers = getModifierKindFromSource(node.parent.parent, 93 /* SyntaxKind.ExportKeyword */);
    const cls = ts.factory.createClassDeclaration(
        modifiers, node.name,
        /* typeParameters*/ undefined, /* heritageClauses*/ undefined, memberElements);
    // Don't call copyComments here because we'll already leave them in place
    return cls;
  }
  function createClassFromFunction(node) {
    const memberElements = createClassElementsFromSymbol(ctorSymbol);
    if (node.body) {
      memberElements.unshift(
          ts.factory.createConstructorDeclaration(/* modifiers*/ undefined, node.parameters, node.body));
    }
    const modifiers = getModifierKindFromSource(node, 93 /* SyntaxKind.ExportKeyword */);
    const cls = ts.factory.createClassDeclaration(
        modifiers, node.name,
        /* typeParameters*/ undefined, /* heritageClauses*/ undefined, memberElements);
    // Don't call copyComments here because we'll already leave them in place
    return cls;
  }
}
function getModifierKindFromSource(source, kind) {
  return ts.canHaveModifiers(source) ? ts.filter(source.modifiers, function(modifier) {
    return modifier.kind === kind;
  }) : undefined;
}
function isConstructorAssignment(x) {
  if (!x.name)
    {return false;}
  if (ts.isIdentifier(x.name) && x.name.text === 'constructor')
    {return true;}
  return false;
}
function tryGetPropertyName(node, compilerOptions, quotePreference) {
  if (ts.isPropertyAccessExpression(node)) {
    return node.name;
  }
  const propName = node.argumentExpression;
  if (ts.isNumericLiteral(propName)) {
    return propName;
  }
  if (ts.isStringLiteralLike(propName)) {
    return ts.isIdentifierText(propName.text, ts.getEmitScriptTarget(compilerOptions)) ?
        ts.factory.createIdentifier(propName.text) :
        ts.isNoSubstitutionTemplateLiteral(propName) ?
        ts.factory.createStringLiteral(propName.text, quotePreference === 0 /* QuotePreference.Single */) :
        propName;
  }
  return undefined;
}
})(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let codefix;
(function(codefix) {
const fixId = 'convertToAsyncFunction';
const errorCodes = [ts.Diagnostics.This_may_be_converted_to_an_async_function.code];
let codeActionSucceeded = true;
codefix.registerCodeFix({
  errorCodes,
  getCodeActions: function(context) {
    codeActionSucceeded = true;
    const changes = ts.textChanges.ChangeTracker.with(context, function(t) {
      return convertToAsyncFunction(t, context.sourceFile, context.span.start, context.program.getTypeChecker());
    });
    return codeActionSucceeded ? [codefix.createCodeFixAction(
                                     fixId, changes, ts.Diagnostics.Convert_to_async_function, fixId,
                                     ts.Diagnostics.Convert_all_to_async_functions)] :
                                 [];
  },
  fixIds: [fixId],
  getAllCodeActions: function(context) {
    return codefix.codeFixAll(context, errorCodes, function(changes, err) {
      return convertToAsyncFunction(changes, err.file, err.start, context.program.getTypeChecker());
    });
  },
});
let SynthBindingNameKind;
(function(SynthBindingNameKind) {
SynthBindingNameKind[SynthBindingNameKind['Identifier'] = 0] = 'Identifier';
SynthBindingNameKind[SynthBindingNameKind['BindingPattern'] = 1] = 'BindingPattern';
})(SynthBindingNameKind || (SynthBindingNameKind = {}));
function convertToAsyncFunction(changes, sourceFile, position, checker) {
  // get the function declaration - returns a promise
  const tokenAtPosition = ts.getTokenAtPosition(sourceFile, position);
  let functionToConvert;
  // if the parent of a FunctionLikeDeclaration is a variable declaration, the convertToAsync diagnostic will be reported on the variable name
  if (ts.isIdentifier(tokenAtPosition) && ts.isVariableDeclaration(tokenAtPosition.parent) &&
      tokenAtPosition.parent.initializer && ts.isFunctionLikeDeclaration(tokenAtPosition.parent.initializer)) {
    functionToConvert = tokenAtPosition.parent.initializer;
  } else {
    functionToConvert =
        ts.tryCast(ts.getContainingFunction(ts.getTokenAtPosition(sourceFile, position)), ts.canBeConvertedToAsync);
  }
  if (!functionToConvert) {
    return;
  }
  const synthNamesMap = new ts.Map();
  const isInJavascript = ts.isInJSFile(functionToConvert);
  const setOfExpressionsToReturn = getAllPromiseExpressionsToReturn(functionToConvert, checker);
  const functionToConvertRenamed = renameCollidingVarNames(functionToConvert, checker, synthNamesMap);
  if (!ts.returnsPromise(functionToConvertRenamed, checker)) {
    return;
  }
  const returnStatements = functionToConvertRenamed.body && ts.isBlock(functionToConvertRenamed.body) ?
      getReturnStatementsWithPromiseHandlers(functionToConvertRenamed.body, checker) :
      ts.emptyArray;
  const transformer = {
    checker,
    synthNamesMap,
    setOfExpressionsToReturn,
    isInJSFile: isInJavascript
  };
  if (!returnStatements.length) {
    return;
  }
  const pos = ts.skipTrivia(sourceFile.text, ts.moveRangePastModifiers(functionToConvert).pos);
  changes.insertModifierAt(sourceFile, pos, 132 /* SyntaxKind.AsyncKeyword */, {suffix: ' '});
  const _loop_12 = function(returnStatement) {
    ts.forEachChild(returnStatement, function visit(node) {
      if (ts.isCallExpression(node)) {
        const newNodes = transformExpression(node, node, transformer, /* hasContinuation*/ false);
        if (hasFailed()) {
          return true;  // return something truthy to shortcut out of more work
        }
        changes.replaceNodeWithNodes(sourceFile, returnStatement, newNodes);
      } else if (!ts.isFunctionLike(node)) {
        ts.forEachChild(node, visit);
        if (hasFailed()) {
          return true;  // return something truthy to shortcut out of more work
        }
      }
    });
    if (hasFailed()) {
      return {value: void 0};
    }
  };
  for (let _i = 0, returnStatements_1 = returnStatements; _i < returnStatements_1.length; _i++) {
    const returnStatement = returnStatements_1[_i];
    const state_5 = _loop_12(returnStatement);
    if (typeof state_5 === 'object')
      {return state_5.value;}
  }
}
function getReturnStatementsWithPromiseHandlers(body, checker) {
  const res = [];
  ts.forEachReturnStatement(body, function(ret) {
    if (ts.isReturnStatementWithFixablePromiseHandler(ret, checker))
      {res.push(ret);}
  });
  return res;
}
/*
            Finds all of the expressions of promise type that should not be saved in a variable during the refactor
        */
function getAllPromiseExpressionsToReturn(func, checker) {
  if (!func.body) {
    return new ts.Set();
  }
  const setOfExpressionsToReturn = new ts.Set();
  ts.forEachChild(func.body, function visit(node) {
    if (isPromiseReturningCallExpression(node, checker, 'then')) {
      setOfExpressionsToReturn.add(ts.getNodeId(node));
      ts.forEach(node.arguments, visit);
    } else if (
        isPromiseReturningCallExpression(node, checker, 'catch') ||
        isPromiseReturningCallExpression(node, checker, 'finally')) {
      setOfExpressionsToReturn.add(ts.getNodeId(node));
      // if .catch() or .finally() is the last call in the chain, move leftward in the chain until we hit something else that should be returned
      ts.forEachChild(node, visit);
    } else if (isPromiseTypedExpression(node, checker)) {
      setOfExpressionsToReturn.add(ts.getNodeId(node));
      // don't recurse here, since we won't refactor any children or arguments of the expression
    } else {
      ts.forEachChild(node, visit);
    }
  });
  return setOfExpressionsToReturn;
}
function isPromiseReturningCallExpression(node, checker, name) {
  if (!ts.isCallExpression(node))
    {return false;}
  const isExpressionOfName = ts.hasPropertyAccessExpressionWithName(node, name);
  const nodeType = isExpressionOfName && checker.getTypeAtLocation(node);
  return !!(nodeType && checker.getPromisedTypeOfPromise(nodeType));
}
// NOTE: this is a mostly copy of `isReferenceToType` from checker.ts. While this violates DRY, it keeps
// `isReferenceToType` in checker local to the checker to avoid the cost of a property lookup on `ts`.
function isReferenceToType(type, target) {
  return (ts.getObjectFlags(type) & 4 /* ObjectFlags.Reference */) !== 0 && type.target === target;
}
function getExplicitPromisedTypeOfPromiseReturningCallExpression(node, callback, checker) {
  if (node.expression.name.escapedText === 'finally') {
    // for a `finally`, there's no type argument
    return undefined;
  }
  // If the call to `then` or `catch` comes from the global `Promise` or `PromiseLike` type, we can safely use the
  // type argument supplied for the callback. For other promise types we would need a more complex heuristic to determine
  // which type argument is safe to use as an annotation.
  const promiseType = checker.getTypeAtLocation(node.expression.expression);
  if (isReferenceToType(promiseType, checker.getPromiseType()) ||
      isReferenceToType(promiseType, checker.getPromiseLikeType())) {
    if (node.expression.name.escapedText === 'then') {
      if (callback === ts.elementAt(node.arguments, 0)) {
        // for the `onfulfilled` callback, use the first type argument
        return ts.elementAt(node.typeArguments, 0);
      } if (callback === ts.elementAt(node.arguments, 1)) {
        // for the `onrejected` callback, use the second type argument
        return ts.elementAt(node.typeArguments, 1);
      }
    } else {
      return ts.elementAt(node.typeArguments, 0);
    }
  }
}
function isPromiseTypedExpression(node, checker) {
  if (!ts.isExpression(node))
    {return false;}
  return !!checker.getPromisedTypeOfPromise(checker.getTypeAtLocation(node));
}
/*
            Renaming of identifiers may be necessary as the refactor changes scopes -
            This function collects all existing identifier names and names of identifiers that will be created in the refactor.
            It then checks for any collisions and renames them through getSynthesizedDeepClone
        */
function renameCollidingVarNames(nodeToRename, checker, synthNamesMap) {
  const identsToRenameMap = new ts.Map();  // key is the symbol id
  const collidingSymbolMap = ts.createMultiMap();
  ts.forEachChild(nodeToRename, function visit(node) {
    if (!ts.isIdentifier(node)) {
      ts.forEachChild(node, visit);
      return;
    }
    const symbol = checker.getSymbolAtLocation(node);
    if (symbol) {
      const type = checker.getTypeAtLocation(node);
      // Note - the choice of the last call signature is arbitrary
      const lastCallSignature = getLastCallSignature(type, checker);
      const symbolIdString = ts.getSymbolId(symbol).toString();
      // If the identifier refers to a function, we want to add the new synthesized variable for the declaration. Example:
      //   fetch('...').then(response => { ... })
      // will eventually become
      //   const response = await fetch('...')
      // so we push an entry for 'response'.
      if (lastCallSignature && !ts.isParameter(node.parent) && !ts.isFunctionLikeDeclaration(node.parent) &&
          !synthNamesMap.has(symbolIdString)) {
        const firstParameter = ts.firstOrUndefined(lastCallSignature.parameters);
        const ident = (firstParameter === null || firstParameter === void 0 ? void 0 : firstParameter.valueDeclaration) &&
                ts.isParameter(firstParameter.valueDeclaration) &&
                ts.tryCast(firstParameter.valueDeclaration.name, ts.isIdentifier) ||
            ts.factory.createUniqueName('result', 16 /* GeneratedIdentifierFlags.Optimistic */);
        const synthName = getNewNameIfConflict(ident, collidingSymbolMap);
        synthNamesMap.set(symbolIdString, synthName);
        collidingSymbolMap.add(ident.text, symbol);
      }
      // We only care about identifiers that are parameters, variable declarations, or binding elements
      else if (
          node.parent &&
          (ts.isParameter(node.parent) || ts.isVariableDeclaration(node.parent) || ts.isBindingElement(node.parent))) {
        const originalName = node.text;
        const collidingSymbols = collidingSymbolMap.get(originalName);
        // if the identifier name conflicts with a different identifier that we've already seen
        if (collidingSymbols && collidingSymbols.some(function(prevSymbol) {
              return prevSymbol !== symbol;
            })) {
          const newName = getNewNameIfConflict(node, collidingSymbolMap);
          identsToRenameMap.set(symbolIdString, newName.identifier);
          synthNamesMap.set(symbolIdString, newName);
          collidingSymbolMap.add(originalName, symbol);
        } else {
          const identifier = ts.getSynthesizedDeepClone(node);
          synthNamesMap.set(symbolIdString, createSynthIdentifier(identifier));
          collidingSymbolMap.add(originalName, symbol);
        }
      }
    }
  });
  return ts.getSynthesizedDeepCloneWithReplacements(nodeToRename, /* includeTrivia*/ true, function(original) {
    if (ts.isBindingElement(original) && ts.isIdentifier(original.name) && ts.isObjectBindingPattern(original.parent)) {
      var symbol = checker.getSymbolAtLocation(original.name);
      var renameInfo = symbol && identsToRenameMap.get(String(ts.getSymbolId(symbol)));
      if (renameInfo && renameInfo.text !== (original.name || original.propertyName).getText()) {
        return ts.factory.createBindingElement(
            original.dotDotDotToken, original.propertyName || original.name, renameInfo, original.initializer);
      }
    } else if (ts.isIdentifier(original)) {
      var symbol = checker.getSymbolAtLocation(original);
      var renameInfo = symbol && identsToRenameMap.get(String(ts.getSymbolId(symbol)));
      if (renameInfo) {
        return ts.factory.createIdentifier(renameInfo.text);
      }
    }
  });
}
function getNewNameIfConflict(name, originalNames) {
  const numVarsSameName = (originalNames.get(name.text) || ts.emptyArray).length;
  const identifier = numVarsSameName === 0 ? name : ts.factory.createIdentifier(name.text + '_' + numVarsSameName);
  return createSynthIdentifier(identifier);
}
function hasFailed() {
  return !codeActionSucceeded;
}
function silentFail() {
  codeActionSucceeded = false;
  return ts.emptyArray;
}
// dispatch function to recursively build the refactoring
// should be kept up to date with isFixablePromiseHandler in suggestionDiagnostics.ts
/**
 * @param hasContinuation Whether another `then`, `catch`, or `finally` continuation follows the continuation to which this expression belongs.
 * @param continuationArgName The argument name for the continuation that follows this call.
 */
function transformExpression(returnContextNode, node, transformer, hasContinuation, continuationArgName) {
  if (isPromiseReturningCallExpression(node, transformer.checker, 'then')) {
    return transformThen(
        node, ts.elementAt(node.arguments, 0), ts.elementAt(node.arguments, 1), transformer, hasContinuation,
        continuationArgName);
  }
  if (isPromiseReturningCallExpression(node, transformer.checker, 'catch')) {
    return transformCatch(node, ts.elementAt(node.arguments, 0), transformer, hasContinuation, continuationArgName);
  }
  if (isPromiseReturningCallExpression(node, transformer.checker, 'finally')) {
    return transformFinally(node, ts.elementAt(node.arguments, 0), transformer, hasContinuation, continuationArgName);
  }
  if (ts.isPropertyAccessExpression(node)) {
    return transformExpression(returnContextNode, node.expression, transformer, hasContinuation, continuationArgName);
  }
  const nodeType = transformer.checker.getTypeAtLocation(node);
  if (nodeType && transformer.checker.getPromisedTypeOfPromise(nodeType)) {
    ts.Debug.assertNode(ts.getOriginalNode(node).parent, ts.isPropertyAccessExpression);
    return transformPromiseExpressionOfPropertyAccess(
        returnContextNode, node, transformer, hasContinuation, continuationArgName);
  }
  return silentFail();
}
function isNullOrUndefined(_a, node) {
  const checker = _a.checker;
  if (node.kind === 104 /* SyntaxKind.NullKeyword */)
    {return true;}
  if (ts.isIdentifier(node) && !ts.isGeneratedIdentifier(node) && ts.idText(node) === 'undefined') {
    const symbol = checker.getSymbolAtLocation(node);
    return !symbol || checker.isUndefinedSymbol(symbol);
  }
  return false;
}
function createUniqueSynthName(prevArgName) {
  const renamedPrevArg =
      ts.factory.createUniqueName(prevArgName.identifier.text, 16 /* GeneratedIdentifierFlags.Optimistic */);
  return createSynthIdentifier(renamedPrevArg);
}
function getPossibleNameForVarDecl(node, transformer, continuationArgName) {
  let possibleNameForVarDecl;
  // If there is another call in the chain after the .catch() or .finally() we are transforming, we will need to save the result of both paths
  // (try block and catch/finally block). To do this, we will need to synthesize a variable that we were not aware of while we were adding
  // identifiers to the synthNamesMap. We will use the continuationArgName and then update the synthNamesMap with a new variable name for
  // the next transformation step
  if (continuationArgName && !shouldReturn(node, transformer)) {
    if (isSynthIdentifier(continuationArgName)) {
      possibleNameForVarDecl = continuationArgName;
      transformer.synthNamesMap.forEach(function(val, key) {
        if (val.identifier.text === continuationArgName.identifier.text) {
          const newSynthName = createUniqueSynthName(continuationArgName);
          transformer.synthNamesMap.set(key, newSynthName);
        }
      });
    } else {
      possibleNameForVarDecl = createSynthIdentifier(
          ts.factory.createUniqueName('result', 16 /* GeneratedIdentifierFlags.Optimistic */),
          continuationArgName.types);
    }
    // We are about to write a 'let' variable declaration, but `transformExpression` for both
    // the try block and catch/finally block will assign to this name. Setting this flag indicates
    // that future assignments should be written as `name = value` instead of `const name = value`.
    declareSynthIdentifier(possibleNameForVarDecl);
  }
  return possibleNameForVarDecl;
}
function finishCatchOrFinallyTransform(node, transformer, tryStatement, possibleNameForVarDecl, continuationArgName) {
  const statements = [];
  // In order to avoid an implicit any, we will synthesize a type for the declaration using the unions of the types of both paths (try block and catch block)
  let varDeclIdentifier;
  if (possibleNameForVarDecl && !shouldReturn(node, transformer)) {
    varDeclIdentifier = ts.getSynthesizedDeepClone(declareSynthIdentifier(possibleNameForVarDecl));
    const typeArray = possibleNameForVarDecl.types;
    const unionType = transformer.checker.getUnionType(typeArray, 2 /* UnionReduction.Subtype */);
    const unionTypeNode = transformer.isInJSFile ?
        undefined :
        transformer.checker.typeToTypeNode(unionType, /* enclosingDeclaration*/ undefined, /* flags*/ undefined);
    const varDecl =
        [ts.factory.createVariableDeclaration(varDeclIdentifier, /* exclamationToken*/ undefined, unionTypeNode)];
    const varDeclList = ts.factory.createVariableStatement(
        /* modifiers*/ undefined, ts.factory.createVariableDeclarationList(varDecl, 1 /* NodeFlags.Let */));
    statements.push(varDeclList);
  }
  statements.push(tryStatement);
  if (continuationArgName && varDeclIdentifier && isSynthBindingPattern(continuationArgName)) {
    statements.push(ts.factory.createVariableStatement(
        /* modifiers*/ undefined,
        ts.factory.createVariableDeclarationList(
            [ts.factory.createVariableDeclaration(
                ts.getSynthesizedDeepClone(declareSynthBindingPattern(continuationArgName)),
                /* exclamationToken*/ undefined,
                /* type*/ undefined, varDeclIdentifier)],
            2 /* NodeFlags.Const */)));
  }
  return statements;
}
/**
 * @param hasContinuation Whether another `then`, `catch`, or `finally` continuation follows this continuation.
 * @param continuationArgName The argument name for the continuation that follows this call.
 */
function transformFinally(node, onFinally, transformer, hasContinuation, continuationArgName) {
  if (!onFinally || isNullOrUndefined(transformer, onFinally)) {
    // Ignore this call as it has no effect on the result
    return transformExpression(/* returnContextNode */ node, node.expression.expression, transformer, hasContinuation,
                               continuationArgName);
  }
  const possibleNameForVarDecl = getPossibleNameForVarDecl(node, transformer, continuationArgName);
  // Transform the left-hand-side of `.finally` into an array of inlined statements. We pass `true` for hasContinuation as `node` is the outer continuation.
  const inlinedLeftHandSide = transformExpression(/* returnContextNode*/ node, node.expression.expression, transformer,
                                                /* hasContinuation*/ true, possibleNameForVarDecl);
  if (hasFailed())
    {return silentFail();}  // shortcut out of more work
  // Transform the callback argument into an array of inlined statements. We pass whether we have an outer continuation here
  // as that indicates whether `return` is valid.
  const inlinedCallback = transformCallbackArgument(
      onFinally, hasContinuation, /* continuationArgName*/ undefined, /* argName*/ undefined, node, transformer);
  if (hasFailed())
    {return silentFail();}  // shortcut out of more work
  const tryBlock = ts.factory.createBlock(inlinedLeftHandSide);
  const finallyBlock = ts.factory.createBlock(inlinedCallback);
  const tryStatement = ts.factory.createTryStatement(tryBlock, /* catchClause*/ undefined, finallyBlock);
  return finishCatchOrFinallyTransform(node, transformer, tryStatement, possibleNameForVarDecl, continuationArgName);
}
/**
 * @param hasContinuation Whether another `then`, `catch`, or `finally` continuation follows this continuation.
 * @param continuationArgName The argument name for the continuation that follows this call.
 */
function transformCatch(node, onRejected, transformer, hasContinuation, continuationArgName) {
  if (!onRejected || isNullOrUndefined(transformer, onRejected)) {
    // Ignore this call as it has no effect on the result
    return transformExpression(/* returnContextNode */ node, node.expression.expression, transformer, hasContinuation,
                               continuationArgName);
  }
  const inputArgName = getArgBindingName(onRejected, transformer);
  const possibleNameForVarDecl = getPossibleNameForVarDecl(node, transformer, continuationArgName);
  // Transform the left-hand-side of `.then`/`.catch` into an array of inlined statements. We pass `true` for hasContinuation as `node` is the outer continuation.
  const inlinedLeftHandSide = transformExpression(/* returnContextNode*/ node, node.expression.expression, transformer,
                                                /* hasContinuation*/ true, possibleNameForVarDecl);
  if (hasFailed())
    {return silentFail();}  // shortcut out of more work
  // Transform the callback argument into an array of inlined statements. We pass whether we have an outer continuation here
  // as that indicates whether `return` is valid.
  const inlinedCallback =
      transformCallbackArgument(onRejected, hasContinuation, possibleNameForVarDecl, inputArgName, node, transformer);
  if (hasFailed())
    {return silentFail();}  // shortcut out of more work
  const tryBlock = ts.factory.createBlock(inlinedLeftHandSide);
  const catchClause = ts.factory.createCatchClause(
      inputArgName && ts.getSynthesizedDeepClone(declareSynthBindingName(inputArgName)),
      ts.factory.createBlock(inlinedCallback));
  const tryStatement = ts.factory.createTryStatement(tryBlock, catchClause, /* finallyBlock*/ undefined);
  return finishCatchOrFinallyTransform(node, transformer, tryStatement, possibleNameForVarDecl, continuationArgName);
}
/**
 * @param hasContinuation Whether another `then`, `catch`, or `finally` continuation follows this continuation.
 * @param continuationArgName The argument name for the continuation that follows this call.
 */
function transformThen(node, onFulfilled, onRejected, transformer, hasContinuation, continuationArgName) {
  if (!onFulfilled || isNullOrUndefined(transformer, onFulfilled)) {
    // If we don't have an `onfulfilled` callback, try treating this as a `.catch`.
    return transformCatch(node, onRejected, transformer, hasContinuation, continuationArgName);
  }
  // We don't currently support transforming a `.then` with both onfulfilled and onrejected handlers, per GH#38152.
  if (onRejected && !isNullOrUndefined(transformer, onRejected)) {
    return silentFail();
  }
  const inputArgName = getArgBindingName(onFulfilled, transformer);
  // Transform the left-hand-side of `.then` into an array of inlined statements. We pass `true` for hasContinuation as `node` is the outer continuation.
  const inlinedLeftHandSide = transformExpression(
      node.expression.expression, node.expression.expression, transformer, /* hasContinuation*/ true, inputArgName);
  if (hasFailed())
    {return silentFail();}  // shortcut out of more work
  // Transform the callback argument into an array of inlined statements. We pass whether we have an outer continuation here
  // as that indicates whether `return` is valid.
  const inlinedCallback =
      transformCallbackArgument(onFulfilled, hasContinuation, continuationArgName, inputArgName, node, transformer);
  if (hasFailed())
    {return silentFail();}  // shortcut out of more work
  return ts.concatenate(inlinedLeftHandSide, inlinedCallback);
}
/**
 * Transforms the 'x' part of `x.then(...)`, or the 'y()' part of `y().catch(...)`, where 'x' and 'y()' are Promises.
 */
function transformPromiseExpressionOfPropertyAccess(
    returnContextNode, node, transformer, hasContinuation, continuationArgName) {
  if (shouldReturn(returnContextNode, transformer)) {
    let returnValue = ts.getSynthesizedDeepClone(node);
    if (hasContinuation) {
      returnValue = ts.factory.createAwaitExpression(returnValue);
    }
    return [ts.factory.createReturnStatement(returnValue)];
  }
  return createVariableOrAssignmentOrExpressionStatement(
      continuationArgName, ts.factory.createAwaitExpression(node), /* typeAnnotation*/ undefined);
}
function createVariableOrAssignmentOrExpressionStatement(variableName, rightHandSide, typeAnnotation) {
  if (!variableName || isEmptyBindingName(variableName)) {
    // if there's no argName to assign to, there still might be side effects
    return [ts.factory.createExpressionStatement(rightHandSide)];
  }
  if (isSynthIdentifier(variableName) && variableName.hasBeenDeclared) {
    // if the variable has already been declared, we don't need "let" or "const"
    return [ts.factory.createExpressionStatement(ts.factory.createAssignment(
        ts.getSynthesizedDeepClone(referenceSynthIdentifier(variableName)), rightHandSide))];
  }
  return [ts.factory.createVariableStatement(
      /* modifiers*/ undefined,
      ts.factory.createVariableDeclarationList(
          [ts.factory.createVariableDeclaration(
              ts.getSynthesizedDeepClone(declareSynthBindingName(variableName)),
              /* exclamationToken*/ undefined, typeAnnotation, rightHandSide)],
          2 /* NodeFlags.Const */))];
}
function maybeAnnotateAndReturn(expressionToReturn, typeAnnotation) {
  if (typeAnnotation && expressionToReturn) {
    const name = ts.factory.createUniqueName('result', 16 /* GeneratedIdentifierFlags.Optimistic */);
    return __spreadArray(
        __spreadArray(
            [],
            createVariableOrAssignmentOrExpressionStatement(
                createSynthIdentifier(name), expressionToReturn, typeAnnotation),
            true),
        [ts.factory.createReturnStatement(name)], false);
  }
  return [ts.factory.createReturnStatement(expressionToReturn)];
}
// should be kept up to date with isFixablePromiseArgument in suggestionDiagnostics.ts
/**
 * @param hasContinuation Whether another `then`, `catch`, or `finally` continuation follows the continuation to which this callback belongs.
 * @param continuationArgName The argument name for the continuation that follows this call.
 * @param inputArgName The argument name provided to this call
 */
function transformCallbackArgument(func, hasContinuation, continuationArgName, inputArgName, parent, transformer) {
  let _a;
  switch (func.kind) {
    case 104 /* SyntaxKind.NullKeyword */:
      // do not produce a transformed statement for a null argument
      break;
    case 208 /* SyntaxKind.PropertyAccessExpression */:
    case 79 /* SyntaxKind.Identifier */:  // identifier includes undefined
      if (!inputArgName) {
        // undefined was argument passed to promise handler
        break;
      }
      var synthCall = ts.factory.createCallExpression(
          ts.getSynthesizedDeepClone(func), /* typeArguments*/ undefined,
          isSynthIdentifier(inputArgName) ? [referenceSynthIdentifier(inputArgName)] : []);
      if (shouldReturn(parent, transformer)) {
        return maybeAnnotateAndReturn(
            synthCall, getExplicitPromisedTypeOfPromiseReturningCallExpression(parent, func, transformer.checker));
      }
      var type = transformer.checker.getTypeAtLocation(func);
      var callSignatures = transformer.checker.getSignaturesOfType(type, 0 /* SignatureKind.Call */);
      if (!callSignatures.length) {
        // if identifier in handler has no call signatures, it's invalid
        return silentFail();
      }
      var returnType = callSignatures[0].getReturnType();
      var varDeclOrAssignment = createVariableOrAssignmentOrExpressionStatement(
          continuationArgName, ts.factory.createAwaitExpression(synthCall),
          getExplicitPromisedTypeOfPromiseReturningCallExpression(parent, func, transformer.checker));
      if (continuationArgName) {
        continuationArgName.types.push(transformer.checker.getAwaitedType(returnType) || returnType);
      }
      return varDeclOrAssignment;
    case 215 /* SyntaxKind.FunctionExpression */:
    case 216 /* SyntaxKind.ArrowFunction */: {
      const funcBody = func.body;
      const returnType_1 =
          (_a = getLastCallSignature(transformer.checker.getTypeAtLocation(func), transformer.checker)) === null ||
              _a === void 0 ?
          void 0 :
          _a.getReturnType();
      // Arrow functions with block bodies { } will enter this control flow
      if (ts.isBlock(funcBody)) {
        let refactoredStmts = [];
        let seenReturnStatement = false;
        for (let _i = 0, _b = funcBody.statements; _i < _b.length; _i++) {
          const statement = _b[_i];
          if (ts.isReturnStatement(statement)) {
            seenReturnStatement = true;
            if (ts.isReturnStatementWithFixablePromiseHandler(statement, transformer.checker)) {
              refactoredStmts = refactoredStmts.concat(transformReturnStatementWithFixablePromiseHandler(
                  transformer, statement, hasContinuation, continuationArgName));
            } else {
              var possiblyAwaitedRightHandSide = returnType_1 && statement.expression ?
                  getPossiblyAwaitedRightHandSide(transformer.checker, returnType_1, statement.expression) :
                  statement.expression;
              refactoredStmts.push.apply(
                  refactoredStmts,
                  maybeAnnotateAndReturn(
                      possiblyAwaitedRightHandSide,
                      getExplicitPromisedTypeOfPromiseReturningCallExpression(parent, func, transformer.checker)));
            }
          } else if (hasContinuation && ts.forEachReturnStatement(statement, ts.returnTrue)) {
            // If there is a nested `return` in a callback that has a trailing continuation, we don't transform it as the resulting complexity is too great. For example:
            //
            // source                               | result
            // -------------------------------------| ---------------------------------------
            // function f(): Promise<number> {      | async function f9(): Promise<number> {
            //     return foo().then(() => {        |     await foo();
            //         if (Math.random()) {         |     if (Math.random()) {
            //             return 1;                |         return 1; // incorrect early return
            //         }                            |     }
            //         return 2;                    |     return 2; // incorrect early return
            //     }).then(a => {                   |     const a = undefined;
            //         return a + 1;                |     return a + 1;
            //     });                              | }
            // }                                    |
            //
            // However, branching returns in the outermost continuation are acceptable as no other continuation follows it:
            //
            // source                               | result
            // --------------------------------------|---------------------------------------
            // function f() {                       | async function f() {
            //     return foo().then(res => {       |     const res = await foo();
            //       if (res.ok) {                  |     if (res.ok) {
            //         return 1;                    |         return 1;
            //       }                              |     }
            //       else {                         |     else {
            //         if (res.buffer.length > 5) { |         if (res.buffer.length > 5) {
            //           return 2;                  |             return 2;
            //         }                            |         }
            //         else {                       |         else {
            //             return 3;                |             return 3;
            //         }                            |         }
            //       }                              |     }
            //     });                              | }
            // }                                    |
            //
            // We may improve this in the future, but for now the heuristics are too complex
            return silentFail();
          } else {
            refactoredStmts.push(statement);
          }
        }
        return shouldReturn(parent, transformer) ?
            refactoredStmts.map(function(s) {
              return ts.getSynthesizedDeepClone(s);
            }) :
            removeReturns(refactoredStmts, continuationArgName, transformer, seenReturnStatement);
      }
        const inlinedStatements = ts.isFixablePromiseHandler(funcBody, transformer.checker) ?
            transformReturnStatementWithFixablePromiseHandler(
                transformer, ts.factory.createReturnStatement(funcBody), hasContinuation, continuationArgName) :
            ts.emptyArray;
        if (inlinedStatements.length > 0) {
          return inlinedStatements;
        }
        if (returnType_1) {
          var possiblyAwaitedRightHandSide =
              getPossiblyAwaitedRightHandSide(transformer.checker, returnType_1, funcBody);
          if (!shouldReturn(parent, transformer)) {
            const transformedStatement = createVariableOrAssignmentOrExpressionStatement(
                continuationArgName, possiblyAwaitedRightHandSide, /* typeAnnotation*/ undefined);
            if (continuationArgName) {
              continuationArgName.types.push(transformer.checker.getAwaitedType(returnType_1) || returnType_1);
            }
            return transformedStatement;
          }
            return maybeAnnotateAndReturn(
                possiblyAwaitedRightHandSide,
                getExplicitPromisedTypeOfPromiseReturningCallExpression(parent, func, transformer.checker));

        }
          return silentFail();

    }
    default:
      // If no cases apply, we've found a transformation body we don't know how to handle, so the refactoring should no-op to avoid deleting code.
      return silentFail();
  }
  return ts.emptyArray;
}
function getPossiblyAwaitedRightHandSide(checker, type, expr) {
  const rightHandSide = ts.getSynthesizedDeepClone(expr);
  return !!checker.getPromisedTypeOfPromise(type) ? ts.factory.createAwaitExpression(rightHandSide) : rightHandSide;
}
function getLastCallSignature(type, checker) {
  const callSignatures = checker.getSignaturesOfType(type, 0 /* SignatureKind.Call */);
  return ts.lastOrUndefined(callSignatures);
}
function removeReturns(stmts, prevArgName, transformer, seenReturnStatement) {
  const ret = [];
  for (let _i = 0, stmts_1 = stmts; _i < stmts_1.length; _i++) {
    const stmt = stmts_1[_i];
    if (ts.isReturnStatement(stmt)) {
      if (stmt.expression) {
        const possiblyAwaitedExpression = isPromiseTypedExpression(stmt.expression, transformer.checker) ?
            ts.factory.createAwaitExpression(stmt.expression) :
            stmt.expression;
        if (prevArgName === undefined) {
          ret.push(ts.factory.createExpressionStatement(possiblyAwaitedExpression));
        } else if (isSynthIdentifier(prevArgName) && prevArgName.hasBeenDeclared) {
          ret.push(ts.factory.createExpressionStatement(
              ts.factory.createAssignment(referenceSynthIdentifier(prevArgName), possiblyAwaitedExpression)));
        } else {
          ret.push(ts.factory.createVariableStatement(
              /* modifiers*/ undefined,
              (ts.factory.createVariableDeclarationList(
                  [ts.factory.createVariableDeclaration(
                      declareSynthBindingName(prevArgName), /* exclamationToken*/ undefined, /* type*/ undefined,
                      possiblyAwaitedExpression)],
                  2 /* NodeFlags.Const */))));
        }
      }
    } else {
      ret.push(ts.getSynthesizedDeepClone(stmt));
    }
  }
  // if block has no return statement, need to define prevArgName as undefined to prevent undeclared variables
  if (!seenReturnStatement && prevArgName !== undefined) {
    ret.push(
        ts.factory.createVariableStatement(/* modifiers*/ undefined,
                                           (ts.factory.createVariableDeclarationList(
                                               [ts.factory.createVariableDeclaration(
                                                   declareSynthBindingName(prevArgName), /* exclamationToken*/ undefined,
                                                   /* type*/ undefined, ts.factory.createIdentifier('undefined'))],
                                               2 /* NodeFlags.Const */))));
  }
  return ret;
}
/**
 * @param hasContinuation Whether another `then`, `catch`, or `finally` continuation follows the continuation to which this statement belongs.
 * @param continuationArgName The argument name for the continuation that follows this call.
 */
function transformReturnStatementWithFixablePromiseHandler(
    transformer, innerRetStmt, hasContinuation, continuationArgName) {
  let innerCbBody = [];
  ts.forEachChild(innerRetStmt, function visit(node) {
    if (ts.isCallExpression(node)) {
      const temp = transformExpression(node, node, transformer, hasContinuation, continuationArgName);
      innerCbBody = innerCbBody.concat(temp);
      if (innerCbBody.length > 0) {
        return;
      }
    } else if (!ts.isFunctionLike(node)) {
      ts.forEachChild(node, visit);
    }
  });
  return innerCbBody;
}
function getArgBindingName(funcNode, transformer) {
  const types = [];
  let name;
  if (ts.isFunctionLikeDeclaration(funcNode)) {
    if (funcNode.parameters.length > 0) {
      const param = funcNode.parameters[0].name;
      name = getMappedBindingNameOrDefault(param);
    }
  } else if (ts.isIdentifier(funcNode)) {
    name = getMapEntryOrDefault(funcNode);
  } else if (ts.isPropertyAccessExpression(funcNode) && ts.isIdentifier(funcNode.name)) {
    name = getMapEntryOrDefault(funcNode.name);
  }
  // return undefined argName when arg is null or undefined
  // eslint-disable-next-line local/no-in-operator
  if (!name || 'identifier' in name && name.identifier.text === 'undefined') {
    return undefined;
  }
  return name;
  function getMappedBindingNameOrDefault(bindingName) {
    if (ts.isIdentifier(bindingName))
      {return getMapEntryOrDefault(bindingName);}
    const elements = ts.flatMap(bindingName.elements, function(element) {
      if (ts.isOmittedExpression(element))
        {return [];}
      return [getMappedBindingNameOrDefault(element.name)];
    });
    return createSynthBindingPattern(bindingName, elements);
  }
  function getMapEntryOrDefault(identifier) {
    const originalNode = getOriginalNode(identifier);
    const symbol = getSymbol(originalNode);
    if (!symbol) {
      return createSynthIdentifier(identifier, types);
    }
    const mapEntry = transformer.synthNamesMap.get(ts.getSymbolId(symbol).toString());
    return mapEntry || createSynthIdentifier(identifier, types);
  }
  function getSymbol(node) {
    return node.symbol ? node.symbol : transformer.checker.getSymbolAtLocation(node);
  }
  function getOriginalNode(node) {
    return node.original ? node.original : node;
  }
}
function isEmptyBindingName(bindingName) {
  if (!bindingName) {
    return true;
  }
  if (isSynthIdentifier(bindingName)) {
    return !bindingName.identifier.text;
  }
  return ts.every(bindingName.elements, isEmptyBindingName);
}
function createSynthIdentifier(identifier, types) {
  if (types === void 0) {
    types = [];
  }
  return {
    kind: 0 /* SynthBindingNameKind.Identifier */,
    identifier,
    types,
    hasBeenDeclared: false,
    hasBeenReferenced: false
  };
}
function createSynthBindingPattern(bindingPattern, elements, types) {
  if (elements === void 0) {
    elements = ts.emptyArray;
  }
  if (types === void 0) {
    types = [];
  }
  return {
    kind: 1 /* SynthBindingNameKind.BindingPattern */,
    bindingPattern,
    elements,
    types
  };
}
function referenceSynthIdentifier(synthId) {
  synthId.hasBeenReferenced = true;
  return synthId.identifier;
}
function declareSynthBindingName(synthName) {
  return isSynthIdentifier(synthName) ? declareSynthIdentifier(synthName) : declareSynthBindingPattern(synthName);
}
function declareSynthBindingPattern(synthPattern) {
  for (let _i = 0, _a = synthPattern.elements; _i < _a.length; _i++) {
    const element = _a[_i];
    declareSynthBindingName(element);
  }
  return synthPattern.bindingPattern;
}
function declareSynthIdentifier(synthId) {
  synthId.hasBeenDeclared = true;
  return synthId.identifier;
}
function isSynthIdentifier(bindingName) {
  return bindingName.kind === 0 /* SynthBindingNameKind.Identifier */;
}
function isSynthBindingPattern(bindingName) {
  return bindingName.kind === 1 /* SynthBindingNameKind.BindingPattern */;
}
function shouldReturn(expression, transformer) {
  return !!expression.original && transformer.setOfExpressionsToReturn.has(ts.getNodeId(expression.original));
}
})(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let codefix;
(function(codefix) {
codefix.registerCodeFix({
  errorCodes: [ts.Diagnostics.File_is_a_CommonJS_module_it_may_be_converted_to_an_ES_module.code],
  getCodeActions: function(context) {
    const sourceFile = context.sourceFile, program = context.program, preferences = context.preferences;
    const changes = ts.textChanges.ChangeTracker.with(context, function(changes) {
      const moduleExportsChangedToDefault = convertFileToEsModule(
          sourceFile, program.getTypeChecker(), changes, ts.getEmitScriptTarget(program.getCompilerOptions()),
          ts.getQuotePreference(sourceFile, preferences));
      if (moduleExportsChangedToDefault) {
        for (let _i = 0, _a = program.getSourceFiles(); _i < _a.length; _i++) {
          const importingFile = _a[_i];
          fixImportOfModuleExports(
              importingFile, sourceFile, changes, ts.getQuotePreference(importingFile, preferences));
        }
      }
    });
    // No support for fix-all since this applies to the whole file at once anyway.
    return [codefix.createCodeFixActionWithoutFixAll(
        'convertToEsModule', changes, ts.Diagnostics.Convert_to_ES_module)];
  },
});
function fixImportOfModuleExports(importingFile, exportingFile, changes, quotePreference) {
  for (let _i = 0, _a = importingFile.imports; _i < _a.length; _i++) {
    const moduleSpecifier = _a[_i];
    const imported = ts.getResolvedModule(
        importingFile, moduleSpecifier.text, ts.getModeForUsageLocation(importingFile, moduleSpecifier));
    if (!imported || imported.resolvedFileName !== exportingFile.fileName) {
      continue;
    }
    const importNode = ts.importFromModuleSpecifier(moduleSpecifier);
    switch (importNode.kind) {
      case 268 /* SyntaxKind.ImportEqualsDeclaration */:
        changes.replaceNode(
            importingFile, importNode,
            ts.makeImport(importNode.name, /* namedImports*/ undefined, moduleSpecifier, quotePreference));
        break;
      case 210 /* SyntaxKind.CallExpression */:
        if (ts.isRequireCall(importNode, /* checkArgumentIsStringLiteralLike*/ false)) {
          changes.replaceNode(
              importingFile, importNode,
              ts.factory.createPropertyAccessExpression(ts.getSynthesizedDeepClone(importNode), 'default'));
        }
        break;
    }
  }
}
/** @returns Whether we converted a `module.exports =` to a default export. */
function convertFileToEsModule(sourceFile, checker, changes, target, quotePreference) {
  const identifiers = {original: collectFreeIdentifiers(sourceFile), additional: new ts.Set()};
  const exports = collectExportRenames(sourceFile, checker, identifiers);
  convertExportsAccesses(sourceFile, exports, changes);
  let moduleExportsChangedToDefault = false;
  let useSitesToUnqualify;
  // Process variable statements first to collect use sites that need to be updated inside other transformations
  for (let _i = 0, _a = ts.filter(sourceFile.statements, ts.isVariableStatement); _i < _a.length; _i++) {
    var statement = _a[_i];
    const newUseSites =
        convertVariableStatement(sourceFile, statement, changes, checker, identifiers, target, quotePreference);
    if (newUseSites) {
      ts.copyEntries(
          newUseSites,
          useSitesToUnqualify !== null && useSitesToUnqualify !== void 0 ? useSitesToUnqualify :
                                                                           (useSitesToUnqualify = new ts.Map()));
    }
  }
  // `convertStatement` will delete entries from `useSitesToUnqualify` when containing statements are replaced
  for (let _b = 0, _c = ts.filter(sourceFile.statements, function(s) {
         return !ts.isVariableStatement(s);
       }); _b < _c.length; _b++) {
    var statement = _c[_b];
    const moduleExportsChanged = convertStatement(
        sourceFile, statement, checker, changes, identifiers, target, exports, useSitesToUnqualify, quotePreference);
    moduleExportsChangedToDefault = moduleExportsChangedToDefault || moduleExportsChanged;
  }
  // Remaining use sites can be changed directly
  useSitesToUnqualify === null || useSitesToUnqualify === void 0 ?
      void 0 :
      useSitesToUnqualify.forEach(function(replacement, original) {
        changes.replaceNode(sourceFile, original, replacement);
      });
  return moduleExportsChangedToDefault;
}
function collectExportRenames(sourceFile, checker, identifiers) {
  const res = new ts.Map();
  forEachExportReference(sourceFile, function(node) {
    const _a = node.name, text = _a.text, originalKeywordKind = _a.originalKeywordKind;
    if (!res.has(text) &&
        (originalKeywordKind !== undefined && ts.isNonContextualKeyword(originalKeywordKind) ||
         checker.resolveName(text, node, 111551 /* SymbolFlags.Value */, /* excludeGlobals*/ true))) {
      // Unconditionally add an underscore in case `text` is a keyword.
      res.set(text, makeUniqueName('_'.concat(text), identifiers));
    }
  });
  return res;
}
function convertExportsAccesses(sourceFile, exports, changes) {
  forEachExportReference(sourceFile, function(node, isAssignmentLhs) {
    if (isAssignmentLhs) {
      return;
    }
    const text = node.name.text;
    changes.replaceNode(sourceFile, node, ts.factory.createIdentifier(exports.get(text) || text));
  });
}
function forEachExportReference(sourceFile, cb) {
  sourceFile.forEachChild(function recur(node) {
    if (ts.isPropertyAccessExpression(node) && ts.isExportsOrModuleExportsOrAlias(sourceFile, node.expression) &&
        ts.isIdentifier(node.name)) {
      const parent = node.parent;
      cb(node,
         ts.isBinaryExpression(parent) && parent.left === node &&
             parent.operatorToken.kind === 63 /* SyntaxKind.EqualsToken */);
    }
    node.forEachChild(recur);
  });
}
function convertStatement(
    sourceFile, statement, checker, changes, identifiers, target, exports, useSitesToUnqualify, quotePreference) {
  switch (statement.kind) {
    case 240 /* SyntaxKind.VariableStatement */:
      convertVariableStatement(sourceFile, statement, changes, checker, identifiers, target, quotePreference);
      return false;
    case 241 /* SyntaxKind.ExpressionStatement */: {
      const expression = statement.expression;
      switch (expression.kind) {
        case 210 /* SyntaxKind.CallExpression */: {
          if (ts.isRequireCall(expression, /* checkArgumentIsStringLiteralLike*/ true)) {
            // For side-effecting require() call, just make a side-effecting import.
            changes.replaceNode(
                sourceFile, statement,
                ts.makeImport(/* name*/ undefined, /* namedImports*/ undefined, expression.arguments[0],
                              quotePreference));
          }
          return false;
        }
        case 223 /* SyntaxKind.BinaryExpression */: {
          const operatorToken = expression.operatorToken;
          return operatorToken.kind === 63 /* SyntaxKind.EqualsToken */ &&
              convertAssignment(sourceFile, checker, expression, changes, exports, useSitesToUnqualify);
        }
      }
    }
    // falls through
    default:
      return false;
  }
}
function convertVariableStatement(sourceFile, statement, changes, checker, identifiers, target, quotePreference) {
  const declarationList = statement.declarationList;
  let foundImport = false;
  const converted = ts.map(declarationList.declarations, function(decl) {
    const name = decl.name, initializer = decl.initializer;
    if (initializer) {
      if (ts.isExportsOrModuleExportsOrAlias(sourceFile, initializer)) {
        // `const alias = module.exports;` can be removed.
        foundImport = true;
        return convertedImports([]);
      } if (ts.isRequireCall(initializer, /* checkArgumentIsStringLiteralLike*/ true)) {
        foundImport = true;
        return convertSingleImport(name, initializer.arguments[0], checker, identifiers, target, quotePreference);
      } if (
          ts.isPropertyAccessExpression(initializer) &&
          ts.isRequireCall(initializer.expression, /* checkArgumentIsStringLiteralLike*/ true)) {
        foundImport = true;
        return convertPropertyAccessImport(
            name, initializer.name.text, initializer.expression.arguments[0], identifiers, quotePreference);
      }
    }
    // Move it out to its own variable statement. (This will not be used if `!foundImport`)
    return convertedImports([ts.factory.createVariableStatement(
        /* modifiers*/ undefined, ts.factory.createVariableDeclarationList([decl], declarationList.flags))]);
  });
  if (foundImport) {
    // useNonAdjustedEndPosition to ensure we don't eat the newline after the statement.
    changes.replaceNodeWithNodes(sourceFile, statement, ts.flatMap(converted, function(c) {
      return c.newImports;
    }));
    let combinedUseSites_1;
    ts.forEach(converted, function(c) {
      if (c.useSitesToUnqualify) {
        ts.copyEntries(
            c.useSitesToUnqualify,
            combinedUseSites_1 !== null && combinedUseSites_1 !== void 0 ? combinedUseSites_1 :
                                                                           (combinedUseSites_1 = new ts.Map()));
      }
    });
    return combinedUseSites_1;
  }
}
/** Converts `const name = require("moduleSpecifier").propertyName` */
function convertPropertyAccessImport(name, propertyName, moduleSpecifier, identifiers, quotePreference) {
  switch (name.kind) {
    case 203 /* SyntaxKind.ObjectBindingPattern */:
    case 204 /* SyntaxKind.ArrayBindingPattern */: {
      // `const [a, b] = require("c").d` --> `import { d } from "c"; const [a, b] = d;`
      const tmp = makeUniqueName(propertyName, identifiers);
      return convertedImports([
        makeSingleImport(tmp, propertyName, moduleSpecifier, quotePreference),
        makeConst(/* modifiers*/ undefined, name, ts.factory.createIdentifier(tmp)),
      ]);
    }
    case 79 /* SyntaxKind.Identifier */:
      // `const a = require("b").c` --> `import { c as a } from "./b";
      return convertedImports([makeSingleImport(name.text, propertyName, moduleSpecifier, quotePreference)]);
    default:
      return ts.Debug.assertNever(name, 'Convert to ES module got invalid syntax form '.concat(name.kind));
  }
}
function convertAssignment(sourceFile, checker, assignment, changes, exports, useSitesToUnqualify) {
  const left = assignment.left, right = assignment.right;
  if (!ts.isPropertyAccessExpression(left)) {
    return false;
  }
  if (ts.isExportsOrModuleExportsOrAlias(sourceFile, left)) {
    if (ts.isExportsOrModuleExportsOrAlias(sourceFile, right)) {
      // `const alias = module.exports;` or `module.exports = alias;` can be removed.
      changes.delete(sourceFile, assignment.parent);
    } else {
      const replacement = ts.isObjectLiteralExpression(right) ? tryChangeModuleExportsObject(right, useSitesToUnqualify) :
          ts.isRequireCall(right, /* checkArgumentIsStringLiteralLike*/ true) ?
                                                              convertReExportAll(right.arguments[0], checker) :
                                                              undefined;
      if (replacement) {
        changes.replaceNodeWithNodes(sourceFile, assignment.parent, replacement[0]);
        return replacement[1];
      }
        changes.replaceRangeWithText(
            sourceFile, ts.createRange(left.getStart(sourceFile), right.pos), 'export default');
        return true;

    }
  } else if (ts.isExportsOrModuleExportsOrAlias(sourceFile, left.expression)) {
    convertNamedExport(sourceFile, assignment, changes, exports);
  }
  return false;
}
/**
 * Convert `module.exports = { ... }` to individual exports..
 * We can't always do this if the module has interesting members -- then it will be a default export instead.
 */
function tryChangeModuleExportsObject(object, useSitesToUnqualify) {
  const statements = ts.mapAllOrFail(object.properties, function(prop) {
    switch (prop.kind) {
      case 174 /* SyntaxKind.GetAccessor */:
      case 175 /* SyntaxKind.SetAccessor */:
      // TODO: Maybe we should handle this? See fourslash test `refactorConvertToEs6Module_export_object_shorthand.ts`.
      // falls through
      case 300 /* SyntaxKind.ShorthandPropertyAssignment */:
      case 301 /* SyntaxKind.SpreadAssignment */:
        return undefined;
      case 299 /* SyntaxKind.PropertyAssignment */:
        return !ts.isIdentifier(prop.name) ?
            undefined :
            convertExportsDotXEquals_replaceNode(prop.name.text, prop.initializer, useSitesToUnqualify);
      case 171 /* SyntaxKind.MethodDeclaration */:
        return !ts.isIdentifier(prop.name) ?
            undefined :
            functionExpressionToDeclaration(
                prop.name.text, [ts.factory.createToken(93 /* SyntaxKind.ExportKeyword */)], prop, useSitesToUnqualify);
      default:
        ts.Debug.assertNever(prop, 'Convert to ES6 got invalid prop kind '.concat(prop.kind));
    }
  });
  return statements && [statements, false];
}
function convertNamedExport(sourceFile, assignment, changes, exports) {
  // If "originalKeywordKind" was set, this is e.g. `exports.
  const text = assignment.left.name.text;
  const rename = exports.get(text);
  if (rename !== undefined) {
    /*
                const _class = 0;
                export { _class as class };
                */
    const newNodes = [
      makeConst(/* modifiers*/ undefined, rename, assignment.right),
      makeExportDeclaration([ts.factory.createExportSpecifier(/* isTypeOnly*/ false, rename, text)]),
    ];
    changes.replaceNodeWithNodes(sourceFile, assignment.parent, newNodes);
  } else {
    convertExportsPropertyAssignment(assignment, sourceFile, changes);
  }
}
function convertReExportAll(reExported, checker) {
  // `module.exports = require("x");` ==> `export * from "x"; export { default } from "x";`
  const moduleSpecifier = reExported.text;
  const moduleSymbol = checker.getSymbolAtLocation(reExported);
  const exports = moduleSymbol ? moduleSymbol.exports : ts.emptyMap;
  return exports.has('export=' /* InternalSymbolName.ExportEquals */) ?
      [[reExportDefault(moduleSpecifier)], true] :
      !exports.has('default' /* InternalSymbolName.Default */) ?
      [[reExportStar(moduleSpecifier)], false] :
      // If there's some non-default export, must include both `export *` and `export default`.
      exports.size > 1 ? [[reExportStar(moduleSpecifier), reExportDefault(moduleSpecifier)], true] :
                         [[reExportDefault(moduleSpecifier)], true];
}
function reExportStar(moduleSpecifier) {
  return makeExportDeclaration(/* exportClause*/ undefined, moduleSpecifier);
}
function reExportDefault(moduleSpecifier) {
  return makeExportDeclaration(
      [ts.factory.createExportSpecifier(/* isTypeOnly*/ false, /* propertyName*/ undefined, 'default')], moduleSpecifier);
}
function convertExportsPropertyAssignment(_a, sourceFile, changes) {
  const left = _a.left, right = _a.right, parent = _a.parent;
  const name = left.name.text;
  if ((ts.isFunctionExpression(right) || ts.isArrowFunction(right) || ts.isClassExpression(right)) &&
      (!right.name || right.name.text === name)) {
    // `exports.f = function() {}` -> `export function f() {}` -- Replace `exports.f = ` with `export `, and insert the name after `function`.
    changes.replaceRange(
        sourceFile, {pos: left.getStart(sourceFile), end: right.getStart(sourceFile)},
        ts.factory.createToken(93 /* SyntaxKind.ExportKeyword */), {suffix: ' '});
    if (!right.name)
      {changes.insertName(sourceFile, right, name);}
    const semi = ts.findChildOfKind(parent, 26 /* SyntaxKind.SemicolonToken */, sourceFile);
    if (semi)
      {changes.delete(sourceFile, semi);}
  } else {
    // `exports.f = function g() {}` -> `export const f = function g() {}` -- just replace `exports.` with `export const `
    changes.replaceNodeRangeWithNodes(
        sourceFile, left.expression, ts.findChildOfKind(left, 24 /* SyntaxKind.DotToken */, sourceFile),
        [
          ts.factory.createToken(93 /* SyntaxKind.ExportKeyword */),
          ts.factory.createToken(85 /* SyntaxKind.ConstKeyword */)
        ],
        {joiner: ' ', suffix: ' '});
  }
}
// TODO: GH#22492 this will cause an error if a change has been made inside the body of the node.
function convertExportsDotXEquals_replaceNode(name, exported, useSitesToUnqualify) {
  const modifiers = [ts.factory.createToken(93 /* SyntaxKind.ExportKeyword */)];
  switch (exported.kind) {
    case 215 /* SyntaxKind.FunctionExpression */: {
      const expressionName = exported.name;
      if (expressionName && expressionName.text !== name) {
        // `exports.f = function g() {}` -> `export const f = function g() {}`
        return exportConst();
      }
    }
    // falls through
    case 216 /* SyntaxKind.ArrowFunction */:
      // `exports.f = function() {}` --> `export function f() {}`
      return functionExpressionToDeclaration(name, modifiers, exported, useSitesToUnqualify);
    case 228 /* SyntaxKind.ClassExpression */:
      // `exports.C = class {}` --> `export class C {}`
      return classExpressionToDeclaration(name, modifiers, exported, useSitesToUnqualify);
    default:
      return exportConst();
  }
  function exportConst() {
    // `exports.x = 0;` --> `export const x = 0;`
    return makeConst(
        modifiers, ts.factory.createIdentifier(name),
        replaceImportUseSites(exported, useSitesToUnqualify));  // TODO: GH#18217
  }
}
function replaceImportUseSites(nodeOrNodes, useSitesToUnqualify) {
  if (!useSitesToUnqualify || !ts.some(ts.arrayFrom(useSitesToUnqualify.keys()), function(original) {
        return ts.rangeContainsRange(nodeOrNodes, original);
      })) {
    return nodeOrNodes;
  }
  return ts.isArray(nodeOrNodes) ?
      ts.getSynthesizedDeepClonesWithReplacements(nodeOrNodes, /* includeTrivia*/ true, replaceNode) :
      ts.getSynthesizedDeepCloneWithReplacements(nodeOrNodes, /* includeTrivia*/ true, replaceNode);
  function replaceNode(original) {
    // We are replacing `mod.SomeExport` wih `SomeExport`, so we only need to look at PropertyAccessExpressions
    if (original.kind === 208 /* SyntaxKind.PropertyAccessExpression */) {
      const replacement = useSitesToUnqualify.get(original);
      // Remove entry from `useSitesToUnqualify` so the refactor knows it's taken care of by the parent statement we're replacing
      useSitesToUnqualify.delete(original);
      return replacement;
    }
  }
}
/**
 * Converts `const <<name>> = require("x");`.
 * Returns nodes that will replace the variable declaration for the commonjs import.
 * May also make use `changes` to remove qualifiers at the use sites of imports, to change `mod.x` to `x`.
 */
function convertSingleImport(name, moduleSpecifier, checker, identifiers, target, quotePreference) {
  switch (name.kind) {
    case 203 /* SyntaxKind.ObjectBindingPattern */: {
      const importSpecifiers = ts.mapAllOrFail(name.elements, function(e) {
        return e.dotDotDotToken || e.initializer || e.propertyName && !ts.isIdentifier(e.propertyName) ||
                !ts.isIdentifier(e.name) ?
            undefined :
            makeImportSpecifier(e.propertyName && e.propertyName.text, e.name.text);
      });
      if (importSpecifiers) {
        return convertedImports(
            [ts.makeImport(/* name*/ undefined, importSpecifiers, moduleSpecifier, quotePreference)]);
      }
    }
    // falls through -- object destructuring has an interesting pattern and must be a variable declaration
    case 204 /* SyntaxKind.ArrayBindingPattern */: {
      /*
                    import x from "x";
                    const [a, b, c] = x;
                    */
      const tmp = makeUniqueName(codefix.moduleSpecifierToValidIdentifier(moduleSpecifier.text, target), identifiers);
      return convertedImports([
        ts.makeImport(ts.factory.createIdentifier(tmp), /* namedImports*/ undefined, moduleSpecifier, quotePreference),
        makeConst(/* modifiers*/ undefined, ts.getSynthesizedDeepClone(name), ts.factory.createIdentifier(tmp)),
      ]);
    }
    case 79 /* SyntaxKind.Identifier */:
      return convertSingleIdentifierImport(name, moduleSpecifier, checker, identifiers, quotePreference);
    default:
      return ts.Debug.assertNever(name, 'Convert to ES module got invalid name kind '.concat(name.kind));
  }
}
/**
 * Convert `import x = require("x").`
 * Also:
 * - Convert `x.default()` to `x()` to handle ES6 default export
 * - Converts uses like `x.y()` to `y()` and uses a named import.
 */
function convertSingleIdentifierImport(name, moduleSpecifier, checker, identifiers, quotePreference) {
  const nameSymbol = checker.getSymbolAtLocation(name);
  // Maps from module property name to name actually used. (The same if there isn't shadowing.)
  const namedBindingsNames = new ts.Map();
  // True if there is some non-property use like `x()` or `f(x)`.
  let needDefaultImport = false;
  let useSitesToUnqualify;
  for (let _i = 0, _a = identifiers.original.get(name.text); _i < _a.length; _i++) {
    const use = _a[_i];
    if (checker.getSymbolAtLocation(use) !== nameSymbol || use === name) {
      // This was a use of a different symbol with the same name, due to shadowing. Ignore.
      continue;
    }
    const parent = use.parent;
    if (ts.isPropertyAccessExpression(parent)) {
      const propertyName = parent.name.text;
      if (propertyName === 'default') {
        needDefaultImport = true;
        const importDefaultName = use.getText();
        (useSitesToUnqualify !== null && useSitesToUnqualify !== void 0 ? useSitesToUnqualify :
                                                                          (useSitesToUnqualify = new ts.Map()))
            .set(parent, ts.factory.createIdentifier(importDefaultName));
      } else {
        ts.Debug.assert(
            parent.expression === use,
            'Didn\'t expect expression === use');  // Else shouldn't have been in `collectIdentifiers`
        let idName = namedBindingsNames.get(propertyName);
        if (idName === undefined) {
          idName = makeUniqueName(propertyName, identifiers);
          namedBindingsNames.set(propertyName, idName);
        }
        (useSitesToUnqualify !== null && useSitesToUnqualify !== void 0 ? useSitesToUnqualify :
                                                                          (useSitesToUnqualify = new ts.Map()))
            .set(parent, ts.factory.createIdentifier(idName));
      }
    } else {
      needDefaultImport = true;
    }
  }
  const namedBindings = namedBindingsNames.size === 0 ?
      undefined :
      ts.arrayFrom(ts.mapIterator(namedBindingsNames.entries(), function(_a) {
        const propertyName = _a[0], idName = _a[1];
        return ts.factory.createImportSpecifier(
            /* isTypeOnly*/ false, propertyName === idName ? undefined : ts.factory.createIdentifier(propertyName),
            ts.factory.createIdentifier(idName));
      }));
  if (!namedBindings) {
    // If it was unused, ensure that we at least import *something*.
    needDefaultImport = true;
  }
  return convertedImports(
      [ts.makeImport(
          needDefaultImport ? ts.getSynthesizedDeepClone(name) : undefined, namedBindings, moduleSpecifier,
          quotePreference)],
      useSitesToUnqualify);
}
// Identifiers helpers
function makeUniqueName(name, identifiers) {
  while (identifiers.original.has(name) || identifiers.additional.has(name)) {
    name = '_'.concat(name);
  }
  identifiers.additional.add(name);
  return name;
}
function collectFreeIdentifiers(file) {
  const map = ts.createMultiMap();
  forEachFreeIdentifier(file, function(id) {
    return map.add(id.text, id);
  });
  return map;
}
/**
 * A free identifier is an identifier that can be accessed through name lookup as a local variable.
 * In the expression `x.y`, `x` is a free identifier, but `y` is not.
 */
function forEachFreeIdentifier(node, cb) {
  if (ts.isIdentifier(node) && isFreeIdentifier(node))
    {cb(node);}
  node.forEachChild(function(child) {
    return forEachFreeIdentifier(child, cb);
  });
}
function isFreeIdentifier(node) {
  const parent = node.parent;
  switch (parent.kind) {
    case 208 /* SyntaxKind.PropertyAccessExpression */:
      return parent.name !== node;
    case 205 /* SyntaxKind.BindingElement */:
      return parent.propertyName !== node;
    case 273 /* SyntaxKind.ImportSpecifier */:
      return parent.propertyName !== node;
    default:
      return true;
  }
}
// Node helpers
function functionExpressionToDeclaration(name, additionalModifiers, fn, useSitesToUnqualify) {
  return ts.factory.createFunctionDeclaration(
      ts.concatenate(additionalModifiers, ts.getSynthesizedDeepClones(fn.modifiers)),
      ts.getSynthesizedDeepClone(fn.asteriskToken), name, ts.getSynthesizedDeepClones(fn.typeParameters),
      ts.getSynthesizedDeepClones(fn.parameters), ts.getSynthesizedDeepClone(fn.type),
      ts.factory.converters.convertToFunctionBlock(replaceImportUseSites(fn.body, useSitesToUnqualify)));
}
function classExpressionToDeclaration(name, additionalModifiers, cls, useSitesToUnqualify) {
  return ts.factory.createClassDeclaration(
      ts.concatenate(additionalModifiers, ts.getSynthesizedDeepClones(cls.modifiers)), name,
      ts.getSynthesizedDeepClones(cls.typeParameters), ts.getSynthesizedDeepClones(cls.heritageClauses),
      replaceImportUseSites(cls.members, useSitesToUnqualify));
}
function makeSingleImport(localName, propertyName, moduleSpecifier, quotePreference) {
  return propertyName === 'default' ?
      ts.makeImport(
          ts.factory.createIdentifier(localName), /* namedImports*/ undefined, moduleSpecifier, quotePreference) :
      ts.makeImport(/* name*/ undefined, [makeImportSpecifier(propertyName, localName)], moduleSpecifier,
                    quotePreference);
}
function makeImportSpecifier(propertyName, name) {
  return ts.factory.createImportSpecifier(
      /* isTypeOnly*/ false,
      propertyName !== undefined && propertyName !== name ? ts.factory.createIdentifier(propertyName) : undefined,
      ts.factory.createIdentifier(name));
}
function makeConst(modifiers, name, init) {
  return ts.factory.createVariableStatement(
      modifiers,
      ts.factory.createVariableDeclarationList(
          [ts.factory.createVariableDeclaration(name, /* exclamationToken*/ undefined, /* type*/ undefined, init)],
          2 /* NodeFlags.Const */));
}
function makeExportDeclaration(exportSpecifiers, moduleSpecifier) {
  return ts.factory.createExportDeclaration(
      /* modifiers*/ undefined,
      /* isTypeOnly*/ false, exportSpecifiers && ts.factory.createNamedExports(exportSpecifiers),
      moduleSpecifier === undefined ? undefined : ts.factory.createStringLiteral(moduleSpecifier));
}
function convertedImports(newImports, useSitesToUnqualify) {
  return {newImports, useSitesToUnqualify};
}
})(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let codefix;
(function(codefix) {
const fixId = 'correctQualifiedNameToIndexedAccessType';
const errorCodes = [
  ts.Diagnostics
      .Cannot_access_0_1_because_0_is_a_type_but_not_a_namespace_Did_you_mean_to_retrieve_the_type_of_the_property_1_in_0_with_0_1
      .code
];
codefix.registerCodeFix({
  errorCodes,
  getCodeActions: function(context) {
    const qualifiedName = getQualifiedName(context.sourceFile, context.span.start);
    if (!qualifiedName)
      {return undefined;}
    const changes = ts.textChanges.ChangeTracker.with(context, function(t) {
      return doChange(t, context.sourceFile, qualifiedName);
    });
    const newText = ''.concat(qualifiedName.left.text, '["').concat(qualifiedName.right.text, '"]');
    return [codefix.createCodeFixAction(
        fixId, changes, [ts.Diagnostics.Rewrite_as_the_indexed_access_type_0, newText], fixId,
        ts.Diagnostics.Rewrite_all_as_indexed_access_types)];
  },
  fixIds: [fixId],
  getAllCodeActions: function(context) {
    return codefix.codeFixAll(context, errorCodes, function(changes, diag) {
      const q = getQualifiedName(diag.file, diag.start);
      if (q) {
        doChange(changes, diag.file, q);
      }
    });
  },
});
function getQualifiedName(sourceFile, pos) {
  const qualifiedName = ts.findAncestor(ts.getTokenAtPosition(sourceFile, pos), ts.isQualifiedName);
  ts.Debug.assert(!!qualifiedName, 'Expected position to be owned by a qualified name.');
  return ts.isIdentifier(qualifiedName.left) ? qualifiedName : undefined;
}
function doChange(changeTracker, sourceFile, qualifiedName) {
  const rightText = qualifiedName.right.text;
  const replacement = ts.factory.createIndexedAccessTypeNode(
      ts.factory.createTypeReferenceNode(qualifiedName.left, /* typeArguments*/ undefined),
      ts.factory.createLiteralTypeNode(ts.factory.createStringLiteral(rightText)));
  changeTracker.replaceNode(sourceFile, qualifiedName, replacement);
}
})(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let codefix;
(function(codefix) {
const errorCodes =
    [ts.Diagnostics.Re_exporting_a_type_when_the_isolatedModules_flag_is_provided_requires_using_export_type.code];
const fixId = 'convertToTypeOnlyExport';
codefix.registerCodeFix({
  errorCodes,
  getCodeActions: function getCodeActionsToConvertToTypeOnlyExport(context) {
    const changes = ts.textChanges.ChangeTracker.with(context, function(t) {
      return fixSingleExportDeclaration(
          t, getExportSpecifierForDiagnosticSpan(context.span, context.sourceFile), context);
    });
    if (changes.length) {
      return [codefix.createCodeFixAction(
          fixId, changes, ts.Diagnostics.Convert_to_type_only_export, fixId,
          ts.Diagnostics.Convert_all_re_exported_types_to_type_only_exports)];
    }
  },
  fixIds: [fixId],
  getAllCodeActions: function getAllCodeActionsToConvertToTypeOnlyExport(context) {
    const fixedExportDeclarations = new ts.Map();
    return codefix.codeFixAll(context, errorCodes, function(changes, diag) {
      const exportSpecifier = getExportSpecifierForDiagnosticSpan(diag, context.sourceFile);
      if (exportSpecifier && ts.addToSeen(fixedExportDeclarations, ts.getNodeId(exportSpecifier.parent.parent))) {
        fixSingleExportDeclaration(changes, exportSpecifier, context);
      }
    });
  }
});
function getExportSpecifierForDiagnosticSpan(span, sourceFile) {
  return ts.tryCast(ts.getTokenAtPosition(sourceFile, span.start).parent, ts.isExportSpecifier);
}
function fixSingleExportDeclaration(changes, exportSpecifier, context) {
  if (!exportSpecifier) {
    return;
  }
  const exportClause = exportSpecifier.parent;
  const exportDeclaration = exportClause.parent;
  const typeExportSpecifiers = getTypeExportSpecifiers(exportSpecifier, context);
  if (typeExportSpecifiers.length === exportClause.elements.length) {
    changes.insertModifierBefore(context.sourceFile, 154 /* SyntaxKind.TypeKeyword */, exportClause);
  } else {
    const valueExportDeclaration = ts.factory.updateExportDeclaration(
        exportDeclaration, exportDeclaration.modifiers,
        /* isTypeOnly*/ false,
        ts.factory.updateNamedExports(
            exportClause,
            ts.filter(
                exportClause.elements,
                function(e) {
                  return !ts.contains(typeExportSpecifiers, e);
                })),
        exportDeclaration.moduleSpecifier,
        /* assertClause*/ undefined);
    const typeExportDeclaration = ts.factory.createExportDeclaration(
        /* modifiers*/ undefined,
        /* isTypeOnly*/ true, ts.factory.createNamedExports(typeExportSpecifiers), exportDeclaration.moduleSpecifier,
        /* assertClause*/ undefined);
    changes.replaceNode(context.sourceFile, exportDeclaration, valueExportDeclaration, {
      leadingTriviaOption: ts.textChanges.LeadingTriviaOption.IncludeAll,
      trailingTriviaOption: ts.textChanges.TrailingTriviaOption.Exclude
    });
    changes.insertNodeAfter(context.sourceFile, exportDeclaration, typeExportDeclaration);
  }
}
function getTypeExportSpecifiers(originExportSpecifier, context) {
  const exportClause = originExportSpecifier.parent;
  if (exportClause.elements.length === 1) {
    return exportClause.elements;
  }
  const diagnostics = ts.getDiagnosticsWithinSpan(
      ts.createTextSpanFromNode(exportClause),
      context.program.getSemanticDiagnostics(context.sourceFile, context.cancellationToken));
  return ts.filter(exportClause.elements, function(element) {
    let _a;
    return element === originExportSpecifier ||
        ((_a = ts.findDiagnosticForNode(element, diagnostics)) === null || _a === void 0 ? void 0 : _a.code) ===
        errorCodes[0];
  });
}
})(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let codefix;
(function(codefix) {
const errorCodes = [
  ts.Diagnostics
      .This_import_is_never_used_as_a_value_and_must_use_import_type_because_importsNotUsedAsValues_is_set_to_error.code
];
const fixId = 'convertToTypeOnlyImport';
codefix.registerCodeFix({
  errorCodes,
  getCodeActions: function getCodeActionsToConvertToTypeOnlyImport(context) {
    const changes = ts.textChanges.ChangeTracker.with(context, function(t) {
      const importDeclaration = getImportDeclarationForDiagnosticSpan(context.span, context.sourceFile);
      fixSingleImportDeclaration(t, importDeclaration, context);
    });
    if (changes.length) {
      return [codefix.createCodeFixAction(
          fixId, changes, ts.Diagnostics.Convert_to_type_only_import, fixId,
          ts.Diagnostics.Convert_all_imports_not_used_as_a_value_to_type_only_imports)];
    }
  },
  fixIds: [fixId],
  getAllCodeActions: function getAllCodeActionsToConvertToTypeOnlyImport(context) {
    return codefix.codeFixAll(context, errorCodes, function(changes, diag) {
      const importDeclaration = getImportDeclarationForDiagnosticSpan(diag, context.sourceFile);
      fixSingleImportDeclaration(changes, importDeclaration, context);
    });
  }
});
function getImportDeclarationForDiagnosticSpan(span, sourceFile) {
  return ts.tryCast(ts.getTokenAtPosition(sourceFile, span.start).parent, ts.isImportDeclaration);
}
function fixSingleImportDeclaration(changes, importDeclaration, context) {
  if (!(importDeclaration === null || importDeclaration === void 0 ? void 0 : importDeclaration.importClause)) {
    return;
  }
  const importClause = importDeclaration.importClause;
  // `changes.insertModifierBefore` produces a range that might overlap further changes
  changes.insertText(context.sourceFile, importDeclaration.getStart() + 'import'.length, ' type');
  // `import type foo, { Bar }` is not allowed, so move `foo` to new declaration
  if (importClause.name && importClause.namedBindings) {
    changes.deleteNodeRangeExcludingEnd(
        context.sourceFile, importClause.name, importDeclaration.importClause.namedBindings);
    changes.insertNodeBefore(
        context.sourceFile, importDeclaration,
        ts.factory.updateImportDeclaration(
            importDeclaration,
            /* modifiers*/ undefined,
            ts.factory.createImportClause(
                /* isTypeOnly*/ true, importClause.name,
                /* namedBindings*/ undefined),
            importDeclaration.moduleSpecifier,
            /* assertClause*/ undefined));
  }
}
})(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let codefix;
(function(codefix) {
const fixId = 'convertLiteralTypeToMappedType';
const errorCodes =
    [ts.Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Did_you_mean_to_use_1_in_0.code];
codefix.registerCodeFix({
  errorCodes,
  getCodeActions: function getCodeActionsToConvertLiteralTypeToMappedType(context) {
    const sourceFile = context.sourceFile, span = context.span;
    const info = getInfo(sourceFile, span.start);
    if (!info) {
      return undefined;
    }
    const name = info.name, constraint = info.constraint;
    const changes = ts.textChanges.ChangeTracker.with(context, function(t) {
      return doChange(t, sourceFile, info);
    });
    return [codefix.createCodeFixAction(
        fixId, changes, [ts.Diagnostics.Convert_0_to_1_in_0, constraint, name], fixId,
        ts.Diagnostics.Convert_all_type_literals_to_mapped_type)];
  },
  fixIds: [fixId],
  getAllCodeActions: function(context) {
    return codefix.codeFixAll(context, errorCodes, function(changes, diag) {
      const info = getInfo(diag.file, diag.start);
      if (info) {
        doChange(changes, diag.file, info);
      }
    });
  }
});
function getInfo(sourceFile, pos) {
  const token = ts.getTokenAtPosition(sourceFile, pos);
  if (ts.isIdentifier(token)) {
    const propertySignature = ts.cast(token.parent.parent, ts.isPropertySignature);
    const propertyName = token.getText(sourceFile);
    return {
      container: ts.cast(propertySignature.parent, ts.isTypeLiteralNode),
      typeNode: propertySignature.type,
      constraint: propertyName,
      name: propertyName === 'K' ? 'P' : 'K',
    };
  }
  return undefined;
}
function doChange(changes, sourceFile, _a) {
  const container = _a.container, typeNode = _a.typeNode, constraint = _a.constraint, name = _a.name;
  changes.replaceNode(
      sourceFile, container,
      ts.factory.createMappedTypeNode(
          /* readonlyToken*/ undefined,
          ts.factory.createTypeParameterDeclaration(/* modifiers*/ undefined, name,
                                                    ts.factory.createTypeReferenceNode(constraint)),
          /* nameType*/ undefined,
          /* questionToken*/ undefined, typeNode,
          /* members*/ undefined));
}
})(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let codefix;
(function(codefix) {
const errorCodes = [
  ts.Diagnostics.Class_0_incorrectly_implements_interface_1.code,
  ts.Diagnostics.Class_0_incorrectly_implements_class_1_Did_you_mean_to_extend_1_and_inherit_its_members_as_a_subclass
      .code
];
const fixId =
    'fixClassIncorrectlyImplementsInterface';  // TODO: share a group with fixClassDoesntImplementInheritedAbstractMember?
codefix.registerCodeFix({
  errorCodes,
  getCodeActions: function(context) {
    const sourceFile = context.sourceFile, span = context.span;
    const classDeclaration = getClass(sourceFile, span.start);
    return ts.mapDefined(ts.getEffectiveImplementsTypeNodes(classDeclaration), function(implementedTypeNode) {
      const changes = ts.textChanges.ChangeTracker.with(context, function(t) {
        return addMissingDeclarations(
            context, implementedTypeNode, sourceFile, classDeclaration, t, context.preferences);
      });
      return changes.length === 0 ?
          undefined :
          codefix.createCodeFixAction(
              fixId, changes, [ts.Diagnostics.Implement_interface_0, implementedTypeNode.getText(sourceFile)], fixId,
              ts.Diagnostics.Implement_all_unimplemented_interfaces);
    });
  },
  fixIds: [fixId],
  getAllCodeActions: function(context) {
    const seenClassDeclarations = new ts.Map();
    return codefix.codeFixAll(context, errorCodes, function(changes, diag) {
      const classDeclaration = getClass(diag.file, diag.start);
      if (ts.addToSeen(seenClassDeclarations, ts.getNodeId(classDeclaration))) {
        for (let _i = 0, _a = ts.getEffectiveImplementsTypeNodes(classDeclaration); _i < _a.length; _i++) {
          const implementedTypeNode = _a[_i];
          addMissingDeclarations(
              context, implementedTypeNode, diag.file, classDeclaration, changes, context.preferences);
        }
      }
    });
  },
});
function getClass(sourceFile, pos) {
  return ts.Debug.checkDefined(
      ts.getContainingClass(ts.getTokenAtPosition(sourceFile, pos)), 'There should be a containing class');
}
function symbolPointsToNonPrivateMember(symbol) {
  return !symbol.valueDeclaration ||
      !(ts.getEffectiveModifierFlags(symbol.valueDeclaration) & 8 /* ModifierFlags.Private */);
}
function addMissingDeclarations(
    context, implementedTypeNode, sourceFile, classDeclaration, changeTracker, preferences) {
  const checker = context.program.getTypeChecker();
  const maybeHeritageClauseSymbol = getHeritageClauseSymbolTable(classDeclaration, checker);
  // Note that this is ultimately derived from a map indexed by symbol names,
  // so duplicates cannot occur.
  const implementedType = checker.getTypeAtLocation(implementedTypeNode);
  const implementedTypeSymbols = checker.getPropertiesOfType(implementedType);
  const nonPrivateAndNotExistedInHeritageClauseMembers =
      implementedTypeSymbols.filter(ts.and(symbolPointsToNonPrivateMember, function(symbol) {
        return !maybeHeritageClauseSymbol.has(symbol.escapedName);
      }));
  const classType = checker.getTypeAtLocation(classDeclaration);
  const constructor = ts.find(classDeclaration.members, function(m) {
    return ts.isConstructorDeclaration(m);
  });
  if (!classType.getNumberIndexType()) {
    createMissingIndexSignatureDeclaration(implementedType, 1 /* IndexKind.Number */);
  }
  if (!classType.getStringIndexType()) {
    createMissingIndexSignatureDeclaration(implementedType, 0 /* IndexKind.String */);
  }
  const importAdder = codefix.createImportAdder(sourceFile, context.program, preferences, context.host);
  codefix.createMissingMemberNodes(
      classDeclaration, nonPrivateAndNotExistedInHeritageClauseMembers, sourceFile, context, preferences, importAdder,
      function(member) {
        return insertInterfaceMemberNode(sourceFile, classDeclaration, member);
      });
  importAdder.writeFixes(changeTracker);
  function createMissingIndexSignatureDeclaration(type, kind) {
    const indexInfoOfKind = checker.getIndexInfoOfType(type, kind);
    if (indexInfoOfKind) {
      insertInterfaceMemberNode(
          sourceFile, classDeclaration,
          checker.indexInfoToIndexSignatureDeclaration(
              indexInfoOfKind, classDeclaration, /* flags*/ undefined,
              codefix.getNoopSymbolTrackerWithResolver(context)));
    }
  }
  // Either adds the node at the top of the class, or if there's a constructor right after that
  function insertInterfaceMemberNode(sourceFile, cls, newElement) {
    if (constructor) {
      changeTracker.insertNodeAfter(sourceFile, constructor, newElement);
    } else {
      changeTracker.insertMemberAtStart(sourceFile, cls, newElement);
    }
  }
}
function getHeritageClauseSymbolTable(classDeclaration, checker) {
  const heritageClauseNode = ts.getEffectiveBaseTypeNode(classDeclaration);
  if (!heritageClauseNode)
    {return ts.createSymbolTable();}
  const heritageClauseType = checker.getTypeAtLocation(heritageClauseNode);
  const heritageClauseTypeSymbols = checker.getPropertiesOfType(heritageClauseType);
  return ts.createSymbolTable(heritageClauseTypeSymbols.filter(symbolPointsToNonPrivateMember));
}
})(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let codefix;
(function(codefix) {
codefix.importFixName = 'import';
const importFixId = 'fixMissingImport';
const errorCodes = [
  ts.Diagnostics.Cannot_find_name_0.code,
  ts.Diagnostics.Cannot_find_name_0_Did_you_mean_1.code,
  ts.Diagnostics.Cannot_find_name_0_Did_you_mean_the_instance_member_this_0.code,
  ts.Diagnostics.Cannot_find_name_0_Did_you_mean_the_static_member_1_0.code,
  ts.Diagnostics.Cannot_find_namespace_0.code,
  ts.Diagnostics._0_refers_to_a_UMD_global_but_the_current_file_is_a_module_Consider_adding_an_import_instead.code,
  ts.Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here.code,
  ts.Diagnostics.No_value_exists_in_scope_for_the_shorthand_property_0_Either_declare_one_or_provide_an_initializer
      .code,
  ts.Diagnostics._0_cannot_be_used_as_a_value_because_it_was_imported_using_import_type.code,
];
codefix.registerCodeFix({
  errorCodes,
  getCodeActions: function(context) {
    const errorCode = context.errorCode, preferences = context.preferences, sourceFile = context.sourceFile,
        span = context.span, program = context.program;
    const info = getFixInfos(context, errorCode, span.start, /* useAutoImportProvider*/ true);
    if (!info)