enFlags.ContainsInvalidEscape */;
                            return text.substring(start, pos);
                        }
                        else if (!isHexDigit(text.charCodeAt(pos + 1))) {
                            pos++;
                            tokenFlags |= 2048 /* TokenFlags.ContainsInvalidEscape */;
                            return text.substring(start, pos);
                        }
                    }
                    // '\xDD'
                    return scanHexadecimalEscape(/*numDigits*/ 2);
                // when encountering a LineContinuation (i.e. a backslash and a line terminator sequence),
                // the line terminator is interpreted to be "the empty code unit sequence".
                case 13 /* CharacterCodes.carriageReturn */:
                    if (pos < end && text.charCodeAt(pos) === 10 /* CharacterCodes.lineFeed */) {
                        pos++;
                    }
                // falls through
                case 10 /* CharacterCodes.lineFeed */:
                case 8232 /* CharacterCodes.lineSeparator */:
                case 8233 /* CharacterCodes.paragraphSeparator */:
                    return "";
                default:
                    return String.fromCharCode(ch);
            }
        }
        function scanHexadecimalEscape(numDigits) {
            var escapedValue = scanExactNumberOfHexDigits(numDigits, /*canHaveSeparators*/ false);
            if (escapedValue >= 0) {
                return String.fromCharCode(escapedValue);
            }
            else {
                error(ts.Diagnostics.Hexadecimal_digit_expected);
                return "";
            }
        }
        function scanExtendedUnicodeEscape() {
            var escapedValueString = scanMinimumNumberOfHexDigits(1, /*canHaveSeparators*/ false);
            var escapedValue = escapedValueString ? parseInt(escapedValueString, 16) : -1;
            var isInvalidExtendedEscape = false;
            // Validate the value of the digit
            if (escapedValue < 0) {
                error(ts.Diagnostics.Hexadecimal_digit_expected);
                isInvalidExtendedEscape = true;
            }
            else if (escapedValue > 0x10FFFF) {
                error(ts.Diagnostics.An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive);
                isInvalidExtendedEscape = true;
            }
            if (pos >= end) {
                error(ts.Diagnostics.Unexpected_end_of_text);
                isInvalidExtendedEscape = true;
            }
            else if (text.charCodeAt(pos) === 125 /* CharacterCodes.closeBrace */) {
                // Only swallow the following character up if it's a '}'.
                pos++;
            }
            else {
                error(ts.Diagnostics.Unterminated_Unicode_escape_sequence);
                isInvalidExtendedEscape = true;
            }
            if (isInvalidExtendedEscape) {
                return "";
            }
            return utf16EncodeAsString(escapedValue);
        }
        // Current character is known to be a backslash. Check for Unicode escape of the form '\uXXXX'
        // and return code point value if valid Unicode escape is found. Otherwise return -1.
        function peekUnicodeEscape() {
            if (pos + 5 < end && text.charCodeAt(pos + 1) === 117 /* CharacterCodes.u */) {
                var start_1 = pos;
                pos += 2;
                var value = scanExactNumberOfHexDigits(4, /*canHaveSeparators*/ false);
                pos = start_1;
                return value;
            }
            return -1;
        }
        function peekExtendedUnicodeEscape() {
            if (codePointAt(text, pos + 1) === 117 /* CharacterCodes.u */ && codePointAt(text, pos + 2) === 123 /* CharacterCodes.openBrace */) {
                var start_2 = pos;
                pos += 3;
                var escapedValueString = scanMinimumNumberOfHexDigits(1, /*canHaveSeparators*/ false);
                var escapedValue = escapedValueString ? parseInt(escapedValueString, 16) : -1;
                pos = start_2;
                return escapedValue;
            }
            return -1;
        }
        function scanIdentifierParts() {
            var result = "";
            var start = pos;
            while (pos < end) {
                var ch = codePointAt(text, pos);
                if (isIdentifierPart(ch, languageVersion)) {
                    pos += charSize(ch);
                }
                else if (ch === 92 /* CharacterCodes.backslash */) {
                    ch = peekExtendedUnicodeEscape();
                    if (ch >= 0 && isIdentifierPart(ch, languageVersion)) {
                        pos += 3;
                        tokenFlags |= 8 /* TokenFlags.ExtendedUnicodeEscape */;
                        result += scanExtendedUnicodeEscape();
                        start = pos;
                        continue;
                    }
                    ch = peekUnicodeEscape();
                    if (!(ch >= 0 && isIdentifierPart(ch, languageVersion))) {
                        break;
                    }
                    tokenFlags |= 1024 /* TokenFlags.UnicodeEscape */;
                    result += text.substring(start, pos);
                    result += utf16EncodeAsString(ch);
                    // Valid Unicode escape is always six characters
                    pos += 6;
                    start = pos;
                }
                else {
                    break;
                }
            }
            result += text.substring(start, pos);
            return result;
        }
        function getIdentifierToken() {
            // Reserved words are between 2 and 12 characters long and start with a lowercase letter
            var len = tokenValue.length;
            if (len >= 2 && len <= 12) {
                var ch = tokenValue.charCodeAt(0);
                if (ch >= 97 /* CharacterCodes.a */ && ch <= 122 /* CharacterCodes.z */) {
                    var keyword = textToKeyword.get(tokenValue);
                    if (keyword !== undefined) {
                        return token = keyword;
                    }
                }
            }
            return token = 79 /* SyntaxKind.Identifier */;
        }
        function scanBinaryOrOctalDigits(base) {
            var value = "";
            // For counting number of digits; Valid binaryIntegerLiteral must have at least one binary digit following B or b.
            // Similarly valid octalIntegerLiteral must have at least one octal digit following o or O.
            var separatorAllowed = false;
            var isPreviousTokenSeparator = false;
            while (true) {
                var ch = text.charCodeAt(pos);
                // Numeric separators are allowed anywhere within a numeric literal, except not at the beginning, or following another separator
                if (ch === 95 /* CharacterCodes._ */) {
                    tokenFlags |= 512 /* TokenFlags.ContainsSeparator */;
                    if (separatorAllowed) {
                        separatorAllowed = false;
                        isPreviousTokenSeparator = true;
                    }
                    else if (isPreviousTokenSeparator) {
                        error(ts.Diagnostics.Multiple_consecutive_numeric_separators_are_not_permitted, pos, 1);
                    }
                    else {
                        error(ts.Diagnostics.Numeric_separators_are_not_allowed_here, pos, 1);
                    }
                    pos++;
                    continue;
                }
                separatorAllowed = true;
                if (!isDigit(ch) || ch - 48 /* CharacterCodes._0 */ >= base) {
                    break;
                }
                value += text[pos];
                pos++;
                isPreviousTokenSeparator = false;
            }
            if (text.charCodeAt(pos - 1) === 95 /* CharacterCodes._ */) {
                // Literal ends with underscore - not allowed
                error(ts.Diagnostics.Numeric_separators_are_not_allowed_here, pos - 1, 1);
            }
            return value;
        }
        function checkBigIntSuffix() {
            if (text.charCodeAt(pos) === 110 /* CharacterCodes.n */) {
                tokenValue += "n";
                // Use base 10 instead of base 2 or base 8 for shorter literals
                if (tokenFlags & 384 /* TokenFlags.BinaryOrOctalSpecifier */) {
                    tokenValue = ts.parsePseudoBigInt(tokenValue) + "n";
                }
                pos++;
                return 9 /* SyntaxKind.BigIntLiteral */;
            }
            else { // not a bigint, so can convert to number in simplified form
                // Number() may not support 0b or 0o, so use parseInt() instead
                var numericValue = tokenFlags & 128 /* TokenFlags.BinarySpecifier */
                    ? parseInt(tokenValue.slice(2), 2) // skip "0b"
                    : tokenFlags & 256 /* TokenFlags.OctalSpecifier */
                        ? parseInt(tokenValue.slice(2), 8) // skip "0o"
                        : +tokenValue;
                tokenValue = "" + numericValue;
                return 8 /* SyntaxKind.NumericLiteral */;
            }
        }
        function scan() {
            var _a;
            startPos = pos;
            tokenFlags = 0 /* TokenFlags.None */;
            var asteriskSeen = false;
            while (true) {
                tokenPos = pos;
                if (pos >= end) {
                    return token = 1 /* SyntaxKind.EndOfFileToken */;
                }
                var ch = codePointAt(text, pos);
                // Special handling for shebang
                if (ch === 35 /* CharacterCodes.hash */ && pos === 0 && isShebangTrivia(text, pos)) {
                    pos = scanShebangTrivia(text, pos);
                    if (skipTrivia) {
                        continue;
                    }
                    else {
                        return token = 6 /* SyntaxKind.ShebangTrivia */;
                    }
                }
                switch (ch) {
                    case 10 /* CharacterCodes.lineFeed */:
                    case 13 /* CharacterCodes.carriageReturn */:
                        tokenFlags |= 1 /* TokenFlags.PrecedingLineBreak */;
                        if (skipTrivia) {
                            pos++;
                            continue;
                        }
                        else {
                            if (ch === 13 /* CharacterCodes.carriageReturn */ && pos + 1 < end && text.charCodeAt(pos + 1) === 10 /* CharacterCodes.lineFeed */) {
                                // consume both CR and LF
                                pos += 2;
                            }
                            else {
                                pos++;
                            }
                            return token = 4 /* SyntaxKind.NewLineTrivia */;
                        }
                    case 9 /* CharacterCodes.tab */:
                    case 11 /* CharacterCodes.verticalTab */:
                    case 12 /* CharacterCodes.formFeed */:
                    case 32 /* CharacterCodes.space */:
                    case 160 /* CharacterCodes.nonBreakingSpace */:
                    case 5760 /* CharacterCodes.ogham */:
                    case 8192 /* CharacterCodes.enQuad */:
                    case 8193 /* CharacterCodes.emQuad */:
                    case 8194 /* CharacterCodes.enSpace */:
                    case 8195 /* CharacterCodes.emSpace */:
                    case 8196 /* CharacterCodes.threePerEmSpace */:
                    case 8197 /* CharacterCodes.fourPerEmSpace */:
                    case 8198 /* CharacterCodes.sixPerEmSpace */:
                    case 8199 /* CharacterCodes.figureSpace */:
                    case 8200 /* CharacterCodes.punctuationSpace */:
                    case 8201 /* CharacterCodes.thinSpace */:
                    case 8202 /* CharacterCodes.hairSpace */:
                    case 8203 /* CharacterCodes.zeroWidthSpace */:
                    case 8239 /* CharacterCodes.narrowNoBreakSpace */:
                    case 8287 /* CharacterCodes.mathematicalSpace */:
                    case 12288 /* CharacterCodes.ideographicSpace */:
                    case 65279 /* CharacterCodes.byteOrderMark */:
                        if (skipTrivia) {
                            pos++;
                            continue;
                        }
                        else {
                            while (pos < end && isWhiteSpaceSingleLine(text.charCodeAt(pos))) {
                                pos++;
                            }
                            return token = 5 /* SyntaxKind.WhitespaceTrivia */;
                        }
                    case 33 /* CharacterCodes.exclamation */:
                        if (text.charCodeAt(pos + 1) === 61 /* CharacterCodes.equals */) {
                            if (text.charCodeAt(pos + 2) === 61 /* CharacterCodes.equals */) {
                                return pos += 3, token = 37 /* SyntaxKind.ExclamationEqualsEqualsToken */;
                            }
                            return pos += 2, token = 35 /* SyntaxKind.ExclamationEqualsToken */;
                        }
                        pos++;
                        return token = 53 /* SyntaxKind.ExclamationToken */;
                    case 34 /* CharacterCodes.doubleQuote */:
                    case 39 /* CharacterCodes.singleQuote */:
                        tokenValue = scanString();
                        return token = 10 /* SyntaxKind.StringLiteral */;
                    case 96 /* CharacterCodes.backtick */:
                        return token = scanTemplateAndSetTokenValue(/* isTaggedTemplate */ false);
                    case 37 /* CharacterCodes.percent */:
                        if (text.charCodeAt(pos + 1) === 61 /* CharacterCodes.equals */) {
                            return pos += 2, token = 69 /* SyntaxKind.PercentEqualsToken */;
                        }
                        pos++;
                        return token = 44 /* SyntaxKind.PercentToken */;
                    case 38 /* CharacterCodes.ampersand */:
                        if (text.charCodeAt(pos + 1) === 38 /* CharacterCodes.ampersand */) {
                            if (text.charCodeAt(pos + 2) === 61 /* CharacterCodes.equals */) {
                                return pos += 3, token = 76 /* SyntaxKind.AmpersandAmpersandEqualsToken */;
                            }
                            return pos += 2, token = 55 /* SyntaxKind.AmpersandAmpersandToken */;
                        }
                        if (text.charCodeAt(pos + 1) === 61 /* CharacterCodes.equals */) {
                            return pos += 2, token = 73 /* SyntaxKind.AmpersandEqualsToken */;
                        }
                        pos++;
                        return token = 50 /* SyntaxKind.AmpersandToken */;
                    case 40 /* CharacterCodes.openParen */:
                        pos++;
                        return token = 20 /* SyntaxKind.OpenParenToken */;
                    case 41 /* CharacterCodes.closeParen */:
                        pos++;
                        return token = 21 /* SyntaxKind.CloseParenToken */;
                    case 42 /* CharacterCodes.asterisk */:
                        if (text.charCodeAt(pos + 1) === 61 /* CharacterCodes.equals */) {
                            return pos += 2, token = 66 /* SyntaxKind.AsteriskEqualsToken */;
                        }
                        if (text.charCodeAt(pos + 1) === 42 /* CharacterCodes.asterisk */) {
                            if (text.charCodeAt(pos + 2) === 61 /* CharacterCodes.equals */) {
                                return pos += 3, token = 67 /* SyntaxKind.AsteriskAsteriskEqualsToken */;
                            }
                            return pos += 2, token = 42 /* SyntaxKind.AsteriskAsteriskToken */;
                        }
                        pos++;
                        if (inJSDocType && !asteriskSeen && (tokenFlags & 1 /* TokenFlags.PrecedingLineBreak */)) {
                            // decoration at the start of a JSDoc comment line
                            asteriskSeen = true;
                            continue;
                        }
                        return token = 41 /* SyntaxKind.AsteriskToken */;
                    case 43 /* CharacterCodes.plus */:
                        if (text.charCodeAt(pos + 1) === 43 /* CharacterCodes.plus */) {
                            return pos += 2, token = 45 /* SyntaxKind.PlusPlusToken */;
                        }
                        if (text.charCodeAt(pos + 1) === 61 /* CharacterCodes.equals */) {
                            return pos += 2, token = 64 /* SyntaxKind.PlusEqualsToken */;
                        }
                        pos++;
                        return token = 39 /* SyntaxKind.PlusToken */;
                    case 44 /* CharacterCodes.comma */:
                        pos++;
                        return token = 27 /* SyntaxKind.CommaToken */;
                    case 45 /* CharacterCodes.minus */:
                        if (text.charCodeAt(pos + 1) === 45 /* CharacterCodes.minus */) {
                            return pos += 2, token = 46 /* SyntaxKind.MinusMinusToken */;
                        }
                        if (text.charCodeAt(pos + 1) === 61 /* CharacterCodes.equals */) {
                            return pos += 2, token = 65 /* SyntaxKind.MinusEqualsToken */;
                        }
                        pos++;
                        return token = 40 /* SyntaxKind.MinusToken */;
                    case 46 /* CharacterCodes.dot */:
                        if (isDigit(text.charCodeAt(pos + 1))) {
                            tokenValue = scanNumber().value;
                            return token = 8 /* SyntaxKind.NumericLiteral */;
                        }
                        if (text.charCodeAt(pos + 1) === 46 /* CharacterCodes.dot */ && text.charCodeAt(pos + 2) === 46 /* CharacterCodes.dot */) {
                            return pos += 3, token = 25 /* SyntaxKind.DotDotDotToken */;
                        }
                        pos++;
                        return token = 24 /* SyntaxKind.DotToken */;
                    case 47 /* CharacterCodes.slash */:
                        // Single-line comment
                        if (text.charCodeAt(pos + 1) === 47 /* CharacterCodes.slash */) {
                            pos += 2;
                            while (pos < end) {
                                if (isLineBreak(text.charCodeAt(pos))) {
                                    break;
                                }
                                pos++;
                            }
                            commentDirectives = appendIfCommentDirective(commentDirectives, text.slice(tokenPos, pos), commentDirectiveRegExSingleLine, tokenPos);
                            if (skipTrivia) {
                                continue;
                            }
                            else {
                                return token = 2 /* SyntaxKind.SingleLineCommentTrivia */;
                            }
                        }
                        // Multi-line comment
                        if (text.charCodeAt(pos + 1) === 42 /* CharacterCodes.asterisk */) {
                            pos += 2;
                            if (text.charCodeAt(pos) === 42 /* CharacterCodes.asterisk */ && text.charCodeAt(pos + 1) !== 47 /* CharacterCodes.slash */) {
                                tokenFlags |= 2 /* TokenFlags.PrecedingJSDocComment */;
                            }
                            var commentClosed = false;
                            var lastLineStart = tokenPos;
                            while (pos < end) {
                                var ch_1 = text.charCodeAt(pos);
                                if (ch_1 === 42 /* CharacterCodes.asterisk */ && text.charCodeAt(pos + 1) === 47 /* CharacterCodes.slash */) {
                                    pos += 2;
                                    commentClosed = true;
                                    break;
                                }
                                pos++;
                                if (isLineBreak(ch_1)) {
                                    lastLineStart = pos;
                                    tokenFlags |= 1 /* TokenFlags.PrecedingLineBreak */;
                                }
                            }
                            commentDirectives = appendIfCommentDirective(commentDirectives, text.slice(lastLineStart, pos), commentDirectiveRegExMultiLine, lastLineStart);
                            if (!commentClosed) {
                                error(ts.Diagnostics.Asterisk_Slash_expected);
                            }
                            if (skipTrivia) {
                                continue;
                            }
                            else {
                                if (!commentClosed) {
                                    tokenFlags |= 4 /* TokenFlags.Unterminated */;
                                }
                                return token = 3 /* SyntaxKind.MultiLineCommentTrivia */;
                            }
                        }
                        if (text.charCodeAt(pos + 1) === 61 /* CharacterCodes.equals */) {
                            return pos += 2, token = 68 /* SyntaxKind.SlashEqualsToken */;
                        }
                        pos++;
                        return token = 43 /* SyntaxKind.SlashToken */;
                    case 48 /* CharacterCodes._0 */:
                        if (pos + 2 < end && (text.charCodeAt(pos + 1) === 88 /* CharacterCodes.X */ || text.charCodeAt(pos + 1) === 120 /* CharacterCodes.x */)) {
                            pos += 2;
                            tokenValue = scanMinimumNumberOfHexDigits(1, /*canHaveSeparators*/ true);
                            if (!tokenValue) {
                                error(ts.Diagnostics.Hexadecimal_digit_expected);
                                tokenValue = "0";
                            }
                            tokenValue = "0x" + tokenValue;
                            tokenFlags |= 64 /* TokenFlags.HexSpecifier */;
                            return token = checkBigIntSuffix();
                        }
                        else if (pos + 2 < end && (text.charCodeAt(pos + 1) === 66 /* CharacterCodes.B */ || text.charCodeAt(pos + 1) === 98 /* CharacterCodes.b */)) {
                            pos += 2;
                            tokenValue = scanBinaryOrOctalDigits(/* base */ 2);
                            if (!tokenValue) {
                                error(ts.Diagnostics.Binary_digit_expected);
                                tokenValue = "0";
                            }
                            tokenValue = "0b" + tokenValue;
                            tokenFlags |= 128 /* TokenFlags.BinarySpecifier */;
                            return token = checkBigIntSuffix();
                        }
                        else if (pos + 2 < end && (text.charCodeAt(pos + 1) === 79 /* CharacterCodes.O */ || text.charCodeAt(pos + 1) === 111 /* CharacterCodes.o */)) {
                            pos += 2;
                            tokenValue = scanBinaryOrOctalDigits(/* base */ 8);
                            if (!tokenValue) {
                                error(ts.Diagnostics.Octal_digit_expected);
                                tokenValue = "0";
                            }
                            tokenValue = "0o" + tokenValue;
                            tokenFlags |= 256 /* TokenFlags.OctalSpecifier */;
                            return token = checkBigIntSuffix();
                        }
                        // Try to parse as an octal
                        if (pos + 1 < end && isOctalDigit(text.charCodeAt(pos + 1))) {
                            tokenValue = "" + scanOctalDigits();
                            tokenFlags |= 32 /* TokenFlags.Octal */;
                            return token = 8 /* SyntaxKind.NumericLiteral */;
                        }
                    // This fall-through is a deviation from the EcmaScript grammar. The grammar says that a leading zero
                    // can only be followed by an octal digit, a dot, or the end of the number literal. However, we are being
                    // permissive and allowing decimal digits of the form 08* and 09* (which many browsers also do).
                    // falls through
                    case 49 /* CharacterCodes._1 */:
                    case 50 /* CharacterCodes._2 */:
                    case 51 /* CharacterCodes._3 */:
                    case 52 /* CharacterCodes._4 */:
                    case 53 /* CharacterCodes._5 */:
                    case 54 /* CharacterCodes._6 */:
                    case 55 /* CharacterCodes._7 */:
                    case 56 /* CharacterCodes._8 */:
                    case 57 /* CharacterCodes._9 */:
                        (_a = scanNumber(), token = _a.type, tokenValue = _a.value);
                        return token;
                    case 58 /* CharacterCodes.colon */:
                        pos++;
                        return token = 58 /* SyntaxKind.ColonToken */;
                    case 59 /* CharacterCodes.semicolon */:
                        pos++;
                        return token = 26 /* SyntaxKind.SemicolonToken */;
                    case 60 /* CharacterCodes.lessThan */:
                        if (isConflictMarkerTrivia(text, pos)) {
                            pos = scanConflictMarkerTrivia(text, pos, error);
                            if (skipTrivia) {
                                continue;
                            }
                            else {
                                return token = 7 /* SyntaxKind.ConflictMarkerTrivia */;
                            }
                        }
                        if (text.charCodeAt(pos + 1) === 60 /* CharacterCodes.lessThan */) {
                            if (text.charCodeAt(pos + 2) === 61 /* CharacterCodes.equals */) {
                                return pos += 3, token = 70 /* SyntaxKind.LessThanLessThanEqualsToken */;
                            }
                            return pos += 2, token = 47 /* SyntaxKind.LessThanLessThanToken */;
                        }
                        if (text.charCodeAt(pos + 1) === 61 /* CharacterCodes.equals */) {
                            return pos += 2, token = 32 /* SyntaxKind.LessThanEqualsToken */;
                        }
                        if (languageVariant === 1 /* LanguageVariant.JSX */ &&
                            text.charCodeAt(pos + 1) === 47 /* CharacterCodes.slash */ &&
                            text.charCodeAt(pos + 2) !== 42 /* CharacterCodes.asterisk */) {
                            return pos += 2, token = 30 /* SyntaxKind.LessThanSlashToken */;
                        }
                        pos++;
                        return token = 29 /* SyntaxKind.LessThanToken */;
                    case 61 /* CharacterCodes.equals */:
                        if (isConflictMarkerTrivia(text, pos)) {
                            pos = scanConflictMarkerTrivia(text, pos, error);
                            if (skipTrivia) {
                                continue;
                            }
                            else {
                                return token = 7 /* SyntaxKind.ConflictMarkerTrivia */;
                            }
                        }
                        if (text.charCodeAt(pos + 1) === 61 /* CharacterCodes.equals */) {
                            if (text.charCodeAt(pos + 2) === 61 /* CharacterCodes.equals */) {
                                return pos += 3, token = 36 /* SyntaxKind.EqualsEqualsEqualsToken */;
                            }
                            return pos += 2, token = 34 /* SyntaxKind.EqualsEqualsToken */;
                        }
                        if (text.charCodeAt(pos + 1) === 62 /* CharacterCodes.greaterThan */) {
                            return pos += 2, token = 38 /* SyntaxKind.EqualsGreaterThanToken */;
                        }
                        pos++;
                        return token = 63 /* SyntaxKind.EqualsToken */;
                    case 62 /* CharacterCodes.greaterThan */:
                        if (isConflictMarkerTrivia(text, pos)) {
                            pos = scanConflictMarkerTrivia(text, pos, error);
                            if (skipTrivia) {
                                continue;
                            }
                            else {
                                return token = 7 /* SyntaxKind.ConflictMarkerTrivia */;
                            }
                        }
                        pos++;
                        return token = 31 /* SyntaxKind.GreaterThanToken */;
                    case 63 /* CharacterCodes.question */:
                        if (text.charCodeAt(pos + 1) === 46 /* CharacterCodes.dot */ && !isDigit(text.charCodeAt(pos + 2))) {
                            return pos += 2, token = 28 /* SyntaxKind.QuestionDotToken */;
                        }
                        if (text.charCodeAt(pos + 1) === 63 /* CharacterCodes.question */) {
                            if (text.charCodeAt(pos + 2) === 61 /* CharacterCodes.equals */) {
                                return pos += 3, token = 77 /* SyntaxKind.QuestionQuestionEqualsToken */;
                            }
                            return pos += 2, token = 60 /* SyntaxKind.QuestionQuestionToken */;
                        }
                        pos++;
                        return token = 57 /* SyntaxKind.QuestionToken */;
                    case 91 /* CharacterCodes.openBracket */:
                        pos++;
                        return token = 22 /* SyntaxKind.OpenBracketToken */;
                    case 93 /* CharacterCodes.closeBracket */:
                        pos++;
                        return token = 23 /* SyntaxKind.CloseBracketToken */;
                    case 94 /* CharacterCodes.caret */:
                        if (text.charCodeAt(pos + 1) === 61 /* CharacterCodes.equals */) {
                            return pos += 2, token = 78 /* SyntaxKind.CaretEqualsToken */;
                        }
                        pos++;
                        return token = 52 /* SyntaxKind.CaretToken */;
                    case 123 /* CharacterCodes.openBrace */:
                        pos++;
                        return token = 18 /* SyntaxKind.OpenBraceToken */;
                    case 124 /* CharacterCodes.bar */:
                        if (isConflictMarkerTrivia(text, pos)) {
                            pos = scanConflictMarkerTrivia(text, pos, error);
                            if (skipTrivia) {
                                continue;
                            }
                            else {
                                return token = 7 /* SyntaxKind.ConflictMarkerTrivia */;
                            }
                        }
                        if (text.charCodeAt(pos + 1) === 124 /* CharacterCodes.bar */) {
                            if (text.charCodeAt(pos + 2) === 61 /* CharacterCodes.equals */) {
                                return pos += 3, token = 75 /* SyntaxKind.BarBarEqualsToken */;
                            }
                            return pos += 2, token = 56 /* SyntaxKind.BarBarToken */;
                        }
                        if (text.charCodeAt(pos + 1) === 61 /* CharacterCodes.equals */) {
                            return pos += 2, token = 74 /* SyntaxKind.BarEqualsToken */;
                        }
                        pos++;
                        return token = 51 /* SyntaxKind.BarToken */;
                    case 125 /* CharacterCodes.closeBrace */:
                        pos++;
                        return token = 19 /* SyntaxKind.CloseBraceToken */;
                    case 126 /* CharacterCodes.tilde */:
                        pos++;
                        return token = 54 /* SyntaxKind.TildeToken */;
                    case 64 /* CharacterCodes.at */:
                        pos++;
                        return token = 59 /* SyntaxKind.AtToken */;
                    case 92 /* CharacterCodes.backslash */:
                        var extendedCookedChar = peekExtendedUnicodeEscape();
                        if (extendedCookedChar >= 0 && isIdentifierStart(extendedCookedChar, languageVersion)) {
                            pos += 3;
                            tokenFlags |= 8 /* TokenFlags.ExtendedUnicodeEscape */;
                            tokenValue = scanExtendedUnicodeEscape() + scanIdentifierParts();
                            return token = getIdentifierToken();
                        }
                        var cookedChar = peekUnicodeEscape();
                        if (cookedChar >= 0 && isIdentifierStart(cookedChar, languageVersion)) {
                            pos += 6;
                            tokenFlags |= 1024 /* TokenFlags.UnicodeEscape */;
                            tokenValue = String.fromCharCode(cookedChar) + scanIdentifierParts();
                            return token = getIdentifierToken();
                        }
                        error(ts.Diagnostics.Invalid_character);
                        pos++;
                        return token = 0 /* SyntaxKind.Unknown */;
                    case 35 /* CharacterCodes.hash */:
                        if (pos !== 0 && text[pos + 1] === "!") {
                            error(ts.Diagnostics.can_only_be_used_at_the_start_of_a_file);
                            pos++;
                            return token = 0 /* SyntaxKind.Unknown */;
                        }
                        var charAfterHash = codePointAt(text, pos + 1);
                        if (charAfterHash === 92 /* CharacterCodes.backslash */) {
                            pos++;
                            var extendedCookedChar_1 = peekExtendedUnicodeEscape();
                            if (extendedCookedChar_1 >= 0 && isIdentifierStart(extendedCookedChar_1, languageVersion)) {
                                pos += 3;
                                tokenFlags |= 8 /* TokenFlags.ExtendedUnicodeEscape */;
                                tokenValue = "#" + scanExtendedUnicodeEscape() + scanIdentifierParts();
                                return token = 80 /* SyntaxKind.PrivateIdentifier */;
                            }
                            var cookedChar_1 = peekUnicodeEscape();
                            if (cookedChar_1 >= 0 && isIdentifierStart(cookedChar_1, languageVersion)) {
                                pos += 6;
                                tokenFlags |= 1024 /* TokenFlags.UnicodeEscape */;
                                tokenValue = "#" + String.fromCharCode(cookedChar_1) + scanIdentifierParts();
                                return token = 80 /* SyntaxKind.PrivateIdentifier */;
                            }
                            pos--;
                        }
                        if (isIdentifierStart(charAfterHash, languageVersion)) {
                            pos++;
                            // We're relying on scanIdentifier's behavior and adjusting the token kind after the fact.
                            // Notably absent from this block is the fact that calling a function named "scanIdentifier",
                            // but identifiers don't include '#', and that function doesn't deal with it at all.
                            // This works because 'scanIdentifier' tries to reuse source characters and builds up substrings;
                            // however, it starts at the 'tokenPos' which includes the '#', and will "accidentally" prepend the '#' for us.
                            scanIdentifier(charAfterHash, languageVersion);
                        }
                        else {
                            tokenValue = "#";
                            error(ts.Diagnostics.Invalid_character, pos++, charSize(ch));
                        }
                        return token = 80 /* SyntaxKind.PrivateIdentifier */;
                    default:
                        var identifierKind = scanIdentifier(ch, languageVersion);
                        if (identifierKind) {
                            return token = identifierKind;
                        }
                        else if (isWhiteSpaceSingleLine(ch)) {
                            pos += charSize(ch);
                            continue;
                        }
                        else if (isLineBreak(ch)) {
                            tokenFlags |= 1 /* TokenFlags.PrecedingLineBreak */;
                            pos += charSize(ch);
                            continue;
                        }
                        var size = charSize(ch);
                        error(ts.Diagnostics.Invalid_character, pos, size);
                        pos += size;
                        return token = 0 /* SyntaxKind.Unknown */;
                }
            }
        }
        function reScanInvalidIdentifier() {
            ts.Debug.assert(token === 0 /* SyntaxKind.Unknown */, "'reScanInvalidIdentifier' should only be called when the current token is 'SyntaxKind.Unknown'.");
            pos = tokenPos = startPos;
            tokenFlags = 0;
            var ch = codePointAt(text, pos);
            var identifierKind = scanIdentifier(ch, 99 /* ScriptTarget.ESNext */);
            if (identifierKind) {
                return token = identifierKind;
            }
            pos += charSize(ch);
            return token; // Still `SyntaKind.Unknown`
        }
        function scanIdentifier(startCharacter, languageVersion) {
            var ch = startCharacter;
            if (isIdentifierStart(ch, languageVersion)) {
                pos += charSize(ch);
                while (pos < end && isIdentifierPart(ch = codePointAt(text, pos), languageVersion))
                    pos += charSize(ch);
                tokenValue = text.substring(tokenPos, pos);
                if (ch === 92 /* CharacterCodes.backslash */) {
                    tokenValue += scanIdentifierParts();
                }
                return getIdentifierToken();
            }
        }
        function reScanGreaterToken() {
            if (token === 31 /* SyntaxKind.GreaterThanToken */) {
                if (text.charCodeAt(pos) === 62 /* CharacterCodes.greaterThan */) {
                    if (text.charCodeAt(pos + 1) === 62 /* CharacterCodes.greaterThan */) {
                        if (text.charCodeAt(pos + 2) === 61 /* CharacterCodes.equals */) {
                            return pos += 3, token = 72 /* SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken */;
                        }
                        return pos += 2, token = 49 /* SyntaxKind.GreaterThanGreaterThanGreaterThanToken */;
                    }
                    if (text.charCodeAt(pos + 1) === 61 /* CharacterCodes.equals */) {
                        return pos += 2, token = 71 /* SyntaxKind.GreaterThanGreaterThanEqualsToken */;
                    }
                    pos++;
                    return token = 48 /* SyntaxKind.GreaterThanGreaterThanToken */;
                }
                if (text.charCodeAt(pos) === 61 /* CharacterCodes.equals */) {
                    pos++;
                    return token = 33 /* SyntaxKind.GreaterThanEqualsToken */;
                }
            }
            return token;
        }
        function reScanAsteriskEqualsToken() {
            ts.Debug.assert(token === 66 /* SyntaxKind.AsteriskEqualsToken */, "'reScanAsteriskEqualsToken' should only be called on a '*='");
            pos = tokenPos + 1;
            return token = 63 /* SyntaxKind.EqualsToken */;
        }
        function reScanSlashToken() {
            if (token === 43 /* SyntaxKind.SlashToken */ || token === 68 /* SyntaxKind.SlashEqualsToken */) {
                var p = tokenPos + 1;
                var inEscape = false;
                var inCharacterClass = false;
                while (true) {
                    // If we reach the end of a file, or hit a newline, then this is an unterminated
                    // regex.  Report error and return what we have so far.
                    if (p >= end) {
                        tokenFlags |= 4 /* TokenFlags.Unterminated */;
                        error(ts.Diagnostics.Unterminated_regular_expression_literal);
                        break;
                    }
                    var ch = text.charCodeAt(p);
                    if (isLineBreak(ch)) {
                        tokenFlags |= 4 /* TokenFlags.Unterminated */;
                        error(ts.Diagnostics.Unterminated_regular_expression_literal);
                        break;
                    }
                    if (inEscape) {
                        // Parsing an escape character;
                        // reset the flag and just advance to the next char.
                        inEscape = false;
                    }
                    else if (ch === 47 /* CharacterCodes.slash */ && !inCharacterClass) {
                        // A slash within a character class is permissible,
                        // but in general it signals the end of the regexp literal.
                        p++;
                        break;
                    }
                    else if (ch === 91 /* CharacterCodes.openBracket */) {
                        inCharacterClass = true;
                    }
                    else if (ch === 92 /* CharacterCodes.backslash */) {
                        inEscape = true;
                    }
                    else if (ch === 93 /* CharacterCodes.closeBracket */) {
                        inCharacterClass = false;
                    }
                    p++;
                }
                while (p < end && isIdentifierPart(text.charCodeAt(p), languageVersion)) {
                    p++;
                }
                pos = p;
                tokenValue = text.substring(tokenPos, pos);
                token = 13 /* SyntaxKind.RegularExpressionLiteral */;
            }
            return token;
        }
        function appendIfCommentDirective(commentDirectives, text, commentDirectiveRegEx, lineStart) {
            var type = getDirectiveFromComment(ts.trimStringStart(text), commentDirectiveRegEx);
            if (type === undefined) {
                return commentDirectives;
            }
            return ts.append(commentDirectives, {
                range: { pos: lineStart, end: pos },
                type: type,
            });
        }
        function getDirectiveFromComment(text, commentDirectiveRegEx) {
            var match = commentDirectiveRegEx.exec(text);
            if (!match) {
                return undefined;
            }
            switch (match[1]) {
                case "ts-expect-error":
                    return 0 /* CommentDirectiveType.ExpectError */;
                case "ts-ignore":
                    return 1 /* CommentDirectiveType.Ignore */;
            }
            return undefined;
        }
        /**
         * Unconditionally back up and scan a template expression portion.
         */
        function reScanTemplateToken(isTaggedTemplate) {
            ts.Debug.assert(token === 19 /* SyntaxKind.CloseBraceToken */, "'reScanTemplateToken' should only be called on a '}'");
            pos = tokenPos;
            return token = scanTemplateAndSetTokenValue(isTaggedTemplate);
        }
        function reScanTemplateHeadOrNoSubstitutionTemplate() {
            pos = tokenPos;
            return token = scanTemplateAndSetTokenValue(/* isTaggedTemplate */ true);
        }
        function reScanJsxToken(allowMultilineJsxText) {
            if (allowMultilineJsxText === void 0) { allowMultilineJsxText = true; }
            pos = tokenPos = startPos;
            return token = scanJsxToken(allowMultilineJsxText);
        }
        function reScanLessThanToken() {
            if (token === 47 /* SyntaxKind.LessThanLessThanToken */) {
                pos = tokenPos + 1;
                return token = 29 /* SyntaxKind.LessThanToken */;
            }
            return token;
        }
        function reScanHashToken() {
            if (token === 80 /* SyntaxKind.PrivateIdentifier */) {
                pos = tokenPos + 1;
                return token = 62 /* SyntaxKind.HashToken */;
            }
            return token;
        }
        function reScanQuestionToken() {
            ts.Debug.assert(token === 60 /* SyntaxKind.QuestionQuestionToken */, "'reScanQuestionToken' should only be called on a '??'");
            pos = tokenPos + 1;
            return token = 57 /* SyntaxKind.QuestionToken */;
        }
        function scanJsxToken(allowMultilineJsxText) {
            if (allowMultilineJsxText === void 0) { allowMultilineJsxText = true; }
            startPos = tokenPos = pos;
            if (pos >= end) {
                return token = 1 /* SyntaxKind.EndOfFileToken */;
            }
            var char = text.charCodeAt(pos);
            if (char === 60 /* CharacterCodes.lessThan */) {
                if (text.charCodeAt(pos + 1) === 47 /* CharacterCodes.slash */) {
                    pos += 2;
                    return token = 30 /* SyntaxKind.LessThanSlashToken */;
                }
                pos++;
                return token = 29 /* SyntaxKind.LessThanToken */;
            }
            if (char === 123 /* CharacterCodes.openBrace */) {
                pos++;
                return token = 18 /* SyntaxKind.OpenBraceToken */;
            }
            // First non-whitespace character on this line.
            var firstNonWhitespace = 0;
            // These initial values are special because the first line is:
            // firstNonWhitespace = 0 to indicate that we want leading whitespace,
            while (pos < end) {
                char = text.charCodeAt(pos);
                if (char === 123 /* CharacterCodes.openBrace */) {
                    break;
                }
                if (char === 60 /* CharacterCodes.lessThan */) {
                    if (isConflictMarkerTrivia(text, pos)) {
                        pos = scanConflictMarkerTrivia(text, pos, error);
                        return token = 7 /* SyntaxKind.ConflictMarkerTrivia */;
                    }
                    break;
                }
                if (char === 62 /* CharacterCodes.greaterThan */) {
                    error(ts.Diagnostics.Unexpected_token_Did_you_mean_or_gt, pos, 1);
                }
                if (char === 125 /* CharacterCodes.closeBrace */) {
                    error(ts.Diagnostics.Unexpected_token_Did_you_mean_or_rbrace, pos, 1);
                }
                // FirstNonWhitespace is 0, then we only see whitespaces so far. If we see a linebreak, we want to ignore that whitespaces.
                // i.e (- : whitespace)
                //      <div>----
                //      </div> becomes <div></div>
                //
                //      <div>----</div> becomes <div>----</div>
                if (isLineBreak(char) && firstNonWhitespace === 0) {
                    firstNonWhitespace = -1;
                }
                else if (!allowMultilineJsxText && isLineBreak(char) && firstNonWhitespace > 0) {
                    // Stop JsxText on each line during formatting. This allows the formatter to
                    // indent each line correctly.
                    break;
                }
                else if (!isWhiteSpaceLike(char)) {
                    firstNonWhitespace = pos;
                }
                pos++;
            }
            tokenValue = text.substring(startPos, pos);
            return firstNonWhitespace === -1 ? 12 /* SyntaxKind.JsxTextAllWhiteSpaces */ : 11 /* SyntaxKind.JsxText */;
        }
        // Scans a JSX identifier; these differ from normal identifiers in that
        // they allow dashes
        function scanJsxIdentifier() {
            if (tokenIsIdentifierOrKeyword(token)) {
                // An identifier or keyword has already been parsed - check for a `-` or a single instance of `:` and then append it and
                // everything after it to the token
                // Do note that this means that `scanJsxIdentifier` effectively _mutates_ the visible token without advancing to a new token
                // Any caller should be expecting this behavior and should only read the pos or token value after calling it.
                var namespaceSeparator = false;
                while (pos < end) {
                    var ch = text.charCodeAt(pos);
                    if (ch === 45 /* CharacterCodes.minus */) {
                        tokenValue += "-";
                        pos++;
                        continue;
                    }
                    else if (ch === 58 /* CharacterCodes.colon */ && !namespaceSeparator) {
                        tokenValue += ":";
                        pos++;
                        namespaceSeparator = true;
                        token = 79 /* SyntaxKind.Identifier */; // swap from keyword kind to identifier kind
                        continue;
                    }
                    var oldPos = pos;
                    tokenValue += scanIdentifierParts(); // reuse `scanIdentifierParts` so unicode escapes are handled
                    if (pos === oldPos) {
                        break;
                    }
                }
                // Do not include a trailing namespace separator in the token, since this is against the spec.
                if (tokenValue.slice(-1) === ":") {
                    tokenValue = tokenValue.slice(0, -1);
                    pos--;
                }
                return getIdentifierToken();
            }
            return token;
        }
        function scanJsxAttributeValue() {
            startPos = pos;
            switch (text.charCodeAt(pos)) {
                case 34 /* CharacterCodes.doubleQuote */:
                case 39 /* CharacterCodes.singleQuote */:
                    tokenValue = scanString(/*jsxAttributeString*/ true);
                    return token = 10 /* SyntaxKind.StringLiteral */;
                default:
                    // If this scans anything other than `{`, it's a parse error.
                    return scan();
            }
        }
        function reScanJsxAttributeValue() {
            pos = tokenPos = startPos;
            return scanJsxAttributeValue();
        }
        function scanJsDocToken() {
            startPos = tokenPos = pos;
            tokenFlags = 0 /* TokenFlags.None */;
            if (pos >= end) {
                return token = 1 /* SyntaxKind.EndOfFileToken */;
            }
            var ch = codePointAt(text, pos);
            pos += charSize(ch);
            switch (ch) {
                case 9 /* CharacterCodes.tab */:
                case 11 /* CharacterCodes.verticalTab */:
                case 12 /* CharacterCodes.formFeed */:
                case 32 /* CharacterCodes.space */:
                    while (pos < end && isWhiteSpaceSingleLine(text.charCodeAt(pos))) {
                        pos++;
                    }
                    return token = 5 /* SyntaxKind.WhitespaceTrivia */;
                case 64 /* CharacterCodes.at */:
                    return token = 59 /* SyntaxKind.AtToken */;
                case 13 /* CharacterCodes.carriageReturn */:
                    if (text.charCodeAt(pos) === 10 /* CharacterCodes.lineFeed */) {
                        pos++;
                    }
                // falls through
                case 10 /* CharacterCodes.lineFeed */:
                    tokenFlags |= 1 /* TokenFlags.PrecedingLineBreak */;
                    return token = 4 /* SyntaxKind.NewLineTrivia */;
                case 42 /* CharacterCodes.asterisk */:
                    return token = 41 /* SyntaxKind.AsteriskToken */;
                case 123 /* CharacterCodes.openBrace */:
                    return token = 18 /* SyntaxKind.OpenBraceToken */;
                case 125 /* CharacterCodes.closeBrace */:
                    return token = 19 /* SyntaxKind.CloseBraceToken */;
                case 91 /* CharacterCodes.openBracket */:
                    return token = 22 /* SyntaxKind.OpenBracketToken */;
                case 93 /* CharacterCodes.closeBracket */:
                    return token = 23 /* SyntaxKind.CloseBracketToken */;
                case 60 /* CharacterCodes.lessThan */:
                    return token = 29 /* SyntaxKind.LessThanToken */;
                case 62 /* CharacterCodes.greaterThan */:
                    return token = 31 /* SyntaxKind.GreaterThanToken */;
                case 61 /* CharacterCodes.equals */:
                    return token = 63 /* SyntaxKind.EqualsToken */;
                case 44 /* CharacterCodes.comma */:
                    return token = 27 /* SyntaxKind.CommaToken */;
                case 46 /* CharacterCodes.dot */:
                    return token = 24 /* SyntaxKind.DotToken */;
                case 96 /* CharacterCodes.backtick */:
                    return token = 61 /* SyntaxKind.BacktickToken */;
                case 35 /* CharacterCodes.hash */:
                    return token = 62 /* SyntaxKind.HashToken */;
                case 92 /* CharacterCodes.backslash */:
                    pos--;
                    var extendedCookedChar = peekExtendedUnicodeEscape();
                    if (extendedCookedChar >= 0 && isIdentifierStart(extendedCookedChar, languageVersion)) {
                        pos += 3;
                        tokenFlags |= 8 /* TokenFlags.ExtendedUnicodeEscape */;
                        tokenValue = scanExtendedUnicodeEscape() + scanIdentifierParts();
                        return token = getIdentifierToken();
                    }
                    var cookedChar = peekUnicodeEscape();
                    if (cookedChar >= 0 && isIdentifierStart(cookedChar, languageVersion)) {
                        pos += 6;
                        tokenFlags |= 1024 /* TokenFlags.UnicodeEscape */;
                        tokenValue = String.fromCharCode(cookedChar) + scanIdentifierParts();
                        return token = getIdentifierToken();
                    }
                    pos++;
                    return token = 0 /* SyntaxKind.Unknown */;
            }
            if (isIdentifierStart(ch, languageVersion)) {
                var char = ch;
                while (pos < end && isIdentifierPart(char = codePointAt(text, pos), languageVersion) || text.charCodeAt(pos) === 45 /* CharacterCodes.minus */)
                    pos += charSize(char);
                tokenValue = text.substring(tokenPos, pos);
                if (char === 92 /* CharacterCodes.backslash */) {
                    tokenValue += scanIdentifierParts();
                }
                return token = getIdentifierToken();
            }
            else {
                return token = 0 /* SyntaxKind.Unknown */;
            }
        }
        function speculationHelper(callback, isLookahead) {
            var savePos = pos;
            var saveStartPos = startPos;
            var saveTokenPos = tokenPos;
            var saveToken = token;
            var saveTokenValue = tokenValue;
            var saveTokenFlags = tokenFlags;
            var result = callback();
            // If our callback returned something 'falsy' or we're just looking ahead,
            // then unconditionally restore us to where we were.
            if (!result || isLookahead) {
                pos = savePos;
                startPos = saveStartPos;
                tokenPos = saveTokenPos;
                token = saveToken;
                tokenValue = saveTokenValue;
                tokenFlags = saveTokenFlags;
            }
            return result;
        }
        function scanRange(start, length, callback) {
            var saveEnd = end;
            var savePos = pos;
            var saveStartPos = startPos;
            var saveTokenPos = tokenPos;
            var saveToken = token;
            var saveTokenValue = tokenValue;
            var saveTokenFlags = tokenFlags;
            var saveErrorExpectations = commentDirectives;
            setText(text, start, length);
            var result = callback();
            end = saveEnd;
            pos = savePos;
            startPos = saveStartPos;
            tokenPos = saveTokenPos;
            token = saveToken;
            tokenValue = saveTokenValue;
            tokenFlags = saveTokenFlags;
            commentDirectives = saveErrorExpectations;
            return result;
        }
        function lookAhead(callback) {
            return speculationHelper(callback, /*isLookahead*/ true);
        }
        function tryScan(callback) {
            return speculationHelper(callback, /*isLookahead*/ false);
        }
        function getText() {
            return text;
        }
        function clearCommentDirectives() {
            commentDirectives = undefined;
        }
        function setText(newText, start, length) {
            text = newText || "";
            end = length === undefined ? text.length : start + length;
            setTextPos(start || 0);
        }
        function setOnError(errorCallback) {
            onError = errorCallback;
        }
        function setScriptTarget(scriptTarget) {
            languageVersion = scriptTarget;
        }
        function setLanguageVariant(variant) {
            languageVariant = variant;
        }
        function setTextPos(textPos) {
            ts.Debug.assert(textPos >= 0);
            pos = textPos;
            startPos = textPos;
            tokenPos = textPos;
            token = 0 /* SyntaxKind.Unknown */;
            tokenValue = undefined;
            tokenFlags = 0 /* TokenFlags.None */;
        }
        function setInJSDocType(inType) {
            inJSDocType += inType ? 1 : -1;
        }
    }
    ts.createScanner = createScanner;
    /* @internal */
    var codePointAt = String.prototype.codePointAt ? function (s, i) { return s.codePointAt(i); } : function codePointAt(str, i) {
        // from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt
        var size = str.length;
        // Account for out-of-bounds indices:
        if (i < 0 || i >= size) {
            return undefined; // String.codePointAt returns `undefined` for OOB indexes
        }
        // Get the first code unit
        var first = str.charCodeAt(i);
        // check if it’s the start of a surrogate pair
        if (first >= 0xD800 && first <= 0xDBFF && size > i + 1) { // high surrogate and there is a next code unit
            var second = str.charCodeAt(i + 1);
            if (second >= 0xDC00 && second <= 0xDFFF) { // low surrogate
                // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
                return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
            }
        }
        return first;
    };
    /* @internal */
    function charSize(ch) {
        if (ch >= 0x10000) {
            return 2;
        }
        return 1;
    }
    // Derived from the 10.1.1 UTF16Encoding of the ES6 Spec.
    function utf16EncodeAsStringFallback(codePoint) {
        ts.Debug.assert(0x0 <= codePoint && codePoint <= 0x10FFFF);
        if (codePoint <= 65535) {
            return String.fromCharCode(codePoint);
        }
        var codeUnit1 = Math.floor((codePoint - 65536) / 1024) + 0xD800;
        var codeUnit2 = ((codePoint - 65536) % 1024) + 0xDC00;
        return String.fromCharCode(codeUnit1, codeUnit2);
    }
    var utf16EncodeAsStringWorker = String.fromCodePoint ? function (codePoint) { return String.fromCodePoint(codePoint); } : utf16EncodeAsStringFallback;
    /* @internal */
    function utf16EncodeAsString(codePoint) {
        return utf16EncodeAsStringWorker(codePoint);
    }
    ts.utf16EncodeAsString = utf16EncodeAsString;
})(ts || (ts = {}));
var ts;
(function (ts) {
    function isExternalModuleNameRelative(moduleName) {
        // TypeScript 1.0 spec (April 2014): 11.2.1
        // An external module name is "relative" if the first term is "." or "..".
        // Update: We also consider a path like `C:\foo.ts` "relative" because we do not search for it in `node_modules` or treat it as an ambient module.
        return ts.pathIsRelative(moduleName) || ts.isRootedDiskPath(moduleName);
    }
    ts.isExternalModuleNameRelative = isExternalModuleNameRelative;
    function sortAndDeduplicateDiagnostics(diagnostics) {
        return ts.sortAndDeduplicate(diagnostics, ts.compareDiagnostics);
    }
    ts.sortAndDeduplicateDiagnostics = sortAndDeduplicateDiagnostics;
    function getDefaultLibFileName(options) {
        switch (ts.getEmitScriptTarget(options)) {
            case 99 /* ScriptTarget.ESNext */:
                return "lib.esnext.full.d.ts";
            case 9 /* ScriptTarget.ES2022 */:
                return "lib.es2022.full.d.ts";
            case 8 /* ScriptTarget.ES2021 */:
                return "lib.es2021.full.d.ts";
            case 7 /* ScriptTarget.ES2020 */:
                return "lib.es2020.full.d.ts";
            case 6 /* ScriptTarget.ES2019 */:
                return "lib.es2019.full.d.ts";
            case 5 /* ScriptTarget.ES2018 */:
                return "lib.es2018.full.d.ts";
            case 4 /* ScriptTarget.ES2017 */:
                return "lib.es2017.full.d.ts";
            case 3 /* ScriptTarget.ES2016 */:
                return "lib.es2016.full.d.ts";
            case 2 /* ScriptTarget.ES2015 */:
                return "lib.es6.d.ts"; // We don't use lib.es2015.full.d.ts due to breaking change.
            default:
                return "lib.d.ts";
        }
    }
    ts.getDefaultLibFileName = getDefaultLibFileName;
    function textSpanEnd(span) {
        return span.start + span.length;
    }
    ts.textSpanEnd = textSpanEnd;
    function textSpanIsEmpty(span) {
        return span.length === 0;
    }
    ts.textSpanIsEmpty = textSpanIsEmpty;
    function textSpanContainsPosition(span, position) {
        return position >= span.start && position < textSpanEnd(span);
    }
    ts.textSpanContainsPosition = textSpanContainsPosition;
    /* @internal */
    function textRangeContainsPositionInclusive(span, position) {
        return position >= span.pos && position <= span.end;
    }
    ts.textRangeContainsPositionInclusive = textRangeContainsPositionInclusive;
    // Returns true if 'span' contains 'other'.
    function textSpanContainsTextSpan(span, other) {
        return other.start >= span.start && textSpanEnd(other) <= textSpanEnd(span);
    }
    ts.textSpanContainsTextSpan = textSpanContainsTextSpan;
    function textSpanOverlapsWith(span, other) {
        return textSpanOverlap(span, other) !== undefined;
    }
    ts.textSpanOverlapsWith = textSpanOverlapsWith;
    function textSpanOverlap(span1, span2) {
        var overlap = textSpanIntersection(span1, span2);
        return overlap && overlap.length === 0 ? undefined : overlap;
    }
    ts.textSpanOverlap = textSpanOverlap;
    function textSpanIntersectsWithTextSpan(span, other) {
        return decodedTextSpanIntersectsWith(span.start, span.length, other.start, other.length);
    }
    ts.textSpanIntersectsWithTextSpan = textSpanIntersectsWithTextSpan;
    function textSpanIntersectsWith(span, start, length) {
        return decodedTextSpanIntersectsWith(span.start, span.length, start, length);
    }
    ts.textSpanIntersectsWith = textSpanIntersectsWith;
    function decodedTextSpanIntersectsWith(start1, length1, start2, length2) {
        var end1 = start1 + length1;
        var end2 = start2 + length2;
        return start2 <= end1 && end2 >= start1;
    }
    ts.decodedTextSpanIntersectsWith = decodedTextSpanIntersectsWith;
    function textSpanIntersectsWithPosition(span, position) {
        return position <= textSpanEnd(span) && position >= span.start;
    }
    ts.textSpanIntersectsWithPosition = textSpanIntersectsWithPosition;
    function textSpanIntersection(span1, span2) {
        var start = Math.max(span1.start, span2.start);
        var end = Math.min(textSpanEnd(span1), textSpanEnd(span2));
        return start <= end ? createTextSpanFromBounds(start, end) : undefined;
    }
    ts.textSpanIntersection = textSpanIntersection;
    function createTextSpan(start, length) {
        if (start < 0) {
            throw new Error("start < 0");
        }
        if (length < 0) {
            throw new Error("length < 0");
        }
        return { start: start, length: length };
    }
    ts.createTextSpan = createTextSpan;
    function createTextSpanFromBounds(start, end) {
        return createTextSpan(start, end - start);
    }
    ts.createTextSpanFromBounds = createTextSpanFromBounds;
    function textChangeRangeNewSpan(range) {
        return createTextSpan(range.span.start, range.newLength);
    }
    ts.textChangeRangeNewSpan = textChangeRangeNewSpan;
    function textChangeRangeIsUnchanged(range) {
        return textSpanIsEmpty(range.span) && range.newLength === 0;
    }
    ts.textChangeRangeIsUnchanged = textChangeRangeIsUnchanged;
    function createTextChangeRange(span, newLength) {
        if (newLength < 0) {
            throw new Error("newLength < 0");
        }
        return { span: span, newLength: newLength };
    }
    ts.createTextChangeRange = createTextChangeRange;
    ts.unchangedTextChangeRange = createTextChangeRange(createTextSpan(0, 0), 0); // eslint-disable-line prefer-const
    /**
     * Called to merge all the changes that occurred across several versions of a script snapshot
     * into a single change.  i.e. if a user keeps making successive edits to a script we will
     * have a text change from V1 to V2, V2 to V3, ..., Vn.
     *
     * This function will then merge those changes into a single change range valid between V1 and
     * Vn.
     */
    function collapseTextChangeRangesAcrossMultipleVersions(changes) {
        if (changes.length === 0) {
            return ts.unchangedTextChangeRange;
        }
        if (changes.length === 1) {
            return changes[0];
        }
        // We change from talking about { { oldStart, oldLength }, newLength } to { oldStart, oldEnd, newEnd }
        // as it makes things much easier to reason about.
        var change0 = changes[0];
        var oldStartN = change0.span.start;
        var oldEndN = textSpanEnd(change0.span);
        var newEndN = oldStartN + change0.newLength;
        for (var i = 1; i < changes.length; i++) {
            var nextChange = changes[i];
            // Consider the following case:
            // i.e. two edits.  The first represents the text change range { { 10, 50 }, 30 }.  i.e. The span starting
            // at 10, with length 50 is reduced to length 30.  The second represents the text change range { { 30, 30 }, 40 }.
            // i.e. the span starting at 30 with length 30 is increased to length 40.
            //
            //      0         10        20        30        40        50        60        70        80        90        100
            //      -------------------------------------------------------------------------------------------------------
            //                |                                                 /
            //                |                                            /----
            //  T1            |                                       /----
            //                |                                  /----
            //                |                             /----
            //      -------------------------------------------------------------------------------------------------------
            //                                     |                            \
            //                                     |                               \
            //   T2                                |                                 \
            //                                     |                                   \
            //                                     |                                      \
            //      -------------------------------------------------------------------------------------------------------
            //
            // Merging these turns out to not be too difficult.  First, determining the new start of the change is trivial
            // it's just the min of the old and new starts.  i.e.:
            //
            //      0         10        20        30        40        50        60        70        80        90        100
            //      ------------------------------------------------------------*------------------------------------------
            //                |                                                 /
            //                |                                            /----
            //  T1            |                                       /----
            //                |                                  /----
            //                |                             /----
            //      ----------------------------------------$-------------------$------------------------------------------
            //                .                    |                            \
            //                .                    |                               \
            //   T2           .                    |                                 \
            //                .                    |                                   \
            //                .                    |                                      \
            //      ----------------------------------------------------------------------*--------------------------------
            //
            // (Note the dots represent the newly inferred start.
            // Determining the new and old end is also pretty simple.  Basically it boils down to paying attention to the
            // absolute positions at the asterisks, and the relative change between the dollar signs. Basically, we see
            // which if the two $'s precedes the other, and we move that one forward until they line up.  in this case that
            // means:
            //
            //      0         10        20        30        40        50        60        70        80        90        100
            //      --------------------------------------------------------------------------------*----------------------
            //                |                                                                     /
            //                |                                                                /----
            //  T1            |                                                           /----
            //                |                                                      /----
            //                |                                                 /----
            //      ------------------------------------------------------------$------------------------------------------
            //                .                    |                            \
            //                .                    |                               \
            //   T2           .                    |                                 \
            //                .                    |                                   \
            //                .                    |                                      \
            //      ----------------------------------------------------------------------*--------------------------------
            //
            // In other words (in this case), we're recognizing that the second edit happened after where the first edit
            // ended with a delta of 20 characters (60 - 40).  Thus, if we go back in time to where the first edit started
            // that's the same as if we started at char 80 instead of 60.
            //
            // As it so happens, the same logic applies if the second edit precedes the first edit.  In that case rather
            // than pushing the first edit forward to match the second, we'll push the second edit forward to match the
            // first.
            //
            // In this case that means we have { oldStart: 10, oldEnd: 80, newEnd: 70 } or, in TextChangeRange
            // semantics: { { start: 10, length: 70 }, newLength: 60 }
            //
            // The math then works out as follows.
            // If we have { oldStart1, oldEnd1, newEnd1 } and { oldStart2, oldEnd2, newEnd2 } then we can compute the
            // final result like so:
            //
            // {
            //      oldStart3: Min(oldStart1, oldStart2),
            //      oldEnd3: Max(oldEnd1, oldEnd1 + (oldEnd2 - newEnd1)),
            //      newEnd3: Max(newEnd2, newEnd2 + (newEnd1 - oldEnd2))
            // }
            var oldStart1 = oldStartN;
            var oldEnd1 = oldEndN;
            var newEnd1 = newEndN;
            var oldStart2 = nextChange.span.start;
            var oldEnd2 = textSpanEnd(nextChange.span);
            var newEnd2 = oldStart2 + nextChange.newLength;
            oldStartN = Math.min(oldStart1, oldStart2);
            oldEndN = Math.max(oldEnd1, oldEnd1 + (oldEnd2 - newEnd1));
            newEndN = Math.max(newEnd2, newEnd2 + (newEnd1 - oldEnd2));
        }
        return createTextChangeRange(createTextSpanFromBounds(oldStartN, oldEndN), /*newLength*/ newEndN - oldStartN);
    }
    ts.collapseTextChangeRangesAcrossMultipleVersions = collapseTextChangeRangesAcrossMultipleVersions;
    function getTypeParameterOwner(d) {
        if (d && d.kind === 165 /* SyntaxKind.TypeParameter */) {
            for (var current = d; current; current = current.parent) {
                if (isFunctionLike(current) || isClassLike(current) || current.kind === 261 /* SyntaxKind.InterfaceDeclaration */) {
                    return current;
                }
            }
        }
    }
    ts.getTypeParameterOwner = getTypeParameterOwner;
    function isParameterPropertyDeclaration(node, parent) {
        return ts.hasSyntacticModifier(node, 16476 /* ModifierFlags.ParameterPropertyModifier */) && parent.kind === 173 /* SyntaxKind.Constructor */;
    }
    ts.isParameterPropertyDeclaration = isParameterPropertyDeclaration;
    function isEmptyBindingPattern(node) {
        if (isBindingPattern(node)) {
            return ts.every(node.elements, isEmptyBindingElement);
        }
        return false;
    }
    ts.isEmptyBindingPattern = isEmptyBindingPattern;
    function isEmptyBindingElement(node) {
        if (ts.isOmittedExpression(node)) {
            return true;
        }
        return isEmptyBindingPattern(node.name);
    }
    ts.isEmptyBindingElement = isEmptyBindingElement;
    function walkUpBindingElementsAndPatterns(binding) {
        var node = binding.parent;
        while (ts.isBindingElement(node.parent)) {
            node = node.parent.parent;
        }
        return node.parent;
    }
    ts.walkUpBindingElementsAndPatterns = walkUpBindingElementsAndPatterns;
    function getCombinedFlags(node, getFlags) {
        if (ts.isBindingElement(node)) {
            node = walkUpBindingElementsAndPatterns(node);
        }
        var flags = getFlags(node);
        if (node.kind === 257 /* SyntaxKind.VariableDeclaration */) {
            node = node.parent;
        }
        if (node && node.kind === 258 /* SyntaxKind.VariableDeclarationList */) {
            flags |= getFlags(node);
            node = node.parent;
        }
        if (node && node.kind === 240 /* SyntaxKind.VariableStatement */) {
            flags |= getFlags(node);
        }
        return flags;
    }
    function getCombinedModifierFlags(node) {
        return getCombinedFlags(node, ts.getEffectiveModifierFlags);
    }
    ts.getCombinedModifierFlags = getCombinedModifierFlags;
    /* @internal */
    function getCombinedNodeFlagsAlwaysIncludeJSDoc(node) {
        return getCombinedFlags(node, ts.getEffectiveModifierFlagsAlwaysIncludeJSDoc);
    }
    ts.getCombinedNodeFlagsAlwaysIncludeJSDoc = getCombinedNodeFlagsAlwaysIncludeJSDoc;
    // Returns the node flags for this node and all relevant parent nodes.  This is done so that
    // nodes like variable declarations and binding elements can returned a view of their flags
    // that includes the modifiers from their container.  i.e. flags like export/declare aren't
    // stored on the variable declaration directly, but on the containing variable statement
    // (if it has one).  Similarly, flags for let/const are stored on the variable declaration
    // list.  By calling this function, all those flags are combined so that the client can treat
    // the node as if it actually had those flags.
    function getCombinedNodeFlags(node) {
        return getCombinedFlags(node, function (n) { return n.flags; });
    }
    ts.getCombinedNodeFlags = getCombinedNodeFlags;
    /* @internal */
    ts.supportedLocaleDirectories = ["cs", "de", "es", "fr", "it", "ja", "ko", "pl", "pt-br", "ru", "tr", "zh-cn", "zh-tw"];
    /**
     * Checks to see if the locale is in the appropriate format,
     * and if it is, attempts to set the appropriate language.
     */
    function validateLocaleAndSetLanguage(locale, sys, errors) {
        var lowerCaseLocale = locale.toLowerCase();
        var matchResult = /^([a-z]+)([_\-]([a-z]+))?$/.exec(lowerCaseLocale);
        if (!matchResult) {
            if (errors) {
                errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.Locale_must_be_of_the_form_language_or_language_territory_For_example_0_or_1, "en", "ja-jp"));
            }
            return;
        }
        var language = matchResult[1];
        var territory = matchResult[3];
        // First try the entire locale, then fall back to just language if that's all we have.
        // Either ways do not fail, and fallback to the English diagnostic strings.
        if (ts.contains(ts.supportedLocaleDirectories, lowerCaseLocale) && !trySetLanguageAndTerritory(language, territory, errors)) {
            trySetLanguageAndTerritory(language, /*territory*/ undefined, errors);
        }
        // Set the UI locale for string collation
        ts.setUILocale(locale);
        function trySetLanguageAndTerritory(language, territory, errors) {
            var compilerFilePath = ts.normalizePath(sys.getExecutingFilePath());
            var containingDirectoryPath = ts.getDirectoryPath(compilerFilePath);
            var filePath = ts.combinePaths(containingDirectoryPath, language);
            if (territory) {
                filePath = filePath + "-" + territory;
            }
            filePath = sys.resolvePath(ts.combinePaths(filePath, "diagnosticMessages.generated.json"));
            if (!sys.fileExists(filePath)) {
                return false;
            }
            // TODO: Add codePage support for readFile?
            var fileContents = "";
            try {
                fileContents = sys.readFile(filePath);
            }
            catch (e) {
                if (errors) {
                    errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.Unable_to_open_file_0, filePath));
                }
                return false;
            }
            try {
                // this is a global mutation (or live binding update)!
                ts.setLocalizedDiagnosticMessages(JSON.parse(fileContents));
            }
            catch (_a) {
                if (errors) {
                    errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.Corrupted_locale_file_0, filePath));
                }
                return false;
            }
            return true;
        }
    }
    ts.validateLocaleAndSetLanguage = validateLocaleAndSetLanguage;
    function getOriginalNode(node, nodeTest) {
        if (node) {
            while (node.original !== undefined) {
                node = node.original;
            }
        }
        return !nodeTest || nodeTest(node) ? node : undefined;
    }
    ts.getOriginalNode = getOriginalNode;
    function findAncestor(node, callback) {
        while (node) {
            var result = callback(node);
            if (result === "quit") {
                return undefined;
            }
            else if (result) {
                return node;
            }
            node = node.parent;
        }
        return undefined;
    }
    ts.findAncestor = findAncestor;
    /**
     * Gets a value indicating whether a node originated in the parse tree.
     *
     * @param node The node to test.
     */
    function isParseTreeNode(node) {
        return (node.flags & 8 /* NodeFlags.Synthesized */) === 0;
    }
    ts.isParseTreeNode = isParseTreeNode;
    function getParseTreeNode(node, nodeTest) {
        if (node === undefined || isParseTreeNode(node)) {
            return node;
        }
        node = node.original;
        while (node) {
            if (isParseTreeNode(node)) {
                return !nodeTest || nodeTest(node) ? node : undefined;
            }
            node = node.original;
        }
    }
    ts.getParseTreeNode = getParseTreeNode;
    /** Add an extra underscore to identifiers that start with two underscores to avoid issues with magic names like '__proto__' */
    function escapeLeadingUnderscores(identifier) {
        return (identifier.length >= 2 && identifier.charCodeAt(0) === 95 /* CharacterCodes._ */ && identifier.charCodeAt(1) === 95 /* CharacterCodes._ */ ? "_" + identifier : identifier);
    }
    ts.escapeLeadingUnderscores = escapeLeadingUnderscores;
    /**
     * Remove extra underscore from escaped identifier text content.
     *
     * @param identifier The escaped identifier text.
     * @returns The unescaped identifier text.
     */
    function unescapeLeadingUnderscores(identifier) {
        var id = identifier;
        return id.length >= 3 && id.charCodeAt(0) === 95 /* CharacterCodes._ */ && id.charCodeAt(1) === 95 /* CharacterCodes._ */ && id.charCodeAt(2) === 95 /* CharacterCodes._ */ ? id.substr(1) : id;
    }
    ts.unescapeLeadingUnderscores = unescapeLeadingUnderscores;
    function idText(identifierOrPrivateName) {
        return unescapeLeadingUnderscores(identifierOrPrivateName.escapedText);
    }
    ts.idText = idText;
    function symbolName(symbol) {
        if (symbol.valueDeclaration && isPrivateIdentifierClassElementDeclaration(symbol.valueDeclaration)) {
            return idText(symbol.valueDeclaration.name);
        }
        return unescapeLeadingUnderscores(symbol.escapedName);
    }
    ts.symbolName = symbolName;
    /**
     * A JSDocTypedef tag has an _optional_ name field - if a name is not directly present, we should
     * attempt to draw the name from the node the declaration is on (as that declaration is what its' symbol
     * will be merged with)
     */
    function nameForNamelessJSDocTypedef(declaration) {
        var hostNode = declaration.parent.parent;
        if (!hostNode) {
            return undefined;
        }
        // Covers classes, functions - any named declaration host node
        if (isDeclaration(hostNode)) {
            return getDeclarationIdentifier(hostNode);
        }
        // Covers remaining cases (returning undefined if none match).
        switch (hostNode.kind) {
            case 240 /* SyntaxKind.VariableStatement */:
                if (hostNode.declarationList && hostNode.declarationList.declarations[0]) {
                    return getDeclarationIdentifier(hostNode.declarationList.declarations[0]);
                }
                break;
            case 241 /* SyntaxKind.ExpressionStatement */:
                var expr = hostNode.expression;
                if (expr.kind === 223 /* SyntaxKind.BinaryExpression */ && expr.operatorToken.kind === 63 /* SyntaxKind.EqualsToken */) {
                    expr = expr.left;
                }
                switch (expr.kind) {
                    case 208 /* SyntaxKind.PropertyAccessExpression */:
                        return expr.name;
                    case 209 /* SyntaxKind.ElementAccessExpression */:
                        var arg = expr.argumentExpression;
                        if (ts.isIdentifier(arg)) {
                            return arg;
                        }
                }
                break;
            case 214 /* SyntaxKind.ParenthesizedExpression */: {
                return getDeclarationIdentifier(hostNode.expression);
            }
            case 253 /* SyntaxKind.LabeledStatement */: {
                if (isDeclaration(hostNode.statement) || isExpression(hostNode.statement)) {
                    return getDeclarationIdentifier(hostNode.statement);
                }
                break;
            }
        }
    }
    function getDeclarationIdentifier(node) {
        var name = getNameOfDeclaration(node);
        return name && ts.isIdentifier(name) ? name : undefined;
    }
    /** @internal */
    function nodeHasName(statement, name) {
        if (isNamedDeclaration(statement) && ts.isIdentifier(statement.name) && idText(statement.name) === idText(name)) {
            return true;
        }
        if (ts.isVariableStatement(statement) && ts.some(statement.declarationList.declarations, function (d) { return nodeHasName(d, name); })) {
            return true;
        }
        return false;
    }
    ts.nodeHasName = nodeHasName;
    function getNameOfJSDocTypedef(declaration) {
        return declaration.name || nameForNamelessJSDocTypedef(declaration);
    }
    ts.getNameOfJSDocTypedef = getNameOfJSDocTypedef;
    /** @internal */
    function isNamedDeclaration(node) {
        return !!node.name; // A 'name' property should always be a DeclarationName.
    }
    ts.isNamedDeclaration = isNamedDeclaration;
    /** @internal */
    function getNonAssignedNameOfDeclaration(declaration) {
        switch (declaration.kind) {
            case 79 /* SyntaxKind.Identifier */:
                return declaration;
            case 350 /* SyntaxKind.JSDocPropertyTag */:
            case 343 /* SyntaxKind.JSDocParameterTag */: {
                var name = declaration.name;
                if (name.kind === 163 /* SyntaxKind.QualifiedName */) {
                    return name.right;
                }
                break;
            }
            case 210 /* SyntaxKind.CallExpression */:
            case 223 /* SyntaxKind.BinaryExpression */: {
                var expr_1 = declaration;
                switch (ts.getAssignmentDeclarationKind(expr_1)) {
                    case 1 /* AssignmentDeclarationKind.ExportsProperty */:
                    case 4 /* AssignmentDeclarationKind.ThisProperty */:
                    case 5 /* AssignmentDeclarationKind.Property */:
                    case 3 /* AssignmentDeclarationKind.PrototypeProperty */:
                        return ts.getElementOrPropertyAccessArgumentExpressionOrName(expr_1.left);
                    case 7 /* AssignmentDeclarationKind.ObjectDefinePropertyValue */:
                    case 8 /* AssignmentDeclarationKind.ObjectDefinePropertyExports */:
                    case 9 /* AssignmentDeclarationKind.ObjectDefinePrototypeProperty */:
                        return expr_1.arguments[1];
                    default:
                        return undefined;
                }
            }
            case 348 /* SyntaxKind.JSDocTypedefTag */:
                return getNameOfJSDocTypedef(declaration);
            case 342 /* SyntaxKind.JSDocEnumTag */:
                return nameForNamelessJSDocTypedef(declaration);
            case 274 /* SyntaxKind.ExportAssignment */: {
                var expression = declaration.expression;
                return ts.isIdentifier(expression) ? expression : undefined;
            }
            case 209 /* SyntaxKind.ElementAccessExpression */:
                var expr = declaration;
                if (ts.isBindableStaticElementAccessExpression(expr)) {
                    return expr.argumentExpression;
                }
        }
        return declaration.name;
    }
    ts.getNonAssignedNameOfDeclaration = getNonAssignedNameOfDeclaration;
    function getNameOfDeclaration(declaration) {
        if (declaration === undefined)
            return undefined;
        return getNonAssignedNameOfDeclaration(declaration) ||
            (ts.isFunctionExpression(declaration) || ts.isArrowFunction(declaration) || ts.isClassExpression(declaration) ? getAssignedName(declaration) : undefined);
    }
    ts.getNameOfDeclaration = getNameOfDeclaration;
    /*@internal*/
    function getAssignedName(node) {
        if (!node.parent) {
            return undefined;
        }
        else if (ts.isPropertyAssignment(node.parent) || ts.isBindingElement(node.parent)) {
            return node.parent.name;
        }
        else if (ts.isBinaryExpression(node.parent) && node === node.parent.right) {
            if (ts.isIdentifier(node.parent.left)) {
                return node.parent.left;
            }
            else if (ts.isAccessExpression(node.parent.left)) {
                return ts.getElementOrPropertyAccessArgumentExpressionOrName(node.parent.left);
            }
        }
        else if (ts.isVariableDeclaration(node.parent) && ts.isIdentifier(node.parent.name)) {
            return node.parent.name;
        }
    }
    ts.getAssignedName = getAssignedName;
    function getDecorators(node) {
        if (ts.hasDecorators(node)) {
            return ts.filter(node.modifiers, ts.isDecorator);
        }
    }
    ts.getDecorators = getDecorators;
    function getModifiers(node) {
        if (ts.hasSyntacticModifier(node, 126975 /* ModifierFlags.Modifier */)) {
            return ts.filter(node.modifiers, isModifier);
        }
    }
    ts.getModifiers = getModifiers;
    function getJSDocParameterTagsWorker(param, noCache) {
        if (param.name) {
            if (ts.isIdentifier(param.name)) {
                var name_1 = param.name.escapedText;
                return getJSDocTagsWorker(param.parent, noCache).filter(function (tag) { return ts.isJSDocParameterTag(tag) && ts.isIdentifier(tag.name) && tag.name.escapedText === name_1; });
            }
            else {
                var i = param.parent.parameters.indexOf(param);
                ts.Debug.assert(i > -1, "Parameters should always be in their parents' parameter list");
                var paramTags = getJSDocTagsWorker(param.parent, noCache).filter(ts.isJSDocParameterTag);
                if (i < paramTags.length) {
                    return [paramTags[i]];
                }
            }
        }
        // return empty array for: out-of-order binding patterns and JSDoc function syntax, which has un-named parameters
        return ts.emptyArray;
    }
    /**
     * Gets the JSDoc parameter tags for the node if present.
     *
     * @remarks Returns any JSDoc param tag whose name matches the provided
     * parameter, whether a param tag on a containing function
     * expression, or a param tag on a variable declaration whose
     * initializer is the containing function. The tags closest to the
     * node are returned first, so in the previous example, the param
     * tag on the containing function expression would be first.
     *
     * For binding patterns, parameter tags are matched by position.
     */
    function getJSDocParameterTags(param) {
        return getJSDocParameterTagsWorker(param, /*noCache*/ false);
    }
    ts.getJSDocParameterTags = getJSDocParameterTags;
    /* @internal */
    function getJSDocParameterTagsNoCache(param) {
        return getJSDocParameterTagsWorker(param, /*noCache*/ true);
    }
    ts.getJSDocParameterTagsNoCache = getJSDocParameterTagsNoCache;
    function getJSDocTypeParameterTagsWorker(param, noCache) {
        var name = param.name.escapedText;
        return getJSDocTagsWorker(param.parent, noCache).filter(function (tag) {
            return ts.isJSDocTemplateTag(tag) && tag.typeParameters.some(function (tp) { return tp.name.escapedText === name; });
        });
    }
    /**
     * Gets the JSDoc type parameter tags for the node if present.
     *
     * @remarks Returns any JSDoc template tag whose names match the provided
     * parameter, whether a template tag on a containing function
     * expression, or a template tag on a variable declaration whose
     * initializer is the containing function. The tags closest to the
     * node are returned first, so in the previous example, the template
     * tag on the containing function expression would be first.
     */
    function getJSDocTypeParameterTags(param) {
        return getJSDocTypeParameterTagsWorker(param, /*noCache*/ false);
    }
    ts.getJSDocTypeParameterTags = getJSDocTypeParameterTags;
    /* @internal */
    function getJSDocTypeParameterTagsNoCache(param) {
        return getJSDocTypeParameterTagsWorker(param, /*noCache*/ true);
    }
    ts.getJSDocTypeParameterTagsNoCache = getJSDocTypeParameterTagsNoCache;
    /**
     * Return true if the node has JSDoc parameter tags.
     *
     * @remarks Includes parameter tags that are not directly on the node,
     * for example on a variable declaration whose initializer is a function expression.
     */
    function hasJSDocParameterTags(node) {
        return !!getFirstJSDocTag(node, ts.isJSDocParameterTag);
    }
    ts.hasJSDocParameterTags = hasJSDocParameterTags;
    /** Gets the JSDoc augments tag for the node if present */
    function getJSDocAugmentsTag(node) {
        return getFirstJSDocTag(node, ts.isJSDocAugmentsTag);
    }
    ts.getJSDocAugmentsTag = getJSDocAugmentsTag;
    /** Gets the JSDoc implements tags for the node if present */
    function getJSDocImplementsTags(node) {
        return getAllJSDocTags(node, ts.isJSDocImplementsTag);
    }
    ts.getJSDocImplementsTags = getJSDocImplementsTags;
    /** Gets the JSDoc class tag for the node if present */
    function getJSDocClassTag(node) {
        return getFirstJSDocTag(node, ts.isJSDocClassTag);
    }
    ts.getJSDocClassTag = getJSDocClassTag;
    /** Gets the JSDoc public tag for the node if present */
    function getJSDocPublicTag(node) {
        return getFirstJSDocTag(node, ts.isJSDocPublicTag);
    }
    ts.getJSDocPublicTag = getJSDocPublicTag;
    /*@internal*/
    function getJSDocPublicTagNoCache(node) {
        return getFirstJSDocTag(node, ts.isJSDocPublicTag, /*noCache*/ true);
    }
    ts.getJSDocPublicTagNoCache = getJSDocPublicTagNoCache;
    /** Gets the JSDoc private tag for the node if present */
    function getJSDocPrivateTag(node) {
        return getFirstJSDocTag(node, ts.isJSDocPrivateTag);
    }
    ts.getJSDocPrivateTag = getJSDocPrivateTag;
    /*@internal*/
    function getJSDocPrivateTagNoCache(node) {
        return getFirstJSDocTag(node, ts.isJSDocPrivateTag, /*noCache*/ true);
    }
    ts.getJSDocPrivateTagNoCache = getJSDocPrivateTagNoCache;
    /** Gets the JSDoc protected tag for the node if present */
    function getJSDocProtectedTag(node) {
        return getFirstJSDocTag(node, ts.isJSDocProtectedTag);
    }
    ts.getJSDocProtectedTag = getJSDocProtectedTag;
    /*@internal*/
    function getJSDocProtectedTagNoCache(node) {
        return getFirstJSDocTag(node, ts.isJSDocProtectedTag, /*noCache*/ true);
    }
    ts.getJSDocProtectedTagNoCache = getJSDocProtectedTagNoCache;
    /** Gets the JSDoc protected tag for the node if present */
    function getJSDocReadonlyTag(node) {
        return getFirstJSDocTag(node, ts.isJSDocReadonlyTag);
    }
    ts.getJSDocReadonlyTag = getJSDocReadonlyTag;
    /*@internal*/
    function getJSDocReadonlyTagNoCache(node) {
        return getFirstJSDocTag(node, ts.isJSDocReadonlyTag, /*noCache*/ true);
    }
    ts.getJSDocReadonlyTagNoCache = getJSDocReadonlyTagNoCache;
    function getJSDocOverrideTagNoCache(node) {
        return getFirstJSDocTag(node, ts.isJSDocOverrideTag, /*noCache*/ true);
    }
    ts.getJSDocOverrideTagNoCache = getJSDocOverrideTagNoCache;
    /** Gets the JSDoc deprecated tag for the node if present */
    function getJSDocDeprecatedTag(node) {
        return getFirstJSDocTag(node, ts.isJSDocDeprecatedTag);
    }
    ts.getJSDocDeprecatedTag = getJSDocDeprecatedTag;
    /*@internal */
    function getJSDocDeprecatedTagNoCache(node) {
        return getFirstJSDocTag(node, ts.isJSDocDeprecatedTag, /*noCache*/ true);
    }
    ts.getJSDocDeprecatedTagNoCache = getJSDocDeprecatedTagNoCache;
    /** Gets the JSDoc enum tag for the node if present */
    function getJSDocEnumTag(node) {
        return getFirstJSDocTag(node, ts.isJSDocEnumTag);
    }
    ts.getJSDocEnumTag = getJSDocEnumTag;
    /** Gets the JSDoc this tag for the node if present */
    function getJSDocThisTag(node) {
        return getFirstJSDocTag(node, ts.isJSDocThisTag);
    }
    ts.getJSDocThisTag = getJSDocThisTag;
    /** Gets the JSDoc return tag for the node if present */
    function getJSDocReturnTag(node) {
        return getFirstJSDocTag(node, ts.isJSDocReturnTag);
    }
    ts.getJSDocReturnTag = getJSDocReturnTag;
    /** Gets the JSDoc template tag for the node if present */
    function getJSDocTemplateTag(node) {
        return getFirstJSDocTag(node, ts.isJSDocTemplateTag);
    }
    ts.getJSDocTemplateTag = getJSDocTemplateTag;
    /** Gets the JSDoc type tag for the node if present and valid */
    function getJSDocTypeTag(node) {
        // We should have already issued an error if there were multiple type jsdocs, so just use the first one.
        var tag = getFirstJSDocTag(node, ts.isJSDocTypeTag);
        if (tag && tag.typeExpression && tag.typeExpression.type) {
            return tag;
        }
        return undefined;
    }
    ts.getJSDocTypeTag = getJSDocTypeTag;
    /**
     * Gets the type node for the node if provided via JSDoc.
     *
     * @remarks The search includes any JSDoc param tag that relates
     * to the provided parameter, for example a type tag on the
     * parameter itself, or a param tag on a containing function
     * expression, or a param tag on a variable declaration whose
     * initializer is the containing function. The tags closest to the
     * node are examined first, so in the previous example, the type
     * tag directly on the node would be returned.
     */
    function getJSDocType(node) {
        var tag = getFirstJSDocTag(node, ts.isJSDocTypeTag);
        if (!tag && ts.isParameter(node)) {
            tag = ts.find(getJSDocParameterTags(node), function (tag) { return !!tag.typeExpression; });
        }
        return tag && tag.typeExpression && tag.typeExpression.type;
    }
    ts.getJSDocType = getJSDocType;
    /**
     * Gets the return type node for the node if provided via JSDoc return tag or type tag.
     *
     * @remarks `getJSDocReturnTag` just gets the whole JSDoc tag. This function
     * gets the type from inside the braces, after the fat arrow, etc.
     */
    function getJSDocReturnType(node) {
        var returnTag = getJSDocReturnTag(node);
        if (returnTag && returnTag.typeExpression) {
            return returnTag.typeExpression.type;
        }
        var typeTag = getJSDocTypeTag(node);
        if (typeTag && typeTag.typeExpression) {
            var type = typeTag.typeExpression.type;
            if (ts.isTypeLiteralNode(type)) {
                var sig = ts.find(type.members, ts.isCallSignatureDeclaration);
                return sig && sig.type;
            }
            if (ts.isFunctionTypeNode(type) || ts.isJSDocFunctionType(type)) {
                return type.type;
            }
        }
    }
    ts.getJSDocReturnType = getJSDocReturnType;
    function getJSDocTagsWorker(node, noCache) {
        var tags = node.jsDocCache;
        // If cache is 'null', that means we did the work of searching for JSDoc tags and came up with nothing.
        if (tags === undefined || noCache) {
            var comments = ts.getJSDocCommentsAndTags(node, noCache);
            ts.Debug.assert(comments.length < 2 || comments[0] !== comments[1]);
            tags = ts.flatMap(comments, function (j) { return ts.isJSDoc(j) ? j.tags : j; });
            if (!noCache) {
                node.jsDocCache = tags;
            }
        }
        return tags;
    }
    /** Get all JSDoc tags related to a node, including those on parent nodes. */
    function getJSDocTags(node) {
        return getJSDocTagsWorker(node, /*noCache*/ false);
    }
    ts.getJSDocTags = getJSDocTags;
    /* @internal */
    function getJSDocTagsNoCache(node) {
        return getJSDocTagsWorker(node, /*noCache*/ true);
    }
    ts.getJSDocTagsNoCache = getJSDocTagsNoCache;
    /** Get the first JSDoc tag of a specified kind, or undefined if not present. */
    function getFirstJSDocTag(node, predicate, noCache) {
        return ts.find(getJSDocTagsWorker(node, noCache), predicate);
    }
    /** Gets all JSDoc tags that match a specified predicate */
    function getAllJSDocTags(node, predicate) {
        return getJSDocTags(node).filter(predicate);
    }
    ts.getAllJSDocTags = getAllJSDocTags;
    /** Gets all JSDoc tags of a specified kind */
    function getAllJSDocTagsOfKind(node, kind) {
        return getJSDocTags(node).filter(function (doc) { return doc.kind === kind; });
    }
    ts.getAllJSDocTagsOfKind = getAllJSDocTagsOfKind;
    /** Gets the text of a jsdoc comment, flattening links to their text. */
    function getTextOfJSDocComment(comment) {
        return typeof comment === "string" ? comment
            : comment === null || comment === void 0 ? void 0 : comment.map(function (c) { return c.kind === 324 /* SyntaxKind.JSDocText */ ? c.text : formatJSDocLink(c); }).join("");
    }
    ts.getTextOfJSDocComment = getTextOfJSDocComment;
    function formatJSDocLink(link) {
        var kind = link.kind === 327 /* SyntaxKind.JSDocLink */ ? "link"
            : link.kind === 328 /* SyntaxKind.JSDocLinkCode */ ? "linkcode"
                : "linkplain";
        var name = link.name ? ts.entityNameToString(link.name) : "";
        var space = link.name && link.text.startsWith("://") ? "" : " ";
        return "{@".concat(kind, " ").concat(name).concat(space).concat(link.text, "}");
    }
    /**
     * Gets the effective type parameters. If the node was parsed in a
     * JavaScript file, gets the type parameters from the `@template` tag from JSDoc.
     *
     * This does *not* return type parameters from a jsdoc reference to a generic type, eg
     *
     * type Id = <T>(x: T) => T
     * /** @type {Id} /
     * function id(x) { return x }
     */
    function getEffectiveTypeParameterDeclarations(node) {
        if (ts.isJSDocSignature(node)) {
            return ts.emptyArray;
        }
        if (ts.isJSDocTypeAlias(node)) {
            ts.Debug.assert(node.parent.kind === 323 /* SyntaxKind.JSDoc */);
            return ts.flatMap(node.parent.tags, function (tag) { return ts.isJSDocTemplateTag(tag) ? tag.typeParameters : undefined; });
        }
        if (node.typeParameters) {
            return node.typeParameters;
        }
        if (ts.canHaveIllegalTypeParameters(node) && node.typeParameters) {
            return node.typeParameters;
        }
        if (ts.isInJSFile(node)) {
            var decls = ts.getJSDocTypeParameterDeclarations(node);
            if (decls.length) {
                return decls;
            }
            var typeTag = getJSDocType(node);
            if (typeTag && ts.isFunctionTypeNode(typeTag) && typeTag.typeParameters) {
                return typeTag.typeParameters;
            }
        }
        return ts.emptyArray;
    }
    ts.getEffectiveTypeParameterDeclarations = getEffectiveTypeParameterDeclarations;
    function getEffectiveConstraintOfTypeParameter(node) {
        return node.constraint ? node.constraint :
            ts.isJSDocTemplateTag(node.parent) && node === node.parent.typeParameters[0] ? node.parent.constraint :
                undefined;
    }
    ts.getEffectiveConstraintOfTypeParameter = getEffectiveConstraintOfTypeParameter;
    // #region
    function isMemberName(node) {
        return node.kind === 79 /* SyntaxKind.Identifier */ || node.kind === 80 /* SyntaxKind.PrivateIdentifier */;
    }
    ts.isMemberName = isMemberName;
    /* @internal */
    function isGetOrSetAccessorDeclaration(node) {
        return node.kind === 175 /* SyntaxKind.SetAccessor */ || node.kind === 174 /* SyntaxKind.GetAccessor */;
    }
    ts.isGetOrSetAccessorDeclaration = isGetOrSetAccessorDeclaration;
    function isPropertyAccessChain(node) {
        return ts.isPropertyAccessExpression(node) && !!(node.flags & 32 /* NodeFlags.OptionalChain */);
    }
    ts.isPropertyAccessChain = isPropertyAccessChain;
    function isElementAccessChain(node) {
        return ts.isElementAccessExpression(node) && !!(node.flags & 32 /* NodeFlags.OptionalChain */);
    }
    ts.isElementAccessChain = isElementAccessChain;
    function isCallChain(node) {
        return ts.isCallExpression(node) && !!(node.flags & 32 /* NodeFlags.OptionalChain */);
    }
    ts.isCallChain = isCallChain;
    function isOptionalChain(node) {
        var kind = node.kind;
        return !!(node.flags & 32 /* NodeFlags.OptionalChain */) &&
            (kind === 208 /* SyntaxKind.PropertyAccessExpression */
                || kind === 209 /* SyntaxKind.ElementAccessExpression */
                || kind === 210 /* SyntaxKind.CallExpression */
                || kind === 232 /* SyntaxKind.NonNullExpression */);
    }
    ts.isOptionalChain = isOptionalChain;
    /* @internal */
    function isOptionalChainRoot(node) {
        return isOptionalChain(node) && !ts.isNonNullExpression(node) && !!node.questionDotToken;
    }
    ts.isOptionalChainRoot = isOptionalChainRoot;
    /**
     * Determines whether a node is the expression preceding an optional chain (i.e. `a` in `a?.b`).
     */
    /* @internal */
    function isExpressionOfOptionalChainRoot(node) {
        return isOptionalChainRoot(node.parent) && node.parent.expression === node;
    }
    ts.isExpressionOfOptionalChainRoot = isExpressionOfOptionalChainRoot;
    /**
     * Determines whether a node is the outermost `OptionalChain` in an ECMAScript `OptionalExpression`:
     *
     * 1. For `a?.b.c`, the outermost chain is `a?.b.c` (`c` is the end of the chain starting at `a?.`)
     * 2. For `a?.b!`, the outermost chain is `a?.b` (`b` is the end of the chain starting at `a?.`)
     * 3. For `(a?.b.c).d`, the outermost chain is `a?.b.c` (`c` is the end of the chain starting at `a?.` since parens end the chain)
     * 4. For `a?.b.c?.d`, both `a?.b.c` and `a?.b.c?.d` are outermost (`c` is the end of the chain starting at `a?.`, and `d` is
     *   the end of the chain starting at `c?.`)
     * 5. For `a?.(b?.c).d`, both `b?.c` and `a?.(b?.c)d` are outermost (`c` is the end of the chain starting at `b`, and `d` is
     *   the end of the chain starting at `a?.`)
     */
    /* @internal */
    function isOutermostOptionalChain(node) {
        return !isOptionalChain(node.parent) // cases 1, 2, and 3
            || isOptionalChainRoot(node.parent) // case 4
            || node !== node.parent.expression; // case 5
    }
    ts.isOutermostOptionalChain = isOutermostOptionalChain;
    function isNullishCoalesce(node) {
        return node.kind === 223 /* SyntaxKind.BinaryExpression */ && node.operatorToken.kind === 60 /* SyntaxKind.QuestionQuestionToken */;
    }
    ts.isNullishCoalesce = isNullishCoalesce;
    function isConstTypeReference(node) {
        return ts.isTypeReferenceNode(node) && ts.isIdentifier(node.typeName) &&
            node.typeName.escapedText === "const" && !node.typeArguments;
    }
    ts.isConstTypeReference = isConstTypeReference;
    function skipPartiallyEmittedExpressions(node) {
        return ts.skipOuterExpressions(node, 8 /* OuterExpressionKinds.PartiallyEmittedExpressions */);
    }
    ts.skipPartiallyEmittedExpressions = skipPartiallyEmittedExpressions;
    function isNonNullChain(node) {
        return ts.isNonNullExpression(node) && !!(node.flags & 32 /* NodeFlags.OptionalChain */);
    }
    ts.isNonNullChain = isNonNullChain;
    function isBreakOrContinueStatement(node) {
        return node.kind === 249 /* SyntaxKind.BreakStatement */ || node.kind === 248 /* SyntaxKind.ContinueStatement */;
    }
    ts.isBreakOrContinueStatement = isBreakOrContinueStatement;
    function isNamedExportBindings(node) {
        return node.kind === 277 /* SyntaxKind.NamespaceExport */ || node.kind === 276 /* SyntaxKind.NamedExports */;
    }
    ts.isNamedExportBindings = isNamedExportBindings;
    function isUnparsedTextLike(node) {
        switch (node.kind) {
            case 305 /* SyntaxKind.UnparsedText */:
            case 306 /* SyntaxKind.UnparsedInternalText */:
                return true;
            default:
                return false;
        }
    }
    ts.isUnparsedTextLike = isUnparsedTextLike;
    function isUnparsedNode(node) {
        return isUnparsedTextLike(node) ||
            node.kind === 303 /* SyntaxKind.UnparsedPrologue */ ||
            node.kind === 307 /* SyntaxKind.UnparsedSyntheticReference */;
    }
    ts.isUnparsedNode = isUnparsedNode;
    function isJSDocPropertyLikeTag(node) {
        return node.kind === 350 /* SyntaxKind.JSDocPropertyTag */ || node.kind === 343 /* SyntaxKind.JSDocParameterTag */;
    }
    ts.isJSDocPropertyLikeTag = isJSDocPropertyLikeTag;
    // #endregion
    // #region
    // Node tests
    //
    // All node tests in the following list should *not* reference parent pointers so that
    // they may be used with transformations.
    /* @internal */
    function isNode(node) {
        return isNodeKind(node.kind);
    }
    ts.isNode = isNode;
    /* @internal */
    function isNodeKind(kind) {
        return kind >= 163 /* SyntaxKind.FirstNode */;
    }
    ts.isNodeKind = isNodeKind;
    /**
     * True if kind is of some token syntax kind.
     * For example, this is true for an IfKeyword but not for an IfStatement.
     * Literals are considered tokens, except TemplateLiteral, but does include TemplateHead/Middle/Tail.
     */
    function isTokenKind(kind) {
        return kind >= 0 /* SyntaxKind.FirstToken */ && kind <= 162 /* SyntaxKind.LastToken */;
    }
    ts.isTokenKind = isTokenKind;
    /**
     * True if node is of some token syntax kind.
     * For example, this is true for an IfKeyword but not for an IfStatement.
     * Literals are considered tokens, except TemplateLiteral, but does include TemplateHead/Middle/Tail.
     */
    function isToken(n) {
        return isTokenKind(n.kind);
    }
    ts.isToken = isToken;
    // Node Arrays
    /* @internal */
    function isNodeArray(array) {
        return ts.hasProperty(array, "pos") && ts.hasProperty(array, "end");
    }
    ts.isNodeArray = isNodeArray;
    // Literals
    /* @internal */
    function isLiteralKind(kind) {
        return 8 /* SyntaxKind.FirstLiteralToken */ <= kind && kind <= 14 /* SyntaxKind.LastLiteralToken */;
    }
    ts.isLiteralKind = isLiteralKind;
    function isLiteralExpression(node) {
        return isLiteralKind(node.kind);
    }
    ts.isLiteralExpression = isLiteralExpression;
    /** @internal */
    function isLiteralExpressionOfObject(node) {
        switch (node.kind) {
            case 207 /* SyntaxKind.ObjectLiteralExpression */:
            case 206 /* SyntaxKind.ArrayLiteralExpression */:
            case 13 /* SyntaxKind.RegularExpressionLiteral */:
            case 215 /* SyntaxKind.FunctionExpression */:
            case 228 /* SyntaxKind.ClassExpression */:
                return true;
        }
        return false;
    }
    ts.isLiteralExpressionOfObject = isLiteralExpressionOfObject;
    // Pseudo-literals
    /* @internal */
    function isTemplateLiteralKind(kind) {
        return 14 /* SyntaxKind.FirstTemplateToken */ <= kind && kind <= 17 /* SyntaxKind.LastTemplateToken */;
    }
    ts.isTemplateLiteralKind = isTemplateLiteralKind;
    function isTemplateLiteralToken(node) {
        return isTemplateLiteralKind(node.kind);
    }
    ts.isTemplateLiteralToken = isTemplateLiteralToken;
    function isTemplateMiddleOrTemplateTail(node) {
        var kind = node.kind;
        return kind === 16 /* SyntaxKind.TemplateMiddle */
            || kind === 17 /* SyntaxKind.TemplateTail */;
    }
    ts.isTemplateMiddleOrTemplateTail = isTemplateMiddleOrTemplateTail;
    function isImportOrExportSpecifier(node) {
        return ts.isImportSpecifier(node) || ts.isExportSpecifier(node);
    }
    ts.isImportOrExportSpecifier = isImportOrExportSpecifier;
    function isTypeOnlyImportOrExportDeclaration(node) {
        switch (node.kind) {
            case 273 /* SyntaxKind.ImportSpecifier */:
            case 278 /* SyntaxKind.ExportSpecifier */:
                return node.isTypeOnly || node.parent.parent.isTypeOnly;
            case 271 /* SyntaxKind.NamespaceImport */:
                return node.parent.isTypeOnly;
            case 270 /* SyntaxKind.ImportClause */:
            case 268 /* SyntaxKind.ImportEqualsDeclaration */:
                return node.isTypeOnly;
            default:
                return false;
        }
    }
    ts.isTypeOnlyImportOrExportDeclaration = isTypeOnlyImportOrExportDeclaration;
    function isAssertionKey(node) {
        return ts.isStringLiteral(node) || ts.isIdentifier(node);
    }
    ts.isAssertionKey = isAssertionKey;
    function isStringTextContainingNode(node) {
        return node.kind === 10 /* SyntaxKind.StringLiteral */ || isTemplateLiteralKind(node.kind);
    }
    ts.isStringTextContainingNode = isStringTextContainingNode;
    // Identifiers
    /* @internal */
    function isGeneratedIdentifier(node) {
        return ts.isIdentifier(node) && (node.autoGenerateFlags & 7 /* GeneratedIdentifierFlags.KindMask */) > 0 /* GeneratedIdentifierFlags.None */;
    }
    ts.isGeneratedIdentifier = isGeneratedIdentifier;
    /* @internal */
    function isGeneratedPrivateIdentifier(node) {
        return ts.isPrivateIdentifier(node) && (node.autoGenerateFlags & 7 /* GeneratedIdentifierFlags.KindMask */) > 0 /* GeneratedIdentifierFlags.None */;
    }
    ts.isGeneratedPrivateIdentifier = isGeneratedPrivateIdentifier;
    // Private Identifiers
    /*@internal*/
    function isPrivateIdentifierClassElementDeclaration(node) {
        return (ts.isPropertyDeclaration(node) || isMethodOrAccessor(node)) && ts.isPrivateIdentifier(node.name);
    }
    ts.isPrivateIdentifierClassElementDeclaration = isPrivateIdentifierClassElementDeclaration;
    /*@internal*/
    function isPrivateIdentifierPropertyAccessExpression(node) {
        return ts.isPropertyAccessExpression(node) && ts.isPrivateIdentifier(node.name);
    }
    ts.isPrivateIdentifierPropertyAccessExpression = isPrivateIdentifierPropertyAccessExpression;
    // Keywords
    /* @internal */
    function isModifierKind(token) {
        switch (token) {
            case 126 /* SyntaxKind.AbstractKeyword */:
            case 127 /* SyntaxKind.AccessorKeyword */:
            case 132 /* SyntaxKind.AsyncKeyword */:
            case 85 /* SyntaxKind.ConstKeyword */:
            case 136 /* SyntaxKind.DeclareKeyword */:
            case 88 /* SyntaxKind.DefaultKeyword */:
            case 93 /* SyntaxKind.ExportKeyword */:
            case 101 /* SyntaxKind.InKeyword */:
            case 123 /* SyntaxKind.PublicKeyword */:
            case 121 /* SyntaxKind.PrivateKeyword */:
            case 122 /* SyntaxKind.ProtectedKeyword */:
            case 146 /* SyntaxKind.ReadonlyKeyword */:
            case 124 /* SyntaxKind.StaticKeyword */:
            case 145 /* SyntaxKind.OutKeyword */:
            case 161 /* SyntaxKind.OverrideKeyword */:
                return true;
        }
        return false;
    }
    ts.isModifierKind = isModifierKind;
    /* @internal */
    function isParameterPropertyModifier(kind) {
        return !!(ts.modifierToFlag(kind) & 16476 /* ModifierFlags.ParameterPropertyModifier */);
    }
    ts.isParameterPropertyModifier = isParameterPropertyModifier;
    /* @internal */
    function isClassMemberModifier(idToken) {
        return isParameterPropertyModifier(idToken) ||
            idToken === 124 /* SyntaxKind.StaticKeyword */ ||
            idToken === 161 /* SyntaxKind.OverrideKeyword */ ||
            idToken === 127 /* SyntaxKind.AccessorKeyword */;
    }
    ts.isClassMemberModifier = isClassMemberModifier;
    function isModifier(node) {
        return isModifierKind(node.kind);
    }
    ts.isModifier = isModifier;
    function isEntityName(node) {
        var kind = node.kind;
        return kind === 163 /* SyntaxKind.QualifiedName */
            || kind === 79 /* SyntaxKind.Identifier */;
    }
    ts.isEntityName = isEntityName;
    function isPropertyName(node) {
        var kind = node.kind;
        return kind === 79 /* SyntaxKind.Identifier */
            || kind === 80 /* SyntaxKind.PrivateIdentifier */
            || kind === 10 /* SyntaxKind.StringLiteral */
            || kind === 8 /* SyntaxKind.NumericLiteral */
            || kind === 164 /* SyntaxKind.ComputedPropertyName */;
    }
    ts.isPropertyName = isPropertyName;
    function isBindingName(node) {
        var kind = node.kind;
        return kind === 79 /* SyntaxKind.Identifier */
            || kind === 203 /* SyntaxKind.ObjectBindingPattern */
            || kind === 204 /* SyntaxKind.ArrayBindingPattern */;
    }
    ts.isBindingName = isBindingName;
    // Functions
    function isFunctionLike(node) {
        return !!node && isFunctionLikeKind(node.kind);
    }
    ts.isFunctionLike = isFunctionLike;
    /* @internal */
    function isFunctionLikeOrClassStaticBlockDeclaration(node) {
        return !!node && (isFunctionLikeKind(node.kind) || ts.isClassStaticBlockDeclaration(node));
    }
    ts.isFunctionLikeOrClassStaticBlockDeclaration = isFunctionLikeOrClassStaticBlockDeclaration;
    /* @internal */
    function isFunctionLikeDeclaration(node) {
        return node && isFunctionLikeDeclarationKind(node.kind);
    }
    ts.isFunctionLikeDeclaration = isFunctionLikeDeclaration;
    /* @internal */
    function isBooleanLiteral(node) {
        return node.kind === 110 /* SyntaxKind.TrueKeyword */ || node.kind === 95 /* SyntaxKind.FalseKeyword */;
    }
    ts.isBooleanLiteral = isBooleanLiteral;
    function isFunctionLikeDeclarationKind(kind) {
        switch (kind) {
            case 259 /* SyntaxKind.FunctionDeclaration */:
            case 171 /* SyntaxKind.MethodDeclaration */:
            case 173 /* SyntaxKind.Constructor */:
            case 174 /* SyntaxKind.GetAccessor */:
            case 175 /* SyntaxKind.SetAccessor */:
            case 215 /* SyntaxKind.FunctionExpression */:
            case 216 /* SyntaxKind.ArrowFunction */:
                return true;
            default:
                return false;
        }
    }
    /* @internal */
    function isFunctionLikeKind(kind) {
        switch (kind) {
            case 170 /* SyntaxKind.MethodSignature */:
            case 176 /* SyntaxKind.CallSignature */:
            case 326 /* SyntaxKind.JSDocSignature */:
            case 177 /* SyntaxKind.ConstructSignature */:
            case 178 /* SyntaxKind.IndexSignature */:
            case 181 /* SyntaxKind.FunctionType */:
            case 320 /* SyntaxKind.JSDocFunctionType */:
            case 182 /* SyntaxKind.ConstructorType */:
                return true;
            default:
                return isFunctionLikeDeclarationKind(kind);
        }
    }
    ts.isFunctionLikeKind = isFunctionLikeKind;
    /* @internal */
    function isFunctionOrModuleBlock(node) {
        return ts.isSourceFile(node) || ts.isModuleBlock(node) || ts.isBlock(node) && isFunctionLike(node.parent);
    }
    ts.isFunctionOrModuleBlock = isFunctionOrModuleBlock;
    // Classes
    function isClassElement(node) {
        var kind = node.kind;
        return kind === 173 /* SyntaxKind.Constructor */
            || kind === 169 /* SyntaxKind.PropertyDeclaration */
            || kind === 171 /* SyntaxKind.MethodDeclaration */
            || kind === 174 /* SyntaxKind.GetAccessor */
            || kind === 175 /* SyntaxKind.SetAccessor */
            || kind === 178 /* SyntaxKind.IndexSignature */
            || kind === 172 /* SyntaxKind.ClassStaticBlockDeclaration */
            || kind === 237 /* SyntaxKind.SemicolonClassElement */;
    }
    ts.isClassElement = isClassElement;
    function isClassLike(node) {
        return node && (node.kind === 260 /* SyntaxKind.ClassDeclaration */ || node.kind === 228 /* SyntaxKind.ClassExpression */);
    }
    ts.isClassLike = isClassLike;
    function isAccessor(node) {
        return node && (node.kind === 174 /* SyntaxKind.GetAccessor */ || node.kind === 175 /* SyntaxKind.SetAccessor */);
    }
    ts.isAccessor = isAccessor;
    function isAutoAccessorPropertyDeclaration(node) {
        return ts.isPropertyDeclaration(node) && ts.hasAccessorModifier(node);
    }
    ts.isAutoAccessorPropertyDeclaration = isAutoAccessorPropertyDeclaration;
    /* @internal */
    function isMethodOrAccessor(node) {
        switch (node.kind) {
            case 171 /* SyntaxKind.MethodDeclaration */:
            case 174 /* SyntaxKind.GetAccessor */:
            case 175 /* SyntaxKind.SetAccessor */:
                return true;
            default:
                return false;
        }
    }
    ts.isMethodOrAccessor = isMethodOrAccessor;
    /* @internal */
    function isNamedClassElement(node) {
        switch (node.kind) {
            case 171 /* SyntaxKind.MethodDeclaration */:
            case 174 /* SyntaxKind.GetAccessor */:
            case 175 /* SyntaxKind.SetAccessor */:
            case 169 /* SyntaxKind.PropertyDeclaration */:
                return true;
            default:
                return false;
        }
    }
    ts.isNamedClassElement = isNamedClassElement;
    // Type members
    function isModifierLike(node) {
        return isModifier(node) || ts.isDecorator(node);
    }
    ts.isModifierLike = isModifierLike;
    function isTypeElement(node) {
        var kind = node.kind;
        return kind === 177 /* SyntaxKind.ConstructSignature */
            || kind === 176 /* SyntaxKind.CallSignature */
            || kind === 168 /* SyntaxKind.PropertySignature */
            || kind === 170 /* SyntaxKind.MethodSignature */
            || kind === 178 /* SyntaxKind.IndexSignature */
            || kind === 174 /* SyntaxKind.GetAccessor */
            || kind === 175 /* SyntaxKind.SetAccessor */;
    }
    ts.isTypeElement = isTypeElement;
    function isClassOrTypeElement(node) {
        return isTypeElement(node) || isClassElement(node);
    }
    ts.isClassOrTypeElement = isClassOrTypeElement;
    function isObjectLiteralElementLike(node) {
        var kind = node.kind;
        return kind === 299 /* SyntaxKind.PropertyAssignment */
            || kind === 300 /* SyntaxKind.ShorthandPropertyAssignment */
            || kind === 301 /* SyntaxKind.SpreadAssignment */
            || kind === 171 /* SyntaxKind.MethodDeclaration */
            || kind === 174 /* SyntaxKind.GetAccessor */
            || kind === 175 /* SyntaxKind.SetAccessor */;
    }
    ts.isObjectLiteralElementLike = isObjectLiteralElementLike;
    // Type
    /**
     * Node test that determines whether a node is a valid type node.
     * This differs from the `isPartOfTypeNode` function which determines whether a node is *part*
     * of a TypeNode.
     */
    function isTypeNode(node) {
        return ts.isTypeNodeKind(node.kind);
    }
    ts.isTypeNode = isTypeNode;
    function isFunctionOrConstructorTypeNode(node) {
        switch (node.kind) {
            case 181 /* SyntaxKind.FunctionType */:
            case 182 /* SyntaxKind.ConstructorType */:
                return true;
        }
        return false;
    }
    ts.isFunctionOrConstructorTypeNode = isFunctionOrConstructorTypeNode;
    // Binding patterns
    /* @internal */
    function isBindingPattern(node) {
        if (node) {
            var kind = node.kind;
            return kind === 204 /* SyntaxKind.ArrayBindingPattern */
                || kind === 203 /* SyntaxKind.ObjectBindingPattern */;
        }
        return false;
    }
    ts.isBindingPattern = isBindingPattern;
    /* @internal */
    function isAssignmentPattern(node) {
        var kind = node.kind;
        return kind === 206 /* SyntaxKind.ArrayLiteralExpression */
            || kind === 207 /* SyntaxKind.ObjectLiteralExpression */;
    }
    ts.isAssignmentPattern = isAssignmentPattern;
    /* @internal */
    function isArrayBindingElement(node) {
        var kind = node.kind;
        return kind === 205 /* SyntaxKind.BindingElement */
            || kind === 229 /* SyntaxKind.OmittedExpression */;
    }
    ts.isArrayBindingElement = isArrayBindingElement;
    /**
     * Determines whether the BindingOrAssignmentElement is a BindingElement-like declaration
     */
    /* @internal */
    function isDeclarationBindingElement(bindingElement) {
        switch (bindingElement.kind) {
            case 257 /* SyntaxKind.VariableDeclaration */:
            case 166 /* SyntaxKind.Parameter */:
            case 205 /* SyntaxKind.BindingElement */:
                return true;
        }
        return false;
    }
    ts.isDeclarationBindingElement = isDeclarationBindingElement;
    /**
     * Determines whether a node is a BindingOrAssignmentPattern
     */
    /* @internal */
    function isBindingOrAssignmentPattern(node) {
        return isObjectBindingOrAssignmentPattern(node)
            || isArrayBindingOrAssignmentPattern(node);
    }
    ts.isBindingOrAssignmentPattern = isBindingOrAssignmentPattern;
    /**
     * Determines whether a node is an ObjectBindingOrAssignmentPattern
     */
    /* @internal */
    function isObjectBindingOrAssignmentPattern(node) {
        switch (node.kind) {
            case 203 /* SyntaxKind.ObjectBindingPattern */:
            case 207 /* SyntaxKind.ObjectLiteralExpression */:
                return true;
        }
        return false;
    }
    ts.isObjectBindingOrAssignmentPattern = isObjectBindingOrAssignmentPattern;
    /* @internal */
    function isObjectBindingOrAssignmentElement(node) {
        switch (node.kind) {
            case 205 /* SyntaxKind.BindingElement */:
            case 299 /* SyntaxKind.PropertyAssignment */: // AssignmentProperty
            case 300 /* SyntaxKind.ShorthandPropertyAssignment */: // AssignmentProperty
            case 301 /* SyntaxKind.SpreadAssignment */: // AssignmentRestProperty
                return true;
        }
        return false;
    }
    ts.isObjectBindingOrAssignmentElement = isObjectBindingOrAssignmentElement;
    /**
     * Determines whether a node is an ArrayBindingOrAssignmentPattern
     */
    /* @internal */
    function isArrayBindingOrAssignmentPattern(node) {
        switch (node.kind) {
            case 204 /* SyntaxKind.ArrayBindingPattern */:
            case 206 /* SyntaxKind.ArrayLiteralExpression */:
                return true;
        }
        return false;
    }
    ts.isArrayBindingOrAssignmentPattern = isArrayBindingOrAssignmentPattern;
    /* @internal */
    function isPropertyAccessOrQualifiedNameOrImportTypeNode(node) {
        var kind = node.kind;
        return kind === 208 /* SyntaxKind.PropertyAccessExpression */
            || kind === 163 /* SyntaxKind.QualifiedName */
            || kind === 202 /* SyntaxKind.ImportType */;
    }
    ts.isPropertyAccessOrQualifiedNameOrImportTypeNode = isPropertyAccessOrQualifiedNameOrImportTypeNode;
    // Expression
    function isPropertyAccessOrQualifiedName(node) {
        var kind = node.kind;
        return kind === 208 /* SyntaxKind.PropertyAccessExpression */
            || kind === 163 /* SyntaxKind.QualifiedName */;
    }
    ts.isPropertyAccessOrQualifiedName = isPropertyAccessOrQualifiedName;
    function isCallLikeExpression(node) {
        switch (node.kind) {
            case 283 /* SyntaxKind.JsxOpeningElement */:
            case 282 /* SyntaxKind.JsxSelfClosingElement */:
            case 210 /* SyntaxKind.CallExpression */:
            case 211 /* SyntaxKind.NewExpression */:
            case 212 /* SyntaxKind.TaggedTemplateExpression */:
            case 167 /* SyntaxKind.Decorator */:
                return true;
            default:
                return false;
        }
    }
    ts.isCallLikeExpression = isCallLikeExpression;
    function isCallOrNewExpression(node) {
        return node.kind === 210 /* SyntaxKind.CallExpression */ || node.kind === 211 /* SyntaxKind.NewExpression */;
    }
    ts.isCallOrNewExpression = isCallOrNewExpression;
    function isTemplateLiteral(node) {
        var kind = node.kind;
        return kind === 225 /* SyntaxKind.TemplateExpression */
            || kind === 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */;
    }
    ts.isTemplateLiteral = isTemplateLiteral;
    /* @internal */
    function isLeftHandSideExpression(node) {
        return isLeftHandSideExpressionKind(skipPartiallyEmittedExpressions(node).kind);
    }
    ts.isLeftHandSideExpression = isLeftHandSideExpression;
    function isLeftHandSideExpressionKind(kind) {
        switch (kind) {
            case 208 /* SyntaxKind.PropertyAccessExpression */:
            case 209 /* SyntaxKind.ElementAccessExpression */:
            case 211 /* SyntaxKind.NewExpression */:
            case 210 /* SyntaxKind.CallExpression */:
            case 281 /* SyntaxKind.JsxElement */:
            case 282 /* SyntaxKind.JsxSelfClosingElement */:
            case 285 /* SyntaxKind.JsxFragment */:
            case 212 /* SyntaxKind.TaggedTemplateExpression */:
            case 206 /* SyntaxKind.ArrayLiteralExpression */:
            case 214 /* SyntaxKind.ParenthesizedExpression */:
            case 207 /* SyntaxKind.ObjectLiteralExpression */:
            case 228 /* SyntaxKind.ClassExpression */:
            case 215 /* SyntaxKind.FunctionExpression */:
            case 79 /* SyntaxKind.Identifier */:
            case 80 /* SyntaxKind.PrivateIdentifier */: // technically this is only an Expression if it's in a `#field in expr` BinaryExpression
            case 13 /* SyntaxKind.RegularExpressionLiteral */:
            case 8 /* SyntaxKind.NumericLiteral */:
            case 9 /* SyntaxKind.BigIntLiteral */:
            case 10 /* SyntaxKind.StringLiteral */:
            case 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */:
            case 225 /* SyntaxKind.TemplateExpression */:
            case 95 /* SyntaxKind.FalseKeyword */:
            case 104 /* SyntaxKind.NullKeyword */:
            case 108 /* SyntaxKind.ThisKeyword */:
            case 110 /* SyntaxKind.TrueKeyword */:
            case 106 /* SyntaxKind.SuperKeyword */:
            case 232 /* SyntaxKind.NonNullExpression */:
            case 230 /* SyntaxKind.ExpressionWithTypeArguments */:
            case 233 /* SyntaxKind.MetaProperty */:
            case 100 /* SyntaxKind.ImportKeyword */: // technically this is only an Expression if it's in a CallExpression
                return true;
            default:
                return false;
        }
    }
    /* @internal */
    function isUnaryExpression(node) {
        return isUnaryExpressionKind(skipPartiallyEmittedExpressions(node).kind);
    }
    ts.isUnaryExpression = isUnaryExpression;
    function isUnaryExpressionKind(kind) {
        switch (kind) {
            case 221 /* SyntaxKind.PrefixUnaryExpression */:
            case 222 /* SyntaxKind.PostfixUnaryExpression */:
            case 217 /* SyntaxKind.DeleteExpression */:
            case 218 /* SyntaxKind.TypeOfExpression */:
            case 219 /* SyntaxKind.VoidExpression */:
            case 220 /* SyntaxKind.AwaitExpression */:
            case 213 /* SyntaxKind.TypeAssertionExpression */:
                return true;
            default:
                return isLeftHandSideExpressionKind(kind);
        }
    }
    /* @internal */
    function isUnaryExpressionWithWrite(expr) {
        switch (expr.kind) {
            case 222 /* SyntaxKind.PostfixUnaryExpression */:
                return true;
            case 221 /* SyntaxKind.PrefixUnaryExpression */:
                return expr.operator === 45 /* SyntaxKind.PlusPlusToken */ ||
                    expr.operator === 46 /* SyntaxKind.MinusMinusToken */;
            default:
                return false;
        }
    }
    ts.isUnaryExpressionWithWrite = isUnaryExpressionWithWrite;
    /* @internal */
    /**
     * Determines whether a node is an expression based only on its kind.
     * Use `isExpressionNode` if not in transforms.
     */
    function isExpression(node) {
        return isExpressionKind(skipPartiallyEmittedExpressions(node).kind);
    }
    ts.isExpression = isExpression;
    function isExpressionKind(kind) {
        switch (kind) {
            case 224 /* SyntaxKind.ConditionalExpression */:
            case 226 /* SyntaxKind.YieldExpression */:
            case 216 /* SyntaxKind.ArrowFunction */:
            case 223 /* SyntaxKind.BinaryExpression */:
            case 227 /* SyntaxKind.SpreadElement */:
            case 231 /* SyntaxKind.AsExpression */:
            case 229 /* SyntaxKind.OmittedExpression */:
            case 354 /* SyntaxKind.CommaListExpression */:
            case 353 /* SyntaxKind.PartiallyEmittedExpression */:
            case 235 /* SyntaxKind.SatisfiesExpression */:
                return true;
            default:
                return isUnaryExpressionKind(kind);
        }
    }
    function isAssertionExpression(node) {
        var kind = node.kind;
        return kind === 213 /* SyntaxKind.TypeAssertionExpression */
            || kind === 231 /* SyntaxKind.AsExpression */;
    }
    ts.isAssertionExpression = isAssertionExpression;
    /* @internal */
    function isNotEmittedOrPartiallyEmittedNode(node) {
        return ts.isNotEmittedStatement(node)
            || ts.isPartiallyEmittedExpression(node);
    }
    ts.isNotEmittedOrPartiallyEmittedNode = isNotEmittedOrPartiallyEmittedNode;
    function isIterationStatement(node, lookInLabeledStatements) {
        switch (node.kind) {
            case 245 /* SyntaxKind.ForStatement */:
            case 246 /* SyntaxKind.ForInStatement */:
            case 247 /* SyntaxKind.ForOfStatement */:
            case 243 /* SyntaxKind.DoStatement */:
            case 244 /* SyntaxKind.WhileStatement */:
                return true;
            case 253 /* SyntaxKind.LabeledStatement */:
                return lookInLabeledStatements && isIterationStatement(node.statement, lookInLabeledStatements);
        }
        return false;
    }
    ts.isIterationStatement = isIterationStatement;
    /* @internal */
    function isScopeMarker(node) {
        return ts.isExportAssignment(node) || ts.isExportDeclaration(node);
    }
    ts.isScopeMarker = isScopeMarker;
    /* @internal */
    function hasScopeMarker(statements) {
        return ts.some(statements, isScopeMarker);
    }
    ts.hasScopeMarker = hasScopeMarker;
    /* @internal */
    function needsScopeMarker(result) {
        return !ts.isAnyImportOrReExport(result) && !ts.isExportAssignment(result) && !ts.hasSyntacticModifier(result, 1 /* ModifierFlags.Export */) && !ts.isAmbientModule(result);
    }
    ts.needsScopeMarker = needsScopeMarker;
    /* @internal */
    function isExternalModuleIndicator(result) {
        // Exported top-level member indicates moduleness
        return ts.isAnyImportOrReExport(result) || ts.isExportAssignment(result) || ts.hasSyntacticModifier(result, 1 /* ModifierFlags.Export */);
    }
    ts.isExternalModuleIndicator = isExternalModuleIndicator;
    /* @internal */
    function isForInOrOfStatement(node) {
        return node.kind === 246 /* SyntaxKind.ForInStatement */ || node.kind === 247 /* SyntaxKind.ForOfStatement */;
    }
    ts.isForInOrOfStatement = isForInOrOfStatement;
    // Element
    /* @internal */
    function isConciseBody(node) {
        return ts.isBlock(node)
            || isExpression(node);
    }
    ts.isConciseBody = isConciseBody;
    /* @internal */
    function isFunctionBody(node) {
        return ts.isBlock(node);
    }
    ts.isFunctionBody = isFunctionBody;
    /* @internal */
    function isForInitializer(node) {
        return ts.isVariableDeclarationList(node)
            || isExpression(node);
    }
    ts.isForInitializer = isForInitializer;
    /* @internal */
    function isModuleBody(node) {
        var kind = node.kind;
        return kind === 265 /* SyntaxKind.ModuleBlock */
            || kind === 264 /* SyntaxKind.ModuleDeclaration */
            || kind === 79 /* SyntaxKind.Identifier */;
    }
    ts.isModuleBody = isModuleBody;
    /* @internal */
    function isNamespaceBody(node) {
        var kind = node.kind;
        return kind === 265 /* SyntaxKind.ModuleBlock */
            || kind === 264 /* SyntaxKind.ModuleDeclaration */;
    }
    ts.isNamespaceBody = isNamespaceBody;
    /* @internal */
    function isJSDocNamespaceBody(node) {
        var kind = node.kind;
        return kind === 79 /* SyntaxKind.Identifier */
            || kind === 264 /* SyntaxKind.ModuleDeclaration */;
    }
    ts.isJSDocNamespaceBody = isJSDocNamespaceBody;
    /* @internal */
    function isNamedImportBindings(node) {
        var kind = node.kind;
        return kind === 272 /* SyntaxKind.NamedImports */
            || kind === 271 /* SyntaxKind.NamespaceImport */;
    }
    ts.isNamedImportBindings = isNamedImportBindings;
    /* @internal */
    function isModuleOrEnumDeclaration(node) {
        return node.kind === 264 /* SyntaxKind.ModuleDeclaration */ || node.kind === 263 /* SyntaxKind.EnumDeclaration */;
    }
    ts.isModuleOrEnumDeclaration = isModuleOrEnumDeclaration;
    function isDeclarationKind(kind) {
        return kind === 216 /* SyntaxKind.ArrowFunction */
            || kind === 205 /* SyntaxKind.BindingElement */
            || kind === 260 /* SyntaxKind.ClassDeclaration */
            || kind === 228 /* SyntaxKind.ClassExpression */
            || kind === 172 /* SyntaxKind.ClassStaticBlockDeclaration */
            || kind === 173 /* SyntaxKind.Constructor */
            || kind === 263 /* SyntaxKind.EnumDeclaration */
            || kind === 302 /* SyntaxKind.EnumMember */
            || kind === 278 /* SyntaxKind.ExportSpecifier */
            || kind === 259 /* SyntaxKind.FunctionDeclaration */
            || kind === 215 /* SyntaxKind.FunctionExpression */
            || kind === 174 /* SyntaxKind.GetAccessor */
            || kind === 270 /* SyntaxKind.ImportClause */
            || kind === 268 /* SyntaxKind.ImportEqualsDeclaration */
            || kind === 273 /* SyntaxKind.ImportSpecifier */
            || kind === 261 /* SyntaxKind.InterfaceDeclaration */
            || kind === 288 /* SyntaxKind.JsxAttribute */
            || kind === 171 /* SyntaxKind.MethodDeclaration */
            || kind === 170 /* SyntaxKind.MethodSignature */
            || kind === 264 /* SyntaxKind.ModuleDeclaration */
            || kind === 267 /* SyntaxKind.NamespaceExportDeclaration */
            || kind === 271 /* SyntaxKind.NamespaceImport */
            || kind === 277 /* SyntaxKind.NamespaceExport */
            || kind === 166 /* SyntaxKind.Parameter */
            || kind === 299 /* SyntaxKind.PropertyAssignment */
            || kind === 169 /* SyntaxKind.PropertyDeclaration */
            || kind === 168 /* SyntaxKind.PropertySignature */
            || kind === 175 /* SyntaxKind.SetAccessor */
            || kind === 300 /* SyntaxKind.ShorthandPropertyAssignment */
            || kind === 262 /* SyntaxKind.TypeAliasDeclaration */
            || kind === 165 /* SyntaxKind.TypeParameter */
            || kind === 257 /* SyntaxKind.VariableDeclaration */
            || kind === 348 /* SyntaxKind.JSDocTypedefTag */
            || kind === 341 /* SyntaxKind.JSDocCallbackTag */
            || kind === 350 /* SyntaxKind.JSDocPropertyTag */;
    }
    function isDeclarationStatementKind(kind) {
        return kind === 259 /* SyntaxKind.FunctionDeclaration */
            || kind === 279 /* SyntaxKind.MissingDeclaration */
            || kind === 260 /* SyntaxKind.ClassDeclaration */
            || kind === 261 /* SyntaxKind.InterfaceDeclaration */
            || kind === 262 /* SyntaxKind.TypeAliasDeclaration */
            || kind === 263 /* SyntaxKind.EnumDeclaration */
            || kind === 264 /* SyntaxKind.ModuleDeclaration */
            || kind === 269 /* SyntaxKind.ImportDeclaration */
            || kind === 268 /* SyntaxKind.ImportEqualsDeclaration */
            || kind === 275 /* SyntaxKind.ExportDeclaration */
            || kind === 274 /* SyntaxKind.ExportAssignment */
            || kind === 267 /* SyntaxKind.NamespaceExportDeclaration */;
    }
    function isStatementKindButNotDeclarationKind(kind) {
        return kind === 249 /* SyntaxKind.BreakStatement */
            || kind === 248 /* SyntaxKind.ContinueStatement */
            || kind === 256 /* SyntaxKind.DebuggerStatement */
            || kind === 243 /* SyntaxKind.DoStatement */
            || kind === 241 /* SyntaxKind.ExpressionStatement */
            || kind === 239 /* SyntaxKind.EmptyStatement */
            || kind === 246 /* SyntaxKind.ForInStatement */
            || kind === 247 /* SyntaxKind.ForOfStatement */
            || kind === 245 /* SyntaxKind.ForStatement */
            || kind === 242 /* SyntaxKind.IfStatement */
            || kind === 253 /* SyntaxKind.LabeledStatement */
            || kind === 250 /* SyntaxKind.ReturnStatement */
            || kind === 252 /* SyntaxKind.SwitchStatement */
            || kind === 254 /* SyntaxKind.ThrowStatement */
            || kind === 255 /* SyntaxKind.TryStatement */
            || kind === 240 /* SyntaxKind.VariableStatement */
            || kind === 244 /* SyntaxKind.WhileStatement */
            || kind === 251 /* SyntaxKind.WithStatement */
            || kind === 352 /* SyntaxKind.NotEmittedStatement */
            || kind === 356 /* SyntaxKind.EndOfDeclarationMarker */
            || kind === 355 /* SyntaxKind.MergeDeclarationMarker */;
    }
    /* @internal */
    function isDeclaration(node) {
        if (node.kind === 165 /* SyntaxKind.TypeParameter */) {
            return (node.parent && node.parent.kind !== 347 /* SyntaxKind.JSDocTemplateTag */) || ts.isInJSFile(node);
        }
        return isDeclarationKind(node.kind);
    }
    ts.isDeclaration = isDeclaration;
    /* @internal */
    function isDeclarationStatement(node) {
        return isDeclarationStatementKind(node.kind);
    }
    ts.isDeclarationStatement = isDeclarationStatement;
    /**
     * Determines whether the node is a statement that is not also a declaration
     */
    /* @internal */
    function isStatementButNotDeclaration(node) {
        return isStatementKindButNotDeclarationKind(node.kind);
    }
    ts.isStatementButNotDeclaration = isStatementButNotDeclaration;
    /* @internal */
    function isStatement(node) {
        var kind = node.kind;
        return isStatementKindButNotDeclarationKind(kind)
            || isDeclarationStatementKind(kind)
            || isBlockStatement(node);
    }
    ts.isStatement = isStatement;
    function isBlockStatement(node) {
        if (node.kind !== 238 /* SyntaxKind.Block */)
            return false;
        if (node.parent !== undefined) {
            if (node.parent.kind === 255 /* SyntaxKind.TryStatement */ || node.parent.kind === 295 /* SyntaxKind.CatchClause */) {
                return false;
            }
        }
        return !ts.isFunctionBlock(node);
    }
    /**
     * NOTE: This is similar to `isStatement` but does not access parent pointers.
     */
    /* @internal */
    function isStatementOrBlock(node) {
        var kind = node.kind;
        return isStatementKindButNotDeclarationKind(kind)
            || isDeclarationStatementKind(kind)
            || kind === 238 /* SyntaxKind.Block */;
    }
    ts.isStatementOrBlock = isStatementOrBlock;
    // Module references
    /* @internal */
    function isModuleReference(node) {
        var kind = node.kind;
        return kind === 280 /* SyntaxKind.ExternalModuleReference */
            || kind === 163 /* SyntaxKind.QualifiedName */
            || kind === 79 /* SyntaxKind.Identifier */;
    }
    ts.isModuleReference = isModuleReference;
    // JSX
    /* @internal */
    function isJsxTagNameExpression(node) {
        var kind = node.kind;
        return kind === 108 /* SyntaxKind.ThisKeyword */
            || kind === 79 /* SyntaxKind.Identifier */
            || kind === 208 /* SyntaxKind.PropertyAccessExpression */;
    }
    ts.isJsxTagNameExpression = isJsxTagNameExpression;
    /* @internal */
    function isJsxChild(node) {
        var kind = node.kind;
        return kind === 281 /* SyntaxKind.JsxElement */
            || kind === 291 /* SyntaxKind.JsxExpression */
            || kind === 282 /* SyntaxKind.JsxSelfClosingElement */
            || kind === 11 /* SyntaxKind.JsxText */
            || kind === 285 /* SyntaxKind.JsxFragment */;
    }
    ts.isJsxChild = isJsxChild;
    /* @internal */
    function isJsxAttributeLike(node) {
        var kind = node.kind;
        return kind === 288 /* SyntaxKind.JsxAttribute */
            || kind === 290 /* SyntaxKind.JsxSpreadAttribute */;
    }
    ts.isJsxAttributeLike = isJsxAttributeLike;
    /* @internal */
    function isStringLiteralOrJsxExpression(node) {
        var kind = node.kind;
        return kind === 10 /* SyntaxKind.StringLiteral */
            || kind === 291 /* SyntaxKind.JsxExpression */;
    }
    ts.isStringLiteralOrJsxExpression = isStringLiteralOrJsxExpression;
    function isJsxOpeningLikeElement(node) {
        var kind = node.kind;
        return kind === 283 /* SyntaxKind.JsxOpeningElement */
            || kind === 282 /* SyntaxKind.JsxSelfClosingElement */;
    }
    ts.isJsxOpeningLikeElement = isJsxOpeningLikeElement;
    // Clauses
    function isCaseOrDefaultClause(node) {
        var kind = node.kind;
        return kind === 292 /* SyntaxKind.CaseClause */
            || kind === 293 /* SyntaxKind.DefaultClause */;
    }
    ts.isCaseOrDefaultClause = isCaseOrDefaultClause;
    // JSDoc
    /** True if node is of some JSDoc syntax kind. */
    /* @internal */
    function isJSDocNode(node) {
        return node.kind >= 312 /* SyntaxKind.FirstJSDocNode */ && node.kind <= 350 /* SyntaxKind.LastJSDocNode */;
    }
    ts.isJSDocNode = isJSDocNode;
    /** True if node is of a kind that may contain comment text. */
    function isJSDocCommentContainingNode(node) {
        return node.kind === 323 /* SyntaxKind.JSDoc */
            || node.kind === 322 /* SyntaxKind.JSDocNamepathType */
            || node.kind === 324 /* SyntaxKind.JSDocText */
            || isJSDocLinkLike(node)
            || isJSDocTag(node)
            || ts.isJSDocTypeLiteral(node)
            || ts.isJSDocSignature(node);
    }
    ts.isJSDocCommentContainingNode = isJSDocCommentContainingNode;
    // TODO: determine what this does before making it public.
    /* @internal */
    function isJSDocTag(node) {
        return node.kind >= 330 /* SyntaxKind.FirstJSDocTagNode */ && node.kind <= 350 /* SyntaxKind.LastJSDocTagNode */;
    }
    ts.isJSDocTag = isJSDocTag;
    function isSetAccessor(node) {
        return node.kind === 175 /* SyntaxKind.SetAccessor */;
    }
    ts.isSetAccessor = isSetAccessor;
    function isGetAccessor(node) {
        return node.kind === 174 /* SyntaxKind.GetAccessor */;
    }
    ts.isGetAccessor = isGetAccessor;
    /** True if has jsdoc nodes attached to it. */
    /* @internal */
    // TODO: GH#19856 Would like to return `node is Node & { jsDoc: JSDoc[] }` but it causes long compile times
    function hasJSDocNodes(node) {
        var jsDoc = node.jsDoc;
        return !!jsDoc && jsDoc.length > 0;
    }
    ts.hasJSDocNodes = hasJSDocNodes;
    /** True if has type node attached to it. */
    /* @internal */
    function hasType(node) {
        return !!node.type;
    }
    ts.hasType = hasType;
    /** True if has initializer node attached to it. */
    /* @internal */
    function hasInitializer(node) {
        return !!node.initializer;
    }
    ts.hasInitializer = hasInitializer;
    /** True if has initializer node attached to it. */
    function hasOnlyExpressionInitializer(node) {
        switch (node.kind) {
            case 257 /* SyntaxKind.VariableDeclaration */:
            case 166 /* SyntaxKind.Parameter */:
            case 205 /* SyntaxKind.BindingElement */:
            case 169 /* SyntaxKind.PropertyDeclaration */:
            case 299 /* SyntaxKind.PropertyAssignment */:
            case 302 /* SyntaxKind.EnumMember */:
                return true;
            default:
                return false;
        }
    }
    ts.hasOnlyExpressionInitializer = hasOnlyExpressionInitializer;
    function isObjectLiteralElement(node) {
        return node.kind === 288 /* SyntaxKind.JsxAttribute */ || node.kind === 290 /* SyntaxKind.JsxSpreadAttribute */ || isObjectLiteralElementLike(node);
    }
    ts.isObjectLiteralElement = isObjectLiteralElement;
    /* @internal */
    function isTypeReferenceType(node) {
        return node.kind === 180 /* SyntaxKind.TypeReference */ || node.kind === 230 /* SyntaxKind.ExpressionWithTypeArguments */;
    }
    ts.isTypeReferenceType = isTypeReferenceType;
    var MAX_SMI_X86 = 1073741823;
    /* @internal */
    function guessIndentation(lines) {
        var indentation = MAX_SMI_X86;
        for (var _i = 0, lines_1 = lines; _i < lines_1.length; _i++) {
            var line = lines_1[_i];
            if (!line.length) {
                continue;
            }
            var i = 0;
            for (; i < line.length && i < indentation; i++) {
                if (!ts.isWhiteSpaceLike(line.charCodeAt(i))) {
                    break;
                }
            }
            if (i < indentation) {
                indentation = i;
            }
            if (indentation === 0) {
                return 0;
            }
        }
        return indentation === MAX_SMI_X86 ? undefined : indentation;
    }
    ts.guessIndentation = guessIndentation;
    function isStringLiteralLike(node) {
        return node.kind === 10 /* SyntaxKind.StringLiteral */ || node.kind === 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */;
    }
    ts.isStringLiteralLike = isStringLiteralLike;
    function isJSDocLinkLike(node) {
        return node.kind === 327 /* SyntaxKind.JSDocLink */ || node.kind === 328 /* SyntaxKind.JSDocLinkCode */ || node.kind === 329 /* SyntaxKind.JSDocLinkPlain */;
    }
    ts.isJSDocLinkLike = isJSDocLinkLike;
    function hasRestParameter(s) {
        var last = ts.lastOrUndefined(s.parameters);
        return !!last && isRestParameter(last);
    }
    ts.hasRestParameter = hasRestParameter;
    function isRestParameter(node) {
        var type = ts.isJSDocParameterTag(node) ? (node.typeExpression && node.typeExpression.type) : node.type;
        return node.dotDotDotToken !== undefined || !!type && type.kind === 321 /* SyntaxKind.JSDocVariadicType */;
    }
    ts.isRestParameter = isRestParameter;
    // #endregion
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    ts.resolvingEmptyArray = [];
    ts.externalHelpersModuleNameText = "tslib";
    ts.defaultMaximumTruncationLength = 160;
    ts.noTruncationMaximumTruncationLength = 1000000;
    function getDeclarationOfKind(symbol, kind) {
        var declarations = symbol.declarations;
        if (declarations) {
            for (var _i = 0, declarations_1 = declarations; _i < declarations_1.length; _i++) {
                var declaration = declarations_1[_i];
                if (declaration.kind === kind) {
                    return declaration;
                }
            }
        }
        return undefined;
    }
    ts.getDeclarationOfKind = getDeclarationOfKind;
    function getDeclarationsOfKind(symbol, kind) {
        return ts.filter(symbol.declarations || ts.emptyArray, function (d) { return d.kind === kind; });
    }
    ts.getDeclarationsOfKind = getDeclarationsOfKind;
    function createSymbolTable(symbols) {
        var result = new ts.Map();
        if (symbols) {
            for (var _i = 0, symbols_1 = symbols; _i < symbols_1.length; _i++) {
                var symbol = symbols_1[_i];
                result.set(symbol.escapedName, symbol);
            }
        }
        return result;
    }
    ts.createSymbolTable = createSymbolTable;
    function isTransientSymbol(symbol) {
        return (symbol.flags & 33554432 /* SymbolFlags.Transient */) !== 0;
    }
    ts.isTransientSymbol = isTransientSymbol;
    var stringWriter = createSingleLineStringWriter();
    function createSingleLineStringWriter() {
        var str = "";
        var writeText = function (text) { return str += text; };
        return {
            getText: function () { return str; },
            write: writeText,
            rawWrite: writeText,
            writeKeyword: writeText,
            writeOperator: writeText,
            writePunctuation: writeText,
            writeSpace: writeText,
            writeStringLiteral: writeText,
            writeLiteral: writeText,
            writeParameter: writeText,
            writeProperty: writeText,
            writeSymbol: function (s, _) { return writeText(s); },
            writeTrailingSemicolon: writeText,
            writeComment: writeText,
            getTextPos: function () { return str.length; },
            getLine: function () { return 0; },
            getColumn: function () { return 0; },
            getIndent: function () { return 0; },
            isAtStartOfLine: function () { return false; },
            hasTrailingComment: function () { return false; },
            hasTrailingWhitespace: function () { return !!str.length && ts.isWhiteSpaceLike(str.charCodeAt(str.length - 1)); },
            // Completely ignore indentation for string writers.  And map newlines to
            // a single space.
            writeLine: function () { return str += " "; },
            increaseIndent: ts.noop,
            decreaseIndent: ts.noop,
            clear: function () { return str = ""; },
            trackSymbol: function () { return false; },
            reportInaccessibleThisError: ts.noop,
            reportInaccessibleUniqueSymbolError: ts.noop,
            reportPrivateInBaseOfClassExpression: ts.noop,
        };
    }
    function changesAffectModuleResolution(oldOptions, newOptions) {
        return oldOptions.configFilePath !== newOptions.configFilePath ||
            optionsHaveModuleResolutionChanges(oldOptions, newOptions);
    }
    ts.changesAffectModuleResolution = changesAffectModuleResolution;
    function optionsHaveModuleResolutionChanges(oldOptions, newOptions) {
        return optionsHaveChanges(oldOptions, newOptions, ts.moduleResolutionOptionDeclarations);
    }
    ts.optionsHaveModuleResolutionChanges = optionsHaveModuleResolutionChanges;
    function changesAffectingProgramStructure(oldOptions, newOptions) {
        return optionsHaveChanges(oldOptions, newOptions, ts.optionsAffectingProgramStructure);
    }
    ts.changesAffectingProgramStructure = changesAffectingProgramStructure;
    function optionsHaveChanges(oldOptions, newOptions, optionDeclarations) {
        return oldOptions !== newOptions && optionDeclarations.some(function (o) {
            return !isJsonEqual(getCompilerOptionValue(oldOptions, o), getCompilerOptionValue(newOptions, o));
        });
    }
    ts.optionsHaveChanges = optionsHaveChanges;
    function forEachAncestor(node, callback) {
        while (true) {
            var res = callback(node);
            if (res === "quit")
                return undefined;
            if (res !== undefined)
                return res;
            if (ts.isSourceFile(node))
                return undefined;
            node = node.parent;
        }
    }
    ts.forEachAncestor = forEachAncestor;
    /**
     * Calls `callback` for each entry in the map, returning the first truthy result.
     * Use `map.forEach` instead for normal iteration.
     */
    function forEachEntry(map, callback) {
        var iterator = map.entries();
        for (var iterResult = iterator.next(); !iterResult.done; iterResult = iterator.next()) {
            var _a = iterResult.value, key = _a[0], value = _a[1];
            var result = callback(value, key);
            if (result) {
                return result;
            }
        }
        return undefined;
    }
    ts.forEachEntry = forEachEntry;
    /** `forEachEntry` for just keys. */
    function forEachKey(map, callback) {
        var iterator = map.keys();
        for (var iterResult = iterator.next(); !iterResult.done; iterResult = iterator.next()) {
            var result = callback(iterResult.value);
            if (result) {
                return result;
            }
        }
        return undefined;
    }
    ts.forEachKey = forEachKey;
    /** Copy entries from `source` to `target`. */
    function copyEntries(source, target) {
        source.forEach(function (value, key) {
            target.set(key, value);
        });
    }
    ts.copyEntries = copyEntries;
    function usingSingleLineStringWriter(action) {
        var oldString = stringWriter.getText();
        try {
            action(stringWriter);
            return stringWriter.getText();
        }
        finally {
            stringWriter.clear();
            stringWriter.writeKeyword(oldString);
        }
    }
    ts.usingSingleLineStringWriter = usingSingleLineStringWriter;
    function getFullWidth(node) {
        return node.end - node.pos;
    }
    ts.getFullWidth = getFullWidth;
    function getResolvedModule(sourceFile, moduleNameText, mode) {
        return sourceFile && sourceFile.resolvedModules && sourceFile.resolvedModules.get(moduleNameText, mode);
    }
    ts.getResolvedModule = getResolvedModule;
    function setResolvedModule(sourceFile, moduleNameText, resolvedModule, mode) {
        if (!sourceFile.resolvedModules) {
            sourceFile.resolvedModules = ts.createModeAwareCache();
        }
        sourceFile.resolvedModules.set(moduleNameText, mode, resolvedModule);
    }
    ts.setResolvedModule = setResolvedModule;
    function setResolvedTypeReferenceDirective(sourceFile, typeReferenceDirectiveName, resolvedTypeReferenceDirective) {
        if (!sourceFile.resolvedTypeReferenceDirectiveNames) {
            sourceFile.resolvedTypeReferenceDirectiveNames = ts.createModeAwareCache();
        }
        sourceFile.resolvedTypeReferenceDirectiveNames.set(typeReferenceDirectiveName, /*mode*/ undefined, resolvedTypeReferenceDirective);
    }
    ts.setResolvedTypeReferenceDirective = setResolvedTypeReferenceDirective;
    function projectReferenceIsEqualTo(oldRef, newRef) {
        return oldRef.path === newRef.path &&
            !oldRef.prepend === !newRef.prepend &&
            !oldRef.circular === !newRef.circular;
    }
    ts.projectReferenceIsEqualTo = projectReferenceIsEqualTo;
    function moduleResolutionIsEqualTo(oldResolution, newResolution) {
        return oldResolution.isExternalLibraryImport === newResolution.isExternalLibraryImport &&
            oldResolution.extension === newResolution.extension &&
            oldResolution.resolvedFileName === newResolution.resolvedFileName &&
            oldResolution.originalPath === newResolution.originalPath &&
            packageIdIsEqual(oldResolution.packageId, newResolution.packageId);
    }
    ts.moduleResolutionIsEqualTo = moduleResolutionIsEqualTo;
    function packageIdIsEqual(a, b) {
        return a === b || !!a && !!b && a.name === b.name && a.subModuleName === b.subModuleName && a.version === b.version;
    }
    function packageIdToPackageName(_a) {
        var name = _a.name, subModuleName = _a.subModuleName;
        return subModuleName ? "".concat(name, "/").concat(subModuleName) : name;
    }
    ts.packageIdToPackageName = packageIdToPackageName;
    function packageIdToString(packageId) {
        return "".concat(packageIdToPackageName(packageId), "@").concat(packageId.version);
    }
    ts.packageIdToString = packageIdToString;
    function typeDirectiveIsEqualTo(oldResolution, newResolution) {
        return oldResolution.resolvedFileName === newResolution.resolvedFileName
            && oldResolution.primary === newResolution.primary
            && oldResolution.originalPath === newResolution.originalPath;
    }
    ts.typeDirectiveIsEqualTo = typeDirectiveIsEqualTo;
    function hasChangesInResolutions(names, newResolutions, oldResolutions, oldSourceFile, comparer) {
        ts.Debug.assert(names.length === newResolutions.length);
        for (var i = 0; i < names.length; i++) {
            var newResolution = newResolutions[i];
            var entry = names[i];
            // We lower-case all type references because npm automatically lowercases all packages. See GH#9824.
            var name = !ts.isString(entry) ? entry.fileName.toLowerCase() : entry;
            var mode = !ts.isString(entry) ? ts.getModeForFileReference(entry, oldSourceFile === null || oldSourceFile === void 0 ? void 0 : oldSourceFile.impliedNodeFormat) : oldSourceFile && ts.getModeForResolutionAtIndex(oldSourceFile, i);
            var oldResolution = oldResolutions && oldResolutions.get(name, mode);
            var changed = oldResolution
                ? !newResolution || !comparer(oldResolution, newResolution)
                : newResolution;
            if (changed) {
                return true;
            }
        }
        return false;
    }
    ts.hasChangesInResolutions = hasChangesInResolutions;
    // Returns true if this node contains a parse error anywhere underneath it.
    function containsParseError(node) {
        aggregateChildData(node);
        return (node.flags & 524288 /* NodeFlags.ThisNodeOrAnySubNodesHasError */) !== 0;
    }
    ts.containsParseError = containsParseError;
    function aggregateChildData(node) {
        if (!(node.flags & 1048576 /* NodeFlags.HasAggregatedChildData */)) {
            // A node is considered to contain a parse error if:
            //  a) the parser explicitly marked that it had an error
            //  b) any of it's children reported that it had an error.
            var thisNodeOrAnySubNodesHasError = ((node.flags & 131072 /* NodeFlags.ThisNodeHasError */) !== 0) ||
                ts.forEachChild(node, containsParseError);
            // If so, mark ourselves accordingly.
            if (thisNodeOrAnySubNodesHasError) {
                node.flags |= 524288 /* NodeFlags.ThisNodeOrAnySubNodesHasError */;
            }
            // Also mark that we've propagated the child information to this node.  This way we can
            // always consult the bit directly on this node without needing to check its children
            // again.
            node.flags |= 1048576 /* NodeFlags.HasAggregatedChildData */;
        }
    }
    function getSourceFileOfNode(node) {
        while (node && node.kind !== 308 /* SyntaxKind.SourceFile */) {
            node = node.parent;
        }
        return node;
    }
    ts.getSourceFileOfNode = getSourceFileOfNode;
    function getSourceFileOfModule(module) {
        return getSourceFileOfNode(module.valueDeclaration || getNonAugmentationDeclaration(module));
    }
    ts.getSourceFileOfModule = getSourceFileOfModule;
    function isPlainJsFile(file, checkJs) {
        return !!file && (file.scriptKind === 1 /* ScriptKind.JS */ || file.scriptKind === 2 /* ScriptKind.JSX */) && !file.checkJsDirective && checkJs === undefined;
    }
    ts.isPlainJsFile = isPlainJsFile;
    function isStatementWithLocals(node) {
        switch (node.kind) {
            case 238 /* SyntaxKind.Block */:
            case 266 /* SyntaxKind.CaseBlock */:
            case 245 /* SyntaxKind.ForStatement */:
            case 246 /* SyntaxKind.ForInStatement */:
            case 247 /* SyntaxKind.ForOfStatement */:
                return true;
        }
        return false;
    }
    ts.isStatementWithLocals = isStatementWithLocals;
    function getStartPositionOfLine(line, sourceFile) {
        ts.Debug.assert(line >= 0);
        return ts.getLineStarts(sourceFile)[line];
    }
    ts.getStartPositionOfLine = getStartPositionOfLine;
    // This is a useful function for debugging purposes.
    function nodePosToString(node) {
        var file = getSourceFileOfNode(node);
        var loc = ts.getLineAndCharacterOfPosition(file, node.pos);
        return "".concat(file.fileName, "(").concat(loc.line + 1, ",").concat(loc.character + 1, ")");
    }
    ts.nodePosToString = nodePosToString;
    function getEndLinePosition(line, sourceFile) {
        ts.Debug.assert(line >= 0);
        var lineStarts = ts.getLineStarts(sourceFile);
        var lineIndex = line;
        var sourceText = sourceFile.text;
        if (lineIndex + 1 === lineStarts.length) {
            // last line - return EOF
            return sourceText.length - 1;
        }
        else {
            // current line start
            var start = lineStarts[lineIndex];
            // take the start position of the next line - 1 = it should be some line break
            var pos = lineStarts[lineIndex + 1] - 1;
            ts.Debug.assert(ts.isLineBreak(sourceText.charCodeAt(pos)));
            // walk backwards skipping line breaks, stop the the beginning of current line.
            // i.e:
            // <some text>
            // $ <- end of line for this position should match the start position
            while (start <= pos && ts.isLineBreak(sourceText.charCodeAt(pos))) {
                pos--;
            }
            return pos;
        }
    }
    ts.getEndLinePosition = getEndLinePosition;
    /**
     * Returns a value indicating whether a name is unique globally or within the current file.
     * Note: This does not consider whether a name appears as a free identifier or not, so at the expression `x.y` this includes both `x` and `y`.
     */
    function isFileLevelUniqueName(sourceFile, name, hasGlobalName) {
        return !(hasGlobalName && hasGlobalName(name)) && !sourceFile.identifiers.has(name);
    }
    ts.isFileLevelUniqueName = isFileLevelUniqueName;
    // Returns true if this node is missing from the actual source code. A 'missing' node is different
    // from 'undefined/defined'. When a node is undefined (which can happen for optional nodes
    // in the tree), it is definitely missing. However, a node may be defined, but still be
    // missing.  This happens whenever the parser knows it needs to parse something, but can't
    // get anything in the source code that it expects at that location. For example:
    //
    //          let a: ;
    //
    // Here, the Type in the Type-Annotation is not-optional (as there is a colon in the source
    // code). So the parser will attempt to parse out a type, and will create an actual node.
    // However, this node will be 'missing' in the sense that no actual source-code/tokens are
    // contained within it.
    function nodeIsMissing(node) {
        if (node === undefined) {
            return true;
        }
        return node.pos === node.end && node.pos >= 0 && node.kind !== 1 /* SyntaxKind.EndOfFileToken */;
    }
    ts.nodeIsMissing = nodeIsMissing;
    function nodeIsPresent(node) {
        return !nodeIsMissing(node);
    }
    ts.nodeIsPresent = nodeIsPresent;
    function insertStatementsAfterPrologue(to, from, isPrologueDirective) {
        if (from === undefined || from.length === 0)
            return to;
        var statementIndex = 0;
        // skip all prologue directives to insert at the correct position
        for (; statementIndex < to.length; ++statementIndex) {
            if (!isPrologueDirective(to[statementIndex])) {
                break;
            }
        }
        to.splice.apply(to, __spreadArray([statementIndex, 0], from, false));
        return to;
    }
    function insertStatementAfterPrologue(to, statement, isPrologueDirective) {
        if (statement === undefined)
            return to;
        var statementIndex = 0;
        // skip all prologue directives to insert at the correct position
        for (; statementIndex < to.length; ++statementIndex) {
            if (!isPrologueDirective(to[statementIndex])) {
                break;
            }
        }
        to.splice(statementIndex, 0, statement);
        return to;
    }
    function isAnyPrologueDirective(node) {
        return isPrologueDirective(node) || !!(getEmitFlags(node) & 1048576 /* EmitFlags.CustomPrologue */);
    }
    /**
     * Prepends statements to an array while taking care of prologue directives.
     */
    function insertStatementsAfterStandardPrologue(to, from) {
        return insertStatementsAfterPrologue(to, from, isPrologueDirective);
    }
    ts.insertStatementsAfterStandardPrologue = insertStatementsAfterStandardPrologue;
    function insertStatementsAfterCustomPrologue(to, from) {
        return insertStatementsAfterPrologue(to, from, isAnyPrologueDirective);
    }
    ts.insertStatementsAfterCustomPrologue = insertStatementsAfterCustomPrologue;
    /**
     * Prepends statements to an array while taking care of prologue directives.
     */
    function insertStatementAfterStandardPrologue(to, statement) {
        return insertStatementAfterPrologue(to, statement, isPrologueDirective);
    }
    ts.insertStatementAfterStandardPrologue = insertStatementAfterStandardPrologue;
    function insertStatementAfterCustomPrologue(to, statement) {
        return insertStatementAfterPrologue(to, statement, isAnyPrologueDirective);
    }
    ts.insertStatementAfterCustomPrologue = insertStatementAfterCustomPrologue;
    /**
     * Determine if the given comment is a triple-slash
     *
     * @return true if the comment is a triple-slash comment else false
     */
    function isRecognizedTripleSlashComment(text, commentPos, commentEnd) {
        // Verify this is /// comment, but do the regexp match only when we first can find /// in the comment text
        // so that we don't end up computing comment string and doing match for all // comments
        if (text.charCodeAt(commentPos + 1) === 47 /* CharacterCodes.slash */ &&
            commentPos + 2 < commentEnd &&
            text.charCodeAt(commentPos + 2) === 47 /* CharacterCodes.slash */) {
            var textSubStr = text.substring(commentPos, commentEnd);
            return ts.fullTripleSlashReferencePathRegEx.test(textSubStr) ||
                ts.fullTripleSlashAMDReferencePathRegEx.test(textSubStr) ||
                fullTripleSlashReferenceTypeReferenceDirectiveRegEx.test(textSubStr) ||
                defaultLibReferenceRegEx.test(textSubStr) ?
                true : false;
        }
        return false;
    }
    ts.isRecognizedTripleSlashComment = isRecognizedTripleSlashComment;
    function isPinnedComment(text, start) {
        return text.charCodeAt(start + 1) === 42 /* CharacterCodes.asterisk */ &&
            text.charCodeAt(start + 2) === 33 /* CharacterCodes.exclamation */;
    }
    ts.isPinnedComment = isPinnedComment;
    function createCommentDirectivesMap(sourceFile, commentDirectives) {
        var directivesByLine = new ts.Map(commentDirectives.map(function (commentDirective) { return ([
            "".concat(ts.getLineAndCharacterOfPosition(sourceFile, commentDirective.range.end).line),
            commentDirective,
        ]); }));
        var usedLines = new ts.Map();
        return { getUnusedExpectations: getUnusedExpectations, markUsed: markUsed };
        function getUnusedExpectations() {
            return ts.arrayFrom(directivesByLine.entries())
                .filter(function (_a) {
                var line = _a[0], directive = _a[1];
                return directive.type === 0 /* CommentDirectiveType.ExpectError */ && !usedLines.get(line);
            })
                .map(function (_a) {
                var _ = _a[0], directive = _a[1];
                return directive;
            });
        }
        function markUsed(line) {
            if (!directivesByLine.has("".concat(line))) {
                return false;
            }
            usedLines.set("".concat(line), true);
            return true;
        }
    }
    ts.createCommentDirectivesMap = createCommentDirectivesMap;
    function getTokenPosOfNode(node, sourceFile, includeJsDoc) {
        // With nodes that have no width (i.e. 'Missing' nodes), we actually *don't*
        // want to skip trivia because this will launch us forward to the next token.
        if (nodeIsMissing(node)) {
            return node.pos;
        }
        if (ts.isJSDocNode(node) || node.kind === 11 /* SyntaxKind.JsxText */) {
            // JsxText cannot actually contain comments, even though the scanner will think it sees comments
            return ts.skipTrivia((sourceFile || getSourceFileOfNode(node)).text, node.pos, /*stopAfterLineBreak*/ false, /*stopAtComments*/ true);
        }
        if (includeJsDoc && ts.hasJSDocNodes(node)) {
            return getTokenPosOfNode(node.jsDoc[0], sourceFile);
        }
        // For a syntax list, it is possible that one of its children has JSDocComment nodes, while
        // the syntax list itself considers them as normal trivia. Therefore if we simply skip
        // trivia for the list, we may have skipped the JSDocComment as well. So we should process its
        // first child to determine the actual position of its first token.
        if (node.kind === 351 /* SyntaxKind.SyntaxList */ && node._children.length > 0) {
            return getTokenPosOfNode(node._children[0], sourceFile, includeJsDoc);
        }
        return ts.skipTrivia((sourceFile || getSourceFileOfNode(node)).text, node.pos,
        /*stopAfterLineBreak*/ false,
        /*stopAtComments*/ false, isInJSDoc(node));
    }
    ts.getTokenPosOfNode = getTokenPosOfNode;
    function getNonDecoratorTokenPosOfNode(node, sourceFile) {
        var lastDecorator = !nodeIsMissing(node) && ts.canHaveModifiers(node) ? ts.findLast(node.modifiers, ts.isDecorator) : undefined;
        if (!lastDecorator) {
            return getTokenPosOfNode(node, sourceFile);
        }
        return ts.skipTrivia((sourceFile || getSourceFileOfNode(node)).text, lastDecorator.end);
    }
    ts.getNonDecoratorTokenPosOfNode = getNonDecoratorTokenPosOfNode;
    function getSourceTextOfNodeFromSourceFile(sourceFile, node, includeTrivia) {
        if (includeTrivia === void 0) { includeTrivia = false; }
        return getTextOfNodeFromSourceText(sourceFile.text, node, includeTrivia);
    }
    ts.getSourceTextOfNodeFromSourceFile = getSourceTextOfNodeFromSourceFile;
    function isJSDocTypeExpressionOrChild(node) {
        return !!ts.findAncestor(node, ts.isJSDocTypeExpression);
    }
    function isExportNamespaceAsDefaultDeclaration(node) {
        return !!(ts.isExportDeclaration(node) && node.exportClause && ts.isNamespaceExport(node.exportClause) && node.exportClause.name.escapedText === "default");
    }
    ts.isExportNamespaceAsDefaultDeclaration = isExportNamespaceAsDefaultDeclaration;
    function getTextOfNodeFromSourceText(sourceText, node, includeTrivia) {
        if (includeTrivia === void 0) { includeTrivia = false; }
        if (nodeIsMissing(node)) {
            return "";
        }
        var text = sourceText.substring(includeTrivia ? node.pos : ts.skipTrivia(sourceText, node.pos), node.end);
        if (isJSDocTypeExpressionOrChild(node)) {
            // strip space + asterisk at line start
            text = text.split(/\r\n|\n|\r/).map(function (line) { return ts.trimStringStart(line.replace(/^\s*\*/, "")); }).join("\n");
        }
        return text;
    }
    ts.getTextOfNodeFromSourceText = getTextOfNodeFromSourceText;
    function getTextOfNode(node, includeTrivia) {
        if (includeTrivia === void 0) { includeTrivia = false; }
        return getSourceTextOfNodeFromSourceFile(getSourceFileOfNode(node), node, includeTrivia);
    }
    ts.getTextOfNode = getTextOfNode;
    function getPos(range) {
        return range.pos;
    }
    /**
     * Note: it is expected that the `nodeArray` and the `node` are within the same file.
     * For example, searching for a `SourceFile` in a `SourceFile[]` wouldn't work.
     */
    function indexOfNode(nodeArray, node) {
        return ts.binarySearch(nodeArray, node, getPos, ts.compareValues);
    }
    ts.indexOfNode = indexOfNode;
    /**
     * Gets flags that control emit behavior of a node.
     */
    function getEmitFlags(node) {
        var emitNode = node.emitNode;
        return emitNode && emitNode.flags || 0;
    }
    ts.getEmitFlags = getEmitFlags;
    function getScriptTargetFeatures() {
        return {
            es2015: {
                Array: ["find", "findIndex", "fill", "copyWithin", "entries", "keys", "values"],
                RegExp: ["flags", "sticky", "unicode"],
                Reflect: ["apply", "construct", "defineProperty", "deleteProperty", "get", " getOwnPropertyDescriptor", "getPrototypeOf", "has", "isExtensible", "ownKeys", "preventExtensions", "set", "setPrototypeOf"],
                ArrayConstructor: ["from", "of"],
                ObjectConstructor: ["assign", "getOwnPropertySymbols", "keys", "is", "setPrototypeOf"],
                NumberConstructor: ["isFinite", "isInteger", "isNaN", "isSafeInteger", "parseFloat", "parseInt"],
                Math: ["clz32", "imul", "sign", "log10", "log2", "log1p", "expm1", "cosh", "sinh", "tanh", "acosh", "asinh", "atanh", "hypot", "trunc", "fround", "cbrt"],
                Map: ["entries", "keys", "values"],
                Set: ["entries", "keys", "values"],
                Promise: ts.emptyArray,
                PromiseConstructor: ["all", "race", "reject", "resolve"],
                Symbol: ["for", "keyFor"],
                WeakMap: ["entries", "keys", "values"],
                WeakSet: ["entries", "keys", "values"],
                Iterator: ts.emptyArray,
                AsyncIterator: ts.emptyArray,
                String: ["codePointAt", "includes", "endsWith", "normalize", "repeat", "startsWith", "anchor", "big", "blink", "bold", "fixed", "fontcolor", "fontsize", "italics", "link", "small", "strike", "sub", "sup"],
                StringConstructor: ["fromCodePoint", "raw"]
            },
            es2016: {
                Array: ["includes"]
            },
            es2017: {
                Atomics: ts.emptyArray,
                SharedArrayBuffer: ts.emptyArray,
                String: ["padStart", "padEnd"],
                ObjectConstructor: ["values", "entries", "getOwnPropertyDescriptors"],
                DateTimeFormat: ["formatToParts"]
            },
            es2018: {
                Promise: ["finally"],
                RegExpMatchArray: ["groups"],
                RegExpExecArray: ["groups"],
                RegExp: ["dotAll"],
                Intl: ["PluralRules"],
                AsyncIterable: ts.emptyArray,
                AsyncIterableIterator: ts.emptyArray,
                AsyncGenerator: ts.emptyArray,
                AsyncGeneratorFunction: ts.emptyArray,
                NumberFormat: ["formatToParts"]
            },
            es2019: {
                Array: ["flat", "flatMap"],
                ObjectConstructor: ["fromEntries"],
                String: ["trimStart", "trimEnd", "trimLeft", "trimRight"],
                Symbol: ["description"]
            },
            es2020: {
                BigInt: ts.emptyArray,
                BigInt64Array: ts.emptyArray,
                BigUint64Array: ts.emptyArray,
                PromiseConstructor: ["allSettled"],
                SymbolConstructor: ["matchAll"],
                String: ["matchAll"],
                DataView: ["setBigInt64", "setBigUint64", "getBigInt64", "getBigUint64"],
                RelativeTimeFormat: ["format", "formatToParts", "resolvedOptions"]
            },
            es2021: {
                PromiseConstructor: ["any"],
                String: ["replaceAll"]
            },
            es2022: {
                Array: ["at"],
                String: ["at"],
                Int8Array: ["at"],
                Uint8Array: ["at"],
                Uint8ClampedArray: ["at"],
                Int16Array: ["at"],
                Uint16Array: ["at"],
                Int32Array: ["at"],
                Uint32Array: ["at"],
                Float32Array: ["at"],
                Float64Array: ["at"],
                BigInt64Array: ["at"],
                BigUint64Array: ["at"],
                ObjectConstructor: ["hasOwn"],
                Error: ["cause"]
            }
        };
    }
    ts.getScriptTargetFeatures = getScriptTargetFeatures;
    var GetLiteralTextFlags;
    (function (GetLiteralTextFlags) {
        GetLiteralTextFlags[GetLiteralTextFlags["None"] = 0] = "None";
        GetLiteralTextFlags[GetLiteralTextFlags["NeverAsciiEscape"] = 1] = "NeverAsciiEscape";
        GetLiteralTextFlags[GetLiteralTextFlags["JsxAttributeEscape"] = 2] = "JsxAttributeEscape";
        GetLiteralTextFlags[GetLiteralTextFlags["TerminateUnterminatedLiterals"] = 4] = "Ter