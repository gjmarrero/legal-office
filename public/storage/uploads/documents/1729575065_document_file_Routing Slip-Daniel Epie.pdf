ent);
  }
}
ts.isInExpressionContext = isInExpressionContext;
function isPartOfTypeQuery(node) {
  while (node.kind === 163 /* SyntaxKind.QualifiedName */ || node.kind === 79 /* SyntaxKind.Identifier */) {
    node = node.parent;
  }
  return node.kind === 183 /* SyntaxKind.TypeQuery */;
}
ts.isPartOfTypeQuery = isPartOfTypeQuery;
function isNamespaceReexportDeclaration(node) {
  return ts.isNamespaceExport(node) && !!node.parent.moduleSpecifier;
}
ts.isNamespaceReexportDeclaration = isNamespaceReexportDeclaration;
function isExternalModuleImportEqualsDeclaration(node) {
  return node.kind === 268 /* SyntaxKind.ImportEqualsDeclaration */ &&
      node.moduleReference.kind === 280 /* SyntaxKind.ExternalModuleReference */;
}
ts.isExternalModuleImportEqualsDeclaration = isExternalModuleImportEqualsDeclaration;
function getExternalModuleImportEqualsDeclarationExpression(node) {
  ts.Debug.assert(isExternalModuleImportEqualsDeclaration(node));
  return node.moduleReference.expression;
}
ts.getExternalModuleImportEqualsDeclarationExpression = getExternalModuleImportEqualsDeclarationExpression;
function getExternalModuleRequireArgument(node) {
  return isVariableDeclarationInitializedToBareOrAccessedRequire(node) &&
      getLeftmostAccessExpression(node.initializer).arguments[0];
}
ts.getExternalModuleRequireArgument = getExternalModuleRequireArgument;
function isInternalModuleImportEqualsDeclaration(node) {
  return node.kind === 268 /* SyntaxKind.ImportEqualsDeclaration */ &&
      node.moduleReference.kind !== 280 /* SyntaxKind.ExternalModuleReference */;
}
ts.isInternalModuleImportEqualsDeclaration = isInternalModuleImportEqualsDeclaration;
function isSourceFileJS(file) {
  return isInJSFile(file);
}
ts.isSourceFileJS = isSourceFileJS;
function isSourceFileNotJS(file) {
  return !isInJSFile(file);
}
ts.isSourceFileNotJS = isSourceFileNotJS;
function isInJSFile(node) {
  return !!node && !!(node.flags & 262144 /* NodeFlags.JavaScriptFile */);
}
ts.isInJSFile = isInJSFile;
function isInJsonFile(node) {
  return !!node && !!(node.flags & 67108864 /* NodeFlags.JsonFile */);
}
ts.isInJsonFile = isInJsonFile;
function isSourceFileNotJson(file) {
  return !isJsonSourceFile(file);
}
ts.isSourceFileNotJson = isSourceFileNotJson;
function isInJSDoc(node) {
  return !!node && !!(node.flags & 8388608 /* NodeFlags.JSDoc */);
}
ts.isInJSDoc = isInJSDoc;
function isJSDocIndexSignature(node) {
  return ts.isTypeReferenceNode(node) && ts.isIdentifier(node.typeName) && node.typeName.escapedText === 'Object' &&
      node.typeArguments && node.typeArguments.length === 2 &&
      (node.typeArguments[0].kind === 152 /* SyntaxKind.StringKeyword */ ||
       node.typeArguments[0].kind === 148 /* SyntaxKind.NumberKeyword */);
}
ts.isJSDocIndexSignature = isJSDocIndexSignature;
function isRequireCall(callExpression, requireStringLiteralLikeArgument) {
  if (callExpression.kind !== 210 /* SyntaxKind.CallExpression */) {
    return false;
  }
  const _a = callExpression, expression = _a.expression, args = _a.arguments;
  if (expression.kind !== 79 /* SyntaxKind.Identifier */ || expression.escapedText !== 'require') {
    return false;
  }
  if (args.length !== 1) {
    return false;
  }
  const arg = args[0];
  return !requireStringLiteralLikeArgument || ts.isStringLiteralLike(arg);
}
ts.isRequireCall = isRequireCall;
/**
 * Returns true if the node is a VariableDeclaration initialized to a require call (see `isRequireCall`).
 * This function does not test if the node is in a JavaScript file or not.
 */
function isVariableDeclarationInitializedToRequire(node) {
  return isVariableDeclarationInitializedWithRequireHelper(node, /* allowAccessedRequire*/ false);
}
ts.isVariableDeclarationInitializedToRequire = isVariableDeclarationInitializedToRequire;
/**
 * Like {@link isVariableDeclarationInitializedToRequire} but allows things like `require("...").foo.bar` or `require("...")["baz"]`.
 */
function isVariableDeclarationInitializedToBareOrAccessedRequire(node) {
  return isVariableDeclarationInitializedWithRequireHelper(node, /* allowAccessedRequire*/ true);
}
ts.isVariableDeclarationInitializedToBareOrAccessedRequire = isVariableDeclarationInitializedToBareOrAccessedRequire;
function isVariableDeclarationInitializedWithRequireHelper(node, allowAccessedRequire) {
  return ts.isVariableDeclaration(node) && !!node.initializer &&
      isRequireCall(
             allowAccessedRequire ? getLeftmostAccessExpression(node.initializer) : node.initializer,
             /* requireStringLiteralLikeArgument*/ true);
}
function isRequireVariableStatement(node) {
  return ts.isVariableStatement(node) && node.declarationList.declarations.length > 0 &&
      ts.every(node.declarationList.declarations, function(decl) {
        return isVariableDeclarationInitializedToRequire(decl);
      });
}
ts.isRequireVariableStatement = isRequireVariableStatement;
function isSingleOrDoubleQuote(charCode) {
  return charCode === 39 /* CharacterCodes.singleQuote */ || charCode === 34 /* CharacterCodes.doubleQuote */;
}
ts.isSingleOrDoubleQuote = isSingleOrDoubleQuote;
function isStringDoubleQuoted(str, sourceFile) {
  return getSourceTextOfNodeFromSourceFile(sourceFile, str).charCodeAt(0) === 34 /* CharacterCodes.doubleQuote */;
}
ts.isStringDoubleQuoted = isStringDoubleQuoted;
function isAssignmentDeclaration(decl) {
  return ts.isBinaryExpression(decl) || isAccessExpression(decl) || ts.isIdentifier(decl) || ts.isCallExpression(decl);
}
ts.isAssignmentDeclaration = isAssignmentDeclaration;
/** Get the initializer, taking into account defaulted Javascript initializers */
function getEffectiveInitializer(node) {
  if (isInJSFile(node) && node.initializer && ts.isBinaryExpression(node.initializer) &&
      (node.initializer.operatorToken.kind === 56 /* SyntaxKind.BarBarToken */ ||
       node.initializer.operatorToken.kind === 60 /* SyntaxKind.QuestionQuestionToken */) &&
      node.name && isEntityNameExpression(node.name) && isSameEntityName(node.name, node.initializer.left)) {
    return node.initializer.right;
  }
  return node.initializer;
}
ts.getEffectiveInitializer = getEffectiveInitializer;
/** Get the declaration initializer when it is container-like (See getExpandoInitializer). */
function getDeclaredExpandoInitializer(node) {
  const init = getEffectiveInitializer(node);
  return init && getExpandoInitializer(init, isPrototypeAccess(node.name));
}
ts.getDeclaredExpandoInitializer = getDeclaredExpandoInitializer;
function hasExpandoValueProperty(node, isPrototypeAssignment) {
  return ts.forEach(node.properties, function(p) {
    return ts.isPropertyAssignment(p) && ts.isIdentifier(p.name) && p.name.escapedText === 'value' && p.initializer &&
        getExpandoInitializer(p.initializer, isPrototypeAssignment);
  });
}
/**
 * Get the assignment 'initializer' -- the righthand side-- when the initializer is container-like (See getExpandoInitializer).
 * We treat the right hand side of assignments with container-like initializers as declarations.
 */
function getAssignedExpandoInitializer(node) {
  if (node && node.parent && ts.isBinaryExpression(node.parent) &&
      node.parent.operatorToken.kind === 63 /* SyntaxKind.EqualsToken */) {
    const isPrototypeAssignment = isPrototypeAccess(node.parent.left);
    return getExpandoInitializer(node.parent.right, isPrototypeAssignment) ||
        getDefaultedExpandoInitializer(node.parent.left, node.parent.right, isPrototypeAssignment);
  }
  if (node && ts.isCallExpression(node) && isBindableObjectDefinePropertyCall(node)) {
    const result = hasExpandoValueProperty(node.arguments[2], node.arguments[1].text === 'prototype');
    if (result) {
      return result;
    }
  }
}
ts.getAssignedExpandoInitializer = getAssignedExpandoInitializer;
/**
 * Recognized expando initializers are:
 * 1. (function() {})() -- IIFEs
 * 2. function() { } -- Function expressions
 * 3. class { } -- Class expressions
 * 4. {} -- Empty object literals
 * 5. { ... } -- Non-empty object literals, when used to initialize a prototype, like `C.prototype = { m() { } }`
 *
 * This function returns the provided initializer, or undefined if it is not valid.
 */
function getExpandoInitializer(initializer, isPrototypeAssignment) {
  if (ts.isCallExpression(initializer)) {
    const e = skipParentheses(initializer.expression);
    return e.kind === 215 /* SyntaxKind.FunctionExpression */ || e.kind === 216 /* SyntaxKind.ArrowFunction */ ?
        initializer :
        undefined;
  }
  if (initializer.kind === 215 /* SyntaxKind.FunctionExpression */ ||
      initializer.kind === 228 /* SyntaxKind.ClassExpression */ ||
      initializer.kind === 216 /* SyntaxKind.ArrowFunction */) {
    return initializer;
  }
  if (ts.isObjectLiteralExpression(initializer) && (initializer.properties.length === 0 || isPrototypeAssignment)) {
    return initializer;
  }
}
ts.getExpandoInitializer = getExpandoInitializer;
/**
 * A defaulted expando initializer matches the pattern
 * `Lhs = Lhs || ExpandoInitializer`
 * or `var Lhs = Lhs || ExpandoInitializer`
 *
 * The second Lhs is required to be the same as the first except that it may be prefixed with
 * 'window.', 'global.' or 'self.' The second Lhs is otherwise ignored by the binder and checker.
 */
function getDefaultedExpandoInitializer(name, initializer, isPrototypeAssignment) {
  const e = ts.isBinaryExpression(initializer) &&
      (initializer.operatorToken.kind === 56 /* SyntaxKind.BarBarToken */ ||
       initializer.operatorToken.kind === 60 /* SyntaxKind.QuestionQuestionToken */) &&
      getExpandoInitializer(initializer.right, isPrototypeAssignment);
  if (e && isSameEntityName(name, initializer.left)) {
    return e;
  }
}
function isDefaultedExpandoInitializer(node) {
  const name = ts.isVariableDeclaration(node.parent) ? node.parent.name :
      ts.isBinaryExpression(node.parent) && node.parent.operatorToken.kind === 63 /* SyntaxKind.EqualsToken */ ?
                                                     node.parent.left :
                                                     undefined;
  return name && getExpandoInitializer(node.right, isPrototypeAccess(name)) && isEntityNameExpression(name) &&
      isSameEntityName(name, node.left);
}
ts.isDefaultedExpandoInitializer = isDefaultedExpandoInitializer;
/** Given an expando initializer, return its declaration name, or the left-hand side of the assignment if it's part of an assignment declaration. */
function getNameOfExpando(node) {
  if (ts.isBinaryExpression(node.parent)) {
    const parent = ((node.parent.operatorToken.kind === 56 /* SyntaxKind.BarBarToken */ ||
                   node.parent.operatorToken.kind === 60 /* SyntaxKind.QuestionQuestionToken */) &&
                  ts.isBinaryExpression(node.parent.parent)) ?
        node.parent.parent :
        node.parent;
    if (parent.operatorToken.kind === 63 /* SyntaxKind.EqualsToken */ && ts.isIdentifier(parent.left)) {
      return parent.left;
    }
  } else if (ts.isVariableDeclaration(node.parent)) {
    return node.parent.name;
  }
}
ts.getNameOfExpando = getNameOfExpando;
/**
 * Is the 'declared' name the same as the one in the initializer?
 * @return true for identical entity names, as well as ones where the initializer is prefixed with
 * 'window', 'self' or 'global'. For example:
 *
 * var my = my || {}
 * var min = window.min || {}
 * my.app = self.my.app || class { }
 */
function isSameEntityName(name, initializer) {
  if (isPropertyNameLiteral(name) && isPropertyNameLiteral(initializer)) {
    return getTextOfIdentifierOrLiteral(name) === getTextOfIdentifierOrLiteral(initializer);
  }
  if (ts.isMemberName(name) && isLiteralLikeAccess(initializer) &&
      (initializer.expression.kind === 108 /* SyntaxKind.ThisKeyword */ ||
       ts.isIdentifier(initializer.expression) &&
           (initializer.expression.escapedText === 'window' || initializer.expression.escapedText === 'self' ||
            initializer.expression.escapedText === 'global'))) {
    return isSameEntityName(name, getNameOrArgument(initializer));
  }
  if (isLiteralLikeAccess(name) && isLiteralLikeAccess(initializer)) {
    return getElementOrPropertyAccessName(name) === getElementOrPropertyAccessName(initializer) &&
        isSameEntityName(name.expression, initializer.expression);
  }
  return false;
}
ts.isSameEntityName = isSameEntityName;
function getRightMostAssignedExpression(node) {
  while (isAssignmentExpression(node, /* excludeCompoundAssignments*/ true)) {
    node = node.right;
  }
  return node;
}
ts.getRightMostAssignedExpression = getRightMostAssignedExpression;
function isExportsIdentifier(node) {
  return ts.isIdentifier(node) && node.escapedText === 'exports';
}
ts.isExportsIdentifier = isExportsIdentifier;
function isModuleIdentifier(node) {
  return ts.isIdentifier(node) && node.escapedText === 'module';
}
ts.isModuleIdentifier = isModuleIdentifier;
function isModuleExportsAccessExpression(node) {
  return (ts.isPropertyAccessExpression(node) || isLiteralLikeElementAccess(node)) &&
      isModuleIdentifier(node.expression) && getElementOrPropertyAccessName(node) === 'exports';
}
ts.isModuleExportsAccessExpression = isModuleExportsAccessExpression;
// / Given a BinaryExpression, returns SpecialPropertyAssignmentKind for the various kinds of property
// / assignments we treat as special in the binder
function getAssignmentDeclarationKind(expr) {
  const special = getAssignmentDeclarationKindWorker(expr);
  return special === 5 /* AssignmentDeclarationKind.Property */ || isInJSFile(expr) ?
      special :
      0 /* AssignmentDeclarationKind.None */;
}
ts.getAssignmentDeclarationKind = getAssignmentDeclarationKind;
function isBindableObjectDefinePropertyCall(expr) {
  return ts.length(expr.arguments) === 3 && ts.isPropertyAccessExpression(expr.expression) &&
      ts.isIdentifier(expr.expression.expression) && ts.idText(expr.expression.expression) === 'Object' &&
      ts.idText(expr.expression.name) === 'defineProperty' && isStringOrNumericLiteralLike(expr.arguments[1]) &&
      isBindableStaticNameExpression(expr.arguments[0], /* excludeThisKeyword*/ true);
}
ts.isBindableObjectDefinePropertyCall = isBindableObjectDefinePropertyCall;
/** x.y OR x[0] */
function isLiteralLikeAccess(node) {
  return ts.isPropertyAccessExpression(node) || isLiteralLikeElementAccess(node);
}
ts.isLiteralLikeAccess = isLiteralLikeAccess;
/** x[0] OR x['a'] OR x[Symbol.y] */
function isLiteralLikeElementAccess(node) {
  return ts.isElementAccessExpression(node) && isStringOrNumericLiteralLike(node.argumentExpression);
}
ts.isLiteralLikeElementAccess = isLiteralLikeElementAccess;
/** Any series of property and element accesses. */
function isBindableStaticAccessExpression(node, excludeThisKeyword) {
  return ts.isPropertyAccessExpression(node) &&
      (!excludeThisKeyword && node.expression.kind === 108 /* SyntaxKind.ThisKeyword */ ||
       ts.isIdentifier(node.name) && isBindableStaticNameExpression(node.expression, /* excludeThisKeyword*/ true)) ||
      isBindableStaticElementAccessExpression(node, excludeThisKeyword);
}
ts.isBindableStaticAccessExpression = isBindableStaticAccessExpression;
/** Any series of property and element accesses, ending in a literal element access */
function isBindableStaticElementAccessExpression(node, excludeThisKeyword) {
  return isLiteralLikeElementAccess(node) &&
      ((!excludeThisKeyword && node.expression.kind === 108 /* SyntaxKind.ThisKeyword */) ||
       isEntityNameExpression(node.expression) ||
       isBindableStaticAccessExpression(node.expression, /* excludeThisKeyword*/ true));
}
ts.isBindableStaticElementAccessExpression = isBindableStaticElementAccessExpression;
function isBindableStaticNameExpression(node, excludeThisKeyword) {
  return isEntityNameExpression(node) || isBindableStaticAccessExpression(node, excludeThisKeyword);
}
ts.isBindableStaticNameExpression = isBindableStaticNameExpression;
function getNameOrArgument(expr) {
  if (ts.isPropertyAccessExpression(expr)) {
    return expr.name;
  }
  return expr.argumentExpression;
}
ts.getNameOrArgument = getNameOrArgument;
function getAssignmentDeclarationKindWorker(expr) {
  if (ts.isCallExpression(expr)) {
    if (!isBindableObjectDefinePropertyCall(expr)) {
      return 0 /* AssignmentDeclarationKind.None */;
    }
    const entityName = expr.arguments[0];
    if (isExportsIdentifier(entityName) || isModuleExportsAccessExpression(entityName)) {
      return 8 /* AssignmentDeclarationKind.ObjectDefinePropertyExports */;
    }
    if (isBindableStaticAccessExpression(entityName) && getElementOrPropertyAccessName(entityName) === 'prototype') {
      return 9 /* AssignmentDeclarationKind.ObjectDefinePrototypeProperty */;
    }
    return 7 /* AssignmentDeclarationKind.ObjectDefinePropertyValue */;
  }
  if (expr.operatorToken.kind !== 63 /* SyntaxKind.EqualsToken */ || !isAccessExpression(expr.left) ||
      isVoidZero(getRightMostAssignedExpression(expr))) {
    return 0 /* AssignmentDeclarationKind.None */;
  }
  if (isBindableStaticNameExpression(expr.left.expression, /* excludeThisKeyword*/ true) &&
      getElementOrPropertyAccessName(expr.left) === 'prototype' &&
      ts.isObjectLiteralExpression(getInitializerOfBinaryExpression(expr))) {
    // F.prototype = { ... }
    return 6 /* AssignmentDeclarationKind.Prototype */;
  }
  return getAssignmentDeclarationPropertyAccessKind(expr.left);
}
function isVoidZero(node) {
  return ts.isVoidExpression(node) && ts.isNumericLiteral(node.expression) && node.expression.text === '0';
}
/**
 * Does not handle signed numeric names like `a[+0]` - handling those would require handling prefix unary expressions
 * throughout late binding handling as well, which is awkward (but ultimately probably doable if there is demand)
 */
/* @internal */
function getElementOrPropertyAccessArgumentExpressionOrName(node) {
  if (ts.isPropertyAccessExpression(node)) {
    return node.name;
  }
  const arg = skipParentheses(node.argumentExpression);
  if (ts.isNumericLiteral(arg) || ts.isStringLiteralLike(arg)) {
    return arg;
  }
  return node;
}
ts.getElementOrPropertyAccessArgumentExpressionOrName = getElementOrPropertyAccessArgumentExpressionOrName;
function getElementOrPropertyAccessName(node) {
  const name = getElementOrPropertyAccessArgumentExpressionOrName(node);
  if (name) {
    if (ts.isIdentifier(name)) {
      return name.escapedText;
    }
    if (ts.isStringLiteralLike(name) || ts.isNumericLiteral(name)) {
      return ts.escapeLeadingUnderscores(name.text);
    }
  }
  return undefined;
}
ts.getElementOrPropertyAccessName = getElementOrPropertyAccessName;
function getAssignmentDeclarationPropertyAccessKind(lhs) {
  if (lhs.expression.kind === 108 /* SyntaxKind.ThisKeyword */) {
    return 4 /* AssignmentDeclarationKind.ThisProperty */;
  } if (isModuleExportsAccessExpression(lhs)) {
    // module.exports = expr
    return 2 /* AssignmentDeclarationKind.ModuleExports */;
  } if (isBindableStaticNameExpression(lhs.expression, /* excludeThisKeyword*/ true)) {
    if (isPrototypeAccess(lhs.expression)) {
      // F.G....prototype.x = expr
      return 3 /* AssignmentDeclarationKind.PrototypeProperty */;
    }
    let nextToLast = lhs;
    while (!ts.isIdentifier(nextToLast.expression)) {
      nextToLast = nextToLast.expression;
    }
    const id = nextToLast.expression;
    if ((id.escapedText === 'exports' ||
         id.escapedText === 'module' && getElementOrPropertyAccessName(nextToLast) === 'exports') &&
        // ExportsProperty does not support binding with computed names
        isBindableStaticAccessExpression(lhs)) {
      // exports.name = expr OR module.exports.name = expr OR exports["name"] = expr ...
      return 1 /* AssignmentDeclarationKind.ExportsProperty */;
    }
    if (isBindableStaticNameExpression(lhs, /* excludeThisKeyword*/ true) ||
        (ts.isElementAccessExpression(lhs) && isDynamicName(lhs))) {
      // F.G...x = expr
      return 5 /* AssignmentDeclarationKind.Property */;
    }
  }
  return 0 /* AssignmentDeclarationKind.None */;
}
ts.getAssignmentDeclarationPropertyAccessKind = getAssignmentDeclarationPropertyAccessKind;
function getInitializerOfBinaryExpression(expr) {
  while (ts.isBinaryExpression(expr.right)) {
    expr = expr.right;
  }
  return expr.right;
}
ts.getInitializerOfBinaryExpression = getInitializerOfBinaryExpression;
function isPrototypePropertyAssignment(node) {
  return ts.isBinaryExpression(node) &&
      getAssignmentDeclarationKind(node) === 3 /* AssignmentDeclarationKind.PrototypeProperty */;
}
ts.isPrototypePropertyAssignment = isPrototypePropertyAssignment;
function isSpecialPropertyDeclaration(expr) {
  return isInJSFile(expr) && expr.parent && expr.parent.kind === 241 /* SyntaxKind.ExpressionStatement */ &&
      (!ts.isElementAccessExpression(expr) || isLiteralLikeElementAccess(expr)) && !!ts.getJSDocTypeTag(expr.parent);
}
ts.isSpecialPropertyDeclaration = isSpecialPropertyDeclaration;
function setValueDeclaration(symbol, node) {
  const valueDeclaration = symbol.valueDeclaration;
  if (!valueDeclaration ||
      !(node.flags & 16777216 /* NodeFlags.Ambient */ &&
        !(valueDeclaration.flags & 16777216 /* NodeFlags.Ambient */)) &&
          (isAssignmentDeclaration(valueDeclaration) && !isAssignmentDeclaration(node)) ||
      (valueDeclaration.kind !== node.kind && isEffectiveModuleDeclaration(valueDeclaration))) {
    // other kinds of value declarations take precedence over modules and assignment declarations
    symbol.valueDeclaration = node;
  }
}
ts.setValueDeclaration = setValueDeclaration;
function isFunctionSymbol(symbol) {
  if (!symbol || !symbol.valueDeclaration) {
    return false;
  }
  const decl = symbol.valueDeclaration;
  return decl.kind === 259 /* SyntaxKind.FunctionDeclaration */ ||
      ts.isVariableDeclaration(decl) && decl.initializer && ts.isFunctionLike(decl.initializer);
}
ts.isFunctionSymbol = isFunctionSymbol;
function tryGetModuleSpecifierFromDeclaration(node) {
  let _a, _b;
  switch (node.kind) {
    case 257 /* SyntaxKind.VariableDeclaration */:
      return (_a = ts.findAncestor(node.initializer, function(node) {
               return isRequireCall(node, /* requireStringLiteralLikeArgument*/ true);
             })) === null || _a === void 0 ? void 0 : _a.arguments[0];
    case 269 /* SyntaxKind.ImportDeclaration */:
      return ts.tryCast(node.moduleSpecifier, ts.isStringLiteralLike);
    case 268 /* SyntaxKind.ImportEqualsDeclaration */:
      return ts.tryCast(
          (_b = ts.tryCast(node.moduleReference, ts.isExternalModuleReference)) === null || _b === void 0 ?
              void 0 :
              _b.expression,
          ts.isStringLiteralLike);
    default:
      ts.Debug.assertNever(node);
  }
}
ts.tryGetModuleSpecifierFromDeclaration = tryGetModuleSpecifierFromDeclaration;
function importFromModuleSpecifier(node) {
  return tryGetImportFromModuleSpecifier(node) || ts.Debug.failBadSyntaxKind(node.parent);
}
ts.importFromModuleSpecifier = importFromModuleSpecifier;
function tryGetImportFromModuleSpecifier(node) {
  switch (node.parent.kind) {
    case 269 /* SyntaxKind.ImportDeclaration */:
    case 275 /* SyntaxKind.ExportDeclaration */:
      return node.parent;
    case 280 /* SyntaxKind.ExternalModuleReference */:
      return node.parent.parent;
    case 210 /* SyntaxKind.CallExpression */:
      return isImportCall(node.parent) || isRequireCall(node.parent, /* checkArg*/ false) ? node.parent : undefined;
    case 198 /* SyntaxKind.LiteralType */:
      ts.Debug.assert(ts.isStringLiteral(node));
      return ts.tryCast(node.parent.parent, ts.isImportTypeNode);
    default:
      return undefined;
  }
}
ts.tryGetImportFromModuleSpecifier = tryGetImportFromModuleSpecifier;
function getExternalModuleName(node) {
  switch (node.kind) {
    case 269 /* SyntaxKind.ImportDeclaration */:
    case 275 /* SyntaxKind.ExportDeclaration */:
      return node.moduleSpecifier;
    case 268 /* SyntaxKind.ImportEqualsDeclaration */:
      return node.moduleReference.kind === 280 /* SyntaxKind.ExternalModuleReference */ ?
          node.moduleReference.expression :
          undefined;
    case 202 /* SyntaxKind.ImportType */:
      return isLiteralImportTypeNode(node) ? node.argument.literal : undefined;
    case 210 /* SyntaxKind.CallExpression */:
      return node.arguments[0];
    case 264 /* SyntaxKind.ModuleDeclaration */:
      return node.name.kind === 10 /* SyntaxKind.StringLiteral */ ? node.name : undefined;
    default:
      return ts.Debug.assertNever(node);
  }
}
ts.getExternalModuleName = getExternalModuleName;
function getNamespaceDeclarationNode(node) {
  switch (node.kind) {
    case 269 /* SyntaxKind.ImportDeclaration */:
      return node.importClause && ts.tryCast(node.importClause.namedBindings, ts.isNamespaceImport);
    case 268 /* SyntaxKind.ImportEqualsDeclaration */:
      return node;
    case 275 /* SyntaxKind.ExportDeclaration */:
      return node.exportClause && ts.tryCast(node.exportClause, ts.isNamespaceExport);
    default:
      return ts.Debug.assertNever(node);
  }
}
ts.getNamespaceDeclarationNode = getNamespaceDeclarationNode;
function isDefaultImport(node) {
  return node.kind === 269 /* SyntaxKind.ImportDeclaration */ && !!node.importClause && !!node.importClause.name;
}
ts.isDefaultImport = isDefaultImport;
function forEachImportClauseDeclaration(node, action) {
  if (node.name) {
    var result = action(node);
    if (result)
      {return result;}
  }
  if (node.namedBindings) {
    var result = ts.isNamespaceImport(node.namedBindings) ? action(node.namedBindings) :
                                                            ts.forEach(node.namedBindings.elements, action);
    if (result)
      {return result;}
  }
}
ts.forEachImportClauseDeclaration = forEachImportClauseDeclaration;
function hasQuestionToken(node) {
  if (node) {
    switch (node.kind) {
      case 166 /* SyntaxKind.Parameter */:
      case 171 /* SyntaxKind.MethodDeclaration */:
      case 170 /* SyntaxKind.MethodSignature */:
      case 300 /* SyntaxKind.ShorthandPropertyAssignment */:
      case 299 /* SyntaxKind.PropertyAssignment */:
      case 169 /* SyntaxKind.PropertyDeclaration */:
      case 168 /* SyntaxKind.PropertySignature */:
        return node.questionToken !== undefined;
    }
  }
  return false;
}
ts.hasQuestionToken = hasQuestionToken;
function isJSDocConstructSignature(node) {
  const param = ts.isJSDocFunctionType(node) ? ts.firstOrUndefined(node.parameters) : undefined;
  const name = ts.tryCast(param && param.name, ts.isIdentifier);
  return !!name && name.escapedText === 'new';
}
ts.isJSDocConstructSignature = isJSDocConstructSignature;
function isJSDocTypeAlias(node) {
  return node.kind === 348 /* SyntaxKind.JSDocTypedefTag */ || node.kind === 341 /* SyntaxKind.JSDocCallbackTag */ ||
      node.kind === 342 /* SyntaxKind.JSDocEnumTag */;
}
ts.isJSDocTypeAlias = isJSDocTypeAlias;
function isTypeAlias(node) {
  return isJSDocTypeAlias(node) || ts.isTypeAliasDeclaration(node);
}
ts.isTypeAlias = isTypeAlias;
function getSourceOfAssignment(node) {
  return ts.isExpressionStatement(node) && ts.isBinaryExpression(node.expression) &&
          node.expression.operatorToken.kind === 63 /* SyntaxKind.EqualsToken */
      ?
      getRightMostAssignedExpression(node.expression) :
      undefined;
}
function getSourceOfDefaultedAssignment(node) {
  return ts.isExpressionStatement(node) && ts.isBinaryExpression(node.expression) &&
          getAssignmentDeclarationKind(node.expression) !== 0 /* AssignmentDeclarationKind.None */ &&
          ts.isBinaryExpression(node.expression.right) &&
          (node.expression.right.operatorToken.kind === 56 /* SyntaxKind.BarBarToken */ ||
           node.expression.right.operatorToken.kind === 60 /* SyntaxKind.QuestionQuestionToken */) ?
      node.expression.right.right :
      undefined;
}
function getSingleInitializerOfVariableStatementOrPropertyDeclaration(node) {
  switch (node.kind) {
    case 240 /* SyntaxKind.VariableStatement */:
      var v = getSingleVariableOfVariableStatement(node);
      return v && v.initializer;
    case 169 /* SyntaxKind.PropertyDeclaration */:
      return node.initializer;
    case 299 /* SyntaxKind.PropertyAssignment */:
      return node.initializer;
  }
}
ts.getSingleInitializerOfVariableStatementOrPropertyDeclaration =
    getSingleInitializerOfVariableStatementOrPropertyDeclaration;
function getSingleVariableOfVariableStatement(node) {
  return ts.isVariableStatement(node) ? ts.firstOrUndefined(node.declarationList.declarations) : undefined;
}
ts.getSingleVariableOfVariableStatement = getSingleVariableOfVariableStatement;
function getNestedModuleDeclaration(node) {
  return ts.isModuleDeclaration(node) && node.body && node.body.kind === 264 /* SyntaxKind.ModuleDeclaration */
      ?
      node.body :
      undefined;
}
function getJSDocCommentsAndTags(hostNode, noCache) {
  let result;
  // Pull parameter comments from declaring function as well
  if (isVariableLike(hostNode) && ts.hasInitializer(hostNode) && ts.hasJSDocNodes(hostNode.initializer)) {
    result = ts.addRange(result, filterOwnedJSDocTags(hostNode, ts.last(hostNode.initializer.jsDoc)));
  }
  let node = hostNode;
  while (node && node.parent) {
    if (ts.hasJSDocNodes(node)) {
      result = ts.addRange(result, filterOwnedJSDocTags(hostNode, ts.last(node.jsDoc)));
    }
    if (node.kind === 166 /* SyntaxKind.Parameter */) {
      result = ts.addRange(result, (noCache ? ts.getJSDocParameterTagsNoCache : ts.getJSDocParameterTags)(node));
      break;
    }
    if (node.kind === 165 /* SyntaxKind.TypeParameter */) {
      result =
          ts.addRange(result, (noCache ? ts.getJSDocTypeParameterTagsNoCache : ts.getJSDocTypeParameterTags)(node));
      break;
    }
    node = getNextJSDocCommentLocation(node);
  }
  return result || ts.emptyArray;
}
ts.getJSDocCommentsAndTags = getJSDocCommentsAndTags;
function filterOwnedJSDocTags(hostNode, jsDoc) {
  if (ts.isJSDoc(jsDoc)) {
    const ownedTags = ts.filter(jsDoc.tags, function(tag) {
      return ownsJSDocTag(hostNode, tag);
    });
    return jsDoc.tags === ownedTags ? [jsDoc] : ownedTags;
  }
  return ownsJSDocTag(hostNode, jsDoc) ? [jsDoc] : undefined;
}
/**
 * Determines whether a host node owns a jsDoc tag. A `@type` tag attached to a
 * a ParenthesizedExpression belongs only to the ParenthesizedExpression.
 */
function ownsJSDocTag(hostNode, tag) {
  return !ts.isJSDocTypeTag(tag) || !tag.parent || !ts.isJSDoc(tag.parent) ||
      !ts.isParenthesizedExpression(tag.parent.parent) || tag.parent.parent === hostNode;
}
function getNextJSDocCommentLocation(node) {
  const parent = node.parent;
  if (parent.kind === 299 /* SyntaxKind.PropertyAssignment */ ||
      parent.kind === 274 /* SyntaxKind.ExportAssignment */ ||
      parent.kind === 169 /* SyntaxKind.PropertyDeclaration */ ||
      parent.kind === 241 /* SyntaxKind.ExpressionStatement */ &&
          node.kind === 208 /* SyntaxKind.PropertyAccessExpression */
      || parent.kind === 250 /* SyntaxKind.ReturnStatement */ || getNestedModuleDeclaration(parent) ||
      ts.isBinaryExpression(node) && node.operatorToken.kind === 63 /* SyntaxKind.EqualsToken */) {
    return parent;
  }
  // Try to recognize this pattern when node is initializer of variable declaration and JSDoc comments are on containing variable statement.
  // /**
  //   * @param {number} name
  //   * @returns {number}
  //   */
  // var x = function(name) { return name.length; }
  if (
      parent.parent &&
      (getSingleVariableOfVariableStatement(parent.parent) === node ||
       ts.isBinaryExpression(parent) && parent.operatorToken.kind === 63 /* SyntaxKind.EqualsToken */)) {
    return parent.parent;
  } if (
      parent.parent && parent.parent.parent &&
      (getSingleVariableOfVariableStatement(parent.parent.parent) ||
       getSingleInitializerOfVariableStatementOrPropertyDeclaration(parent.parent.parent) === node ||
       getSourceOfDefaultedAssignment(parent.parent.parent))) {
    return parent.parent.parent;
  }
}
ts.getNextJSDocCommentLocation = getNextJSDocCommentLocation;
/** Does the opposite of `getJSDocParameterTags`: given a JSDoc parameter, finds the parameter corresponding to it. */
function getParameterSymbolFromJSDoc(node) {
  if (node.symbol) {
    return node.symbol;
  }
  if (!ts.isIdentifier(node.name)) {
    return undefined;
  }
  const name = node.name.escapedText;
  const decl = getHostSignatureFromJSDoc(node);
  if (!decl) {
    return undefined;
  }
  const parameter = ts.find(decl.parameters, function(p) {
    return p.name.kind === 79 /* SyntaxKind.Identifier */ && p.name.escapedText === name;
  });
  return parameter && parameter.symbol;
}
ts.getParameterSymbolFromJSDoc = getParameterSymbolFromJSDoc;
function getEffectiveContainerForJSDocTemplateTag(node) {
  if (ts.isJSDoc(node.parent) && node.parent.tags) {
    // A @template tag belongs to any @typedef, @callback, or @enum tags in the same comment block, if they exist.
    const typeAlias = ts.find(node.parent.tags, isJSDocTypeAlias);
    if (typeAlias) {
      return typeAlias;
    }
  }
  // otherwise it belongs to the host it annotates
  return getHostSignatureFromJSDoc(node);
}
ts.getEffectiveContainerForJSDocTemplateTag = getEffectiveContainerForJSDocTemplateTag;
function getHostSignatureFromJSDoc(node) {
  const host = getEffectiveJSDocHost(node);
  if (host) {
    return ts.isPropertySignature(host) && host.type && ts.isFunctionLike(host.type) ? host.type :
        ts.isFunctionLike(host)                                                      ? host :
                                                                                       undefined;
  }
  return undefined;
}
ts.getHostSignatureFromJSDoc = getHostSignatureFromJSDoc;
function getEffectiveJSDocHost(node) {
  const host = getJSDocHost(node);
  if (host) {
    return getSourceOfDefaultedAssignment(host) || getSourceOfAssignment(host) ||
        getSingleInitializerOfVariableStatementOrPropertyDeclaration(host) ||
        getSingleVariableOfVariableStatement(host) || getNestedModuleDeclaration(host) || host;
  }
}
ts.getEffectiveJSDocHost = getEffectiveJSDocHost;
/** Use getEffectiveJSDocHost if you additionally need to look for jsdoc on parent nodes, like assignments. */
function getJSDocHost(node) {
  const jsDoc = getJSDocRoot(node);
  if (!jsDoc) {
    return undefined;
  }
  const host = jsDoc.parent;
  if (host && host.jsDoc && jsDoc === ts.lastOrUndefined(host.jsDoc)) {
    return host;
  }
}
ts.getJSDocHost = getJSDocHost;
function getJSDocRoot(node) {
  return ts.findAncestor(node.parent, ts.isJSDoc);
}
ts.getJSDocRoot = getJSDocRoot;
function getTypeParameterFromJsDoc(node) {
  const name = node.name.escapedText;
  const typeParameters = node.parent.parent.parent.typeParameters;
  return typeParameters && ts.find(typeParameters, function(p) {
    return p.name.escapedText === name;
  });
}
ts.getTypeParameterFromJsDoc = getTypeParameterFromJsDoc;
function hasTypeArguments(node) {
  return !!node.typeArguments;
}
ts.hasTypeArguments = hasTypeArguments;
let AssignmentKind;
(function(AssignmentKind) {
AssignmentKind[AssignmentKind['None'] = 0] = 'None';
AssignmentKind[AssignmentKind['Definite'] = 1] = 'Definite';
AssignmentKind[AssignmentKind['Compound'] = 2] = 'Compound';
})(AssignmentKind = ts.AssignmentKind || (ts.AssignmentKind = {}));
function getAssignmentTargetKind(node) {
  let parent = node.parent;
  while (true) {
    switch (parent.kind) {
      case 223 /* SyntaxKind.BinaryExpression */:
        var binaryOperator = parent.operatorToken.kind;
        return isAssignmentOperator(binaryOperator) && parent.left === node ?
            binaryOperator === 63 /* SyntaxKind.EqualsToken */ ||
                    isLogicalOrCoalescingAssignmentOperator(binaryOperator) ?
            1 /* AssignmentKind.Definite */ :
            2 /* AssignmentKind.Compound */ :
            0 /* AssignmentKind.None */;
      case 221 /* SyntaxKind.PrefixUnaryExpression */:
      case 222 /* SyntaxKind.PostfixUnaryExpression */:
        var unaryOperator = parent.operator;
        return unaryOperator === 45 /* SyntaxKind.PlusPlusToken */ ||
                unaryOperator === 46 /* SyntaxKind.MinusMinusToken */ ?
            2 /* AssignmentKind.Compound */ :
            0 /* AssignmentKind.None */;
      case 246 /* SyntaxKind.ForInStatement */:
      case 247 /* SyntaxKind.ForOfStatement */:
        return parent.initializer === node ? 1 /* AssignmentKind.Definite */ : 0 /* AssignmentKind.None */;
      case 214 /* SyntaxKind.ParenthesizedExpression */:
      case 206 /* SyntaxKind.ArrayLiteralExpression */:
      case 227 /* SyntaxKind.SpreadElement */:
      case 232 /* SyntaxKind.NonNullExpression */:
        node = parent;
        break;
      case 301 /* SyntaxKind.SpreadAssignment */:
        node = parent.parent;
        break;
      case 300 /* SyntaxKind.ShorthandPropertyAssignment */:
        if (parent.name !== node) {
          return 0 /* AssignmentKind.None */;
        }
        node = parent.parent;
        break;
      case 299 /* SyntaxKind.PropertyAssignment */:
        if (parent.name === node) {
          return 0 /* AssignmentKind.None */;
        }
        node = parent.parent;
        break;
      default:
        return 0 /* AssignmentKind.None */;
    }
    parent = node.parent;
  }
}
ts.getAssignmentTargetKind = getAssignmentTargetKind;
// A node is an assignment target if it is on the left hand side of an '=' token, if it is parented by a property
// assignment in an object literal that is an assignment target, or if it is parented by an array literal that is
// an assignment target. Examples include 'a = xxx', '{ p: a } = xxx', '[{ a }] = xxx'.
// (Note that `p` is not a target in the above examples, only `a`.)
function isAssignmentTarget(node) {
  return getAssignmentTargetKind(node) !== 0 /* AssignmentKind.None */;
}
ts.isAssignmentTarget = isAssignmentTarget;
/**
 * Indicates whether a node could contain a `var` VariableDeclarationList that contributes to
 * the same `var` declaration scope as the node's parent.
 */
function isNodeWithPossibleHoistedDeclaration(node) {
  switch (node.kind) {
    case 238 /* SyntaxKind.Block */:
    case 240 /* SyntaxKind.VariableStatement */:
    case 251 /* SyntaxKind.WithStatement */:
    case 242 /* SyntaxKind.IfStatement */:
    case 252 /* SyntaxKind.SwitchStatement */:
    case 266 /* SyntaxKind.CaseBlock */:
    case 292 /* SyntaxKind.CaseClause */:
    case 293 /* SyntaxKind.DefaultClause */:
    case 253 /* SyntaxKind.LabeledStatement */:
    case 245 /* SyntaxKind.ForStatement */:
    case 246 /* SyntaxKind.ForInStatement */:
    case 247 /* SyntaxKind.ForOfStatement */:
    case 243 /* SyntaxKind.DoStatement */:
    case 244 /* SyntaxKind.WhileStatement */:
    case 255 /* SyntaxKind.TryStatement */:
    case 295 /* SyntaxKind.CatchClause */:
      return true;
  }
  return false;
}
ts.isNodeWithPossibleHoistedDeclaration = isNodeWithPossibleHoistedDeclaration;
function isValueSignatureDeclaration(node) {
  return ts.isFunctionExpression(node) || ts.isArrowFunction(node) || ts.isMethodOrAccessor(node) ||
      ts.isFunctionDeclaration(node) || ts.isConstructorDeclaration(node);
}
ts.isValueSignatureDeclaration = isValueSignatureDeclaration;
function walkUp(node, kind) {
  while (node && node.kind === kind) {
    node = node.parent;
  }
  return node;
}
function walkUpParenthesizedTypes(node) {
  return walkUp(node, 193 /* SyntaxKind.ParenthesizedType */);
}
ts.walkUpParenthesizedTypes = walkUpParenthesizedTypes;
function walkUpParenthesizedExpressions(node) {
  return walkUp(node, 214 /* SyntaxKind.ParenthesizedExpression */);
}
ts.walkUpParenthesizedExpressions = walkUpParenthesizedExpressions;
/**
 * Walks up parenthesized types.
 * It returns both the outermost parenthesized type and its parent.
 * If given node is not a parenthesiezd type, undefined is return as the former.
 */
function walkUpParenthesizedTypesAndGetParentAndChild(node) {
  let child;
  while (node && node.kind === 193 /* SyntaxKind.ParenthesizedType */) {
    child = node;
    node = node.parent;
  }
  return [child, node];
}
ts.walkUpParenthesizedTypesAndGetParentAndChild = walkUpParenthesizedTypesAndGetParentAndChild;
function skipTypeParentheses(node) {
  while (ts.isParenthesizedTypeNode(node))
    {node = node.type;}
  return node;
}
ts.skipTypeParentheses = skipTypeParentheses;
function skipParentheses(node, excludeJSDocTypeAssertions) {
  const flags = excludeJSDocTypeAssertions ?
      1 /* OuterExpressionKinds.Parentheses */ | 16 /* OuterExpressionKinds.ExcludeJSDocTypeAssertion */ :
      1 /* OuterExpressionKinds.Parentheses */;
  return ts.skipOuterExpressions(node, flags);
}
ts.skipParentheses = skipParentheses;
// a node is delete target iff. it is PropertyAccessExpression/ElementAccessExpression with parentheses skipped
function isDeleteTarget(node) {
  if (node.kind !== 208 /* SyntaxKind.PropertyAccessExpression */ &&
      node.kind !== 209 /* SyntaxKind.ElementAccessExpression */) {
    return false;
  }
  node = walkUpParenthesizedExpressions(node.parent);
  return node && node.kind === 217 /* SyntaxKind.DeleteExpression */;
}
ts.isDeleteTarget = isDeleteTarget;
function isNodeDescendantOf(node, ancestor) {
  while (node) {
    if (node === ancestor)
      {return true;}
    node = node.parent;
  }
  return false;
}
ts.isNodeDescendantOf = isNodeDescendantOf;
// True if `name` is the name of a declaration node
function isDeclarationName(name) {
  return !ts.isSourceFile(name) && !ts.isBindingPattern(name) && ts.isDeclaration(name.parent) &&
      name.parent.name === name;
}
ts.isDeclarationName = isDeclarationName;
// See GH#16030
function getDeclarationFromName(name) {
  const parent = name.parent;
  switch (name.kind) {
    case 10 /* SyntaxKind.StringLiteral */:
    case 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */:
    case 8 /* SyntaxKind.NumericLiteral */:
      if (ts.isComputedPropertyName(parent))
        {return parent.parent;}
    // falls through
    case 79 /* SyntaxKind.Identifier */:
      if (ts.isDeclaration(parent)) {
        return parent.name === name ? parent : undefined;
      } if (ts.isQualifiedName(parent)) {
        const tag = parent.parent;
        return ts.isJSDocParameterTag(tag) && tag.name === parent ? tag : undefined;
      }
        var binExp = parent.parent;
        return ts.isBinaryExpression(binExp) &&
                getAssignmentDeclarationKind(binExp) !== 0 /* AssignmentDeclarationKind.None */ &&
                (binExp.left.symbol || binExp.symbol) && ts.getNameOfDeclaration(binExp) === name ?
            binExp :
            undefined;

    case 80 /* SyntaxKind.PrivateIdentifier */:
      return ts.isDeclaration(parent) && parent.name === name ? parent : undefined;
    default:
      return undefined;
  }
}
ts.getDeclarationFromName = getDeclarationFromName;
function isLiteralComputedPropertyDeclarationName(node) {
  return isStringOrNumericLiteralLike(node) && node.parent.kind === 164 /* SyntaxKind.ComputedPropertyName */ &&
      ts.isDeclaration(node.parent.parent);
}
ts.isLiteralComputedPropertyDeclarationName = isLiteralComputedPropertyDeclarationName;
// Return true if the given identifier is classified as an IdentifierName
function isIdentifierName(node) {
  const parent = node.parent;
  switch (parent.kind) {
    case 169 /* SyntaxKind.PropertyDeclaration */:
    case 168 /* SyntaxKind.PropertySignature */:
    case 171 /* SyntaxKind.MethodDeclaration */:
    case 170 /* SyntaxKind.MethodSignature */:
    case 174 /* SyntaxKind.GetAccessor */:
    case 175 /* SyntaxKind.SetAccessor */:
    case 302 /* SyntaxKind.EnumMember */:
    case 299 /* SyntaxKind.PropertyAssignment */:
    case 208 /* SyntaxKind.PropertyAccessExpression */:
      // Name in member declaration or property name in property access
      return parent.name === node;
    case 163 /* SyntaxKind.QualifiedName */:
      // Name on right hand side of dot in a type query or type reference
      return parent.right === node;
    case 205 /* SyntaxKind.BindingElement */:
    case 273 /* SyntaxKind.ImportSpecifier */:
      // Property name in binding element or import specifier
      return parent.propertyName === node;
    case 278 /* SyntaxKind.ExportSpecifier */:
    case 288 /* SyntaxKind.JsxAttribute */:
    case 282 /* SyntaxKind.JsxSelfClosingElement */:
    case 283 /* SyntaxKind.JsxOpeningElement */:
    case 284 /* SyntaxKind.JsxClosingElement */:
      // Any name in an export specifier or JSX Attribute or Jsx Element
      return true;
  }
  return false;
}
ts.isIdentifierName = isIdentifierName;
// An alias symbol is created by one of the following declarations:
// import <symbol> = ...
// import <symbol> from ...
// import * as <symbol> from ...
// import { x as <symbol> } from ...
// export { x as <symbol> } from ...
// export * as ns <symbol> from ...
// export = <EntityNameExpression>
// export default <EntityNameExpression>
// module.exports = <EntityNameExpression>
// module.exports.x = <EntityNameExpression>
// const x = require("...")
// const { x } = require("...")
// const x = require("...").y
// const { x } = require("...").y
function isAliasSymbolDeclaration(node) {
  if (node.kind === 268 /* SyntaxKind.ImportEqualsDeclaration */ ||
      node.kind === 267 /* SyntaxKind.NamespaceExportDeclaration */ ||
      node.kind === 270 /* SyntaxKind.ImportClause */ && !!node.name ||
      node.kind === 271 /* SyntaxKind.NamespaceImport */ || node.kind === 277 /* SyntaxKind.NamespaceExport */ ||
      node.kind === 273 /* SyntaxKind.ImportSpecifier */ || node.kind === 278 /* SyntaxKind.ExportSpecifier */ ||
      node.kind === 274 /* SyntaxKind.ExportAssignment */ && exportAssignmentIsAlias(node)) {
    return true;
  }
  return isInJSFile(node) &&
      (ts.isBinaryExpression(node) &&
           getAssignmentDeclarationKind(node) === 2 /* AssignmentDeclarationKind.ModuleExports */ &&
           exportAssignmentIsAlias(node) ||
       ts.isPropertyAccessExpression(node) && ts.isBinaryExpression(node.parent) && node.parent.left === node &&
           node.parent.operatorToken.kind === 63 /* SyntaxKind.EqualsToken */
           && isAliasableExpression(node.parent.right));
}
ts.isAliasSymbolDeclaration = isAliasSymbolDeclaration;
function getAliasDeclarationFromName(node) {
  switch (node.parent.kind) {
    case 270 /* SyntaxKind.ImportClause */:
    case 273 /* SyntaxKind.ImportSpecifier */:
    case 271 /* SyntaxKind.NamespaceImport */:
    case 278 /* SyntaxKind.ExportSpecifier */:
    case 274 /* SyntaxKind.ExportAssignment */:
    case 268 /* SyntaxKind.ImportEqualsDeclaration */:
    case 277 /* SyntaxKind.NamespaceExport */:
      return node.parent;
    case 163 /* SyntaxKind.QualifiedName */:
      do {
        node = node.parent;
      } while (node.parent.kind === 163 /* SyntaxKind.QualifiedName */);
      return getAliasDeclarationFromName(node);
  }
}
ts.getAliasDeclarationFromName = getAliasDeclarationFromName;
function isAliasableExpression(e) {
  return isEntityNameExpression(e) || ts.isClassExpression(e);
}
ts.isAliasableExpression = isAliasableExpression;
function exportAssignmentIsAlias(node) {
  const e = getExportAssignmentExpression(node);
  return isAliasableExpression(e);
}
ts.exportAssignmentIsAlias = exportAssignmentIsAlias;
function getExportAssignmentExpression(node) {
  return ts.isExportAssignment(node) ? node.expression : node.right;
}
ts.getExportAssignmentExpression = getExportAssignmentExpression;
function getPropertyAssignmentAliasLikeExpression(node) {
  return node.kind === 300 /* SyntaxKind.ShorthandPropertyAssignment */ ? node.name :
      node.kind === 299 /* SyntaxKind.PropertyAssignment */             ? node.initializer :
                                                                          node.parent.right;
}
ts.getPropertyAssignmentAliasLikeExpression = getPropertyAssignmentAliasLikeExpression;
function getEffectiveBaseTypeNode(node) {
  const baseType = getClassExtendsHeritageElement(node);
  if (baseType && isInJSFile(node)) {
    // Prefer an @augments tag because it may have type parameters.
    const tag = ts.getJSDocAugmentsTag(node);
    if (tag) {
      return tag.class;
    }
  }
  return baseType;
}
ts.getEffectiveBaseTypeNode = getEffectiveBaseTypeNode;
function getClassExtendsHeritageElement(node) {
  const heritageClause = getHeritageClause(node.heritageClauses, 94 /* SyntaxKind.ExtendsKeyword */);
  return heritageClause && heritageClause.types.length > 0 ? heritageClause.types[0] : undefined;
}
ts.getClassExtendsHeritageElement = getClassExtendsHeritageElement;
function getEffectiveImplementsTypeNodes(node) {
  if (isInJSFile(node)) {
    return ts.getJSDocImplementsTags(node).map(function(n) {
      return n.class;
    });
  }
    const heritageClause = getHeritageClause(node.heritageClauses, 117 /* SyntaxKind.ImplementsKeyword */);
    return heritageClause === null || heritageClause === void 0 ? void 0 : heritageClause.types;

}
ts.getEffectiveImplementsTypeNodes = getEffectiveImplementsTypeNodes;
/** Returns the node in an `extends` or `implements` clause of a class or interface. */
function getAllSuperTypeNodes(node) {
  return ts.isInterfaceDeclaration(node) ?
      getInterfaceBaseTypeNodes(node) || ts.emptyArray :
      ts.isClassLike(node) ?
      ts.concatenate(ts.singleElementArray(getEffectiveBaseTypeNode(node)), getEffectiveImplementsTypeNodes(node)) ||
          ts.emptyArray :
      ts.emptyArray;
}
ts.getAllSuperTypeNodes = getAllSuperTypeNodes;
function getInterfaceBaseTypeNodes(node) {
  const heritageClause = getHeritageClause(node.heritageClauses, 94 /* SyntaxKind.ExtendsKeyword */);
  return heritageClause ? heritageClause.types : undefined;
}
ts.getInterfaceBaseTypeNodes = getInterfaceBaseTypeNodes;
function getHeritageClause(clauses, kind) {
  if (clauses) {
    for (let _i = 0, clauses_1 = clauses; _i < clauses_1.length; _i++) {
      const clause = clauses_1[_i];
      if (clause.token === kind) {
        return clause;
      }
    }
  }
  return undefined;
}
ts.getHeritageClause = getHeritageClause;
function getAncestor(node, kind) {
  while (node) {
    if (node.kind === kind) {
      return node;
    }
    node = node.parent;
  }
  return undefined;
}
ts.getAncestor = getAncestor;
function isKeyword(token) {
  return 81 /* SyntaxKind.FirstKeyword */ <= token && token <= 162 /* SyntaxKind.LastKeyword */;
}
ts.isKeyword = isKeyword;
function isContextualKeyword(token) {
  return 126 /* SyntaxKind.FirstContextualKeyword */ <= token && token <= 162 /* SyntaxKind.LastContextualKeyword */;
}
ts.isContextualKeyword = isContextualKeyword;
function isNonContextualKeyword(token) {
  return isKeyword(token) && !isContextualKeyword(token);
}
ts.isNonContextualKeyword = isNonContextualKeyword;
function isFutureReservedKeyword(token) {
  return 117 /* SyntaxKind.FirstFutureReservedWord */ <= token && token <= 125 /* SyntaxKind.LastFutureReservedWord */;
}
ts.isFutureReservedKeyword = isFutureReservedKeyword;
function isStringANonContextualKeyword(name) {
  const token = ts.stringToToken(name);
  return token !== undefined && isNonContextualKeyword(token);
}
ts.isStringANonContextualKeyword = isStringANonContextualKeyword;
function isStringAKeyword(name) {
  const token = ts.stringToToken(name);
  return token !== undefined && isKeyword(token);
}
ts.isStringAKeyword = isStringAKeyword;
function isIdentifierANonContextualKeyword(_a) {
  const originalKeywordKind = _a.originalKeywordKind;
  return !!originalKeywordKind && !isContextualKeyword(originalKeywordKind);
}
ts.isIdentifierANonContextualKeyword = isIdentifierANonContextualKeyword;
function isTrivia(token) {
  return 2 /* SyntaxKind.FirstTriviaToken */ <= token && token <= 7 /* SyntaxKind.LastTriviaToken */;
}
ts.isTrivia = isTrivia;
let FunctionFlags;
(function(FunctionFlags) {
FunctionFlags[FunctionFlags['Normal'] = 0] = 'Normal';
FunctionFlags[FunctionFlags['Generator'] = 1] = 'Generator';
FunctionFlags[FunctionFlags['Async'] = 2] = 'Async';
FunctionFlags[FunctionFlags['Invalid'] = 4] = 'Invalid';
FunctionFlags[FunctionFlags['AsyncGenerator'] = 3] = 'AsyncGenerator';
})(FunctionFlags = ts.FunctionFlags || (ts.FunctionFlags = {}));
function getFunctionFlags(node) {
  if (!node) {
    return 4 /* FunctionFlags.Invalid */;
  }
  let flags = 0 /* FunctionFlags.Normal */;
  switch (node.kind) {
    case 259 /* SyntaxKind.FunctionDeclaration */:
    case 215 /* SyntaxKind.FunctionExpression */:
    case 171 /* SyntaxKind.MethodDeclaration */:
      if (node.asteriskToken) {
        flags |= 1 /* FunctionFlags.Generator */;
      }
    // falls through
    case 216 /* SyntaxKind.ArrowFunction */:
      if (hasSyntacticModifier(node, 512 /* ModifierFlags.Async */)) {
        flags |= 2 /* FunctionFlags.Async */;
      }
      break;
  }
  if (!node.body) {
    flags |= 4 /* FunctionFlags.Invalid */;
  }
  return flags;
}
ts.getFunctionFlags = getFunctionFlags;
function isAsyncFunction(node) {
  switch (node.kind) {
    case 259 /* SyntaxKind.FunctionDeclaration */:
    case 215 /* SyntaxKind.FunctionExpression */:
    case 216 /* SyntaxKind.ArrowFunction */:
    case 171 /* SyntaxKind.MethodDeclaration */:
      return node.body !== undefined && node.asteriskToken === undefined &&
          hasSyntacticModifier(node, 512 /* ModifierFlags.Async */);
  }
  return false;
}
ts.isAsyncFunction = isAsyncFunction;
function isStringOrNumericLiteralLike(node) {
  return ts.isStringLiteralLike(node) || ts.isNumericLiteral(node);
}
ts.isStringOrNumericLiteralLike = isStringOrNumericLiteralLike;
function isSignedNumericLiteral(node) {
  return ts.isPrefixUnaryExpression(node) &&
      (node.operator === 39 /* SyntaxKind.PlusToken */ || node.operator === 40 /* SyntaxKind.MinusToken */) &&
      ts.isNumericLiteral(node.operand);
}
ts.isSignedNumericLiteral = isSignedNumericLiteral;
/**
 * A declaration has a dynamic name if all of the following are true:
 *   1. The declaration has a computed property name.
 *   2. The computed name is *not* expressed as a StringLiteral.
 *   3. The computed name is *not* expressed as a NumericLiteral.
 *   4. The computed name is *not* expressed as a PlusToken or MinusToken
 *      immediately followed by a NumericLiteral.
 */
function hasDynamicName(declaration) {
  const name = ts.getNameOfDeclaration(declaration);
  return !!name && isDynamicName(name);
}
ts.hasDynamicName = hasDynamicName;
function isDynamicName(name) {
  if (!(name.kind === 164 /* SyntaxKind.ComputedPropertyName */ ||
        name.kind === 209 /* SyntaxKind.ElementAccessExpression */)) {
    return false;
  }
  const expr = ts.isElementAccessExpression(name) ? skipParentheses(name.argumentExpression) : name.expression;
  return !isStringOrNumericLiteralLike(expr) && !isSignedNumericLiteral(expr);
}
ts.isDynamicName = isDynamicName;
function getPropertyNameForPropertyNameNode(name) {
  switch (name.kind) {
    case 79 /* SyntaxKind.Identifier */:
    case 80 /* SyntaxKind.PrivateIdentifier */:
      return name.escapedText;
    case 10 /* SyntaxKind.StringLiteral */:
    case 8 /* SyntaxKind.NumericLiteral */:
      return ts.escapeLeadingUnderscores(name.text);
    case 164 /* SyntaxKind.ComputedPropertyName */:
      var nameExpression = name.expression;
      if (isStringOrNumericLiteralLike(nameExpression)) {
        return ts.escapeLeadingUnderscores(nameExpression.text);
      } if (isSignedNumericLiteral(nameExpression)) {
        if (nameExpression.operator === 40 /* SyntaxKind.MinusToken */) {
          return ts.tokenToString(nameExpression.operator) + nameExpression.operand.text;
        }
        return nameExpression.operand.text;
      }
      return undefined;
    default:
      return ts.Debug.assertNever(name);
  }
}
ts.getPropertyNameForPropertyNameNode = getPropertyNameForPropertyNameNode;
function isPropertyNameLiteral(node) {
  switch (node.kind) {
    case 79 /* SyntaxKind.Identifier */:
    case 10 /* SyntaxKind.StringLiteral */:
    case 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */:
    case 8 /* SyntaxKind.NumericLiteral */:
      return true;
    default:
      return false;
  }
}
ts.isPropertyNameLiteral = isPropertyNameLiteral;
function getTextOfIdentifierOrLiteral(node) {
  return ts.isMemberName(node) ? ts.idText(node) : node.text;
}
ts.getTextOfIdentifierOrLiteral = getTextOfIdentifierOrLiteral;
function getEscapedTextOfIdentifierOrLiteral(node) {
  return ts.isMemberName(node) ? node.escapedText : ts.escapeLeadingUnderscores(node.text);
}
ts.getEscapedTextOfIdentifierOrLiteral = getEscapedTextOfIdentifierOrLiteral;
function getPropertyNameForUniqueESSymbol(symbol) {
  return '__@'.concat(ts.getSymbolId(symbol), '@').concat(symbol.escapedName);
}
ts.getPropertyNameForUniqueESSymbol = getPropertyNameForUniqueESSymbol;
function getSymbolNameForPrivateIdentifier(containingClassSymbol, description) {
  return '__#'.concat(ts.getSymbolId(containingClassSymbol), '@').concat(description);
}
ts.getSymbolNameForPrivateIdentifier = getSymbolNameForPrivateIdentifier;
function isKnownSymbol(symbol) {
  return ts.startsWith(symbol.escapedName, '__@');
}
ts.isKnownSymbol = isKnownSymbol;
function isPrivateIdentifierSymbol(symbol) {
  return ts.startsWith(symbol.escapedName, '__#');
}
ts.isPrivateIdentifierSymbol = isPrivateIdentifierSymbol;
/**
 * Includes the word "Symbol" with unicode escapes
 */
function isESSymbolIdentifier(node) {
  return node.kind === 79 /* SyntaxKind.Identifier */ && node.escapedText === 'Symbol';
}
ts.isESSymbolIdentifier = isESSymbolIdentifier;
function isPushOrUnshiftIdentifier(node) {
  return node.escapedText === 'push' || node.escapedText === 'unshift';
}
ts.isPushOrUnshiftIdentifier = isPushOrUnshiftIdentifier;
function isParameterDeclaration(node) {
  const root = getRootDeclaration(node);
  return root.kind === 166 /* SyntaxKind.Parameter */;
}
ts.isParameterDeclaration = isParameterDeclaration;
function getRootDeclaration(node) {
  while (node.kind === 205 /* SyntaxKind.BindingElement */) {
    node = node.parent.parent;
  }
  return node;
}
ts.getRootDeclaration = getRootDeclaration;
function nodeStartsNewLexicalEnvironment(node) {
  const kind = node.kind;
  return kind === 173 /* SyntaxKind.Constructor */
      || kind === 215 /* SyntaxKind.FunctionExpression */
      || kind === 259 /* SyntaxKind.FunctionDeclaration */
      || kind === 216 /* SyntaxKind.ArrowFunction */
      || kind === 171 /* SyntaxKind.MethodDeclaration */
      || kind === 174 /* SyntaxKind.GetAccessor */
      || kind === 175 /* SyntaxKind.SetAccessor */
      || kind === 264 /* SyntaxKind.ModuleDeclaration */
      || kind === 308 /* SyntaxKind.SourceFile */;
}
ts.nodeStartsNewLexicalEnvironment = nodeStartsNewLexicalEnvironment;
function nodeIsSynthesized(range) {
  return positionIsSynthesized(range.pos) || positionIsSynthesized(range.end);
}
ts.nodeIsSynthesized = nodeIsSynthesized;
function getOriginalSourceFile(sourceFile) {
  return ts.getParseTreeNode(sourceFile, ts.isSourceFile) || sourceFile;
}
ts.getOriginalSourceFile = getOriginalSourceFile;
let Associativity;
(function(Associativity) {
Associativity[Associativity['Left'] = 0] = 'Left';
Associativity[Associativity['Right'] = 1] = 'Right';
})(Associativity = ts.Associativity || (ts.Associativity = {}));
function getExpressionAssociativity(expression) {
  const operator = getOperator(expression);
  const hasArguments = expression.kind === 211 /* SyntaxKind.NewExpression */ && expression.arguments !== undefined;
  return getOperatorAssociativity(expression.kind, operator, hasArguments);
}
ts.getExpressionAssociativity = getExpressionAssociativity;
function getOperatorAssociativity(kind, operator, hasArguments) {
  switch (kind) {
    case 211 /* SyntaxKind.NewExpression */:
      return hasArguments ? 0 /* Associativity.Left */ : 1 /* Associativity.Right */;
    case 221 /* SyntaxKind.PrefixUnaryExpression */:
    case 218 /* SyntaxKind.TypeOfExpression */:
    case 219 /* SyntaxKind.VoidExpression */:
    case 217 /* SyntaxKind.DeleteExpression */:
    case 220 /* SyntaxKind.AwaitExpression */:
    case 224 /* SyntaxKind.ConditionalExpression */:
    case 226 /* SyntaxKind.YieldExpression */:
      return 1 /* Associativity.Right */;
    case 223 /* SyntaxKind.BinaryExpression */:
      switch (operator) {
        case 42 /* SyntaxKind.AsteriskAsteriskToken */:
        case 63 /* SyntaxKind.EqualsToken */:
        case 64 /* SyntaxKind.PlusEqualsToken */:
        case 65 /* SyntaxKind.MinusEqualsToken */:
        case 67 /* SyntaxKind.AsteriskAsteriskEqualsToken */:
        case 66 /* SyntaxKind.AsteriskEqualsToken */:
        case 68 /* SyntaxKind.SlashEqualsToken */:
        case 69 /* SyntaxKind.PercentEqualsToken */:
        case 70 /* SyntaxKind.LessThanLessThanEqualsToken */:
        case 71 /* SyntaxKind.GreaterThanGreaterThanEqualsToken */:
        case 72 /* SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken */:
        case 73 /* SyntaxKind.AmpersandEqualsToken */:
        case 78 /* SyntaxKind.CaretEqualsToken */:
        case 74 /* SyntaxKind.BarEqualsToken */:
        case 75 /* SyntaxKind.BarBarEqualsToken */:
        case 76 /* SyntaxKind.AmpersandAmpersandEqualsToken */:
        case 77 /* SyntaxKind.QuestionQuestionEqualsToken */:
          return 1 /* Associativity.Right */;
      }
  }
  return 0 /* Associativity.Left */;
}
ts.getOperatorAssociativity = getOperatorAssociativity;
function getExpressionPrecedence(expression) {
  const operator = getOperator(expression);
  const hasArguments = expression.kind === 211 /* SyntaxKind.NewExpression */ && expression.arguments !== undefined;
  return getOperatorPrecedence(expression.kind, operator, hasArguments);
}
ts.getExpressionPrecedence = getExpressionPrecedence;
function getOperator(expression) {
  if (expression.kind === 223 /* SyntaxKind.BinaryExpression */) {
    return expression.operatorToken.kind;
  } if (
      expression.kind === 221 /* SyntaxKind.PrefixUnaryExpression */ ||
      expression.kind === 222 /* SyntaxKind.PostfixUnaryExpression */) {
    return expression.operator;
  }
    return expression.kind;

}
ts.getOperator = getOperator;
let OperatorPrecedence;
(function(OperatorPrecedence) {
// Expression:
//     AssignmentExpression
//     Expression `,` AssignmentExpression
OperatorPrecedence[OperatorPrecedence['Comma'] = 0] = 'Comma';
// NOTE: `Spread` is higher than `Comma` due to how it is parsed in |ElementList|
// SpreadElement:
//     `...` AssignmentExpression
OperatorPrecedence[OperatorPrecedence['Spread'] = 1] = 'Spread';
// AssignmentExpression:
//     ConditionalExpression
//     YieldExpression
//     ArrowFunction
//     AsyncArrowFunction
//     LeftHandSideExpression `=` AssignmentExpression
//     LeftHandSideExpression AssignmentOperator AssignmentExpression
//
// NOTE: AssignmentExpression is broken down into several precedences due to the requirements
//       of the parenthesizer rules.
// AssignmentExpression: YieldExpression
// YieldExpression:
//     `yield`
//     `yield` AssignmentExpression
//     `yield` `*` AssignmentExpression
OperatorPrecedence[OperatorPrecedence['Yield'] = 2] = 'Yield';
// AssignmentExpression: LeftHandSideExpression `=` AssignmentExpression
// AssignmentExpression: LeftHandSideExpression AssignmentOperator AssignmentExpression
// AssignmentOperator: one of
//     `*=` `/=` `%=` `+=` `-=` `<<=` `>>=` `>>>=` `&=` `^=` `|=` `**=`
OperatorPrecedence[OperatorPrecedence['Assignment'] = 3] = 'Assignment';
// NOTE: `Conditional` is considered higher than `Assignment` here, but in reality they have
//       the same precedence.
// AssignmentExpression: ConditionalExpression
// ConditionalExpression:
//     ShortCircuitExpression
//     ShortCircuitExpression `?` AssignmentExpression `:` AssignmentExpression
// ShortCircuitExpression:
//     LogicalORExpression
//     CoalesceExpression
OperatorPrecedence[OperatorPrecedence['Conditional'] = 4] = 'Conditional';
// CoalesceExpression:
//     CoalesceExpressionHead `??` BitwiseORExpression
// CoalesceExpressionHead:
//     CoalesceExpression
//     BitwiseORExpression
OperatorPrecedence[OperatorPrecedence['Coalesce'] = 4] = 'Coalesce';
// LogicalORExpression:
//     LogicalANDExpression
//     LogicalORExpression `||` LogicalANDExpression
OperatorPrecedence[OperatorPrecedence['LogicalOR'] = 5] = 'LogicalOR';
// LogicalANDExpression:
//     BitwiseORExpression
//     LogicalANDExprerssion `&&` BitwiseORExpression
OperatorPrecedence[OperatorPrecedence['LogicalAND'] = 6] = 'LogicalAND';
// BitwiseORExpression:
//     BitwiseXORExpression
//     BitwiseORExpression `^` BitwiseXORExpression
OperatorPrecedence[OperatorPrecedence['BitwiseOR'] = 7] = 'BitwiseOR';
// BitwiseXORExpression:
//     BitwiseANDExpression
//     BitwiseXORExpression `^` BitwiseANDExpression
OperatorPrecedence[OperatorPrecedence['BitwiseXOR'] = 8] = 'BitwiseXOR';
// BitwiseANDExpression:
//     EqualityExpression
//     BitwiseANDExpression `^` EqualityExpression
OperatorPrecedence[OperatorPrecedence['BitwiseAND'] = 9] = 'BitwiseAND';
// EqualityExpression:
//     RelationalExpression
//     EqualityExpression `==` RelationalExpression
//     EqualityExpression `!=` RelationalExpression
//     EqualityExpression `===` RelationalExpression
//     EqualityExpression `!==` RelationalExpression
OperatorPrecedence[OperatorPrecedence['Equality'] = 10] = 'Equality';
// RelationalExpression:
//     ShiftExpression
//     RelationalExpression `<` ShiftExpression
//     RelationalExpression `>` ShiftExpression
//     RelationalExpression `<=` ShiftExpression
//     RelationalExpression `>=` ShiftExpression
//     RelationalExpression `instanceof` ShiftExpression
//     RelationalExpression `in` ShiftExpression
//     [+TypeScript] RelationalExpression `as` Type
OperatorPrecedence[OperatorPrecedence['Relational'] = 11] = 'Relational';
// ShiftExpression:
//     AdditiveExpression
//     ShiftExpression `<<` AdditiveExpression
//     ShiftExpression `>>` AdditiveExpression
//     ShiftExpression `>>>` AdditiveExpression
OperatorPrecedence[OperatorPrecedence['Shift'] = 12] = 'Shift';
// AdditiveExpression:
//     MultiplicativeExpression
//     AdditiveExpression `+` MultiplicativeExpression
//     AdditiveExpression `-` MultiplicativeExpression
OperatorPrecedence[OperatorPrecedence['Additive'] = 13] = 'Additive';
// MultiplicativeExpression:
//     ExponentiationExpression
//     MultiplicativeExpression MultiplicativeOperator ExponentiationExpression
// MultiplicativeOperator: one of `*`, `/`, `%`
OperatorPrecedence[OperatorPrecedence['Multiplicative'] = 14] = 'Multiplicative';
// ExponentiationExpression:
//     UnaryExpression
//     UpdateExpression `**` ExponentiationExpression
OperatorPrecedence[OperatorPrecedence['Exponentiation'] = 15] = 'Exponentiation';
// UnaryExpression:
//     UpdateExpression
//     `delete` UnaryExpression
//     `void` UnaryExpression
//     `typeof` UnaryExpression
//     `+` UnaryExpression
//     `-` UnaryExpression
//     `~` UnaryExpression
//     `!` UnaryExpression
//     AwaitExpression
// UpdateExpression:            // TODO: Do we need to investigate the precedence here?
//     `++` UnaryExpression
//     `--` UnaryExpression
OperatorPrecedence[OperatorPrecedence['Unary'] = 16] = 'Unary';
// UpdateExpression:
//     LeftHandSideExpression
//     LeftHandSideExpression `++`
//     LeftHandSideExpression `--`
OperatorPrecedence[OperatorPrecedence['Update'] = 17] = 'Update';
// LeftHandSideExpression:
//     NewExpression
//     CallExpression
// NewExpression:
//     MemberExpression
//     `new` NewExpression
OperatorPrecedence[OperatorPrecedence['LeftHandSide'] = 18] = 'LeftHandSide';
// CallExpression:
//     CoverCallExpressionAndAsyncArrowHead
//     SuperCall
//     ImportCall
//     CallExpression Arguments
//     CallExpression `[` Expression `]`
//     CallExpression `.` IdentifierName
//     CallExpression TemplateLiteral
// MemberExpression:
//     PrimaryExpression
//     MemberExpression `[` Expression `]`
//     MemberExpression `.` IdentifierName
//     MemberExpression TemplateLiteral
//     SuperProperty
//     MetaProperty
//     `new` MemberExpression Arguments
OperatorPrecedence[OperatorPrecedence['Member'] = 19] = 'Member';
// TODO: JSXElement?
// PrimaryExpression:
//     `this`
//     IdentifierReference
//     Literal
//     ArrayLiteral
//     ObjectLiteral
//     FunctionExpression
//     ClassExpression
//     GeneratorExpression
//     AsyncFunctionExpression
//     AsyncGeneratorExpression
//     RegularExpressionLiteral
//     TemplateLiteral
//     CoverParenthesizedExpressionAndArrowParameterList
OperatorPrecedence[OperatorPrecedence['Primary'] = 20] = 'Primary';
OperatorPrecedence[OperatorPrecedence['Highest'] = 20] = 'Highest';
OperatorPrecedence[OperatorPrecedence['Lowest'] = 0] = 'Lowest';
// -1 is lower than all other precedences. Returning it will cause binary expression
// parsing to stop.
OperatorPrecedence[OperatorPrecedence['Invalid'] = -1] = 'Invalid';
})(OperatorPrecedence = ts.OperatorPrecedence || (ts.OperatorPrecedence = {}));
function getOperatorPrecedence(nodeKind, operatorKind, hasArguments) {
  switch (nodeKind) {
    case 354 /* SyntaxKind.CommaListExpression */:
      return 0 /* OperatorPrecedence.Comma */;
    case 227 /* SyntaxKind.SpreadElement */:
      return 1 /* OperatorPrecedence.Spread */;
    case 226 /* SyntaxKind.YieldExpression */:
      return 2 /* OperatorPrecedence.Yield */;
    case 224 /* SyntaxKind.ConditionalExpression */:
      return 4 /* OperatorPrecedence.Conditional */;
    case 223 /* SyntaxKind.BinaryExpression */:
      switch (operatorKind) {
        case 27 /* SyntaxKind.CommaToken */:
          return 0 /* OperatorPrecedence.Comma */;
        case 63 /* SyntaxKind.EqualsToken */:
        case 64 /* SyntaxKind.PlusEqualsToken */:
        case 65 /* SyntaxKind.MinusEqualsToken */:
        case 67 /* SyntaxKind.AsteriskAsteriskEqualsToken */:
        case 66 /* SyntaxKind.AsteriskEqualsToken */:
        case 68 /* SyntaxKind.SlashEqualsToken */:
        case 69 /* SyntaxKind.PercentEqualsToken */:
        case 70 /* SyntaxKind.LessThanLessThanEqualsToken */:
        case 71 /* SyntaxKind.GreaterThanGreaterThanEqualsToken */:
        case 72 /* SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken */:
        case 73 /* SyntaxKind.AmpersandEqualsToken */:
        case 78 /* SyntaxKind.CaretEqualsToken */:
        case 74 /* SyntaxKind.BarEqualsToken */:
        case 75 /* SyntaxKind.BarBarEqualsToken */:
        case 76 /* SyntaxKind.AmpersandAmpersandEqualsToken */:
        case 77 /* SyntaxKind.QuestionQuestionEqualsToken */:
          return 3 /* OperatorPrecedence.Assignment */;
        default:
          return getBinaryOperatorPrecedence(operatorKind);
      }
    // TODO: Should prefix `++` and `--` be moved to the `Update` precedence?
    case 213 /* SyntaxKind.TypeAssertionExpression */:
    case 232 /* SyntaxKind.NonNullExpression */:
    case 221 /* SyntaxKind.PrefixUnaryExpression */:
    case 218 /* SyntaxKind.TypeOfExpression */:
    case 219 /* SyntaxKind.VoidExpression */:
    case 217 /* SyntaxKind.DeleteExpression */:
    case 220 /* SyntaxKind.AwaitExpression */:
      return 16 /* OperatorPrecedence.Unary */;
    case 222 /* SyntaxKind.PostfixUnaryExpression */:
      return 17 /* OperatorPrecedence.Update */;
    case 210 /* SyntaxKind.CallExpression */:
      return 18 /* OperatorPrecedence.LeftHandSide */;
    case 211 /* SyntaxKind.NewExpression */:
      return hasArguments ? 19 /* OperatorPrecedence.Member */ : 18 /* OperatorPrecedence.LeftHandSide */;
    case 212 /* SyntaxKind.TaggedTemplateExpression */:
    case 208 /* SyntaxKind.PropertyAccessExpression */:
    case 209 /* SyntaxKind.ElementAccessExpression */:
    case 233 /* SyntaxKind.MetaProperty */:
      return 19 /* OperatorPrecedence.Member */;
    case 231 /* SyntaxKind.AsExpression */:
    case 235 /* SyntaxKind.SatisfiesExpression */:
      return 11 /* OperatorPrecedence.Relational */;
    case 108 /* SyntaxKind.ThisKeyword */:
    case 106 /* SyntaxKind.SuperKeyword */:
    case 79 /* SyntaxKind.Identifier */:
    case 80 /* SyntaxKind.PrivateIdentifier */:
    case 104 /* SyntaxKind.NullKeyword */:
    case 110 /* SyntaxKind.TrueKeyword */:
    case 95 /* SyntaxKind.FalseKeyword */:
    case 8 /* SyntaxKind.NumericLiteral */:
    case 9 /* SyntaxKind.BigIntLiteral */:
    case 10 /* SyntaxKind.StringLiteral */:
    case 206 /* SyntaxKind.ArrayLiteralExpression */:
    case 207 /* SyntaxKind.ObjectLiteralExpression */:
    case 215 /* SyntaxKind.FunctionExpression */:
    case 216 /* SyntaxKind.ArrowFunction */:
    case 228 /* SyntaxKind.ClassExpression */:
    case 13 /* SyntaxKind.RegularExpressionLiteral */:
    case 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */:
    case 225 /* SyntaxKind.TemplateExpression */:
    case 214 /* SyntaxKind.ParenthesizedExpression */:
    case 229 /* SyntaxKind.OmittedExpression */:
    case 281 /* SyntaxKind.JsxElement */:
    case 282 /* SyntaxKind.JsxSelfClosingElement */:
    case 285 /* SyntaxKind.JsxFragment */:
      return 20 /* OperatorPrecedence.Primary */;
    default:
      return -1 /* OperatorPrecedence.Invalid */;
  }
}
ts.getOperatorPrecedence = getOperatorPrecedence;
function getBinaryOperatorPrecedence(kind) {
  switch (kind) {
    case 60 /* SyntaxKind.QuestionQuestionToken */:
      return 4 /* OperatorPrecedence.Coalesce */;
    case 56 /* SyntaxKind.BarBarToken */:
      return 5 /* OperatorPrecedence.LogicalOR */;
    case 55 /* SyntaxKind.AmpersandAmpersandToken */:
      return 6 /* OperatorPrecedence.LogicalAND */;
    case 51 /* SyntaxKind.BarToken */:
      return 7 /* OperatorPrecedence.BitwiseOR */;
    case 52 /* SyntaxKind.CaretToken */:
      return 8 /* OperatorPrecedence.BitwiseXOR */;
    case 50 /* SyntaxKind.AmpersandToken */:
      return 9 /* OperatorPrecedence.BitwiseAND */;
    case 34 /* SyntaxKind.EqualsEqualsToken */:
    case 35 /* SyntaxKind.ExclamationEqualsToken */:
    case 36 /* SyntaxKind.EqualsEqualsEqualsToken */:
    case 37 /* SyntaxKind.ExclamationEqualsEqualsToken */:
      return 10 /* OperatorPrecedence.Equality */;
    case 29 /* SyntaxKind.LessThanToken */:
    case 31 /* SyntaxKind.GreaterThanToken */:
    case 32 /* SyntaxKind.LessThanEqualsToken */:
    case 33 /* SyntaxKind.GreaterThanEqualsToken */:
    case 102 /* SyntaxKind.InstanceOfKeyword */:
    case 101 /* SyntaxKind.InKeyword */:
    case 128 /* SyntaxKind.AsKeyword */:
    case 150 /* SyntaxKind.SatisfiesKeyword */:
      return 11 /* OperatorPrecedence.Relational */;
    case 47 /* SyntaxKind.LessThanLessThanToken */:
    case 48 /* SyntaxKind.GreaterThanGreaterThanToken */:
    case 49 /* SyntaxKind.GreaterThanGreaterThanGreaterThanToken */:
      return 12 /* OperatorPrecedence.Shift */;
    case 39 /* SyntaxKind.PlusToken */:
    case 40 /* SyntaxKind.MinusToken */:
      return 13 /* OperatorPrecedence.Additive */;
    case 41 /* SyntaxKind.AsteriskToken */:
    case 43 /* SyntaxKind.SlashToken */:
    case 44 /* SyntaxKind.PercentToken */:
      return 14 /* OperatorPrecedence.Multiplicative */;
    case 42 /* SyntaxKind.AsteriskAsteriskToken */:
      return 15 /* OperatorPrecedence.Exponentiation */;
  }
  // -1 is lower than all other precedences.  Returning it will cause binary expression
  // parsing to stop.
  return -1;
}
ts.getBinaryOperatorPrecedence = getBinaryOperatorPrecedence;
function getSemanticJsxChildren(children) {
  return ts.filter(children, function(i) {
    switch (i.kind) {
      case 291 /* SyntaxKind.JsxExpression */:
        return !!i.expression;
      case 11 /* SyntaxKind.JsxText */:
        return !i.containsOnlyTriviaWhiteSpaces;
      default:
        return true;
    }
  });
}
ts.getSemanticJsxChildren = getSemanticJsxChildren;
function createDiagnosticCollection() {
  let nonFileDiagnostics = [];  // See GH#19873
  const filesWithDiagnostics = [];
  const fileDiagnostics = new ts.Map();
  let hasReadNonFileDiagnostics = false;
  return {
    add,
    lookup,
    getGlobalDiagnostics,
    getDiagnostics,
  };
  function lookup(diagnostic) {
    let diagnostics;
    if (diagnostic.file) {
      diagnostics = fileDiagnostics.get(diagnostic.file.fileName);
    } else {
      diagnostics = nonFileDiagnostics;
    }
    if (!diagnostics) {
      return undefined;
    }
    const result = ts.binarySearch(diagnostics, diagnostic, ts.identity, compareDiagnosticsSkipRelatedInformation);
    if (result >= 0) {
      return diagnostics[result];
    }
    return undefined;
  }
  function add(diagnostic) {
    let diagnostics;
    if (diagnostic.file) {
      diagnostics = fileDiagnostics.get(diagnostic.file.fileName);
      if (!diagnostics) {
        diagnostics = [];  // See GH#19873
        fileDiagnostics.set(diagnostic.file.fileName, diagnostics);
        ts.insertSorted(filesWithDiagnostics, diagnostic.file.fileName, ts.compareStringsCaseSensitive);
      }
    } else {
      // If we've already read the non-file diagnostics, do not modify the existing array.
      if (hasReadNonFileDiagnostics) {
        hasReadNonFileDiagnostics = false;
        nonFileDiagnostics = nonFileDiagnostics.slice();
      }
      diagnostics = nonFileDiagnostics;
    }
    ts.insertSorted(diagnostics, diagnostic, compareDiagnosticsSkipRelatedInformation);
  }
  function getGlobalDiagnostics() {
    hasReadNonFileDiagnostics = true;
    return nonFileDiagnostics;
  }
  function getDiagnostics(fileName) {
    if (fileName) {
      return fileDiagnostics.get(fileName) || [];
    }
    const fileDiags = ts.flatMapToMutable(filesWithDiagnostics, function(f) {
      return fileDiagnostics.get(f);
    });
    if (!nonFileDiagnostics.length) {
      return fileDiags;
    }
    fileDiags.unshift.apply(fileDiags, nonFileDiagnostics);
    return fileDiags;
  }
}
ts.createDiagnosticCollection = createDiagnosticCollection;
const templateSubstitutionRegExp = /\$\{/g;
function escapeTemplateSubstitution(str) {
  return str.replace(templateSubstitutionRegExp, '\\${');
}
/** @internal */
function hasInvalidEscape(template) {
  return template &&
      !!(ts.isNoSubstitutionTemplateLiteral(template) ?
             template.templateFlags :
             (template.head.templateFlags || ts.some(template.templateSpans, function(span) {
               return !!span.literal.templateFlags;
             })));
}
ts.hasInvalidEscape = hasInvalidEscape;
// This consists of the first 19 unprintable ASCII characters, canonical escapes, lineSeparator,
// paragraphSeparator, and nextLine. The latter three are just desirable to suppress new lines in
// the language service. These characters should be escaped when printing, and if any characters are added,
// the map below must be updated. Note that this regexp *does not* include the 'delete' character.
// There is no reason for this other than that JSON.stringify does not handle it either.
const doubleQuoteEscapedCharsRegExp = /[\\\"\u0000-\u001f\t\v\f\b\r\n\u2028\u2029\u0085]/g;
const singleQuoteEscapedCharsRegExp = /[\\\'\u0000-\u001f\t\v\f\b\r\n\u2028\u2029\u0085]/g;
// Template strings preserve simple LF newlines, still encode CRLF (or CR)
const backtickQuoteEscapedCharsRegExp = /\r\n|[\\\`\u0000-\u001f\t\v\f\b\r\u2028\u2029\u0085]/g;
const escapedCharsMap = new ts.Map(ts.getEntries({
  '\t': '\\t',
  '\v': '\\v',
  '\f': '\\f',
  '\b': '\\b',
  '\r': '\\r',
  '\n': '\\n',
  '\\': '\\\\',
  '"': '\\"',
  '\'': '\\\'',
  '\`': '\\\`',
  '\u2028': '\\u2028',
  '\u2029': '\\u2029',
  '\u0085': '\\u0085',
  '\r\n': '\\r\\n',  // special case for CRLFs in backticks
}));
function encodeUtf16EscapeSequence(charCode) {
  const hexCharCode = charCode.toString(16).toUpperCase();
  const paddedHexCode = ('0000' + hexCharCode).slice(-4);
  return '\\u' + paddedHexCode;
}
function getReplacement(c, offset, input) {
  if (c.charCodeAt(0) === 0 /* CharacterCodes.nullCharacter */) {
    const lookAhead = input.charCodeAt(offset + c.length);
    if (lookAhead >= 48 /* CharacterCodes._0 */ && lookAhead <= 57 /* CharacterCodes._9 */) {
      // If the null character is followed by digits, print as a hex escape to prevent the result from parsing as an octal (which is forbidden in strict mode)
      return '\\x00';
    }
    // Otherwise, keep printing a literal \0 for the null character
    return '\\0';
  }
  return escapedCharsMap.get(c) || encodeUtf16EscapeSequence(c.charCodeAt(0));
}
/**
 * Based heavily on the abstract 'Quote'/'QuoteJSONString' operation from ECMA-262 (24.3.2.2),
 * but augmented for a few select characters (e.g. lineSeparator, paragraphSeparator, nextLine)
 * Note that this doesn't actually wrap the input in double quotes.
 */
function escapeString(s, quoteChar) {
  const escapedCharsRegExp = quoteChar === 96 /* CharacterCodes.backtick */ ? backtickQuoteEscapedCharsRegExp :
      quoteChar === 39 /* CharacterCodes.singleQuote */                   ? singleQuoteEscapedCharsRegExp :
                                                                            doubleQuoteEscapedCharsRegExp;
  return s.replace(escapedCharsRegExp, getReplacement);
}
ts.escapeString = escapeString;
const nonAsciiCharacters = /[^\u0000-\u007F]/g;
function escapeNonAsciiString(s, quoteChar) {
  s = escapeString(s, quoteChar);
  // Replace non-ASCII characters with '\uNNNN' escapes if any exist.
  // Otherwise just return the original string.
  return nonAsciiCharacters.test(s) ? s.replace(nonAsciiCharacters, function(c) {
    return encodeUtf16EscapeSequence(c.charCodeAt(0));
  }) : s;
}
ts.escapeNonAsciiString = escapeNonAsciiString;
// This consists of the first 19 unprintable ASCII characters, JSX canonical escapes, lineSeparator,
// paragraphSeparator, and nextLine. The latter three are just desirable to suppress new lines in
// the language service. These characters should be escaped when printing, and if any characters are added,
// the map below must be updated.
const jsxDoubleQuoteEscapedCharsRegExp = /[\"\u0000-\u001f\u2028\u2029\u0085]/g;
const jsxSingleQuoteEscapedCharsRegExp = /[\'\u0000-\u001f\u2028\u2029\u0085]/g;
const jsxEscapedCharsMap = new ts.Map(ts.getEntries({'"': '&quot;', '\'': '&apos;'}));
function encodeJsxCharacterEntity(charCode) {
  const hexCharCode = charCode.toString(16).toUpperCase();
  return '&#x' + hexCharCode + ';';
}
function getJsxAttributeStringReplacement(c) {
  if (c.charCodeAt(0) === 0 /* CharacterCodes.nullCharacter */) {
    return '&#0;';
  }
  return jsxEscapedCharsMap.get(c) || encodeJsxCharacterEntity(c.charCodeAt(0));
}
function escapeJsxAttributeString(s, quoteChar) {
  const escapedCharsRegExp = quoteChar === 39 /* CharacterCodes.singleQuote */ ? jsxSingleQuoteEscapedCharsRegExp :
                                                                               jsxDoubleQuoteEscapedCharsRegExp;
  return s.replace(escapedCharsRegExp, getJsxAttributeStringReplacement);
}
ts.escapeJsxAttributeString = escapeJsxAttributeString;
/**
 * Strip off existed surrounding single quotes, double quotes, or backticks from a given string
 *
 * @return non-quoted string
 */
function stripQuotes(name) {
  const length = name.length;
  if (length >= 2 && name.charCodeAt(0) === name.charCodeAt(length - 1) && isQuoteOrBacktick(name.charCodeAt(0))) {
    return name.substring(1, length - 1);
  }
  return name;
}
ts.stripQuotes = stripQuotes;
function isQuoteOrBacktick(charCode) {
  return charCode === 39 /* CharacterCodes.singleQuote */ || charCode === 34 /* CharacterCodes.doubleQuote */ ||
      charCode === 96 /* CharacterCodes.backtick */;
}
function isIntrinsicJsxName(name) {
  const ch = name.charCodeAt(0);
  return (ch >= 97 /* CharacterCodes.a */ && ch <= 122 /* CharacterCodes.z */) || ts.stringContains(name, '-') ||
      ts.stringContains(name, ':');
}
ts.isIntrinsicJsxName = isIntrinsicJsxName;
const indentStrings = ['', '    '];
function getIndentString(level) {
  // prepopulate cache
  const singleLevel = indentStrings[1];
  for (let current = indentStrings.length; current <= level; current++) {
    indentStrings.push(indentStrings[current - 1] + singleLevel);
  }
  return indentStrings[level];
}
ts.getIndentString = getIndentString;
function getIndentSize() {
  return indentStrings[1].length;
}
ts.getIndentSize = getIndentSize;
function isNightly() {
  return ts.stringContains(ts.version, '-dev') || ts.stringContains(ts.version, '-insiders');
}
ts.isNightly = isNightly;
function createTextWriter(newLine) {
  let output;
  let indent;
  let lineStart;
  let lineCount;
  let linePos;
  let hasTrailingComment = false;
  function updateLineCountAndPosFor(s) {
    const lineStartsOfS = ts.computeLineStarts(s);
    if (lineStartsOfS.length > 1) {
      lineCount = lineCount + lineStartsOfS.length - 1;
      linePos = output.length - s.length + ts.last(lineStartsOfS);
      lineStart = (linePos - output.length) === 0;
    } else {
      lineStart = false;
    }
  }
  function writeText(s) {
    if (s && s.length) {
      if (lineStart) {
        s = getIndentString(indent) + s;
        lineStart = false;
      }
      output += s;
      updateLineCountAndPosFor(s);
    }
  }
  function write(s) {
    if (s)
      {hasTrailingComment = false;}
    writeText(s);
  }
  function writeComment(s) {
    if (s)
      {hasTrailingComment = true;}
    writeText(s);
  }
  function reset() {
    output = '';
    indent = 0;
    lineStart = true;
    lineCount = 0;
    linePos = 0;
    hasTrailingComment = false;
  }
  function rawWrite(s) {
    if (s !== undefined) {
      output += s;
      updateLineCountAndPosFor(s);
      hasTrailingComment = false;
    }
  }
  function writeLiteral(s) {
    if (s && s.length) {
      write(s);
    }
  }
  function writeLine(force) {
    if (!lineStart || force) {
      output += newLine;
      lineCount++;
      linePos = output.length;
      lineStart = true;
      hasTrailingComment = false;
    }
  }
  function getTextPosWithWriteLine() {
    return lineStart ? output.length : (output.length + newLine.length);
  }
  reset();
  return {
    write,
    rawWrite,
    writeLiteral,
    writeLine,
    increaseIndent: function() {
      indent++;
    },
    decreaseIndent: function() {
      indent--;
    },
    getIndent: function() {
      return indent;
    },
    getTextPos: function() {
      return output.length;
    },
    getLine: function() {
      return lineCount;
    },
    getColumn: function() {
      return lineStart ? indent * getIndentSize() : output.length - linePos;
    },
    getText: function() {
      return output;
    },
    isAtStartOfLine: function() {
      return lineStart;
    },
    hasTrailingComment: function() {
      return hasTrailingComment;
    },
    hasTrailingWhitespace: function() {
      return !!output.length && ts.isWhiteSpaceLike(output.charCodeAt(output.length - 1));
    },
    clear: reset,
    reportInaccessibleThisError: ts.noop,
    reportPrivateInBaseOfClassExpression: ts.noop,
    reportInaccessibleUniqueSymbolError: ts.noop,
    trackSymbol: function() {
      return false;
    },
    writeKeyword: write,
    writeOperator: write,
    writeParameter: write,
    writeProperty: write,
    writePunctuation: write,
    writeSpace: write,
    writeStringLiteral: write,
    writeSymbol: function(s, _) {
      return write(s);
    },
    writeTrailingSemicolon: write,
    writeComment,
    getTextPosWithWriteLine
  };
}
ts.createTextWriter = createTextWriter;
function getTrailingSemicolonDeferringWriter(writer) {
  let pendingTrailingSemicolon = false;
  function commitPendingTrailingSemicolon() {
    if (pendingTrailingSemicolon) {
      writer.writeTrailingSemicolon(';');
      pendingTrailingSemicolon = false;
    }
  }
  return __assign(__assign({}, writer), {
    writeTrailingSemicolon: function() {
      pendingTrailingSemicolon = true;
    },
    writeLiteral: function(s) {
      commitPendingTrailingSemicolon();
      writer.writeLiteral(s);
    },
    writeStringLiteral: function(s) {
      commitPendingTrailingSemicolon();
      writer.writeStringLiteral(s);
    },
    writeSymbol: function(s, sym) {
      commitPendingTrailingSemicolon();
      writer.writeSymbol(s, sym);
    },
    writePunctuation: function(s) {
      commitPendingTrailingSemicolon();
      writer.writePunctuation(s);
    },
    writeKeyword: function(s) {
      commitPendingTrailingSemicolon();
      writer.writeKeyword(s);
    },
    writeOperator: function(s) {
      commitPendingTrailingSemicolon();
      writer.writeOperator(s);
    },
    writeParameter: function(s) {
      commitPendingTrailingSemicolon();
      writer.writeParameter(s);
    },
    writeSpace: function(s) {
      commitPendingTrailingSemicolon();
      writer.writeSpace(s);
    },
    writeProperty: function(s) {
      commitPendingTrailingSemicolon();
      writer.writeProperty(s);
    },
    writeComment: function(s) {
      commitPendingTrailingSemicolon();
      writer.writeComment(s);
    },
    writeLine: function() {
      commitPendingTrailingSemicolon();
      writer.writeLine();
    },
    increaseIndent: function() {
      commitPendingTrailingSemicolon();
      writer.increaseIndent();
    },
    decreaseIndent: function() {
      commitPendingTrailingSemicolon();
      writer.decreaseIndent();
    }
  });
}
ts.getTrailingSemicolonDeferringWriter = getTrailingSemicolonDeferringWriter;
function hostUsesCaseSensitiveFileNames(host) {
  return host.useCaseSensitiveFileNames ? host.useCaseSensitiveFileNames() : false;
}
ts.hostUsesCaseSensitiveFileNames = hostUsesCaseSensitiveFileNames;
function hostGetCanonicalFileName(host) {
  return ts.createGetCanonicalFileName(hostUsesCaseSensitiveFileNames(host));
}
ts.hostGetCanonicalFileName = hostGetCanonicalFileName;
function getResolvedExternalModuleName(host, file, referenceFile) {
  return file.moduleName || getExternalModuleNameFromPath(host, file.fileName, referenceFile && referenceFile.fileName);
}
ts.getResolvedExternalModuleName = getResolvedExternalModuleName;
function getCanonicalAbsolutePath(host, path) {
  return host.getCanonicalFileName(ts.getNormalizedAbsolutePath(path, host.getCurrentDirectory()));
}
function getExternalModuleNameFromDeclaration(host, resolver, declaration) {
  const file = resolver.getExternalModuleFileFromDeclaration(declaration);
  if (!file || file.isDeclarationFile) {
    return undefined;
  }
  // If the declaration already uses a non-relative name, and is outside the common source directory, continue to use it
  const specifier = getExternalModuleName(declaration);
  if (specifier && ts.isStringLiteralLike(specifier) && !ts.pathIsRelative(specifier.text) &&
      getCanonicalAbsolutePath(host, file.path)
              .indexOf(getCanonicalAbsolutePath(
                  host, ts.ensureTrailingDirectorySeparator(host.getCommonSourceDirectory()))) === -1) {
    return undefined;
  }
  return getResolvedExternalModuleName(host, file);
}
ts.getExternalModuleNameFromDeclaration = getExternalModuleNameFromDeclaration;
/**
 * Resolves a local path to a path which is absolute to the base of the emit
 */
function getExternalModuleNameFromPath(host, fileName, referencePath) {
  const getCanonicalFileName = function(f) {
    return host.getCanonicalFileName(f);
  };
  const dir = ts.toPath(
      referencePath ? ts.getDirectoryPath(referencePath) : host.getCommonSourceDirectory(), host.getCurrentDirectory(),
      getCanonicalFileName);
  const filePath = ts.getNormalizedAbsolutePath(fileName, host.getCurrentDirectory());
  const relativePath =
      ts.getRelativePathToDirectoryOrUrl(dir, filePath, dir, getCanonicalFileName, /* isAbsolutePathAnUrl*/ false);
  const extensionless = removeFileExtension(relativePath);
  return referencePath ? ts.ensurePathIsNonModuleName(extensionless) : extensionless;
}
ts.getExternalModuleNameFromPath = getExternalModuleNameFromPath;
function getOwnEmitOutputFilePath(fileName, host, extension) {
  const compilerOptions = host.getCompilerOptions();
  let emitOutputFilePathWithoutExtension;
  if (compilerOptions.outDir) {
    emitOutputFilePathWithoutExtension =
        removeFileExtension(getSourceFilePathInNewDir(fileName, host, compilerOptions.outDir));
  } else {
    emitOutputFilePathWithoutExtension = removeFileExtension(fileName);
  }
  return emitOutputFilePathWithoutExtension + extension;
}
ts.getOwnEmitOutputFilePath = getOwnEmitOutputFilePath;
function getDeclarationEmitOutputFilePath(fileName, host) {
  return getDeclarationEmitOutputFilePathWorker(
      fileName, host.getCompilerOptions(), host.getCurrentDirectory(), host.getCommonSourceDirectory(), function(f) {
        return host.getCanonicalFileName(f);
      });
}
ts.getDeclarationEmitOutputFilePath = getDeclarationEmitOutputFilePath;
function getDeclarationEmitOutputFilePathWorker(
    fileName, options, currentDirectory, commonSourceDirectory, getCanonicalFileName) {
  const outputDir = options.declarationDir || options.outDir;  // Prefer declaration folder if specified
  const path = outputDir ? getSourceFilePathInNewDirWorker(
                             fileName, outputDir, currentDirectory, commonSourceDirectory, getCanonicalFileName) :
                         fileName;
  const declarationExtension = getDeclarationEmitExtensionForPath(path);
  return removeFileExtension(path) + declarationExtension;
}
ts.getDeclarationEmitOutputFilePathWorker = getDeclarationEmitOutputFilePathWorker;
function getDeclarationEmitExtensionForPath(path) {
  return ts.fileExtensionIsOneOf(path, ['.mjs' /* Extension.Mjs */, '.mts' /* Extension.Mts */]) ? '.d.mts' /* Extension.Dmts */ :
            ts.fileExtensionIsOneOf(path, ['.cjs' /* Extension.Cjs */, '.cts' /* Extension.Cts */]) ? '.d.cts' /* Extension.Dcts */ :
                ts.fileExtensionIsOneOf(path, ['.json' /* Extension.Json */]) ? '.json.d.ts' : // Drive-by redefinition of json declaration file output name so if it's ever enabled, it behaves well
                    '.d.ts' /* Extension.Dts */;
}
ts.getDeclarationEmitExtensionForPath = getDeclarationEmitExtensionForPath;
/**
 * This function is an inverse of `getDeclarationEmitExtensionForPath`.
 */
function getPossibleOriginalInputExtensionForExtension(path) {
  return ts.fileExtensionIsOneOf(
             path, ['.d.mts' /* Extension.Dmts */, '.mjs' /* Extension.Mjs */, '.mts' /* Extension.Mts */]) ?
      ['.mts' /* Extension.Mts */, '.mjs' /* Extension.Mjs */] :
      ts.fileExtensionIsOneOf(
          path, ['.d.cts' /* Extension.Dcts */, '.cjs' /* Extension.Cjs */, '.cts' /* Extension.Cts */]) ?
      ['.cts' /* Extension.Cts */, '.cjs' /* Extension.Cjs */] :
      ts.fileExtensionIsOneOf(path, ['.json.d.ts']) ?
      ['.json' /* Extension.Json */] :
      ['.tsx' /* Extension.Tsx */, '.ts' /* Extension.Ts */, '.jsx' /* Extension.Jsx */, '.js' /* Extension.Js */];
}
ts.getPossibleOriginalInputExtensionForExtension = getPossibleOriginalInputExtensionForExtension;
function outFile(options) {
  return options.outFile || options.out;
}
ts.outFile = outFile;
/** Returns 'undefined' if and only if 'options.paths' is undefined. */
function getPathsBasePath(options, host) {
  let _a, _b;
  if (!options.paths)
    {return undefined;}
  return (_a = options.baseUrl) !== null && _a !== void 0 ?
      _a :
      ts.Debug.checkDefined(
          options.pathsBasePath || ((_b = host.getCurrentDirectory) === null || _b === void 0 ? void 0 : _b.call(host)),
          'Encountered \'paths\' without a \'baseUrl\', config file, or host \'getCurrentDirectory\'.');
}
ts.getPathsBasePath = getPathsBasePath;
/**
 * Gets the source files that are expected to have an emit output.
 *
 * Originally part of `forEachExpectedEmitFile`, this functionality was extracted to support
 * transformations.
 *
 * @param host An EmitHost.
 * @param targetSourceFile An optional target source file to emit.
 */
function getSourceFilesToEmit(host, targetSourceFile, forceDtsEmit) {
  const options = host.getCompilerOptions();
  if (outFile(options)) {
    const moduleKind = getEmitModuleKind(options);
    const moduleEmitEnabled_1 =
        options.emitDeclarationOnly || moduleKind === ts.ModuleKind.AMD || moduleKind === ts.ModuleKind.System;
    // Can emit only sources that are not declaration file and are either non module code or module with --module or --target es6 specified
    return ts.filter(host.getSourceFiles(), function(sourceFile) {
      return (moduleEmitEnabled_1 || !ts.isExternalModule(sourceFile)) &&
          sourceFileMayBeEmitted(sourceFile, host, forceDtsEmit);
    });
  }
    const sourceFiles = targetSourceFile === undefined ? host.getSourceFiles() : [targetSourceFile];
    return ts.filter(sourceFiles, function(sourceFile) {
      return sourceFileMayBeEmitted(sourceFile, host, forceDtsEmit);
    });

}
ts.getSourceFilesToEmit = getSourceFilesToEmit;
/** Don't call this for `--outFile`, just for `--outDir` or plain emit. `--outFile` needs additional checks. */
function sourceFileMayBeEmitted(sourceFile, host, forceDtsEmit) {
  const options = host.getCompilerOptions();
  return !(options.noEmitForJsFiles && isSourceFileJS(sourceFile)) && !sourceFile.isDeclarationFile &&
      !host.isSourceFileFromExternalLibrary(sourceFile) &&
      (forceDtsEmit ||
       (!(isJsonSourceFile(sourceFile) && host.getResolvedProjectReferenceToRedirect(sourceFile.fileName)) &&
        !host.isSourceOfProjectReferenceRedirect(sourceFile.fileName)));
}
ts.