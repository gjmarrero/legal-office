p();
            var current = node;
            while (current) {
                if (ts.isFunctionLike(current)) {
                    break;
                }
                if (ts.isLabeledStatement(current)) {
                    var name = current.label.text;
                    if (!uniques.has(name)) {
                        uniques.set(name, true);
                        entries.push({
                            name: name,
                            kindModifiers: "" /* ScriptElementKindModifier.none */,
                            kind: "label" /* ScriptElementKind.label */,
                            sortText: Completions.SortText.LocationPriority
                        });
                    }
                }
                current = current.parent;
            }
            return entries;
        }
        function getSymbolCompletionFromEntryId(program, log, sourceFile, position, entryId, host, preferences) {
            if (entryId.data) {
                var autoImport = getAutoImportSymbolFromCompletionEntryData(entryId.name, entryId.data, program, host);
                if (autoImport) {
                    var _a = getRelevantTokens(position, sourceFile), contextToken_1 = _a.contextToken, previousToken_1 = _a.previousToken;
                    return {
                        type: "symbol",
                        symbol: autoImport.symbol,
                        location: ts.getTouchingPropertyName(sourceFile, position),
                        previousToken: previousToken_1,
                        contextToken: contextToken_1,
                        isJsxInitializer: false,
                        isTypeOnlyLocation: false,
                        origin: autoImport.origin,
                    };
                }
            }
            var compilerOptions = program.getCompilerOptions();
            var completionData = getCompletionData(program, log, sourceFile, compilerOptions, position, { includeCompletionsForModuleExports: true, includeCompletionsWithInsertText: true }, entryId, host, /*formatContext*/ undefined);
            if (!completionData) {
                return { type: "none" };
            }
            if (completionData.kind !== 0 /* CompletionDataKind.Data */) {
                return { type: "request", request: completionData };
            }
            var symbols = completionData.symbols, literals = completionData.literals, location = completionData.location, completionKind = completionData.completionKind, symbolToOriginInfoMap = completionData.symbolToOriginInfoMap, contextToken = completionData.contextToken, previousToken = completionData.previousToken, isJsxInitializer = completionData.isJsxInitializer, isTypeOnlyLocation = completionData.isTypeOnlyLocation;
            var literal = ts.find(literals, function (l) { return completionNameForLiteral(sourceFile, preferences, l) === entryId.name; });
            if (literal !== undefined)
                return { type: "literal", literal: literal };
            // Find the symbol with the matching entry name.
            // We don't need to perform character checks here because we're only comparing the
            // name against 'entryName' (which is known to be good), not building a new
            // completion entry.
            return ts.firstDefined(symbols, function (symbol, index) {
                var origin = symbolToOriginInfoMap[index];
                var info = getCompletionEntryDisplayNameForSymbol(symbol, ts.getEmitScriptTarget(compilerOptions), origin, completionKind, completionData.isJsxIdentifierExpected);
                return info && info.name === entryId.name && (entryId.source === CompletionSource.ClassMemberSnippet && symbol.flags & 106500 /* SymbolFlags.ClassMember */
                    || entryId.source === CompletionSource.ObjectLiteralMethodSnippet && symbol.flags & (4 /* SymbolFlags.Property */ | 8192 /* SymbolFlags.Method */)
                    || getSourceFromOrigin(origin) === entryId.source)
                    ? { type: "symbol", symbol: symbol, location: location, origin: origin, contextToken: contextToken, previousToken: previousToken, isJsxInitializer: isJsxInitializer, isTypeOnlyLocation: isTypeOnlyLocation }
                    : undefined;
            }) || { type: "none" };
        }
        function getCompletionEntryDetails(program, log, sourceFile, position, entryId, host, formatContext, preferences, cancellationToken) {
            var typeChecker = program.getTypeChecker();
            var compilerOptions = program.getCompilerOptions();
            var name = entryId.name, source = entryId.source, data = entryId.data;
            var contextToken = ts.findPrecedingToken(position, sourceFile);
            if (ts.isInString(sourceFile, position, contextToken)) {
                return Completions.StringCompletions.getStringLiteralCompletionDetails(name, sourceFile, position, contextToken, typeChecker, compilerOptions, host, cancellationToken, preferences);
            }
            // Compute all the completion symbols again.
            var symbolCompletion = getSymbolCompletionFromEntryId(program, log, sourceFile, position, entryId, host, preferences);
            switch (symbolCompletion.type) {
                case "request": {
                    var request = symbolCompletion.request;
                    switch (request.kind) {
                        case 1 /* CompletionDataKind.JsDocTagName */:
                            return ts.JsDoc.getJSDocTagNameCompletionDetails(name);
                        case 2 /* CompletionDataKind.JsDocTag */:
                            return ts.JsDoc.getJSDocTagCompletionDetails(name);
                        case 3 /* CompletionDataKind.JsDocParameterName */:
                            return ts.JsDoc.getJSDocParameterNameCompletionDetails(name);
                        case 4 /* CompletionDataKind.Keywords */:
                            return ts.some(request.keywordCompletions, function (c) { return c.name === name; }) ? createSimpleDetails(name, "keyword" /* ScriptElementKind.keyword */, ts.SymbolDisplayPartKind.keyword) : undefined;
                        default:
                            return ts.Debug.assertNever(request);
                    }
                }
                case "symbol": {
                    var symbol = symbolCompletion.symbol, location = symbolCompletion.location, contextToken_2 = symbolCompletion.contextToken, origin = symbolCompletion.origin, previousToken = symbolCompletion.previousToken;
                    var _a = getCompletionEntryCodeActionsAndSourceDisplay(name, location, contextToken_2, origin, symbol, program, host, compilerOptions, sourceFile, position, previousToken, formatContext, preferences, data, source, cancellationToken), codeActions = _a.codeActions, sourceDisplay = _a.sourceDisplay;
                    return createCompletionDetailsForSymbol(symbol, typeChecker, sourceFile, location, cancellationToken, codeActions, sourceDisplay); // TODO: GH#18217
                }
                case "literal": {
                    var literal = symbolCompletion.literal;
                    return createSimpleDetails(completionNameForLiteral(sourceFile, preferences, literal), "string" /* ScriptElementKind.string */, typeof literal === "string" ? ts.SymbolDisplayPartKind.stringLiteral : ts.SymbolDisplayPartKind.numericLiteral);
                }
                case "none":
                    // Didn't find a symbol with this name.  See if we can find a keyword instead.
                    return allKeywordsCompletions().some(function (c) { return c.name === name; }) ? createSimpleDetails(name, "keyword" /* ScriptElementKind.keyword */, ts.SymbolDisplayPartKind.keyword) : undefined;
                default:
                    ts.Debug.assertNever(symbolCompletion);
            }
        }
        Completions.getCompletionEntryDetails = getCompletionEntryDetails;
        function createSimpleDetails(name, kind, kind2) {
            return createCompletionDetails(name, "" /* ScriptElementKindModifier.none */, kind, [ts.displayPart(name, kind2)]);
        }
        function createCompletionDetailsForSymbol(symbol, checker, sourceFile, location, cancellationToken, codeActions, sourceDisplay) {
            var _a = checker.runWithCancellationToken(cancellationToken, function (checker) {
                return ts.SymbolDisplay.getSymbolDisplayPartsDocumentationAndSymbolKind(checker, symbol, sourceFile, location, location, 7 /* SemanticMeaning.All */);
            }), displayParts = _a.displayParts, documentation = _a.documentation, symbolKind = _a.symbolKind, tags = _a.tags;
            return createCompletionDetails(symbol.name, ts.SymbolDisplay.getSymbolModifiers(checker, symbol), symbolKind, displayParts, documentation, tags, codeActions, sourceDisplay);
        }
        Completions.createCompletionDetailsForSymbol = createCompletionDetailsForSymbol;
        function createCompletionDetails(name, kindModifiers, kind, displayParts, documentation, tags, codeActions, source) {
            return { name: name, kindModifiers: kindModifiers, kind: kind, displayParts: displayParts, documentation: documentation, tags: tags, codeActions: codeActions, source: source, sourceDisplay: source };
        }
        Completions.createCompletionDetails = createCompletionDetails;
        function getCompletionEntryCodeActionsAndSourceDisplay(name, location, contextToken, origin, symbol, program, host, compilerOptions, sourceFile, position, previousToken, formatContext, preferences, data, source, cancellationToken) {
            if (data === null || data === void 0 ? void 0 : data.moduleSpecifier) {
                if (previousToken && getImportStatementCompletionInfo(contextToken || previousToken).replacementSpan) {
                    // Import statement completion: 'import c|'
                    return { codeActions: undefined, sourceDisplay: [ts.textPart(data.moduleSpecifier)] };
                }
            }
            if (source === CompletionSource.ClassMemberSnippet) {
                var importAdder = getEntryForMemberCompletion(host, program, compilerOptions, preferences, name, symbol, location, contextToken, formatContext).importAdder;
                if (importAdder) {
                    var changes = ts.textChanges.ChangeTracker.with({ host: host, formatContext: formatContext, preferences: preferences }, importAdder.writeFixes);
                    return {
                        sourceDisplay: undefined,
                        codeActions: [{
                                changes: changes,
                                description: ts.diagnosticToString([ts.Diagnostics.Includes_imports_of_types_referenced_by_0, name]),
                            }],
                    };
                }
            }
            if (originIsTypeOnlyAlias(origin)) {
                var codeAction_1 = ts.codefix.getPromoteTypeOnlyCompletionAction(sourceFile, origin.declaration.name, program, host, formatContext, preferences);
                ts.Debug.assertIsDefined(codeAction_1, "Expected to have a code action for promoting type-only alias");
                return { codeActions: [codeAction_1], sourceDisplay: undefined };
            }
            if (!origin || !(originIsExport(origin) || originIsResolvedExport(origin))) {
                return { codeActions: undefined, sourceDisplay: undefined };
            }
            var checker = origin.isFromPackageJson ? host.getPackageJsonAutoImportProvider().getTypeChecker() : program.getTypeChecker();
            var moduleSymbol = origin.moduleSymbol;
            var targetSymbol = checker.getMergedSymbol(ts.skipAlias(symbol.exportSymbol || symbol, checker));
            var isJsxOpeningTagName = (contextToken === null || contextToken === void 0 ? void 0 : contextToken.kind) === 29 /* SyntaxKind.LessThanToken */ && ts.isJsxOpeningLikeElement(contextToken.parent);
            var _a = ts.codefix.getImportCompletionAction(targetSymbol, moduleSymbol, sourceFile, ts.getNameForExportedSymbol(symbol, ts.getEmitScriptTarget(compilerOptions), isJsxOpeningTagName), isJsxOpeningTagName, host, program, formatContext, previousToken && ts.isIdentifier(previousToken) ? previousToken.getStart(sourceFile) : position, preferences, cancellationToken), moduleSpecifier = _a.moduleSpecifier, codeAction = _a.codeAction;
            ts.Debug.assert(!(data === null || data === void 0 ? void 0 : data.moduleSpecifier) || moduleSpecifier === data.moduleSpecifier);
            return { sourceDisplay: [ts.textPart(moduleSpecifier)], codeActions: [codeAction] };
        }
        function getCompletionEntrySymbol(program, log, sourceFile, position, entryId, host, preferences) {
            var completion = getSymbolCompletionFromEntryId(program, log, sourceFile, position, entryId, host, preferences);
            return completion.type === "symbol" ? completion.symbol : undefined;
        }
        Completions.getCompletionEntrySymbol = getCompletionEntrySymbol;
        var CompletionDataKind;
        (function (CompletionDataKind) {
            CompletionDataKind[CompletionDataKind["Data"] = 0] = "Data";
            CompletionDataKind[CompletionDataKind["JsDocTagName"] = 1] = "JsDocTagName";
            CompletionDataKind[CompletionDataKind["JsDocTag"] = 2] = "JsDocTag";
            CompletionDataKind[CompletionDataKind["JsDocParameterName"] = 3] = "JsDocParameterName";
            CompletionDataKind[CompletionDataKind["Keywords"] = 4] = "Keywords";
        })(CompletionDataKind || (CompletionDataKind = {}));
        var CompletionKind;
        (function (CompletionKind) {
            CompletionKind[CompletionKind["ObjectPropertyDeclaration"] = 0] = "ObjectPropertyDeclaration";
            CompletionKind[CompletionKind["Global"] = 1] = "Global";
            CompletionKind[CompletionKind["PropertyAccess"] = 2] = "PropertyAccess";
            CompletionKind[CompletionKind["MemberLike"] = 3] = "MemberLike";
            CompletionKind[CompletionKind["String"] = 4] = "String";
            CompletionKind[CompletionKind["None"] = 5] = "None";
        })(CompletionKind = Completions.CompletionKind || (Completions.CompletionKind = {}));
        function getRecommendedCompletion(previousToken, contextualType, checker) {
            // For a union, return the first one with a recommended completion.
            return ts.firstDefined(contextualType && (contextualType.isUnion() ? contextualType.types : [contextualType]), function (type) {
                var symbol = type && type.symbol;
                // Don't include make a recommended completion for an abstract class
                return symbol && (symbol.flags & (8 /* SymbolFlags.EnumMember */ | 384 /* SymbolFlags.Enum */ | 32 /* SymbolFlags.Class */) && !ts.isAbstractConstructorSymbol(symbol))
                    ? getFirstSymbolInChain(symbol, previousToken, checker)
                    : undefined;
            });
        }
        function getContextualType(previousToken, position, sourceFile, checker) {
            var parent = previousToken.parent;
            switch (previousToken.kind) {
                case 79 /* SyntaxKind.Identifier */:
                    return ts.getContextualTypeFromParent(previousToken, checker);
                case 63 /* SyntaxKind.EqualsToken */:
                    switch (parent.kind) {
                        case 257 /* SyntaxKind.VariableDeclaration */:
                            return checker.getContextualType(parent.initializer); // TODO: GH#18217
                        case 223 /* SyntaxKind.BinaryExpression */:
                            return checker.getTypeAtLocation(parent.left);
                        case 288 /* SyntaxKind.JsxAttribute */:
                            return checker.getContextualTypeForJsxAttribute(parent);
                        default:
                            return undefined;
                    }
                case 103 /* SyntaxKind.NewKeyword */:
                    return checker.getContextualType(parent);
                case 82 /* SyntaxKind.CaseKeyword */:
                    var caseClause = ts.tryCast(parent, ts.isCaseClause);
                    return caseClause ? ts.getSwitchedType(caseClause, checker) : undefined;
                case 18 /* SyntaxKind.OpenBraceToken */:
                    return ts.isJsxExpression(parent) && !ts.isJsxElement(parent.parent) && !ts.isJsxFragment(parent.parent) ? checker.getContextualTypeForJsxAttribute(parent.parent) : undefined;
                default:
                    var argInfo = ts.SignatureHelp.getArgumentInfoForCompletions(previousToken, position, sourceFile);
                    return argInfo ?
                        // At `,`, treat this as the next argument after the comma.
                        checker.getContextualTypeForArgumentAtIndex(argInfo.invocation, argInfo.argumentIndex + (previousToken.kind === 27 /* SyntaxKind.CommaToken */ ? 1 : 0)) :
                        ts.isEqualityOperatorKind(previousToken.kind) && ts.isBinaryExpression(parent) && ts.isEqualityOperatorKind(parent.operatorToken.kind) ?
                            // completion at `x ===/**/` should be for the right side
                            checker.getTypeAtLocation(parent.left) :
                            checker.getContextualType(previousToken);
            }
        }
        function getFirstSymbolInChain(symbol, enclosingDeclaration, checker) {
            var chain = checker.getAccessibleSymbolChain(symbol, enclosingDeclaration, /*meaning*/ 67108863 /* SymbolFlags.All */, /*useOnlyExternalAliasing*/ false);
            if (chain)
                return ts.first(chain);
            return symbol.parent && (isModuleSymbol(symbol.parent) ? symbol : getFirstSymbolInChain(symbol.parent, enclosingDeclaration, checker));
        }
        function isModuleSymbol(symbol) {
            var _a;
            return !!((_a = symbol.declarations) === null || _a === void 0 ? void 0 : _a.some(function (d) { return d.kind === 308 /* SyntaxKind.SourceFile */; }));
        }
        function getCompletionData(program, log, sourceFile, compilerOptions, position, preferences, detailsEntryId, host, formatContext, cancellationToken) {
            var typeChecker = program.getTypeChecker();
            var inCheckedFile = isCheckedFile(sourceFile, compilerOptions);
            var start = ts.timestamp();
            var currentToken = ts.getTokenAtPosition(sourceFile, position); // TODO: GH#15853
            // We will check for jsdoc comments with insideComment and getJsDocTagAtPosition. (TODO: that seems rather inefficient to check the same thing so many times.)
            log("getCompletionData: Get current token: " + (ts.timestamp() - start));
            start = ts.timestamp();
            var insideComment = ts.isInComment(sourceFile, position, currentToken);
            log("getCompletionData: Is inside comment: " + (ts.timestamp() - start));
            var insideJsDocTagTypeExpression = false;
            var isInSnippetScope = false;
            if (insideComment) {
                if (ts.hasDocComment(sourceFile, position)) {
                    if (sourceFile.text.charCodeAt(position - 1) === 64 /* CharacterCodes.at */) {
                        // The current position is next to the '@' sign, when no tag name being provided yet.
                        // Provide a full list of tag names
                        return { kind: 1 /* CompletionDataKind.JsDocTagName */ };
                    }
                    else {
                        // When completion is requested without "@", we will have check to make sure that
                        // there are no comments prefix the request position. We will only allow "*" and space.
                        // e.g
                        //   /** |c| /*
                        //
                        //   /**
                        //     |c|
                        //    */
                        //
                        //   /**
                        //    * |c|
                        //    */
                        //
                        //   /**
                        //    *         |c|
                        //    */
                        var lineStart = ts.getLineStartPositionForPosition(position, sourceFile);
                        if (!/[^\*|\s(/)]/.test(sourceFile.text.substring(lineStart, position))) {
                            return { kind: 2 /* CompletionDataKind.JsDocTag */ };
                        }
                    }
                }
                // Completion should work inside certain JsDoc tags. For example:
                //     /** @type {number | string} */
                // Completion should work in the brackets
                var tag = getJsDocTagAtPosition(currentToken, position);
                if (tag) {
                    if (tag.tagName.pos <= position && position <= tag.tagName.end) {
                        return { kind: 1 /* CompletionDataKind.JsDocTagName */ };
                    }
                    var typeExpression = tryGetTypeExpressionFromTag(tag);
                    if (typeExpression) {
                        currentToken = ts.getTokenAtPosition(sourceFile, position);
                        if (!currentToken ||
                            (!ts.isDeclarationName(currentToken) &&
                                (currentToken.parent.kind !== 350 /* SyntaxKind.JSDocPropertyTag */ ||
                                    currentToken.parent.name !== currentToken))) {
                            // Use as type location if inside tag's type expression
                            insideJsDocTagTypeExpression = isCurrentlyEditingNode(typeExpression);
                        }
                    }
                    if (!insideJsDocTagTypeExpression && ts.isJSDocParameterTag(tag) && (ts.nodeIsMissing(tag.name) || tag.name.pos <= position && position <= tag.name.end)) {
                        return { kind: 3 /* CompletionDataKind.JsDocParameterName */, tag: tag };
                    }
                }
                if (!insideJsDocTagTypeExpression) {
                    // Proceed if the current position is in jsDoc tag expression; otherwise it is a normal
                    // comment or the plain text part of a jsDoc comment, so no completion should be available
                    log("Returning an empty list because completion was inside a regular comment or plain text part of a JsDoc comment.");
                    return undefined;
                }
            }
            start = ts.timestamp();
            // The decision to provide completion depends on the contextToken, which is determined through the previousToken.
            // Note: 'previousToken' (and thus 'contextToken') can be undefined if we are the beginning of the file
            var isJsOnlyLocation = !insideJsDocTagTypeExpression && ts.isSourceFileJS(sourceFile);
            var tokens = getRelevantTokens(position, sourceFile);
            var previousToken = tokens.previousToken;
            var contextToken = tokens.contextToken;
            log("getCompletionData: Get previous token: " + (ts.timestamp() - start));
            // Find the node where completion is requested on.
            // Also determine whether we are trying to complete with members of that node
            // or attributes of a JSX tag.
            var node = currentToken;
            var propertyAccessToConvert;
            var isRightOfDot = false;
            var isRightOfQuestionDot = false;
            var isRightOfOpenTag = false;
            var isStartingCloseTag = false;
            var isJsxInitializer = false;
            var isJsxIdentifierExpected = false;
            var importStatementCompletion;
            var location = ts.getTouchingPropertyName(sourceFile, position);
            var keywordFilters = 0 /* KeywordCompletionFilters.None */;
            var isNewIdentifierLocation = false;
            var flags = 0 /* CompletionInfoFlags.None */;
            if (contextToken) {
                var importStatementCompletionInfo = getImportStatementCompletionInfo(contextToken);
                if (importStatementCompletionInfo.keywordCompletion) {
                    if (importStatementCompletionInfo.isKeywordOnlyCompletion) {
                        return {
                            kind: 4 /* CompletionDataKind.Keywords */,
                            keywordCompletions: [keywordToCompletionEntry(importStatementCompletionInfo.keywordCompletion)],
                            isNewIdentifierLocation: importStatementCompletionInfo.isNewIdentifierLocation,
                        };
                    }
                    keywordFilters = keywordFiltersFromSyntaxKind(importStatementCompletionInfo.keywordCompletion);
                }
                if (importStatementCompletionInfo.replacementSpan && preferences.includeCompletionsForImportStatements && preferences.includeCompletionsWithInsertText) {
                    // Import statement completions use `insertText`, and also require the `data` property of `CompletionEntryIdentifier`
                    // added in TypeScript 4.3 to be sent back from the client during `getCompletionEntryDetails`. Since this feature
                    // is not backward compatible with older clients, the language service defaults to disabling it, allowing newer clients
                    // to opt in with the `includeCompletionsForImportStatements` user preference.
                    flags |= 2 /* CompletionInfoFlags.IsImportStatementCompletion */;
                    importStatementCompletion = importStatementCompletionInfo;
                    isNewIdentifierLocation = importStatementCompletionInfo.isNewIdentifierLocation;
                }
                // Bail out if this is a known invalid completion location
                if (!importStatementCompletionInfo.replacementSpan && isCompletionListBlocker(contextToken)) {
                    log("Returning an empty list because completion was requested in an invalid position.");
                    return keywordFilters
                        ? keywordCompletionData(keywordFilters, isJsOnlyLocation, isNewIdentifierDefinitionLocation())
                        : undefined;
                }
                var parent = contextToken.parent;
                if (contextToken.kind === 24 /* SyntaxKind.DotToken */ || contextToken.kind === 28 /* SyntaxKind.QuestionDotToken */) {
                    isRightOfDot = contextToken.kind === 24 /* SyntaxKind.DotToken */;
                    isRightOfQuestionDot = contextToken.kind === 28 /* SyntaxKind.QuestionDotToken */;
                    switch (parent.kind) {
                        case 208 /* SyntaxKind.PropertyAccessExpression */:
                            propertyAccessToConvert = parent;
                            node = propertyAccessToConvert.expression;
                            var leftmostAccessExpression = ts.getLeftmostAccessExpression(propertyAccessToConvert);
                            if (ts.nodeIsMissing(leftmostAccessExpression) ||
                                ((ts.isCallExpression(node) || ts.isFunctionLike(node)) &&
                                    node.end === contextToken.pos &&
                                    node.getChildCount(sourceFile) &&
                                    ts.last(node.getChildren(sourceFile)).kind !== 21 /* SyntaxKind.CloseParenToken */)) {
                                // This is likely dot from incorrectly parsed expression and user is starting to write spread
                                // eg: Math.min(./**/)
                                // const x = function (./**/) {}
                                // ({./**/})
                                return undefined;
                            }
                            break;
                        case 163 /* SyntaxKind.QualifiedName */:
                            node = parent.left;
                            break;
                        case 264 /* SyntaxKind.ModuleDeclaration */:
                            node = parent.name;
                            break;
                        case 202 /* SyntaxKind.ImportType */:
                            node = parent;
                            break;
                        case 233 /* SyntaxKind.MetaProperty */:
                            node = parent.getFirstToken(sourceFile);
                            ts.Debug.assert(node.kind === 100 /* SyntaxKind.ImportKeyword */ || node.kind === 103 /* SyntaxKind.NewKeyword */);
                            break;
                        default:
                            // There is nothing that precedes the dot, so this likely just a stray character
                            // or leading into a '...' token. Just bail out instead.
                            return undefined;
                    }
                }
                else if (!importStatementCompletion) {
                    // <UI.Test /* completion position */ />
                    // If the tagname is a property access expression, we will then walk up to the top most of property access expression.
                    // Then, try to get a JSX container and its associated attributes type.
                    if (parent && parent.kind === 208 /* SyntaxKind.PropertyAccessExpression */) {
                        contextToken = parent;
                        parent = parent.parent;
                    }
                    // Fix location
                    if (currentToken.parent === location) {
                        switch (currentToken.kind) {
                            case 31 /* SyntaxKind.GreaterThanToken */:
                                if (currentToken.parent.kind === 281 /* SyntaxKind.JsxElement */ || currentToken.parent.kind === 283 /* SyntaxKind.JsxOpeningElement */) {
                                    location = currentToken;
                                }
                                break;
                            case 43 /* SyntaxKind.SlashToken */:
                                if (currentToken.parent.kind === 282 /* SyntaxKind.JsxSelfClosingElement */) {
                                    location = currentToken;
                                }
                                break;
                        }
                    }
                    switch (parent.kind) {
                        case 284 /* SyntaxKind.JsxClosingElement */:
                            if (contextToken.kind === 43 /* SyntaxKind.SlashToken */) {
                                isStartingCloseTag = true;
                                location = contextToken;
                            }
                            break;
                        case 223 /* SyntaxKind.BinaryExpression */:
                            if (!binaryExpressionMayBeOpenTag(parent)) {
                                break;
                            }
                        // falls through
                        case 282 /* SyntaxKind.JsxSelfClosingElement */:
                        case 281 /* SyntaxKind.JsxElement */:
                        case 283 /* SyntaxKind.JsxOpeningElement */:
                            isJsxIdentifierExpected = true;
                            if (contextToken.kind === 29 /* SyntaxKind.LessThanToken */) {
                                isRightOfOpenTag = true;
                                location = contextToken;
                            }
                            break;
                        case 291 /* SyntaxKind.JsxExpression */:
                        case 290 /* SyntaxKind.JsxSpreadAttribute */:
                            // For `<div foo={true} [||] ></div>`, `parent` will be `{true}` and `previousToken` will be `}`
                            if (previousToken.kind === 19 /* SyntaxKind.CloseBraceToken */ && currentToken.kind === 31 /* SyntaxKind.GreaterThanToken */) {
                                isJsxIdentifierExpected = true;
                            }
                            break;
                        case 288 /* SyntaxKind.JsxAttribute */:
                            // For `<div className="x" [||] ></div>`, `parent` will be JsxAttribute and `previousToken` will be its initializer
                            if (parent.initializer === previousToken &&
                                previousToken.end < position) {
                                isJsxIdentifierExpected = true;
                                break;
                            }
                            switch (previousToken.kind) {
                                case 63 /* SyntaxKind.EqualsToken */:
                                    isJsxInitializer = true;
                                    break;
                                case 79 /* SyntaxKind.Identifier */:
                                    isJsxIdentifierExpected = true;
                                    // For `<div x=[|f/**/|]`, `parent` will be `x` and `previousToken.parent` will be `f` (which is its own JsxAttribute)
                                    // Note for `<div someBool f>` we don't want to treat this as a jsx inializer, instead it's the attribute name.
                                    if (parent !== previousToken.parent &&
                                        !parent.initializer &&
                                        ts.findChildOfKind(parent, 63 /* SyntaxKind.EqualsToken */, sourceFile)) {
                                        isJsxInitializer = previousToken;
                                    }
                            }
                            break;
                    }
                }
            }
            var semanticStart = ts.timestamp();
            var completionKind = 5 /* CompletionKind.None */;
            var isNonContextualObjectLiteral = false;
            var hasUnresolvedAutoImports = false;
            // This also gets mutated in nested-functions after the return
            var symbols = [];
            var importSpecifierResolver;
            var symbolToOriginInfoMap = [];
            var symbolToSortTextMap = [];
            var seenPropertySymbols = new ts.Map();
            var isTypeOnlyLocation = isTypeOnlyCompletion();
            var getModuleSpecifierResolutionHost = ts.memoizeOne(function (isFromPackageJson) {
                return ts.createModuleSpecifierResolutionHost(isFromPackageJson ? host.getPackageJsonAutoImportProvider() : program, host);
            });
            if (isRightOfDot || isRightOfQuestionDot) {
                getTypeScriptMemberSymbols();
            }
            else if (isRightOfOpenTag) {
                symbols = typeChecker.getJsxIntrinsicTagNamesAt(location);
                ts.Debug.assertEachIsDefined(symbols, "getJsxIntrinsicTagNames() should all be defined");
                tryGetGlobalSymbols();
                completionKind = 1 /* CompletionKind.Global */;
                keywordFilters = 0 /* KeywordCompletionFilters.None */;
            }
            else if (isStartingCloseTag) {
                var tagName = contextToken.parent.parent.openingElement.tagName;
                var tagSymbol = typeChecker.getSymbolAtLocation(tagName);
                if (tagSymbol) {
                    symbols = [tagSymbol];
                }
                completionKind = 1 /* CompletionKind.Global */;
                keywordFilters = 0 /* KeywordCompletionFilters.None */;
            }
            else {
                // For JavaScript or TypeScript, if we're not after a dot, then just try to get the
                // global symbols in scope.  These results should be valid for either language as
                // the set of symbols that can be referenced from this location.
                if (!tryGetGlobalSymbols()) {
                    return keywordFilters
                        ? keywordCompletionData(keywordFilters, isJsOnlyLocation, isNewIdentifierLocation)
                        : undefined;
                }
            }
            log("getCompletionData: Semantic work: " + (ts.timestamp() - semanticStart));
            var contextualType = previousToken && getContextualType(previousToken, position, sourceFile, typeChecker);
            var literals = ts.mapDefined(contextualType && (contextualType.isUnion() ? contextualType.types : [contextualType]), function (t) { return t.isLiteral() && !(t.flags & 1024 /* TypeFlags.EnumLiteral */) ? t.value : undefined; });
            var recommendedCompletion = previousToken && contextualType && getRecommendedCompletion(previousToken, contextualType, typeChecker);
            return {
                kind: 0 /* CompletionDataKind.Data */,
                symbols: symbols,
                completionKind: completionKind,
                isInSnippetScope: isInSnippetScope,
                propertyAccessToConvert: propertyAccessToConvert,
                isNewIdentifierLocation: isNewIdentifierLocation,
                location: location,
                keywordFilters: keywordFilters,
                literals: literals,
                symbolToOriginInfoMap: symbolToOriginInfoMap,
                recommendedCompletion: recommendedCompletion,
                previousToken: previousToken,
                contextToken: contextToken,
                isJsxInitializer: isJsxInitializer,
                insideJsDocTagTypeExpression: insideJsDocTagTypeExpression,
                symbolToSortTextMap: symbolToSortTextMap,
                isTypeOnlyLocation: isTypeOnlyLocation,
                isJsxIdentifierExpected: isJsxIdentifierExpected,
                isRightOfOpenTag: isRightOfOpenTag,
                importStatementCompletion: importStatementCompletion,
                hasUnresolvedAutoImports: hasUnresolvedAutoImports,
                flags: flags,
            };
            function isTagWithTypeExpression(tag) {
                switch (tag.kind) {
                    case 343 /* SyntaxKind.JSDocParameterTag */:
                    case 350 /* SyntaxKind.JSDocPropertyTag */:
                    case 344 /* SyntaxKind.JSDocReturnTag */:
                    case 346 /* SyntaxKind.JSDocTypeTag */:
                    case 348 /* SyntaxKind.JSDocTypedefTag */:
                        return true;
                    case 347 /* SyntaxKind.JSDocTemplateTag */:
                        return !!tag.constraint;
                    default:
                        return false;
                }
            }
            function tryGetTypeExpressionFromTag(tag) {
                if (isTagWithTypeExpression(tag)) {
                    var typeExpression = ts.isJSDocTemplateTag(tag) ? tag.constraint : tag.typeExpression;
                    return typeExpression && typeExpression.kind === 312 /* SyntaxKind.JSDocTypeExpression */ ? typeExpression : undefined;
                }
                return undefined;
            }
            function getTypeScriptMemberSymbols() {
                // Right of dot member completion list
                completionKind = 2 /* CompletionKind.PropertyAccess */;
                // Since this is qualified name check it's a type node location
                var isImportType = ts.isLiteralImportTypeNode(node);
                var isTypeLocation = insideJsDocTagTypeExpression
                    || (isImportType && !node.isTypeOf)
                    || ts.isPartOfTypeNode(node.parent)
                    || ts.isPossiblyTypeArgumentPosition(contextToken, sourceFile, typeChecker);
                var isRhsOfImportDeclaration = ts.isInRightSideOfInternalImportEqualsDeclaration(node);
                if (ts.isEntityName(node) || isImportType || ts.isPropertyAccessExpression(node)) {
                    var isNamespaceName = ts.isModuleDeclaration(node.parent);
                    if (isNamespaceName)
                        isNewIdentifierLocation = true;
                    var symbol = typeChecker.getSymbolAtLocation(node);
                    if (symbol) {
                        symbol = ts.skipAlias(symbol, typeChecker);
                        if (symbol.flags & (1536 /* SymbolFlags.Module */ | 384 /* SymbolFlags.Enum */)) {
                            // Extract module or enum members
                            var exportedSymbols = typeChecker.getExportsOfModule(symbol);
                            ts.Debug.assertEachIsDefined(exportedSymbols, "getExportsOfModule() should all be defined");
                            var isValidValueAccess_1 = function (symbol) { return typeChecker.isValidPropertyAccess(isImportType ? node : node.parent, symbol.name); };
                            var isValidTypeAccess_1 = function (symbol) { return symbolCanBeReferencedAtTypeLocation(symbol, typeChecker); };
                            var isValidAccess = isNamespaceName
                                // At `namespace N.M/**/`, if this is the only declaration of `M`, don't include `M` as a completion.
                                ? function (symbol) { var _a; return !!(symbol.flags & 1920 /* SymbolFlags.Namespace */) && !((_a = symbol.declarations) === null || _a === void 0 ? void 0 : _a.every(function (d) { return d.parent === node.parent; })); }
                                : isRhsOfImportDeclaration ?
                                    // Any kind is allowed when dotting off namespace in internal import equals declaration
                                    function (symbol) { return isValidTypeAccess_1(symbol) || isValidValueAccess_1(symbol); } :
                                    isTypeLocation ? isValidTypeAccess_1 : isValidValueAccess_1;
                            for (var _i = 0, exportedSymbols_1 = exportedSymbols; _i < exportedSymbols_1.length; _i++) {
                                var exportedSymbol = exportedSymbols_1[_i];
                                if (isValidAccess(exportedSymbol)) {
                                    symbols.push(exportedSymbol);
                                }
                            }
                            // If the module is merged with a value, we must get the type of the class and add its propertes (for inherited static methods).
                            if (!isTypeLocation &&
                                symbol.declarations &&
                                symbol.declarations.some(function (d) { return d.kind !== 308 /* SyntaxKind.SourceFile */ && d.kind !== 264 /* SyntaxKind.ModuleDeclaration */ && d.kind !== 263 /* SyntaxKind.EnumDeclaration */; })) {
                                var type = typeChecker.getTypeOfSymbolAtLocation(symbol, node).getNonOptionalType();
                                var insertQuestionDot = false;
                                if (type.isNullableType()) {
                                    var canCorrectToQuestionDot = isRightOfDot &&
                                        !isRightOfQuestionDot &&
                                        preferences.includeAutomaticOptionalChainCompletions !== false;
                                    if (canCorrectToQuestionDot || isRightOfQuestionDot) {
                                        type = type.getNonNullableType();
                                        if (canCorrectToQuestionDot) {
                                            insertQuestionDot = true;
                                        }
                                    }
                                }
                                addTypeProperties(type, !!(node.flags & 32768 /* NodeFlags.AwaitContext */), insertQuestionDot);
                            }
                            return;
                        }
                    }
                }
                if (!isTypeLocation) {
                    // GH#39946. Pulling on the type of a node inside of a function with a contextual `this` parameter can result in a circularity
                    // if the `node` is part of the exprssion of a `yield` or `return`. This circularity doesn't exist at compile time because
                    // we will check (and cache) the type of `this` *before* checking the type of the node.
                    typeChecker.tryGetThisTypeAt(node, /*includeGlobalThis*/ false);
                    var type = typeChecker.getTypeAtLocation(node).getNonOptionalType();
                    var insertQuestionDot = false;
                    if (type.isNullableType()) {
                        var canCorrectToQuestionDot = isRightOfDot &&
                            !isRightOfQuestionDot &&
                            preferences.includeAutomaticOptionalChainCompletions !== false;
                        if (canCorrectToQuestionDot || isRightOfQuestionDot) {
                            type = type.getNonNullableType();
                            if (canCorrectToQuestionDot) {
                                insertQuestionDot = true;
                            }
                        }
                    }
                    addTypeProperties(type, !!(node.flags & 32768 /* NodeFlags.AwaitContext */), insertQuestionDot);
                }
            }
            function addTypeProperties(type, insertAwait, insertQuestionDot) {
                isNewIdentifierLocation = !!type.getStringIndexType();
                if (isRightOfQuestionDot && ts.some(type.getCallSignatures())) {
                    isNewIdentifierLocation = true;
                }
                var propertyAccess = node.kind === 202 /* SyntaxKind.ImportType */ ? node : node.parent;
                if (inCheckedFile) {
                    for (var _i = 0, _a = type.getApparentProperties(); _i < _a.length; _i++) {
                        var symbol = _a[_i];
                        if (typeChecker.isValidPropertyAccessForCompletions(propertyAccess, type, symbol)) {
                            addPropertySymbol(symbol, /* insertAwait */ false, insertQuestionDot);
                        }
                    }
                }
                else {
                    // In javascript files, for union types, we don't just get the members that
                    // the individual types have in common, we also include all the members that
                    // each individual type has. This is because we're going to add all identifiers
                    // anyways. So we might as well elevate the members that were at least part
                    // of the individual types to a higher status since we know what they are.
                    symbols.push.apply(symbols, ts.filter(getPropertiesForCompletion(type, typeChecker), function (s) { return typeChecker.isValidPropertyAccessForCompletions(propertyAccess, type, s); }));
                }
                if (insertAwait && preferences.includeCompletionsWithInsertText) {
                    var promiseType = typeChecker.getPromisedTypeOfPromise(type);
                    if (promiseType) {
                        for (var _b = 0, _c = promiseType.getApparentProperties(); _b < _c.length; _b++) {
                            var symbol = _c[_b];
                            if (typeChecker.isValidPropertyAccessForCompletions(propertyAccess, promiseType, symbol)) {
                                addPropertySymbol(symbol, /* insertAwait */ true, insertQuestionDot);
                            }
                        }
                    }
                }
            }
            function addPropertySymbol(symbol, insertAwait, insertQuestionDot) {
                var _a;
                // For a computed property with an accessible name like `Symbol.iterator`,
                // we'll add a completion for the *name* `Symbol` instead of for the property.
                // If this is e.g. [Symbol.iterator], add a completion for `Symbol`.
                var computedPropertyName = ts.firstDefined(symbol.declarations, function (decl) { return ts.tryCast(ts.getNameOfDeclaration(decl), ts.isComputedPropertyName); });
                if (computedPropertyName) {
                    var leftMostName = getLeftMostName(computedPropertyName.expression); // The completion is for `Symbol`, not `iterator`.
                    var nameSymbol = leftMostName && typeChecker.getSymbolAtLocation(leftMostName);
                    // If this is nested like for `namespace N { export const sym = Symbol(); }`, we'll add the completion for `N`.
                    var firstAccessibleSymbol = nameSymbol && getFirstSymbolInChain(nameSymbol, contextToken, typeChecker);
                    if (firstAccessibleSymbol && ts.addToSeen(seenPropertySymbols, ts.getSymbolId(firstAccessibleSymbol))) {
                        var index = symbols.length;
                        symbols.push(firstAccessibleSymbol);
                        var moduleSymbol = firstAccessibleSymbol.parent;
                        if (!moduleSymbol ||
                            !ts.isExternalModuleSymbol(moduleSymbol) ||
                            typeChecker.tryGetMemberInModuleExportsAndProperties(firstAccessibleSymbol.name, moduleSymbol) !== firstAccessibleSymbol) {
                            symbolToOriginInfoMap[index] = { kind: getNullableSymbolOriginInfoKind(2 /* SymbolOriginInfoKind.SymbolMemberNoExport */) };
                        }
                        else {
                            var fileName = ts.isExternalModuleNameRelative(ts.stripQuotes(moduleSymbol.name)) ? (_a = ts.getSourceFileOfModule(moduleSymbol)) === null || _a === void 0 ? void 0 : _a.fileName : undefined;
                            var moduleSpecifier = ((importSpecifierResolver || (importSpecifierResolver = ts.codefix.createImportSpecifierResolver(sourceFile, program, host, preferences))).getModuleSpecifierForBestExportInfo([{
                                    exportKind: 0 /* ExportKind.Named */,
                                    moduleFileName: fileName,
                                    isFromPackageJson: false,
                                    moduleSymbol: moduleSymbol,
                                    symbol: firstAccessibleSymbol,
                                    targetFlags: ts.skipAlias(firstAccessibleSymbol, typeChecker).flags,
                                }], firstAccessibleSymbol.name, position, ts.isValidTypeOnlyAliasUseSite(location)) || {}).moduleSpecifier;
                            if (moduleSpecifier) {
                                var origin = {
                                    kind: getNullableSymbolOriginInfoKind(6 /* SymbolOriginInfoKind.SymbolMemberExport */),
                                    moduleSymbol: moduleSymbol,
                                    isDefaultExport: false,
                                    symbolName: firstAccessibleSymbol.name,
                                    exportName: firstAccessibleSymbol.name,
                                    fileName: fileName,
                                    moduleSpecifier: moduleSpecifier,
                                };
                                symbolToOriginInfoMap[index] = origin;
                            }
                        }
                    }
                    else if (preferences.includeCompletionsWithInsertText) {
                        addSymbolOriginInfo(symbol);
                        addSymbolSortInfo(symbol);
                        symbols.push(symbol);
                    }
                }
                else {
                    addSymbolOriginInfo(symbol);
                    addSymbolSortInfo(symbol);
                    symbols.push(symbol);
                }
                function addSymbolSortInfo(symbol) {
                    if (isStaticProperty(symbol)) {
                        symbolToSortTextMap[ts.getSymbolId(symbol)] = Completions.SortText.LocalDeclarationPriority;
                    }
                }
                function addSymbolOriginInfo(symbol) {
                    if (preferences.includeCompletionsWithInsertText) {
                        if (insertAwait && ts.addToSeen(seenPropertySymbols, ts.getSymbolId(symbol))) {
                            symbolToOriginInfoMap[symbols.length] = { kind: getNullableSymbolOriginInfoKind(8 /* SymbolOriginInfoKind.Promise */) };
                        }
                        else if (insertQuestionDot) {
                            symbolToOriginInfoMap[symbols.length] = { kind: 16 /* SymbolOriginInfoKind.Nullable */ };
                        }
                    }
                }
                function getNullableSymbolOriginInfoKind(kind) {
                    return insertQuestionDot ? kind | 16 /* SymbolOriginInfoKind.Nullable */ : kind;
                }
            }
            /** Given 'a.b.c', returns 'a'. */
            function getLeftMostName(e) {
                return ts.isIdentifier(e) ? e : ts.isPropertyAccessExpression(e) ? getLeftMostName(e.expression) : undefined;
            }
            function tryGetGlobalSymbols() {
                var result = tryGetObjectTypeLiteralInTypeArgumentCompletionSymbols()
                    || tryGetObjectLikeCompletionSymbols()
                    || tryGetImportCompletionSymbols()
                    || tryGetImportOrExportClauseCompletionSymbols()
                    || tryGetLocalNamedExportCompletionSymbols()
                    || tryGetConstructorCompletion()
                    || tryGetClassLikeCompletionSymbols()
                    || tryGetJsxCompletionSymbols()
                    || (getGlobalCompletions(), 1 /* GlobalsSearch.Success */);
                return result === 1 /* GlobalsSearch.Success */;
            }
            function tryGetConstructorCompletion() {
                if (!tryGetConstructorLikeCompletionContainer(contextToken))
                    return 0 /* GlobalsSearch.Continue */;
                // no members, only keywords
                completionKind = 5 /* CompletionKind.None */;
                // Declaring new property/method/accessor
                isNewIdentifierLocation = true;
                // Has keywords for constructor parameter
                keywordFilters = 4 /* KeywordCompletionFilters.ConstructorParameterKeywords */;
                return 1 /* GlobalsSearch.Success */;
            }
            function tryGetJsxCompletionSymbols() {
                var jsxContainer = tryGetContainingJsxElement(contextToken);
                // Cursor is inside a JSX self-closing element or opening element
                var attrsType = jsxContainer && typeChecker.getContextualType(jsxContainer.attributes);
                if (!attrsType)
                    return 0 /* GlobalsSearch.Continue */;
                var completionsType = jsxContainer && typeChecker.getContextualType(jsxContainer.attributes, 4 /* ContextFlags.Completions */);
                symbols = ts.concatenate(symbols, filterJsxAttributes(getPropertiesForObjectExpression(attrsType, completionsType, jsxContainer.attributes, typeChecker), jsxContainer.attributes.properties));
                setSortTextToOptionalMember();
                completionKind = 3 /* CompletionKind.MemberLike */;
                isNewIdentifierLocation = false;
                return 1 /* GlobalsSearch.Success */;
            }
            function tryGetImportCompletionSymbols() {
                if (!importStatementCompletion)
                    return 0 /* GlobalsSearch.Continue */;
                isNewIdentifierLocation = true;
                collectAutoImports();
                return 1 /* GlobalsSearch.Success */;
            }
            function getGlobalCompletions() {
                keywordFilters = tryGetFunctionLikeBodyCompletionContainer(contextToken) ? 5 /* KeywordCompletionFilters.FunctionLikeBodyKeywords */ : 1 /* KeywordCompletionFilters.All */;
                // Get all entities in the current scope.
                completionKind = 1 /* CompletionKind.Global */;
                isNewIdentifierLocation = isNewIdentifierDefinitionLocation();
                if (previousToken !== contextToken) {
                    ts.Debug.assert(!!previousToken, "Expected 'contextToken' to be defined when different from 'previousToken'.");
                }
                // We need to find the node that will give us an appropriate scope to begin
                // aggregating completion candidates. This is achieved in 'getScopeNode'
                // by finding the first node that encompasses a position, accounting for whether a node
                // is "complete" to decide whether a position belongs to the node.
                //
                // However, at the end of an identifier, we are interested in the scope of the identifier
                // itself, but fall outside of the identifier. For instance:
                //
                //      xyz => x$
                //
                // the cursor is outside of both the 'x' and the arrow function 'xyz => x',
                // so 'xyz' is not returned in our results.
                //
                // We define 'adjustedPosition' so that we may appropriately account for
                // being at the end of an identifier. The intention is that if requesting completion
                // at the end of an identifier, it should be effectively equivalent to requesting completion
                // anywhere inside/at the beginning of the identifier. So in the previous case, the
                // 'adjustedPosition' will work as if requesting completion in the following:
                //
                //      xyz => $x
                //
                // If previousToken !== contextToken, then
                //   - 'contextToken' was adjusted to the token prior to 'previousToken'
                //      because we were at the end of an identifier.
                //   - 'previousToken' is defined.
                var adjustedPosition = previousToken !== contextToken ?
                    previousToken.getStart() :
                    position;
                var scopeNode = getScopeNode(contextToken, adjustedPosition, sourceFile) || sourceFile;
                isInSnippetScope = isSnippetScope(scopeNode);
                var symbolMeanings = (isTypeOnlyLocation ? 0 /* SymbolFlags.None */ : 111551 /* SymbolFlags.Value */) | 788968 /* SymbolFlags.Type */ | 1920 /* SymbolFlags.Namespace */ | 2097152 /* SymbolFlags.Alias */;
                var typeOnlyAliasNeedsPromotion = previousToken && !ts.isValidTypeOnlyAliasUseSite(previousToken);
                symbols = ts.concatenate(symbols, typeChecker.getSymbolsInScope(scopeNode, symbolMeanings));
                ts.Debug.assertEachIsDefined(symbols, "getSymbolsInScope() should all be defined");
                for (var i = 0; i < symbols.length; i++) {
                    var symbol = symbols[i];
                    if (!typeChecker.isArgumentsSymbol(symbol) &&
                        !ts.some(symbol.declarations, function (d) { return d.getSourceFile() === sourceFile; })) {
                        symbolToSortTextMap[ts.getSymbolId(symbol)] = Completions.SortText.GlobalsOrKeywords;
                    }
                    if (typeOnlyAliasNeedsPromotion && !(symbol.flags & 111551 /* SymbolFlags.Value */)) {
                        var typeOnlyAliasDeclaration = symbol.declarations && ts.find(symbol.declarations, ts.isTypeOnlyImportOrExportDeclaration);
                        if (typeOnlyAliasDeclaration) {
                            var origin = { kind: 64 /* SymbolOriginInfoKind.TypeOnlyAlias */, declaration: typeOnlyAliasDeclaration };
                            symbolToOriginInfoMap[i] = origin;
                        }
                    }
                }
                // Need to insert 'this.' before properties of `this` type, so only do that if `includeInsertTextCompletions`
                if (preferences.includeCompletionsWithInsertText && scopeNode.kind !== 308 /* SyntaxKind.SourceFile */) {
                    var thisType = typeChecker.tryGetThisTypeAt(scopeNode, /*includeGlobalThis*/ false, ts.isClassLike(scopeNode.parent) ? scopeNode : undefined);
                    if (thisType && !isProbablyGlobalType(thisType, sourceFile, typeChecker)) {
                        for (var _i = 0, _a = getPropertiesForCompletion(thisType, typeChecker); _i < _a.length; _i++) {
                            var symbol = _a[_i];
                            symbolToOriginInfoMap[symbols.length] = { kind: 1 /* SymbolOriginInfoKind.ThisType */ };
                            symbols.push(symbol);
                            symbolToSortTextMap[ts.getSymbolId(symbol)] = Completions.SortText.SuggestedClassMembers;
                        }
                    }
                }
                collectAutoImports();
                if (isTypeOnlyLocation) {
                    keywordFilters = contextToken && ts.isAssertionExpression(contextToken.parent)
                        ? 6 /* KeywordCompletionFilters.TypeAssertionKeywords */
                        : 7 /* KeywordCompletionFilters.TypeKeywords */;
                }
            }
            function shouldOfferImportCompletions() {
                // If already typing an import statement, provide completions for it.
                if (importStatementCompletion)
                    return true;
                // If current completion is for non-contextual Object literal shortahands, ignore auto-import symbols
                if (isNonContextualObjectLiteral)
                    return false;
                // If not already a module, must have modules enabled.
                if (!preferences.includeCompletionsForModuleExports)
                    return false;
                // If already using ES modules, OK to continue using them.
                if (sourceFile.externalModuleIndicator || sourceFile.commonJsModuleIndicator)
                    return true;
                // If module transpilation is enabled or we're targeting es6 or above, or not emitting, OK.
                if (ts.compilerOptionsIndicateEsModules(program.getCompilerOptions()))
                    return true;
                // If some file is using ES6 modules, assume that it's OK to add more.
                return ts.programContainsModules(program);
            }
            function isSnippetScope(scopeNode) {
                switch (scopeNode.kind) {
                    case 308 /* SyntaxKind.SourceFile */:
                    case 225 /* SyntaxKind.TemplateExpression */:
                    case 291 /* SyntaxKind.JsxExpression */:
                    case 238 /* SyntaxKind.Block */:
                        return true;
                    default:
                        return ts.isStatement(scopeNode);
                }
            }
            function isTypeOnlyCompletion() {
                return insideJsDocTagTypeExpression
                    || !!importStatementCompletion && ts.isTypeOnlyImportOrExportDeclaration(location.parent)
                    || !isContextTokenValueLocation(contextToken) &&
                        (ts.isPossiblyTypeArgumentPosition(contextToken, sourceFile, typeChecker)
                            || ts.isPartOfTypeNode(location)
                            || isContextTokenTypeLocation(contextToken));
            }
            function isContextTokenValueLocation(contextToken) {
                return contextToken &&
                    ((contextToken.kind === 112 /* SyntaxKind.TypeOfKeyword */ &&
                        (contextToken.parent.kind === 183 /* SyntaxKind.TypeQuery */ || ts.isTypeOfExpression(contextToken.parent))) ||
                        (contextToken.kind === 129 /* SyntaxKind.AssertsKeyword */ && contextToken.parent.kind === 179 /* SyntaxKind.TypePredicate */));
            }
            function isContextTokenTypeLocation(contextToken) {
                if (contextToken) {
                    var parentKind = contextToken.parent.kind;
                    switch (contextToken.kind) {
                        case 58 /* SyntaxKind.ColonToken */:
                            return parentKind === 169 /* SyntaxKind.PropertyDeclaration */ ||
                                parentKind === 168 /* SyntaxKind.PropertySignature */ ||
                                parentKind === 166 /* SyntaxKind.Parameter */ ||
                                parentKind === 257 /* SyntaxKind.VariableDeclaration */ ||
                                ts.isFunctionLikeKind(parentKind);
                        case 63 /* SyntaxKind.EqualsToken */:
                            return parentKind === 262 /* SyntaxKind.TypeAliasDeclaration */;
                        case 128 /* SyntaxKind.AsKeyword */:
                            return parentKind === 231 /* SyntaxKind.AsExpression */;
                        case 29 /* SyntaxKind.LessThanToken */:
                            return parentKind === 180 /* SyntaxKind.TypeReference */ ||
                                parentKind === 213 /* SyntaxKind.TypeAssertionExpression */;
                        case 94 /* SyntaxKind.ExtendsKeyword */:
                            return parentKind === 165 /* SyntaxKind.TypeParameter */;
                        case 150 /* SyntaxKind.SatisfiesKeyword */:
                            return parentKind === 235 /* SyntaxKind.SatisfiesExpression */;
                    }
                }
                return false;
            }
            /** Mutates `symbols`, `symbolToOriginInfoMap`, and `symbolToSortTextMap` */
            function collectAutoImports() {
                var _a, _b;
                if (!shouldOfferImportCompletions())
                    return;
                ts.Debug.assert(!(detailsEntryId === null || detailsEntryId === void 0 ? void 0 : detailsEntryId.data), "Should not run 'collectAutoImports' when faster path is available via `data`");
                if (detailsEntryId && !detailsEntryId.source) {
                    // Asking for completion details for an item that is not an auto-import
                    return;
                }
                flags |= 1 /* CompletionInfoFlags.MayIncludeAutoImports */;
                // import { type | -> token text should be blank
                var isAfterTypeOnlyImportSpecifierModifier = previousToken === contextToken
                    && importStatementCompletion;
                var lowerCaseTokenText = isAfterTypeOnlyImportSpecifierModifier ? "" :
                    previousToken && ts.isIdentifier(previousToken) ? previousToken.text.toLowerCase() :
                        "";
                var moduleSpecifierCache = (_a = host.getModuleSpecifierCache) === null || _a === void 0 ? void 0 : _a.call(host);
                var exportInfo = ts.getExportInfoMap(sourceFile, host, program, preferences, cancellationToken);
                var packageJsonAutoImportProvider = (_b = host.getPackageJsonAutoImportProvider) === null || _b === void 0 ? void 0 : _b.call(host);
                var packageJsonFilter = detailsEntryId ? undefined : ts.createPackageJsonImportFilter(sourceFile, preferences, host);
                resolvingModuleSpecifiers("collectAutoImports", host, importSpecifierResolver || (importSpecifierResolver = ts.codefix.createImportSpecifierResolver(sourceFile, program, host, preferences)), program, position, preferences, !!importStatementCompletion, ts.isValidTypeOnlyAliasUseSite(location), function (context) {
                    exportInfo.search(sourceFile.path,
                    /*preferCapitalized*/ isRightOfOpenTag, function (symbolName, targetFlags) {
                        if (!ts.isIdentifierText(symbolName, ts.getEmitScriptTarget(host.getCompilationSettings())))
                            return false;
                        if (!detailsEntryId && ts.isStringANonContextualKeyword(symbolName))
                            return false;
                        if (!isTypeOnlyLocation && !importStatementCompletion && !(targetFlags & 111551 /* SymbolFlags.Value */))
                            return false;
                        if (isTypeOnlyLocation && !(targetFlags & (1536 /* SymbolFlags.Module */ | 788968 /* SymbolFlags.Type */)))
                            return false;
                        // Do not try to auto-import something with a lowercase first letter for a JSX tag
                        var firstChar = symbolName.charCodeAt(0);
                        if (isRightOfOpenTag && (firstChar < 65 /* CharacterCodes.A */ || firstChar > 90 /* CharacterCodes.Z */))
                            return false;
                        if (detailsEntryId)
                            return true;
                        return charactersFuzzyMatchInString(symbolName, lowerCaseTokenText);
                    }, function (info, symbolName, isFromAmbientModule, exportMapKey) {
                        var _a;
                        if (detailsEntryId && !ts.some(info, function (i) { return detailsEntryId.source === ts.stripQuotes(i.moduleSymbol.name); })) {
                            return;
                        }
                        // Do a relatively cheap check to bail early if all re-exports are non-importable
                        // due to file location or package.json dependency filtering. For non-node16+
                        // module resolution modes, getting past this point guarantees that we'll be
                        // able to generate a suitable module specifier, so we can safely show a completion,
                        // even if we defer computing the module specifier.
                        var firstImportableExportInfo = ts.find(info, isImportableExportInfo);
                        if (!firstImportableExportInfo) {
                            return;
                        }
                        // In node16+, module specifier resolution can fail due to modules being blocked
                        // by package.json `exports`. If that happens, don't show a completion item.
                        // N.B. in this resolution mode we always try to resolve module specifiers here,
                        // because we have to know now if it's going to fail so we can omit the completion
                        // from the list.
                        var result = context.tryResolve(info, symbolName, isFromAmbientModule) || {};
                        if (result === "failed")
                            return;
                        // If we skipped resolving module specifiers, our selection of which ExportInfo
                        // to use here is arbitrary, since the info shown in the completion list derived from
                        // it should be identical regardless of which one is used. During the subsequent
                        // `CompletionEntryDetails` request, we'll get all the ExportInfos again and pick
                        // the best one based on the module specifier it produces.
                        var exportInfo = firstImportableExportInfo, moduleSpecifier;
                        if (result !== "skipped") {
                            (_a = result.exportInfo, exportInfo = _a === void 0 ? firstImportableExportInfo : _a, moduleSpecifier = result.moduleSpecifier);
                        }
                        var isDefaultExport = exportInfo.exportKind === 1 /* ExportKind.Default */;
                        var symbol = isDefaultExport && ts.getLocalSymbolForExportDefault(exportInfo.symbol) || exportInfo.symbol;
                        pushAutoImportSymbol(symbol, {
                            kind: moduleSpecifier ? 32 /* SymbolOriginInfoKind.ResolvedExport */ : 4 /* SymbolOriginInfoKind.Export */,
                            moduleSpecifier: moduleSpecifier,
                            symbolName: symbolName,
                            exportMapKey: exportMapKey,
                            exportName: exportInfo.exportKind === 2 /* ExportKind.ExportEquals */ ? "export=" /* InternalSymbolName.ExportEquals */ : exportInfo.symbol.name,
                            fileName: exportInfo.moduleFileName,
                            isDefaultExport: isDefaultExport,
                            moduleSymbol: exportInfo.moduleSymbol,
                            isFromPackageJson: exportInfo.isFromPackageJson,
                        });
                    });
                    hasUnresolvedAutoImports = context.skippedAny();
                    flags |= context.resolvedAny() ? 8 /* CompletionInfoFlags.ResolvedModuleSpecifiers */ : 0;
                    flags |= context.resolvedBeyondLimit() ? 16 /* CompletionInfoFlags.ResolvedModuleSpecifiersBeyondLimit */ : 0;
                });
                function isImportableExportInfo(info) {
                    var moduleFile = ts.tryCast(info.moduleSymbol.valueDeclaration, ts.isSourceFile);
                    if (!moduleFile) {
                        var moduleName = ts.stripQuotes(info.moduleSymbol.name);
                        if (ts.JsTyping.nodeCoreModules.has(moduleName) && ts.startsWith(moduleName, "node:") !== ts.shouldUseUriStyleNodeCoreModules(sourceFile, program)) {
                            return false;
                        }
                        return packageJsonFilter
                            ? packageJsonFilter.allowsImportingAmbientModule(info.moduleSymbol, getModuleSpecifierResolutionHost(info.isFromPackageJson))
                            : true;
                    }
                    return ts.isImportableFile(info.isFromPackageJson ? packageJsonAutoImportProvider : program, sourceFile, moduleFile, preferences, packageJsonFilter, getModuleSpecifierResolutionHost(info.isFromPackageJson), moduleSpecifierCache);
                }
            }
            function pushAutoImportSymbol(symbol, origin) {
                var symbolId = ts.getSymbolId(symbol);
                if (symbolToSortTextMap[symbolId] === Completions.SortText.GlobalsOrKeywords) {
                    // If an auto-importable symbol is available as a global, don't add the auto import
                    return;
                }
                symbolToOriginInfoMap[symbols.length] = origin;
                symbolToSortTextMap[symbolId] = importStatementCompletion ? Completions.SortText.LocationPriority : Completions.SortText.AutoImportSuggestions;
                symbols.push(symbol);
            }
            /* Mutates `symbols` and `symbolToOriginInfoMap`. */
            function collectObjectLiteralMethodSymbols(members, enclosingDeclaration) {
                // TODO: support JS files.
                if (ts.isInJSFile(location)) {
                    return;
                }
                members.forEach(function (member) {
                    if (!isObjectLiteralMethodSymbol(member)) {
                        return;
                    }
                    var displayName = getCompletionEntryDisplayNameForSymbol(member, ts.getEmitScriptTarget(compilerOptions),
                    /*origin*/ undefined, 0 /* CompletionKind.ObjectPropertyDeclaration */,
                    /*jsxIdentifierExpected*/ false);
                    if (!displayName) {
                        return;
                    }
                    var name = displayName.name;
                    var entryProps = getEntryForObjectLiteralMethodCompletion(member, name, enclosingDeclaration, program, host, compilerOptions, preferences, formatContext);
                    if (!entryProps) {
                        return;
                    }
                    var origin = __assign({ kind: 128 /* SymbolOriginInfoKind.ObjectLiteralMethod */ }, entryProps);
                    flags |= 32 /* CompletionInfoFlags.MayIncludeMethodSnippets */;
                    symbolToOriginInfoMap[symbols.length] = origin;
                    symbols.push(member);
                });
            }
            function isObjectLiteralMethodSymbol(symbol) {
                /*
                    For an object type
                    `type Foo = {
                        bar(x: number): void;
                        foo: (x: string) => string;
                    }`,
                    `bar` will have symbol flag `Method`,
                    `foo` will have symbol flag `Property`.
                */
                if (!(symbol.flags & (4 /* SymbolFlags.Property */ | 8192 /* SymbolFlags.Method */))) {
                    return false;
                }
                return true;
            }
            /**
             * Finds the first node that "embraces" the position, so that one may
             * accurately aggregate locals from the closest containing scope.
             */
            function getScopeNode(initialToken, position, sourceFile) {
                var scope = initialToken;
                while (scope && !ts.positionBelongsToNode(scope, position, sourceFile)) {
                    scope = scope.parent;
                }
                return scope;
            }
            function isCompletionListBlocker(contextToken) {
                var start = ts.timestamp();
                var result = isInStringOrRegularExpressionOrTemplateLiteral(contextToken) ||
                    isSolelyIdentifierDefinitionLocation(contextToken) ||
                    isDotOfNumericLiteral(contextToken) ||
                    isInJsxText(contextToken) ||
                    ts.isBigIntLiteral(contextToken);
                log("getCompletionsAtPosition: isCompletionListBlocker: " + (ts.timestamp() - start));
                return result;
            }
            function isInJsxText(contextToken) {
                if (contextToken.kind === 11 /* SyntaxKind.JsxText */) {
                    return true;
                }
                if (contextToken.kind === 31 /* SyntaxKind.GreaterThanToken */ && contextToken.parent) {
                    // <Component<string> /**/ />
                    // <Component<string> /**/ ><Component>
                    // - contextToken: GreaterThanToken (before cursor)
                    // - location: JsxSelfClosingElement or JsxOpeningElement
                    // - contextToken.parent === location
                    if (location === contextToken.parent && (location.kind === 283 /* SyntaxKind.JsxOpeningElement */ || location.kind === 282 /* SyntaxKind.JsxSelfClosingElement */)) {
                        return false;
                    }
                    if (contextToken.parent.kind === 283 /* SyntaxKind.JsxOpeningElement */) {
                        // <div>/**/
                        // - contextToken: GreaterThanToken (before cursor)
                        // - location: JSXElement
                        // - different parents (JSXOpeningElement, JSXElement)
                        return location.parent.kind !== 283 /* SyntaxKind.JsxOpeningElement */;
                    }
                    if (contextToken.parent.kind === 284 /* SyntaxKind.JsxClosingElement */ || contextToken.parent.kind === 282 /* SyntaxKind.JsxSelfClosingElement */) {
                        return !!contextToken.parent.parent && contextToken.parent.parent.kind === 281 /* SyntaxKind.JsxElement */;
                    }
                }
                return false;
            }
            function isNewIdentifierDefinitionLocation() {
                if (contextToken) {
                    var containingNodeKind = contextToken.parent.kind;
                    var tokenKind = keywordForNode(contextToken);
                    // Previous token may have been a keyword that was converted to an identifier.
                    switch (tokenKind) {
                        case 27 /* SyntaxKind.CommaToken */:
                            return containingNodeKind === 210 /* SyntaxKind.CallExpression */ // func( a, |
                                || containingNodeKind === 173 /* SyntaxKind.Constructor */ // constructor( a, |   /* public, protected, private keywords are allowed here, so show completion */
                                || containingNodeKind === 211 /* SyntaxKind.NewExpression */ // new C(a, |
                                || containingNodeKind === 206 /* SyntaxKind.ArrayLiteralExpression */ // [a, |
                                || containingNodeKind === 223 /* SyntaxKind.BinaryExpression */ // const x = (a, |
                                || containingNodeKind === 181 /* SyntaxKind.FunctionType */ // var x: (s: string, list|
                                || containingNodeKind === 207 /* SyntaxKind.ObjectLiteralExpression */; // const obj = { x, |
                        case 20 /* SyntaxKind.OpenParenToken */:
                            return containingNodeKind === 210 /* SyntaxKind.CallExpression */ // func( |
                                || containingNodeKind === 173 /* SyntaxKind.Constructor */ // constructor( |
                                || containingNodeKind === 211 /* SyntaxKind.NewExpression */ // new C(a|
                                || containingNodeKind === 214 /* SyntaxKind.ParenthesizedExpression */ // const x = (a|
                                || containingNodeKind === 193 /* SyntaxKind.ParenthesizedType */; // function F(pred: (a| /* this can become an arrow function, where 'a' is the argument */
                        case 22 /* SyntaxKind.OpenBracketToken */:
                            return containingNodeKind === 206 /* SyntaxKind.ArrayLiteralExpression */ // [ |
                                || containingNodeKind === 178 /* SyntaxKind.IndexSignature */ // [ | : string ]
                                || containingNodeKind === 164 /* SyntaxKind.ComputedPropertyName */; // [ |    /* this can become an index signature */
                        case 142 /* SyntaxKind.ModuleKeyword */: // module |
                        case 143 /* SyntaxKind.NamespaceKeyword */: // namespace |
                        case 100 /* SyntaxKind.ImportKeyword */: // import |
                            return true;
                        case 24 /* SyntaxKind.DotToken */:
                            return containingNodeKind === 264 /* SyntaxKind.ModuleDeclaration */; // module A.|
                        case 18 /* SyntaxKind.OpenBraceToken */:
                            return containingNodeKind === 260 /* SyntaxKind.ClassDeclaration */ // class A { |
                                || containingNodeKind === 207 /* SyntaxKind.ObjectLiteralExpression */; // const obj = { |
                        case 63 /* SyntaxKind.EqualsToken */:
                            return containingNodeKind === 257 /* SyntaxKind.VariableDeclaration */ // const x = a|
                                || containingNodeKind === 223 /* SyntaxKind.BinaryExpression */; // x = a|
                        case 15 /* SyntaxKind.TemplateHead */:
                            return containingNodeKind === 225 /* SyntaxKind.TemplateExpression */; // `aa ${|
                        case 16 /* SyntaxKind.TemplateMiddle */:
                            return containingNodeKind === 236 /* SyntaxKind.TemplateSpan */; // `aa ${10} dd ${|
                        case 132 /* SyntaxKind.AsyncKeyword */:
                            return containingNodeKind === 171 /* SyntaxKind.MethodDeclaration */ // const obj = { async c|()
                                || containingNodeKind === 300 /* SyntaxKind.ShorthandPropertyAssignment */; // const obj = { async c|
                        case 41 /* SyntaxKind.AsteriskToken */:
                            return containingNodeKind === 171 /* SyntaxKind.MethodDeclaration */; // const obj = { * c|
                    }
                    if (isClassMemberCompletionKeyword(tokenKind)) {
                        return true;
                    }
                }
                return false;
            }
            function isInStringOrRegularExpressionOrTemplateLiteral(contextToken) {
                // To be "in" one of these literals, the position has to be:
                //   1. entirely within the token text.
                //   2. at the end position of an unterminated token.
                //   3. at the end of a regular expression (due to trailing flags like '/foo/g').
                return (ts.isRegularExpressionLiteral(contextToken) || ts.isStringTextContainingNode(contextToken)) && (ts.rangeContainsPositionExclusive(ts.createTextRangeFromSpan(ts.createTextSpanFromNode(contextToken)), position) ||
                    position === contextToken.end && (!!contextToken.isUnterminated || ts.isRegularExpressionLiteral(contextToken)));
            }
            function tryGetObjectTypeLiteralInTypeArgumentCompletionSymbols() {
                var typeLiteralNode = tryGetTypeLiteralNode(contextToken);
                if (!typeLiteralNode)
                    return 0 /* GlobalsSearch.Continue */;
                var intersectionTypeNode = ts.isIntersectionTypeNode(typeLiteralNode.parent) ? typeLiteralNode.parent : undefined;
                var containerTypeNode = intersectionTypeNode || typeLiteralNode;
                var containerExpectedType = getConstraintOfTypeArgumentProperty(containerTypeNode, typeChecker);
                if (!containerExpectedType)
                    return 0 /* GlobalsSearch.Continue */;
                var containerActualType = typeChecker.getTypeFromTypeNode(containerTypeNode);
                var members = getPropertiesForCompletion(containerExpectedType, typeChecker);
                var existingMembers = getPropertiesForCompletion(containerActualType, typeChecker);
                var existingMemberEscapedNames = new ts.Set();
                existingMembers.forEach(function (s) { return existingMemberEscapedNames.add(s.escapedName); });
                symbols = ts.concatenate(symbols, ts.filter(members, function (s) { return !existingMemberEscapedNames.has(s.escapedName); }));
                completionKind = 0 /* CompletionKind.ObjectPropertyDeclaration */;
                isNewIdentifierLocation = true;
                return 1 /* GlobalsSearch.Success */;
            }
            /**
             * Aggregates relevant symbols for completion in object literals and object binding patterns.
             * Relevant symbols are stored in the captured 'symbols' variable.
             *
             * @returns true if 'symbols' was successfully populated; false otherwise.
             */
            function tryGetObjectLikeCompletionSymbols() {
                var symbolsStartIndex = symbols.length;
                var objectLikeContainer = tryGetObjectLikeCompletionContainer(contextToken);
                if (!objectLikeContainer)
                    return 0 /* GlobalsSearch.Continue */;
                // We're looking up possible property names from contextual/inferred/declared type.
                completionKind = 0 /* CompletionKind.ObjectPropertyDeclaration */;
                var typeMembers;
                var existingMembers;
                if (objectLikeContainer.kind === 207 /* SyntaxKind.ObjectLiteralExpression */) {
                    var instantiatedType = tryGetObjectLiteralContextualType(objectLikeContainer, typeChecker);
                    // Check completions for Object property value shorthand
                    if (instantiatedType === undefined) {
                        if (objectLikeContainer.flags & 33554432 /* NodeFlags.InWithStatement */) {
                            return 2 /* GlobalsSearch.Fail */;
                        }
                        isNonContextualObjectLiteral = true;
                        return 0 /* GlobalsSearch.Continue */;
                    }
                    var completionsType = typeChecker.getContextualType(objectLikeContainer, 4 /* ContextFlags.Completions */);
                    var hasStringIndexType = (completionsType || instantiatedType).getStringIndexType();
                    var hasNumberIndextype = (completionsType || instantiatedType).getNumberIndexType();
                    isNewIdentifierLocation = !!hasStringIndexType || !!hasNumberIndextype;
                    typeMembers = getPropertiesForObjectExpression(instantiatedType, completionsType, objectLikeContainer, typeChecker);
                    existingMembers = objectLikeContainer.properties;
                    if (typeMembers.length === 0) {
                        // Edge case: If NumberIndexType exists
                        if (!hasNumberIndextype) {
                            isNonContextualObjectLiteral = true;
                            return 0 /* GlobalsSearch.Continue */;
                        }
                    }
                }
                else {
                    ts.Debug.assert(objectLikeContainer.kind === 203 /* SyntaxKind.ObjectBindingPattern */);
                    // We are *only* completing on properties from the type being destructured.
                    isNewIdentifierLocation = false;
                    var rootDeclaration = ts.getRootDeclaration(objectLikeContainer.parent);
                    if (!ts.isVariableLike(rootDeclaration))
                        return ts.Debug.fail("Root declaration is not variable-like.");
                    // We don't want to complete using the type acquired by the shape
                    // of the binding pattern; we are only interested in types acquired
                    // through type declaration or inference.
                    // Also proceed if rootDeclaration is a parameter and if its containing function expression/arrow function is contextually typed -
                    // type of parameter will flow in from the contextual type of the function
                    var canGetType = ts.hasInitializer(rootDeclaration) || !!ts.getEffectiveTypeAnnotationNode(rootDeclaration) || rootDeclaration.parent.parent.kind === 247 /* SyntaxKind.ForOfStatement */;
                    if (!canGetType && rootDeclaration.kind === 166 /* SyntaxKind.Parameter */) {
                        if (ts.isExpression(rootDeclaration.parent)) {
                            canGetType = !!typeChecker.getContextualType(rootDeclaration.parent);
                        }
                        else if (rootDeclaration.parent.kind === 171 /* SyntaxKind.MethodDeclaration */ || rootDeclaration.parent.kind === 175 /* SyntaxKind.SetAccessor */) {
                            canGetType = ts.isExpression(rootDeclaration.parent.parent) && !!typeChecker.getContextualType(rootDeclaration.parent.parent);
                        }
                    }
                    if (canGetType) {
                        var typeForObject_1 = typeChecker.getTypeAtLocation(objectLikeContainer);
                        if (!typeForObject_1)
                            return 2 /* GlobalsSearch.Fail */;
                        typeMembers = typeChecker.getPropertiesOfType(typeForObject_1).filter(function (propertySymbol) {
                            return typeChecker.isPropertyAccessible(objectLikeContainer, /*isSuper*/ false, /*writing*/ false, typeForObject_1, propertySymbol);
                        });
                        existingMembers = objectLikeContainer.elements;
                    }
                }
                if (typeMembers && typeMembers.length > 0) {
                    // Add filtered items to the completion list
                    var filteredMembers = filterObjectMembersList(typeMembers, ts.Debug.checkDefined(existingMembers));
                    symbols = ts.concatenate(symbols, filteredMembers);
                    setSortTextToOptionalMember();
                    if (objectLikeContainer.kind === 207 /* SyntaxKind.ObjectLiteralExpression */
                        && preferences.includeCompletionsWithObjectLiteralMethodSnippets
                        && preferences.includeCompletionsWithInsertText) {
                        transformObjectLiteralMembersSortText(symbolsStartIndex);
                        collectObjectLiteralMethodSymbols(filteredMembers, objectLikeContainer);
                    }
                }
                return 1 /* GlobalsSearch.Success */;
            }
            /**
             * Aggregates relevant symbols for completion in import clauses and export clauses
             * whose declarations have a module specifier; for instance, symbols will be aggregated for
             *
             *      import { | } from "moduleName";
             *      export { a as foo, | } from "moduleName";
             *
             * but not for
             *
             *      export { | };
             *
             * Relevant symbols are stored in the captured 'symbols' variable.
             */
            function tryGetImportOrExportClauseCompletionSymbols() {
                if (!contextToken)
                    return 0 /* GlobalsSearch.Continue */;
                // `import { |` or `import { a as 0, | }` or `import { type | }`
                var namedImportsOrExports = contextToken.kind === 18 /* SyntaxKind.OpenBraceToken */ || contextToken.kind === 27 /* SyntaxKind.CommaToken */ ? ts.tryCast(contextToken.parent, ts.isNamedImportsOrExports) :
                    ts.isTypeKeywordTokenOrIdentifier(contextToken) ? ts.tryCast(contextToken.parent.parent, ts.isNamedImportsOrExports) : undefined;
                if (!namedImportsOrExports)
                    return 0 /* GlobalsSearch.Continue */;
                // We can at least offer `type` at `import { |`
                if (!ts.isTypeKeywordTokenOrIdentifier(contextToken)) {
                    keywordFilters = 8 /* KeywordCompletionFilters.TypeKeyword */;
                }
                // try to show exported member for imported/re-exported module
                var moduleSpecifier = (namedImportsOrExports.kind === 272 /* SyntaxKind.NamedImports */ ? namedImportsOrExports.parent.parent : namedImportsOrExports.parent).moduleSpecifier;
                if (!moduleSpecifier) {
                    isNewIdentifierLocation = true;
                    return namedImportsOrExports.kind === 272 /* SyntaxKind.NamedImports */ ? 2 /* GlobalsSearch.Fail */ : 0 /* GlobalsSearch.Continue */;
                }
                var moduleSpecifierSymbol = typeChecker.getSymbolAtLocation(moduleSpecifier); // TODO: GH#18217
                if (!moduleSpecifierSymbol) {
                    isNewIdentifierLocation = true;
                    return 2 /* GlobalsSearch.Fail */;
                }
                completionKind = 3 /* CompletionKind.MemberLike */;
                isNewIdentifierLocation = false;
                var exports = typeChecker.getExportsAndPropertiesOfModule(moduleSpecifierSymbol);
                var existing = new ts.Set(namedImportsOrExports.elements.filter(function (n) { return !isCurrentlyEditingNode(n); }).map(function (n) { return (n.propertyName || n.name).escapedText; }));
                var uniques = exports.filter(function (e) { return e.escapedName !== "default" /* InternalSymbolName.Default */ && !existing.has(e.escapedName); });
                symbols = ts.concatenate(symbols, uniques);
                if (!uniques.length) {
                    // If there's nothing else to import, don't offer `type` either
                    keywordFilters = 0 /* KeywordCompletionFilters.None */;
                }
                return 1 /* GlobalsSearch.Success */;
            }
            /**
             * Adds local declarations for completions in named exports:
             *
             *   export { | };
             *
             * Does not check for the absence of a module specifier (`export {} from "./other"`)
             * because `tryGetImportOrExportClauseCompletionSymbols` runs first and handles that,
             * preventing this function from running.
             */
            function tryGetLocalNamedExportCompletionSymbols() {
                var _a;
                var namedExports = contextToken && (contextToken.kind === 18 /* SyntaxKind.OpenBraceToken */ || contextToken.kind === 27 /* SyntaxKind.CommaToken */)
                    ? ts.tryCast(contextToken.parent, ts.isNamedExports)
                    : undefined;
                if (!namedExports) {
                    return 0 /* GlobalsSearch.Continue */;
                }
                var localsContainer = ts.findAncestor(namedExports, ts.or(ts.isSourceFile, ts.isModuleDeclaration));
                completionKind = 5 /* CompletionKind.None */;
                isNewIdentifierLocation = false;
                (_a = localsContainer.locals) === null || _a === void 0 ? void 0 : _a.forEach(function (symbol, name) {
                    var _a, _b;
                    symbols.push(symbol);
                    if ((_b = (_a = localsContainer.symbol) === null || _a === void 0 ? void 0 : _a.exports) === null || _b === void 0 ? void 0 : _b.has(name)) {
                        symbolToSortTextMap[ts.getSymbolId(symbol)] = Completions.SortText.OptionalMember;
                    }
                });
                return 1 /* GlobalsSearch.Success */;
            }
            /**
             * Aggregates relevant symbols for completion in class declaration
             * Relevant symbols are stored in the captured 'symbols' variable.
             */
            function tryGetClassLikeCompletionSymbols() {
                var decl = tryGetObjectTypeDeclarationCompletionContainer(sourceFile, contextToken, location, position);
                if (!decl)
                    return 0 /* GlobalsSearch.Continue */;
                // We're looking up possible property names from parent type.
                completionKind = 3 /* CompletionKind.MemberLike */;
                // Declaring new property/method/accessor
                isNewIdentifierLocation = true;
                keywordFilters = contextToken.kind === 41 /* SyntaxKind.AsteriskToken */ ? 0 /* KeywordCompletionFilters.None */ :
                    ts.isClassLike(decl) ? 2 /* KeywordCompletionFilters.ClassElementKeywords */ : 3 /* KeywordCompletionFilters.InterfaceElementKeywords */;
                // If you're in an interface you don't want to repeat things from super-interface. So just stop here.
                if (!ts.isClassLike(decl))
                    return 1 /* GlobalsSearch.Success */;
                var classElement = contextToken.kind === 26 /* SyntaxKind.SemicolonToken */ ? contextToken.parent.parent : contextToken.parent;
                var classElementModifierFlags = ts.isClassElement(classElement) ? ts.getEffectiveModifierFlags(classElement) : 0 /* ModifierFlags.None */;
                // If this is context token is not something we are editing now, consider if this would lead to be modifier
                if (contextToken.kind === 79 /* SyntaxKind.Identifier */ && !isCurrentlyEditingNode(contextToken)) {
                    switch (contextToken.getText()) {
                        case "private":
                            classElementModifierFlags = classElementModifierFlags | 8 /* ModifierFlags.Private */;
                            break;
                        case "static":
                            classElementModifierFlags = classElementModifierFlags | 32 /* ModifierFlags.Static */;
                            break;
                        case "override":
                            classElementModifierFlags = classElementModifierFlags | 16384 /* ModifierFlags.Override */;
                            break;
                    }
                }
                if (ts.isClassStaticBlockDeclaration(classElement)) {
                    classElementModifierFlags |= 32 /* ModifierFlags.Static */;
                }
                // No member list for private methods
                if (!(classElementModifierFlags & 8 /* ModifierFlags.Private */)) {
                    // List of property symbols of base type that are not private and already implemented
                    var baseTypeNodes = ts.isClassLike(decl) && classElementModifierFlags & 16384 /* ModifierFlags.Override */ ? ts.singleElementArray(ts.getEffectiveBaseTypeNode(decl)) : ts.getAllSuperTypeNodes(decl);
                    var baseSymbols = ts.flatMap(baseTypeNodes, function (baseTypeNode) {
                        var type = typeChecker.getTypeAtLocation(baseTypeNode);
                        return classElementModifierFlags & 32 /* ModifierFlags.Static */ ?
                            (type === null || type === void 0 ? void 0 : type.symbol) && typeChecker.getPropertiesOfType(typeChecker.getTypeOfSymbolAtLocation(type.symbol, decl)) :
                            type && typeChecker.getPropertiesOfType(type);
                    });
                    symbols = ts.concatenate(symbols, filterClassMembersList(baseSymbols, decl.members, classElementModifierFlags));
                }
                return 1 /* GlobalsSearch.Success */;
            }
            function isConstructorParameterCompletion(node) {
                return !!node.parent && ts.isParameter(node.parent) && ts.isConstructorDeclaration(node.parent.parent)
                    && (ts.isParameterPropertyModifier(node.kind) || ts.isDeclarationName(node));
            }
            /**
             * Returns the immediate owning class declaration of a context token,
             * on the condition that one exists and that the context implies completion should be given.
             */
            function tryGetConstructorLikeCompletionContainer(contextToken) {
                if (contextToken) {
                    var parent = contextToken.parent;
                    switch (contextToken.kind) {
                        case 20 /* SyntaxKind.OpenParenToken */:
                        case 27 /* SyntaxKind.CommaToken */:
                            return ts.isConstructorDeclaration(contextToken.parent) ? contextToken.parent : undefined;
                        default:
                            if (isConstructorParameterCompletion(contextToken)) {
                                return parent.parent;
                            }
                    }
                }
                return undefined;
            }
            function tryGetFunctionLikeBodyCompletionContainer(contextToken) {
                if (contextToken) {
                    var prev_1;
                    var container = ts.findAncestor(contextToken.parent, function (node) {
                        if (ts.isClassLike(node)) {
                            return "quit";
                        }
                        if (ts.isFunctionLikeDeclaration(node) && prev_1 === node.body) {
                            return true;
                        }
                        prev_1 = node;
                        return false;
                    });
                    return container && container;
                }
            }
            function tryGetContainingJsxElement(contextToken) {
                if (contextToken) {
                    var parent = contextToken.parent;
                    switch (contextToken.kind) {
                        case 31 /* SyntaxKind.GreaterThanToken */: // End of a type argument list
                        case 30 /* SyntaxKind.LessThanSlashToken */:
                        case 43 /* SyntaxKind.SlashToken */:
                        case 79 /* SyntaxKind.Identifier */:
                        case 208 /* SyntaxKind.PropertyAccessExpression */:
                        case 289 /* SyntaxKind.JsxAttributes */:
                        case 288 /* SyntaxKind.JsxAttribute */:
                        case 290 /* SyntaxKind.JsxSpreadAttribute */:
                            if (parent && (parent.kind === 282 /* SyntaxKind.JsxSelfClosingElement */ || parent.kind === 283 /* SyntaxKind.JsxOpeningElement */)) {
                                if (contextToken.kind === 31 /* SyntaxKind.GreaterThanToken */) {
                                    var precedingToken = ts.findPrecedingToken(contextToken.pos, sourceFile, /*startNode*/ undefined);
                                    if (!parent.typeArguments || (precedingToken && precedingToken.kind === 43 /* SyntaxKind.SlashToken */))
                                        break;
                                }
                                return parent;
                            }
                            else if (parent.kind === 288 /* SyntaxKind.JsxAttribute */) {
                                // Currently we parse JsxOpeningLikeElement as:
                                //      JsxOpeningLikeElement
                                //          attributes: JsxAttributes
                                //             properties: NodeArray<JsxAttributeLike>
                                return parent.parent.parent;
                            }
                            break;
                        // The context token is the closing } or " of an attribute, which means
                        // its parent is a JsxExpression, whose parent is a JsxAttribute,
                        // whose parent is a JsxOpeningLikeElement
                        case 10 /* SyntaxKind.StringLiteral */:
                            if (parent && ((parent.kind === 288 /* SyntaxKind.JsxAttribute */) || (parent.kind === 290 /* SyntaxKind.JsxSpreadAttribute */))) {
                                // Currently we parse JsxOpeningLikeElement as:
                                //      JsxOpeningLikeElement
                                //          attributes: JsxAttributes
                                //             properties: NodeArray<JsxAttributeLike>
                                return parent.parent.parent;
                            }
                            break;
                        case 19 /* SyntaxKind.CloseBraceToken */:
                            if (parent &&
                                parent.kind === 291 /* SyntaxKind.JsxExpression */ &&
                                parent.parent && parent.parent.kind === 288 /* SyntaxKind.JsxAttribute */) {
                                // Currently we parse JsxOpeningLikeElement as:
                                //      JsxOpeningLikeElement
                                //          attributes: JsxAttributes
                                //             properties: NodeArray<JsxAttributeLike>
                                //                  each JsxAttribute can have initializer as JsxExpression
                                return parent.parent.parent.parent;
                            }
                            if (parent && parent.kind === 290 /* SyntaxKind.JsxSpreadAttribute */) {
                                // Currently we parse JsxOpeningLikeElement as:
                                //      JsxOpeningLikeElement
                                //          attributes: JsxAttributes
                                //             properties: NodeArray<JsxAttributeLike>
                                return parent.parent.parent;
                            }
                            break;
                    }
                }
                return undefined;
            }
            /**
             * @returns true if we are certain that the currently edited location must define a new location; false otherwise.
             */
            function isSolelyIdentifierDefinitionLocation(contextToken) {
                var parent = contextToken.parent;
                var containingNodeKind = parent.kind;
                switch (contextToken.kind) {
                    case 27 /* SyntaxKind.CommaToken */:
                        return containingNodeKind === 257 /* SyntaxKind.VariableDeclaration */ ||
                            isVariableDeclarationListButNotTypeArgument(contextToken) ||
                            containingNodeKind === 240 /* SyntaxKind.VariableStatement */ ||
                            containingNodeKind === 263 /* SyntaxKind.EnumDeclaration */ || // enum a { foo, |
                            isFunctionLikeButNotConstructor(containingNodeKind) ||
                            containingNodeKind === 261 /* SyntaxKind.InterfaceDeclaration */ || // interface A<T, |
                            containingNodeKind === 204 /* SyntaxKind.ArrayBindingPattern */ || // var [x, y|
                            containingNodeKind === 262 /* SyntaxKind.TypeAliasDeclaration */ || // type Map, K, |
                            // class A<T, |
                            // var C = class D<T, |
                            (ts.isClassLike(parent) &&
                                !!parent.typeParameters &&
                                parent.typeParameters.end >= contextToken.pos);
                    case 24 /* SyntaxKind.DotToken */:
                        return containingNodeKind === 204 /* SyntaxKind.ArrayBindingPattern */; // var [.|
                    case 58 /* SyntaxKind.ColonToken */:
                        return containingNodeKind === 205 /* SyntaxKind.BindingElement */; // var {x :html|
                    case 22 /* SyntaxKind.OpenBracketToken */:
                        return containingNodeKind === 204 /* SyntaxKind.ArrayBindingPattern */; // var [x|
                    case 20 /* SyntaxKind.OpenParenToken */:
                        return containingNodeKind === 295 /* SyntaxKind.CatchClause */ ||
                            isFunctionLikeButNotConstructor(containingNodeKind);
                    case 18 /* SyntaxKind.OpenBraceToken */:
                        return containingNodeKind === 263 /* SyntaxKind.EnumDeclaration */; // enum a { |
                    case 29 /* SyntaxKind.LessThanToken */:
                        return containingNodeKind === 260 /* SyntaxKind.ClassDeclaration */ || // class A< |
                            containingNodeKind === 228 /* SyntaxKind.ClassExpression */ || // var C = class D< |
                            containingNodeKind === 261 /* SyntaxKind.InterfaceDeclaration */ || // interface A< |
                            containingNodeKind === 262 /* SyntaxKind.TypeAliasDeclaration */ || // type List< |
                            ts.isFunctionLikeKind(containingNodeKind);
                    case 124 /* SyntaxKind.StaticKeyword */:
                        return containingNodeKind === 169 /* SyntaxKind.PropertyDeclaration */ && !ts.isClassLike(parent.parent);
                    case 25 /* SyntaxKind.DotDotDotToken */:
                        return containingNodeKind === 166 /* SyntaxKind.Parameter */ ||
                            (!!parent.parent && parent.parent.kind === 204 /* SyntaxKind.ArrayBindingPattern */); // var [...z|
                    case 123 /* SyntaxKind.PublicKeyword */:
                    case 121 /* SyntaxKind.PrivateKeyword */:
                    case 122 /* SyntaxKind.ProtectedKeyword */:
                        return containingNodeKind === 166 /* SyntaxKind.Parameter */ && !ts.isConstructorDeclaration(parent.parent);
                    case 128 /* SyntaxKind.AsKeyword */:
                        return containingNodeKind === 273 /* SyntaxKind.ImportSpecifier */ ||
                            containingNodeKind === 278 /* SyntaxKind.ExportSpecifier */ ||
                            containingNodeKind === 271 /* SyntaxKind.NamespaceImport */;
                    case 137 /* SyntaxKind.GetKeyword */:
                    case 151 /* SyntaxKind.SetKeyword */:
                        return !isFromObjectTypeDeclaration(contextToken);
                    case 79 /* SyntaxKind.Identifier */:
                        if (containingNodeKind === 273 /* SyntaxKind.ImportSpecifier */ &&
                            contextToken === parent.name &&
                            contextToken.text === "type") {
                            // import { type | }
                            return false;
                        }
                        break;
                    case 84 /* SyntaxKind.ClassKeyword */:
                    case 92 /* SyntaxKind.EnumKeyword */:
                    case 118 /* SyntaxKind.InterfaceKeyword */:
                    case 98 /* SyntaxKind.FunctionKeyword */:
                    case 113 /* SyntaxKind.VarKeyword */:
                    case 100 /* SyntaxKind.ImportKeyword */:
                    case 119 /* SyntaxKind.LetKeyword */:
                    case 85 /* SyntaxKind.ConstKeyword */:
                    case 138 /* SyntaxKind.InferKeyword */:
                        return true;
                    case 154 /* SyntaxKind.TypeKeyword */:
                        // import { type foo| }
                        return containingNodeKind !== 273 /* SyntaxKind.ImportSpecifier */;
                    case 41 /* SyntaxKind.AsteriskToken */:
                        return ts.isFunctionLike(contextToken.parent) && !ts.isMethodDeclaration(contextToken.parent);
                }
                // If the previous token is keyword corresponding to class member completion keyword
                // there will be completion available here
                if (isClassMemberCompletionKeyword(keywordForNode(contextToken)) && isFromObjectTypeDeclaration(contextToken)) {
                    return false;
                }
                if (isConstructorParameterCompletion(contextToken)) {
                    // constructor parameter completion is available only if
                    // - its modifier of the constructor parameter or
                    // - its name of the parameter and not being edited
                    // eg. constructor(a |<- this shouldnt show completion
                    if (!ts.isIdentifier(contextToken) ||
                        ts.isParameterPropertyModifier(keywordForNode(contextToken)) ||
                        isCurrentlyEditingNode(contextToken)) {
                        return false;
                    }
                }
                // Previous token may have been a keyword that was converted to an identifier.
                switch (keywordForNode(contextToken)) {
                    case 126 /* SyntaxKind.AbstractKeyword */:
                    case 84 /* SyntaxKind.ClassKeyword */:
                    case 85 /* SyntaxKind.ConstKeyword */:
                    case 136 /* SyntaxKind.DeclareKeyword */:
                    case 92 /* SyntaxKind.EnumKeyword */:
                    case 98 /* SyntaxKind.FunctionKeyword */:
                    case 118 /* SyntaxKind.InterfaceKeyword */:
                    case 119 /* SyntaxKind.LetKeyword */:
                    case 121 /* SyntaxKind.PrivateKeyword */:
                    case 122 /* SyntaxKind.ProtectedKeyword */:
                    case 123 /* SyntaxKind.PublicKeyword */:
                    case 124 /* SyntaxKind.StaticKeyword */:
                    case 113 /* SyntaxKind.VarKeyword */:
                        return true;
                    case 132 /* SyntaxKind.AsyncKeyword */:
                        return ts.isPropertyDeclaration(contextToken.parent);
                }
                // If we are inside a class declaration, and `constructor` is totally not present,
                // but we request a completion manually at a whitespace...
                var ancestorClassLike = ts.findAncestor(contextToken.parent, ts.isClassLike);
                if (ancestorClassLike && contextToken === previousToken && isPreviousPropertyDeclarationTerminated(contextToken, position)) {
                    return false; // Don't block completions.
                }
                var ancestorPropertyDeclaraion = ts.getAncestor(contextToken.parent, 169 /* SyntaxKind.PropertyDeclaration */);
                // If we are inside a class declaration and typing `constructor` after property declaration...
                if (ancestorPropertyDeclaraion
                    && contextToken !== previousToken
                    && ts.isClassLike(previousToken.parent.parent)
                    // And the cursor is at the token...
                    && position <= previousToken.end) {
                    // If we are sure that the previous property declaration is terminated according to newline or semicolon...
                    if (isPreviousPropertyDeclarationTerminated(contextToken, previousToken.end)) {
                        return false; // Don't block completions.
                    }
                    else if (contextToken.kind !== 63 /* SyntaxKind.EqualsToken */
                        // Should not block: `class C { blah = c/**/ }`
                        // But should block: `class C { blah = somewhat c/**/ }` and `class C { blah: SomeType c/**/ }`
                        && (ts.isInitializedProperty(ancestorPropertyDeclaraion)
                            || ts.hasType(ancestorPropertyDeclaraion))) {
                        return true;
                    }
                }
                return ts.isDeclarationName(contextToken)
                    && !ts.isShorthandPropertyAssignment(contextToken.parent)
                    && !ts.isJsxAttribute(contextToken.parent)
                    // Don't block completions if we're in `class C /**/`, because we're *past* the end of the identifier and might want to complete `extends`.
                    // If `contextToken !== previousToken`, this is `class C ex/**/`.
                    && !(ts.isClassLike(contextToken.parent) && (contextToken !== previousToken || position > previousToken.end));
            }
            function isPreviousPropertyDeclarationTerminated(contextToken, position) {
                return contextToken.kind !== 63 /* SyntaxKind.EqualsToken */ &&
                    (contextToken.kind === 26 /* SyntaxKind.SemicolonToken */
                        || !ts.positionsAreOnSameLine(contextToken.end, position, sourceFile));
            }
            function isFunctionLikeButNotConstructor(kind) {
                return ts.isFunctionLikeKind(kind) && kind !== 173 /* SyntaxKind.Constructor */;
            }
            function isDotOfNumericLiteral(contextToken) {
                if (contextToken.kind === 8 /* SyntaxKind.NumericLiteral */) {
                    var text = contextToken.getFullText();
                    return text.charAt(text.length - 1) === ".";
                }
                return false;
            }
            function isVariableDeclarationListButNotTypeArgument(node) {
                return node.parent.kind === 258 /* SyntaxKind.VariableDeclarationList */
                    && !ts.isPossiblyTypeArgumentPosition(node, sourceFile, typeChecker);
            }
            /**
             * Filters out completion suggestions for named imports or exports.
             *
             * @returns Symbols to be suggested in an object binding pattern or object literal expression, barring those whose declarations
             *          do not occur at the current position and have not otherwise been typed.
             */
            function filterObjectMembersList(contextualMemberSymbols, existingMembers) {
                if (existingMembers.length === 0) {
                    return contextualMemberSymbols;
                }
                var membersDeclaredBySpreadAssignment = new ts.Set();
                var existingMemberNames = new ts.Set();
                for (var _i = 0, existingMembers_1 = existingMembers; _i < existingMembers_1.length; _i++) {
                    var m = existingMembers_1[_i];
                    // Ignore omitted expressions for missing members
                    if (m.kind !== 299 /* SyntaxKind.PropertyAssignment */ &&
                        m.kind !== 300 /* SyntaxKind.ShorthandPropertyAssignment */ &&
                        m.kind !== 205 /* SyntaxKind.BindingElement */ &&
                        m.kind !== 171 /* SyntaxKind.MethodDeclaration */ &&
                        m.kind !== 174 /* SyntaxKind.GetAccessor */ &&
                        m.kind !== 175 /* SyntaxKind.SetAccessor */ &&
                        m.kind !== 301 /* SyntaxKind.SpreadAssignment */) {
                        continue;
                    }
                    // If this is the current item we are editing right now, do not filter it out
                    if (isCurrentlyEditingNode(m)) {
                        continue;
                    }
                    var existingName = void 0;
                    if (ts.isSpreadAssignment(m)) {
                        setMembersDeclaredBySpreadAssignment(m, membersDeclaredBySpreadAssignment);
                    }
                    else if (ts.isBindingElement(m) && m.propertyName) {
                        // include only identifiers in completion list
                        if (m.propertyName.kind === 79 /* SyntaxKind.Identifier */) {
                            existingName = m.propertyName.escapedText;
                        }
                    }
                    else {
                        // TODO: Account for computed property name
                        // NOTE: if one only performs this step when m.name is an identifier,
                        // things like '__proto__' are not filtered out.
                        var name = ts.getNameOfDeclaration(m);
                        existingName = name && ts.isPropertyNameLiteral(name) ? ts.getEscapedTextOfIdentifierOrLiteral(name) : undefined;
                    }
                    if (existingName !== undefined) {
                        existingMemberNames.add(existingName);
                    }
                }
                var filteredSymbols = contextualMemberSymbols.filter(function (m) { return !existingMemberNames.has(m.escapedName); });
                setSortTextToMemberDeclaredBySpreadAssignment(membersDeclaredBySpreadAssignment, filteredSymbols);
                return filteredSymbols;
            }
            function setMembersDeclaredBySpreadAssignment(declaration, membersDeclaredBySpreadAssignment) {
                var expression = declaration.expression;
                var symbol = typeChecker.getSymbolAtLocation(expression);
                var type = symbol && typeChecker.getTypeOfSymbolAtLocation(symbol, expression);
                var properties = type && type.properties;
                if (properties) {
                    properties.forEach(function (property) {
                        membersDeclaredBySpreadAssignment.add(property.name);
                    });
                }
            }
            // Set SortText to OptionalMember if it is an optional member
            function setSortTextToOptionalMember() {
                symbols.forEach(function (m) {
                    var _a;
                    if (m.flags & 16777216 /* SymbolFlags.Optional */) {
                        var symbolId = ts.getSymbolId(m);
                        symbolToSortTextMap[symbolId] = (_a = symbolToSortTextMap[symbolId]) !== null && _a !== void 0 ? _a : Completions.SortText.OptionalMember;
                    }
                });
            }
            // Set SortText to MemberDeclaredBySpreadAssignment if it is fulfilled by spread assignment
            function setSortTextToMemberDeclaredBySpreadAssignment(membersDeclaredBySpreadAssignment, contextualMemberSymbols) {
                if (membersDeclaredBySpreadAssignment.size === 0) {
                    return;
                }
                for (var _i = 0, contextualMemberSymbols_1 = contextualMemberSymbols; _i < contextualMemberSymbols_1.length; _i++) {
                    var contextualMemberSymbol = contextualMemberSymbols_1[_i];
                    if (membersDeclaredBySpreadAssignment.has(contextualMemberSymbol.name)) {
                        symbolToSortTextMap[ts.getSymbolId(contextualMemberSymbol)] = Completions.SortText.MemberDeclaredBySpreadAssignment;
                    }
                }
            }
            function transformObjectLiteralMembersSortText(start) {
                var _a;
                for (var i = start; i < symbols.length; i++) {
                    var symbol = symbols[i];
                    var symbolId = ts.getSymbolId(symbol);
                    var origin = symbolToOriginInfoMap === null || symbolToOriginInfoMap === void 0 ? void 0 : symbolToOriginInfoMap[i];
                    var target = ts.getEmitScriptTarget(compilerOptions);
                    var displayName = getCompletionEntryDisplayNameForSymbol(symbol, target, origin, 0 /* CompletionKind.ObjectPropertyDeclaration */,
                    /*jsxIdentifierExpected*/ false);
                    if (displayName) {
                        var originalSortText = (_a = symbolToSortTextMap[symbolId]) !== null && _a !== void 0 ? _a : Completions.SortText.LocationPriority;
                        var name = displayName.name;
                        symbolToSortTextMap[symbolId] = Completions.SortText.ObjectLiteralProperty(originalSortText, name);
                    }
                }
            }
            /**
             * Filters out completion suggestions for class elements.
             *
             * @returns Symbols to be suggested in an class element depending on existing memebers and symbol flags
             */
            function filterClassMembersList(baseSymbols, existingMembers, currentClassElementModifierFlags) {
                var existingMemberNames = new ts.Set();
                for (var _i = 0, existingMembers_2 = existingMembers; _i < existingMembers_2.length; _i++) {
                    var m = existingMembers_2[_i];
                    // Ignore omitted expressions for missing members
                    if (m.kind !== 169 /* SyntaxKind.PropertyDeclaration */ &&
                        m.kind !== 171 /* SyntaxKind.MethodDeclaration */ &&
                        m.kind !== 174 /* SyntaxKind.GetAccessor */ &&
                        m.kind !== 175 /* SyntaxKind.SetAccessor */) {
                        continue;
                    }
                    // If this is the current item we are editing right now, do not filter it out
                    if (isCurrentlyEditingNode(m)) {
                        continue;
                    }
                    // Dont filter member even if the name matches if it is declared private in the list
                    if (ts.hasEffectiveModifier(m, 8 /* ModifierFlags.Private */)) {
                        continue;
                    }
                    // do not filter it out if the static presence doesnt match
                    if (ts.isStatic(m) !== !!(currentClassElementModifierFlags & 32 /* ModifierFlags.Static */)) {
                        continue;
                    }
                    var existingName = ts.getPropertyNameForPropertyNameNode(m.name);
                    if (existingName) {
                        existingMemberNames.add(existingName);
                    }
                }
                return baseSymbols.filter(function (propertySymbol) {
                    return !existingMemberNames.has(propertySymbol.escapedName) &&
                        !!propertySymbol.declarations &&
                        !(ts.getDeclarationModifierFlagsFromSymbol(propertySymbol) & 8 /* ModifierFlags.Private */) &&
                        !(propertySymbol.valueDeclaration && ts.isPrivateIdentifierClassElementDeclaration(propertySymbol.valueDeclaration));
                });
            }
            /**
             * Filters out completion suggestions from 'symbols' according to existing JSX attributes.
             *
             * @returns Symbols to be suggested in a JSX element, barring those whose attributes
             *          do not occur at the current position and have not otherwise been typed.
             */
            function filterJsxAttributes(symbols, attributes) {
                var seenNames = new ts.Set();
                var membersDeclaredBySpreadAssignment = new ts.Set();
                for (var _i = 0, attributes_1 = attributes; _i < attributes_1.length; _i++) {
                    var attr = attributes_1[_i];
                    // If this is the current item we are editing right now, do not filter it out
                    if (isCurrentlyEditingNode(attr)) {
                        continue;
                    }
                    if (attr.kind === 288 /* SyntaxKind.JsxAttribute */) {
                        seenNames.add(attr.name.escapedText);
                    }
                    else if (ts.isJsxSpreadAttribute(attr)) {
                        setMembersDeclaredBySpreadAssignment(attr, membersDeclaredBySpreadAssignment);
                    }
                }
                var filteredSymbols = symbols.filter(function (a) { return !seenNames.has(a.escapedName); });
                setSortTextToMemberDeclaredBySpreadAssignment(membersDeclaredBySpreadAssignment, filteredSymbols);
                return filteredSymbols;
            }
            function isCurrentlyEditingNode(node) {
                return node.getStart(sourceFile) <= position && position <= node.getEnd();
            }
        }
        /**
         * Returns the immediate owning object literal or binding pattern of a context token,
         * on the condition that one exists and that the context implies completion should be given.
         */
        function tryGetObjectLikeCompletionContainer(contextToken) {
            if (contextToken) {
                var parent = contextToken.parent;
                switch (contextToken.kind) {
                    case 18 /* SyntaxKind.OpenBraceToken */: // const x = { |
                    case 27 /* SyntaxKind.CommaToken */: // const x = { a: 0, |
                        if (ts.isObjectLiteralExpression(parent) || ts.isObjectBindingPattern(parent)) {
                            return parent;
                        }
                        break;
                    case 41 /* SyntaxKind.AsteriskToken */:
                        return ts.isMethodDeclaration(parent) ? ts.tryCast(parent.parent, ts.isObjectLiteralExpression) : undefined;
                    case 79 /* SyntaxKind.Identifier */:
                        return contextToken.text === "async" && ts.isShorthandPropertyAssignment(contextToken.parent)
                            ? contextToken.parent.parent : undefined;
                }
            }
            return undefined;
        }
        function getRelevantTokens(position, sourceFile) {
            var previousToken = ts.findPrecedingToken(position, sourceFile);
            if (previousToken && position <= previousToken.end && (ts.isMemberName(previousToken) || ts.isKeyword(previousToken.kind))) {
                var contextToken = ts.findPrecedingToken(previousToken.getFullStart(), sourceFile, /*startNode*/ undefined); // TODO: GH#18217
                return { contextToken: contextToken, previousToken: previousToken };
            }
            return { contextToken: previousToken, previousToken: previousToken };
        }
        function getAutoImportSymbolFromCompletionEntryData(name, data, program, host) {
            var containingProgram = data.isPackageJsonImport ? host.getPackageJsonAutoImportProvider() : program;
            var checker = containingProgram.getTypeChecker();
            var moduleSymbol = data.ambientModuleName ? checker.tryFindAmbientModule(data.ambientModuleName) :
                data.fileName ? checker.getMergedSymbol(ts.Debug.checkDefined(containingProgram.getSourceFile(data.fileName)).symbol) :
                    undefined;
            if (!moduleSymbol)
                return undefined;
            var symbol = data.exportName === "export=" /* InternalSymbolName.ExportEquals */
                ? checker.resolveExternalModuleSymbol(moduleSymbol)
                : checker.tryGetMemberInModuleExportsAndProperties(data.exportName, moduleSymbol);
            if (!symbol)
                return undefined;
            var isDefaultExport = data.exportName === "default" /* InternalSymbolName.Default */;
            symbol = isDefaultExport && ts.getLocalSymbolForExportDefault(symbol) || symbol;
            return { symbol: symbol, origin: completionEntryDataToSymbolOriginInfo(data, name, moduleSymbol) };
        }
        function getCompletionEntryDisplayNameForSymbol(symbol, target, origin, kind, jsxIdentifierExpected) {
            var name = originIncludesSymbolName(origin) ? origin.symbolName : symbol.name;
            if (name === undefined
                // If the symbol is external module, don't show it in the completion list
                // (i.e declare module "http" { const x; } | // <= request completion here, "http" should not be there)
                || symbol.flags & 1536 /* SymbolFlags.Module */ && ts.isSingleOrDoubleQuote(name.charCodeAt(0))
                // If the symbol is the internal name of an ES symbol, it is not a valid entry. Internal names for ES symbols start with "__@"
                || ts.isKnownSymbol(symbol)) {
                return undefined;
            }
            var validNameResult = { name: name, needsConvertPropertyAccess: false };
            if (ts.isIdentifierText(name, target, jsxIdentifierExpected ? 1 /* LanguageVariant.JSX */ : 0 /* LanguageVariant.Standard */) || symbol.valueDeclaration && ts.isPrivateIdentifierClassElementDeclaration(symbol.valueDeclaration)) {
                return validNameResult;
            }
            switch (kind) {
                case 3 /* CompletionKind.MemberLike */:
                    return undefined;
                case 0 /* CompletionKind.ObjectPropertyDeclaration */:
                    // TODO: GH#18169
                    return { name: JSON.stringify(name), needsConvertPropertyAccess: false };
                case 2 /* CompletionKind.PropertyAccess */:
                case 1 /* CompletionKind.Global */: // For a 'this.' completion it will be in a global context, but may have a non-identifier name.
                    // Don't add a completion for a name starting with a space. See https://github.com/Microsoft/TypeScript/pull/20547
                    return name.charCodeAt(0) === 32 /* CharacterCodes.space */ ? undefined : { name: name, needsConvertPropertyAccess: true };
                case 5 /* CompletionKind.None */:
                case 4 /* CompletionKind.String */:
                    return validNameResult;
                default:
                    ts.Debug.assertNever(kind);
            }
        }
        // A cache of completion entries for keywords, these do not change between sessions
        var _keywordCompletions = [];
        var allKeywordsCompletions = ts.memoize(function () {
            var res = [];
            for (var i = 81 /* SyntaxKind.FirstKeyword */; i <= 162 /* SyntaxKind.LastKeyword */; i++) {
                res.push({
                    name: ts.tokenToString(i),
                    kind: "keyword" /* ScriptElementKind.keyword */,
                    kindModifiers: "" /* ScriptElementKindModifier.none */,
                    sortText: Completions.SortText.GlobalsOrKeywords
                });
            }
            return res;
        });
        function getKeywordCompletions(keywordFilter, filterOutTsOnlyKeywords) {
            if (!filterOutTsOnlyKeywords)
                return getTypescriptKeywordCompletions(keywordFilter);
            var index = keywordFilter + 8 /* KeywordCompletionFilters.Last */ + 1;
            return _keywordCompletions[index] ||
                (_keywordCompletions[index] = getTypescriptKeywordCompletions(keywordFilter)
                    .filter(function (entry) { return !isTypeScriptOnlyKeyword(ts.stringToToken(entry.name)); }));
        }
        function getTypescriptKeywordCompletions(keywordFilter) {
            return _keywordCompletions[keywordFilter] || (_keywordCompletions[keywordFilter] = allKeywordsCompletions().filter(function (entry) {
                var kind = ts.stringToToken(entry.name);
                switch (keywordFilter) {
                    case 0 /* KeywordCompletionFilters.None */:
                        return false;
                    case 1 /* KeywordCompletionFilters.All */:
                        return isFunctionLikeBodyKeyword(kind)
                            || kind === 136 /* SyntaxKind.DeclareKeyword */
                            || kind === 142 /* SyntaxKind.ModuleKeyword */
                            || kind === 154 /* SyntaxKind.TypeKeyword */
                            || kind === 143 /* SyntaxKind.NamespaceKeyword */
                            || kind === 126 /* SyntaxKind.AbstractKeyword */
                            || ts.isTypeKeyword(kind) && kind !== 155 /* SyntaxKind.UndefinedKeyword */;
                    case 5 /* KeywordCompletionFilters.FunctionLikeBodyKeywords */:
                        return isFunctionLikeBodyKeyword(kind);
                    case 2 /* KeywordCompletionFilters.ClassElementKeywords */:
                        return isClassMemberCompletionKeyword(kind);
                    case 3 /* KeywordCompletionFilters.InterfaceElementKeywords */:
                        return isInterfaceOrTypeLiteralCompletionKeyword(kind);
                    case 4 /* KeywordCompletionFilters.ConstructorParameterKeywords */:
                        return ts.isParameterPropertyModifier(kind);
                    case 6 /* KeywordCompletionFilters.TypeAssertionKeywords */:
                        return ts.isTypeKeyword(kind) || kind === 85 /* SyntaxKind.ConstKeyword */;
                    case 7 /* KeywordCompletionFilters.TypeKeywords */:
                        return ts.isTypeKeyword(kind);
                    case 8 /* KeywordCompletionFilters.TypeKeyword */:
                        return kind === 154 /* SyntaxKind.TypeKeyword */;
                    default:
                        return ts.Debug.assertNever(keywordFilter);
                }
            }));
        }
        function isTypeScriptOnlyKeyword(kind) {
            switch (kind) {
                case 126 /* SyntaxKind.AbstractKeyword */:
                case 131 /* SyntaxKind.AnyKeyword */:
                case 160 /* SyntaxKind.BigIntKeyword */:
                case 134 /* SyntaxKind.BooleanKeyword */:
                case 136 /* SyntaxKind.DeclareKeyword */:
                case 92 /* SyntaxKind.EnumKeyword */:
                case 159 /* SyntaxKind.GlobalKeyword */:
                case 117 /* SyntaxKind.ImplementsKeyword */:
                case 138 /* SyntaxKind.InferKeyword */:
                case 118 /* SyntaxKind.InterfaceKeyword */:
                case 140 /* SyntaxKind.IsKeyword */:
                case 141 /* SyntaxKind.KeyOfKeyword */:
                case 142 /* SyntaxKind.ModuleKeyword */:
                case 143 /* SyntaxKind.NamespaceKeyword */:
                case 144 /* SyntaxKind.NeverKeyword */:
                case 148 /* SyntaxKind.NumberKeyword */:
                case 149 /* SyntaxKind.ObjectKeyword */:
                case 161 /* SyntaxKind.OverrideKeyword */:
                case 121 /* SyntaxKind.PrivateKeyword */:
                case 122 /* SyntaxKind.ProtectedKeyword */:
                case 123 /* SyntaxKind.PublicKeyword */:
                case 146 /* SyntaxKind.ReadonlyKeyword */:
                case 152 /* SyntaxKind.StringKeyword */:
                case 153 /* SyntaxKind.SymbolKeyword */:
                case 154 /* SyntaxKind.TypeKeyword */:
                case 156 /* SyntaxKind.UniqueKeyword */:
                case 157 /* SyntaxKind.UnknownKeyword */:
                    return true;
                default:
                    return false;
            }
        }
        function isInterfaceOrTypeLiteralCompletionKeyword(kind) {
            return kind === 146 /* SyntaxKind.ReadonlyKeyword */;
        }
        function isClassMemberCompletionKeyword(kind) {
            switch (kind) {
                case 126 /* SyntaxKind.AbstractKeyword */:
                case 127 /* SyntaxKind.AccessorKeyword */:
                case 135 /* SyntaxKind.ConstructorKeyword */:
                case 137 /* SyntaxKind.GetKeyword */:
                case 151 /* SyntaxKind.SetKeyword */:
                case 132 /* SyntaxKind.AsyncKeyword */:
                case 136 /* SyntaxKind.DeclareKeyword */:
                case 161 /* SyntaxKind.OverrideKeyword */:
                    return true;
                default:
                    return ts.isClassMemberModifier(kind);
            }
        }
        function isFunctionLikeBodyKeyword(kind) {
            return kind === 132 /* SyntaxKind.AsyncKeyword */
                || kind === 133 /* SyntaxKind.AwaitKeyword */
                || kind === 128 /* SyntaxKind.AsKeyword */
                || kind === 150 /* SyntaxKind.SatisfiesKeyword */
                || kind === 154 /* SyntaxKind.TypeKeyword */
                || !ts.isContextualKeyword(kind) && !isClassMemberCompletionKeyword(kind);
        }
        function keywordForNode(node) {
            return ts.isIdentifier(node) ? node.originalKeywordKind || 0 /* SyntaxKind.Unknown */ : node.kind;
        }
        function getContextualKeywords(contextToken, position) {
            var entries = [];
            /**
             * An `AssertClause` can come after an import declaration:
             *  import * from "foo" |
             *  import "foo" |
             * or after a re-export declaration that has a module specifier:
             *  export { foo } from "foo" |
             * Source: https://tc39.es/proposal-import-assertions/
             */
            if (contextToken) {
                var file = contextToken.getSourceFile();
                var parent = contextToken.parent;
                var tokenLine = file.getLineAndCharacterOfPosition(contextToken.end).line;
                var currentLine = file.getLineAndCharacterOfPosition(position).line;
                if ((ts.isImportDeclaration(parent) || ts.isExportDeclaration(parent) && parent.moduleSpecifier)
                    && contextToken === parent.moduleSpecifier
                    && tokenLine === currentLine) {
                    entries.push({
                        name: ts.tokenToString(130 /* SyntaxKind.AssertKeyword */),
                        kind: "keyword" /* ScriptElementKind.keyword */,
                        kindModifiers: "" /* ScriptElementKindModifier.none */,
                        sortText: Completions.SortText.GlobalsOrKeywords,
                    });
                }
            }
            return entries;
        }
        /** Get the corresponding JSDocTag node if the position is in a jsDoc comment */
        function getJsDocTagAtPosition(node, position) {
            return ts.findAncestor(node, function (n) {
                return ts.isJSDocTag(n) && ts.rangeContainsPosition(n, position) ? true :
                    ts.isJSDoc(n) ? "quit" : false;
            });
        }
        function getPropertiesForObjectExpression(contextualType, completionsType, obj, checker) {
            var hasCompletionsType = completionsType && completionsType !== contextualType;
            var type = hasCompletionsType && !(completionsType.flags & 3 /* TypeFlags.AnyOrUnknown */)
                ? checker.getUnionType([contextualType, completionsType])
                : contextualType;
            var properties = getApparentProperties(type, obj, checker);
            return type.isClass() && containsNonPublicProperties(properties) ? [] :
                hasCompletionsType ? ts.filter(properties, hasDeclarationOtherThanSelf) : properties;
            // Filter out members whose only declaration is the object literal itself to avoid
            // self-fulfilling completions like:
            //
            // function f<T>(x: T) {}
            // f({ abc/**/: "" }) // `abc` is a member of `T` but only because it declares itself
            function hasDeclarationOtherThanSelf(member) {
                if (!ts.length(member.declarations))
                    return true;
                return ts.some(member.declarations, function (decl) { return decl.parent !== obj; });
            }
        }
        Completions.getPropertiesForObjectExpression = getPropertiesForObjectExpression;
        function getApparentProperties(type, node, checker) {
            if (!type.isUnion())
                return type.getApparentProperties();
            return checker.getAllPossiblePropertiesOfTypes(ts.filter(type.types, function (memberType) {
                return !(memberType.flags & 131068 /* TypeFlags.Primitive */
                    || checker.isArrayLikeType(memberType)
                    || checker.isTypeInvalidDueToUnionDiscriminant(memberType, node)
                    || ts.typeHasCallOrConstructSignatures(memberType, checker)
                    || memberType.isClass() && containsNonPublicProperties(memberType.getApparentProperties()));
            }));
        }
        function containsNonPublicProperties(props) {
            return ts.some(props, function (p) { return !!(ts.getDeclarationModifierFlagsFromSymbol(p) & 24 /* ModifierFlags.NonPublicAccessibilityModifier */); });
        }
        /**
         * Gets all properties on a type, but if that type is a union of several types,
         * excludes array-like types or callable/constructable types.
         */
        function getPropertiesForCompletion(type, checker) {
            return type.isUnion()
                ? ts.Debug.checkEachDefined(checker.getAllPossiblePropertiesOfTypes(type.types), "getAllPossiblePropertiesOfTypes() should all be defined")
                : ts.Debug.checkEachDefined(type.getApparentProperties(), "getApparentProperties() should all be defined");
        }
        /**
         * Returns the immediate owning class declaration of a context token,
         * on the condition that one exists and that the context implies completion should be given.
         */
        function tryGetObjectTypeDeclarationCompletionContainer(sourceFile, contextToken, location, position) {
            // class c { method() { } | method2() { } }
            switch (location.kind) {
                case 351 /* SyntaxKind.SyntaxList */:
                    return ts.tryCast(location.parent, ts.isObjectTypeDeclaration);
                case 1 /* SyntaxKind.EndOfFileToken */:
                    var cls = ts.tryCast(ts.lastOrUndefined(ts.cast(location.parent, ts.isSourceFile).statements), ts.isObjectTypeDeclaration);
                    if (cls && !ts.findChildOfKind(cls, 19 /* SyntaxKind.CloseBraceToken */, sourceFile)) {
                        return cls;
                    }
                    break;
                case 79 /* SyntaxKind.Identifier */: {
                    var originalKeywordKind = location.originalKeywordKind;
                    if (originalKeywordKind && ts.isKeyword(originalKeywordKind)) {
                        return undefined;
                    }
                    // class c { public prop = c| }
                    if (ts.isPropertyDeclaration(location.parent) && location.parent.initializer === location) {
                        return undefined;
                    }
                    // class c extends React.Component { a: () => 1\n compon| }
                    if (isFromObjectTypeDeclaration(location)) {
                        return ts.findAncestor(location, ts.isObjectTypeDeclaration);
                    }
                }
            }
            if (!contextToken)
                return undefined;
            // class C { blah; constructor/**/ } and so on
            if (location.kind === 135 /* SyntaxKind.ConstructorKeyword */
                // class C { blah \n constructor/**/ }
                || (ts.isIdentifier(contextToken) && ts.isPropertyDeclaration(contextToken.parent) && ts.isClassLike(location))) {
                return ts.findAncestor(contextToken, ts.isClassLike);
            }
            switch (contextToken.kind) {
                case 63 /* SyntaxKind.EqualsToken */: // class c { public prop = | /* global completions */ }
                    return undefined;
                case 26 /* SyntaxKind.SemicolonToken */: // class c {getValue(): number; | }
                case 19 /* SyntaxKind.CloseBraceToken */: // class c { method() { } | }
                    // class c { method() { } b| }
                    return isFromObjectTypeDeclaration(location) && location.parent.name === location
                        ? location.parent.parent
                        : ts.tryCast(location, ts.isObjectTypeDeclaration);
                case 18 /* SyntaxKind.OpenBraceToken */: // class c { |
                case 27 /* SyntaxKind.CommaToken */: // class c {getValue(): number, | }
                    return ts.tryCast(contextToken.parent, ts.isObjectTypeDeclaration);
                default:
                    if (!isFromObjectTypeDeclaration(contextToken)) {
                        // class c extends React.Component { a: () => 1\n| }
                        if (ts.getLineAndCharacterOfPosition(sourceFile, contextToken.getEnd()).line !== ts.getLineAndCharacterOfPosition(sourceFile, position).line && ts.isObjectTypeDeclaration(location)) {
                            return location;
                        }
                        return undefined;
                    }
                    var isValidKeyword = ts.isClassLike(contextToken.parent.parent) ? isClassMemberCompletionKeyword : isInterfaceOrTypeLiteralCompletionKeyword;
                    return (isValidKeyword(contextToken.kind) || contextToken.kind === 41 /* SyntaxKind.AsteriskToken */ || ts.isIdentifier(contextToken) && isValidKeyword(ts.stringToToken(contextToken.text))) // TODO: GH#18217
                        ? contextToken.parent.parent : undefined;
            }
        }
        function tryGetTypeLiteralNode(node) {
            if (!node)
                return undefined;
            var parent = node.parent;
            switch (node.kind) {
                case 18 /* SyntaxKind.OpenBraceToken */:
                    if (ts.isTypeLiteralNode(parent)) {
                        return parent;
                    }
                    break;
                case 26 /* SyntaxKind.SemicolonToken */:
                case 27 /* SyntaxKind.CommaToken */:
                case 79 /* SyntaxKind.Identifier */:
                    if (parent.kind === 168 /* SyntaxKind.PropertySignature */ && ts.isTypeLiteralNode(parent.parent)) {
                        return parent.parent;
                    }
                    break;
            }
            return undefined;
        }
        function getConstraintOfTypeArgumentProperty(node, checker) {
            if (!node)
                return undefined;
            if (ts.isTypeNode(node) && ts.isTypeReferenceType(node.parent)) {
                return checker.getTypeArgumentConstraint(node);
            }
            var t = getConstraintOfTypeArgumentProperty(node.parent, checker);
            if (!t)
                return undefined;
            switch (node.kind) {
                case 168 /* SyntaxKind.PropertySignature */:
                    return checker.getTypeOfPropertyOfContextualType(t, node.symbol.escapedName);
                case 190 /* SyntaxKind.IntersectionType */:
                case 184 /* SyntaxKind.TypeLiteral */:
                case 189 /* SyntaxKind.UnionType */:
                    return t;
            }
        }
        // TODO: GH#19856 Would like to return `node is Node & { parent: (ClassElement | TypeElement) & { parent: ObjectTypeDeclaration } }` but then compilation takes > 10 minutes
        function isFromObjectTypeDeclaration(node) {
            return node.parent && ts.isClassOrTypeElement(node.parent) && ts.isObjectTypeDeclaration(node.parent.parent);
        }
        function isValidTrigger(sourceFile, triggerCharacter, contextToken, position) {
            switch (triggerCharacter) {
                case ".":
                case "@":
                    return true;
                case '"':
                case "'":
                case "`":
                    // Only automatically bring up completions if this is an opening quote.
                    return !!contextToken && ts.isStringLiteralOrTemplate(contextToken) && position === contextToken.getStart(sourceFile) + 1;
                case "#":
                    return !!contextToken && ts.isPrivateIdentifier(contextToken) && !!ts.getContainingClass(contextToken);
                case "<":
                    // Opening JSX tag
                    return !!contextToken && contextToken.kind === 29 /* SyntaxKind.LessThanToken */ && (!ts.isBinaryExpression(contextToken.parent) || binaryExpressionMayBeOpenTag(contextToken.parent));
                case "/":
                    return !!contextToken && (ts.isStringLiteralLike(contextToken)
                        ? !!ts.tryGetImportFromModuleSpecifier(contextToken)
                        : contextToken.kind === 43 /* SyntaxKind.SlashToken */ && ts.isJsxClosingElement(contextToken.parent));
                case " ":
                    return !!contextToken && ts.isImportKeyword(contextToken) && contextToken.parent.kind === 308 /* SyntaxKind.SourceFile */;
                default:
                    return ts.Debug.assertNever(triggerCharacter);
            }
        }
        function binaryExpressionMayBeOpenTag(_a) {
            var left = _a.left;
            return ts.nodeIsMissing(left);
        }
        /** Determines if a type is exactly the same type resolved by the global 'self', 'global', or 'globalThis'. */
        function isProbablyGlobalType(type, sourceFile, checker) {
            // The type of `self` and `window` is the same in lib.dom.d.ts, but `window` does not exist in
            // lib.webworker.d.ts, so checking against `self` is also a check against `window` when it exists.
            var selfSymbol = checker.resolveName("self", /*location*/ undefined, 111551 /* SymbolFlags.Value */, /*excludeGlobals*/ false);
            if (selfSymbol && checker.getTypeOfSymbolAtLocation(selfSymbol, sourceFile) === type) {
                return true;
            }
            var globalSymbol = checker.resolveName("global", /*location*/ undefined, 111551 /* SymbolFlags.Value */, /*excludeGlobals*/ false);
            if (globalSymbol && checker.getTypeOfSymbolAtLocation(globalSymbol, sourceFile) === type) {
                return true;
            }
            var globalThisSymbol = checker.resolveName("globalThis", /*location*/ undefined, 111551 /* SymbolFlags.Value */, /*excludeGlobals*/ false);
            if (globalThisSymbol && checker.getTypeOfSymbolAtLocation(globalThisSymbol, sourceFile) === type) {
                return true;
            }
            return false;
        }
        function isStaticProperty(symbol) {
            return !!(symbol.valueDeclaration && ts.getEffectiveModifierFlags(symbol.valueDeclaration) & 32 /* ModifierFlags.Static */ && ts.isClassLike(symbol.valueDeclaration.parent));
        }
        function tryGetObjectLiteralContextualType(node, typeChecker) {
            var type = typeChecker.getContextualType(node);
            if (type) {
                return type;
            }
            var parent = ts.walkUpParenthesizedExpressions(node.parent);
            if (ts.isBinaryExpression(parent) && parent.operatorToken.kind === 63 /* SyntaxKind.EqualsToken */ && node === parent.left) {
                // Object literal is assignment pattern: ({ | } = x)
                return typeChecker.getTypeAtLocation(parent);
            }
            if (ts.isExpression(parent)) {
                // f(() => (({ | })));
                return typeChecker.getContextualType(parent);
            }
            return undefined;
        }
        function getImportStatementCompletionInfo(contextToken) {
            var _a, _b, _c;
            var keywordCompletion;
            var isKeywordOnlyCompletion = false;
            var candidate = getCandidate();
            return {
                isKeywordOnlyCompletion: isKeywordOnlyCompletion,
                keywordCompletion: keywordCompletion,
                isNewIdentifierLocation: !!(candidate || keywordCompletion === 154 /* SyntaxKind.TypeKeyword */),
                isTopLevelTypeOnly: !!((_b = (_a = ts.tryCast(candidate, ts.isImportDeclaration)) === null || _a === void 0 ? void 0 : _a.importClause) === null || _b === void 0 ? void 0 : _b.isTypeOnly) || !!((_c = ts.tryCast(candidate, ts.isImportEqualsDeclaration)) === null || _c === void 0 ? void 0 : _c.isTypeOnly),
                couldBeTypeOnlyImportSpecifier: !!candidate && couldBeTypeOnlyImportSpecifier(candidate, contextToken),
                replacementSpan: getSingleLineReplacementSpanForImportCompletionNode(candidate),
            };
            function getCandidate() {
                var parent = contextToken.parent;
                if (ts.isImportEqualsDeclaration(parent)) {
                    keywordCompletion = contextToken.kind === 154 /* SyntaxKind.TypeKeyword */ ? undefined : 154 /* SyntaxKind.TypeKeyword */;
                    return isModuleSpecifierMissingOrEmpty(parent.moduleReference) ? parent : undefined;
                }
                if (couldBeTypeOnlyImportSpecifier(parent, contextToken) && canCompleteFromNamedBindings(parent.parent)) {
                    return parent;
                }
                if (ts.isNamedImports(parent) || ts.isNamespaceImport(parent)) {
                    if (!parent.parent.isTypeOnly && (contextToken.kind === 18 /* SyntaxKind.OpenBraceToken */ ||
                        contextToken.kind === 100 /* SyntaxKind.ImportKeyword */ ||
                        contextToken.kind === 27 /* SyntaxKind.CommaToken */)) {
                        keywordCompletion = 154 /* SyntaxKind.TypeKeyword */;
                    }
                    if (canCompleteFromNamedBindings(parent)) {
                        // At `import { ... } |` or `import * as Foo |`, the only possible completion is `from`
                        if (contextToken.kind === 19 /* SyntaxKind.CloseBraceToken */ || contextToken.kind === 79 /* SyntaxKind.Identifier */) {
                            isKeywordOnlyCompletion = true;
                            keywordCompletion = 158 /* SyntaxKind.FromKeyword */;
                        }
                        else {
                            return parent.parent.parent;
                        }
                    }
                    return undefined;
                }
                if (ts.isImportKeyword(contextToken) && ts.isSourceFile(parent)) {
                    // A lone import keyword with nothing following it does not parse as a statement at all
                    keywordCompletion = 154 /* SyntaxKind.TypeKeyword */;
                    return contextToken;
                }
                if (ts.isImportKeyword(contextToken) && ts.isImportDeclaration(parent)) {
                    // `import s| from`
                    keywordCompletion = 154 /* SyntaxKind.TypeKeyword */;
                    return isModuleSpecifierMissingOrEmpty(parent.moduleSpecifier) ? parent : undefined;
                }
                return undefined;
            }
        }
        function getSingleLineReplacementSpanForImportCompletionNode(node) {
            var _a, _b, _c;
            if (!node)
                return undefined;
            var top = (_a = ts.findAncestor(node, ts.or(ts.isImportDeclaration, ts.isImportEqualsDeclaration))) !== null && _a !== void 0 ? _a : node;
            var sourceFile = top.getSourceFile();
            if (ts.rangeIsOnSingleLine(top, sourceFile)) {
                return ts.createTextSpanFromNode(top, sourceFile);
            }
            // ImportKeyword was necessarily on one line; ImportSpecifier was necessarily parented in an ImportDeclaration
            ts.Debug.assert(top.kind !== 100 /* SyntaxKind.ImportKeyword */ && top.kind !== 273 /* SyntaxKind.ImportSpecifier */);
            // Guess which point in the import might actually be a later statement parsed as part of the import
            // during parser recovery - either in the middle of named imports, or the module specifier.
            var potentialSplitPoint = top.kind === 269 /* SyntaxKind.ImportDeclaration */
                ? (_c = getPotentiallyInvalidImportSpecifier((_b = top.importClause) === null || _b === void 0 ? void 0 : _b.namedBindings)) !== null && _c !== void 0 ? _c : top.moduleSpecifier
                : top.moduleReference;
            var withoutModuleSpecifier = {
                pos: top.getFirstToken().getStart(),
                end: potentialSplitPoint.pos,
            };
            // The module specifier/reference was previously found to be missing, empty, or
            // not a string literal - in this last case, it's likely that statement on a following
            // line was parsed as the module specifier of a partially-typed import, e.g.
            //   import Foo|
            //   interface Blah {}
            // This appears to be a multiline-import, and editors can't replace multiple lines.
            // But if everything but the "module specifier" is on one line, by this point we can
            // assume that the "module specifier" is actually just another statement, and return
            // the single-line range of the import excluding that probable statement.
            if (ts.rangeIsOnSingleLine(withoutModuleSpecifier, sourceFile)) {
                return ts.createTextSpanFromRange(withoutModuleSpecifier);
            }
        }
        // Tries to identify the first named import that is not really a named import, but rather
        // just parser recovery for a situation like:
        //   import { Foo|
        //   interface Bar {}
        // in which `Foo`, `interface`, and `Bar` are all parsed as import specifiers. The caller
        // will also check if this token is on a separate line from the rest of the import.
        function getPotentiallyInvalidImportSpecifier(namedBindings) {
            var _a;
            return ts.find((_a = ts.tryCast(namedBindings, ts.isNamedImports)) === null || _a === void 0 ? void 0 : _a.elements, function (e) {
                var _a;
                return !e.propertyName &&
                    ts.isStringANonContextualKeyword(e.name.text) &&
                    ((_a = ts.findPrecedingToken(e.name.pos, namedBindings.getSourceFile(), namedBindings)) === null || _a === void 0 ? void 0 : _a.kind) !== 27 /* SyntaxKind.CommaToken */;
            });
        }
        function couldBeTypeOnlyImportSpecifier(importSpecifier, contextToken) {
            return ts.isImportSpecifier(importSpecifier)
                && (importSpecifier.isTypeOnly || contextToken === importSpecifier.name && ts.isTypeKeywordTokenOrIdentifier(contextToken));
        }
        function canCompleteFromNamedBindings(namedBindings) {
            if (!isModuleSpecifierMissingOrEmpty(namedBindings.parent.parent.moduleSpecifier) || namedBindings.parent.name) {
                return false;
            }
            if (ts.isNamedImports(namedBindings)) {
                // We can only complete on named imports if there are no other named imports already,
                // but parser recovery sometimes puts later statements in the named imports list, so
                // we try to only consider the probably-valid ones.
                var invalidNamedImport = getPotentiallyInvalidImportSpecifier(namedBindings);
                var validImports = invalidNamedImport ? namedBindings.elements.indexOf(invalidNamedImport) : namedBindings.elements.length;
                return validImports < 2;
            }
            return true;
        }
        function isModuleSpecifierMissingOrEmpty(specifier) {
            var _a;
            if (ts.nodeIsMissing(specifier))
                return true;
            return !((_a = ts.tryCast(ts.isExternalModuleReference(specifier) ? specifier.expression : specifier, ts.isStringLiteralLike)) === null || _a === void 0 ? void 0 : _a.text);
        }
        function getVariableDeclaration(property) {
            var variableDeclaration = ts.findAncestor(property, function (node) {
                return ts.isFunctionBlock(node) || isArrowFunctionBody(node) || ts.isBindingPattern(node)
                    ? "quit"
                    : ts.isVariableDeclaration(node);
            });
            return variableDeclaration;
        }
        function isArrowFunctionBody(node) {
            return node.parent && ts.isArrowFunction(node.parent) && node.parent.body === node;
        }
        /** True if symbol is a type or a module containing at least one type. */
        function symbolCanBeReferencedAtTypeLocation(symbol, checker, seenModules) {
            if (seenModules === void 0) { seenModules = new ts.Map(); }
            // Since an alias can be merged with a local declaration, we need to test both the alias and its target.
            // This code used to just test the result of `skipAlias`, but that would ignore any locally introduced meanings.
            return nonAliasCanBeReferencedAtTypeLocation(symbol) || nonAliasCanBeReferencedAtTypeLocation(ts.skipAlias(symbol.exportSymbol || symbol, checker));
            function nonAliasCanBeReferencedAtTypeLocation(symbol) {
                return !!(symbol.flags & 788968 /* SymbolFlags.Type */) || checker.isUnknownSymbol(symbol) ||
                    !!(symbol.flags & 1536 /* SymbolFlags.Module */) && ts.addToSeen(seenModules, ts.getSymbolId(symbol)) &&
                        checker.getExportsOfModule(symbol).some(function (e) { return symbolCanBeReferencedAtTypeLocation(e, checker, seenModules); });
            }
        }
        function isDeprecated(symbol, checker) {
            var declarations = ts.skipAlias(symbol, checker).declarations;
            return !!ts.length(declarations) && ts.every(declarations, ts.isDeprecatedDeclaration);
        }
        /**
         * True if the first character of `lowercaseCharacters` is the first character
         * of some "word" in `identiferString` (where the string is split into "words"
         * by camelCase and snake_case segments), then if the remaining characters of
         * `lowercaseCharacters` appear, in order, in the rest of `identifierString`.
         *
         * True:
         * 'state' in 'useState'
         * 'sae' in 'useState'
         * 'viable' in 'ENVIRONMENT_VARIABLE'
         *
         * False:
         * 'staet' in 'useState'
         * 'tate' in 'useState'
         * 'ment' in 'ENVIRONMENT_VARIABLE'
         */
        function charactersFuzzyMatchInString(identifierString, lowercaseCharacters) {
            if (lowercaseCharacters.length === 0) {
                return true;
            }
            var matchedFirstCharacter = false;
            var prevChar;
            var characterIndex = 0;
            var len = identifierString.length;
            for (var strIndex = 0; strIndex < len; strIndex++) {
                var strChar = identifierString.charCodeAt(strIndex);
                var testChar = lowercaseCharacters.charCodeAt(characterIndex);
                if (strChar === testChar || strChar === toUpperCharCode(testChar)) {
                    matchedFirstCharacter || (matchedFirstCharacter = prevChar === undefined || // Beginning of word
                        97 /* CharacterCodes.a */ <= prevChar && prevChar <= 122 /* CharacterCodes.z */ && 65 /* CharacterCodes.A */ <= strChar && strChar <= 90 /* CharacterCodes.Z */ || // camelCase transition
                        prevChar === 95 /* CharacterCodes._ */ && strChar !== 95 /* CharacterCodes._ */); // snake_case transition
                    if (matchedFirstCharacter) {
                        characterIndex++;
                    }
                    if (characterIndex === lowercaseCharacters.length) {
                        return true;
                    }
                }
                prevChar = strChar;
            }
            // Did not find all characters
            return false;
        }
        function toUpperCharCode(charCode) {
            if (97 /* CharacterCodes.a */ <= charCode && charCode <= 122 /* CharacterCodes.z */) {
                return charCode - 32;
            }
            return charCode;
        }
    })(Completions = ts.Completions || (ts.Completions = {}));
})(ts || (ts = {}));
var ts;
(function (ts) {
    /* @internal */
    var DocumentHighlights;
    (function (DocumentHighlights) {
        function getDocumentHighlights(program, cancellationToken, sourceFile, position, sourceFilesToSearch) {
            var node = ts.getTouchingPropertyName(sourceFile, position);
            if (node.parent && (ts.isJsxOpeningElement(node.parent) && node.parent.tagName === node || ts.isJsxClosingElement(node.parent))) {
                // For a JSX element, just highlight the matching tag, not all references.
                var _a = node.parent.parent, openingElement = _a.openingElement, closingElement = _a.closingElement;
                var highlightSpans = [openingElement, closingElement].map(function (_a) {
                    var tagName = _a.tagName;
                    return getHighlightSpanForNode(tagName, sourceFile);
                });
                return [{ fileName: sourceFile.fileName, highlightSpans: highlightSpans }];
            }
            return getSemanticDocumentHighlights(position, node, program, cancellationToken, sourceFilesToSearch) || getSyntacticDocumentHighlights(node, sourceFile);
        }
        DocumentHighlights.getDocumentHighlights = getDocumentHighlights;
        function getHighlightSpanForNode(node, sourceFile) {
            return {
                fileName: sourceFile.fileName,
                textSpan: ts.createTextSpanFromNode(node, sourceFile),
                kind: "none" /* HighlightSpanKind.none */
            };
        }
        function getSemanticDocumentHighlights(position, node, program, cancellationToken, sourceFilesToSearch) {
            var sourceFilesSet = new ts.Set(sourceFilesToSearch.map(function (f) { return f.fileName; }));
            var referenceEntries = ts.FindAllReferences.getReferenceEntriesForNode(position, node, program, sourceFilesToSearch, cancellationToken, /*options*/ undefined, sourceFilesSet);
            if (!referenceEntries)
                return undefined;
            var map = ts.arrayToMultiMap(referenceEntries.map(ts.FindAllReferences.toHighlightSpan), function (e) { return e.fileName; }, function (e) { return e.span; });
            var getCanonicalFileName = ts.createGetCanonicalFileName(program.useCaseSensitiveFileNames());
            return ts.mapDefined(ts.arrayFrom(map.entries()), function (_a) {
                var fileName = _a[0], highlightSpans = _a[1];
                if (!sourceFilesSet.has(fileName)) {
                    if (!program.redirectTargetsMap.has(ts.toPath(fileName, program.getCurrentDirectory(), getCanonicalFileName))) {
                        return undefined;
                    }
                    var redirectTarget_1 = program.getSourceFile(fileName);
                    var redirect = ts.find(sourceFilesToSearch, function (f) { return !!f.redirectInfo && f.redirectInfo.redirectTarget === redirectTarget_1; });
                    fileName = redirect.fileName;
                    ts.Debug.assert(sourceFilesSet.has(fileName));
                }
                return { fileName: fileName, highlightSpans: highlightSpans };
            });
        }
        function getSyntacticDocumentHighlights(node, sourceFile) {
            var highlightSpans = getHighlightSpans(node, sourceFile);
            return highlightSpans && [{ fileName: sourceFile.fileName, highlightSpans: highlightSpans }];
        }
        function getHighlightSpans(node, sourceFile) {
            switch (node.kind) {
                case 99 /* SyntaxKind.IfKeyword */:
                case 91 /* SyntaxKind.ElseKeyword */:
                    return ts.isIfStatement(node.parent) ? getIfElseOccurrences(node.parent, sourceFile) : undefined;
                case 105 /* SyntaxKind.ReturnKeyword */:
                    return useParent(node.parent, ts.isReturnStatement, getReturnOccurrences);
                case 109 /* SyntaxKind.ThrowKeyword */:
                    return useParent(node.parent, ts.isThrowStatement, getThrowOccurrences);
                case 111 /* SyntaxKind.TryKeyword */:
                case 83 /* SyntaxKind.CatchKeyword */:
                case 96 /* SyntaxKind.FinallyKeyword */:
                    var tryStatement = node.kind === 83 /* SyntaxKind.CatchKeyword */ ? node.parent.parent : node.parent;
                    return useParent(tryStatement, ts.isTryStatement, getTryCatchFinallyOccurrences);
                case 107 /* SyntaxKind.SwitchKeyword */:
                    return useParent(node.parent, ts.isSwitchStatement, getSwitchCaseDefaultOccurrences);
                case 82 /* SyntaxKind.CaseKeyword */:
                case 88 /* SyntaxKind.DefaultKeyword */: {
                    if (ts.isDefaultClause(node.parent) || ts.isCaseClause(node.parent)) {
                        return useParent(node.parent.parent.parent, ts.isSwitchStatement, getSwitchCaseDefaultOccurrences);
                    }
                    return undefined;
                }
                case 81 /* SyntaxKind.BreakKeyword */:
                case 86 /* SyntaxKind.ContinueKeyword */:
                    return useParent(node.parent, ts.isBreakOrContinueStatement, getBreakOrContinueStatementOccurrences);
                case 97 /* SyntaxKind.ForKeyword */:
                case 115 /* SyntaxKind.WhileKeyword */:
                case 90 /* SyntaxKind.DoKeyword */:
                    return useParent(node.parent, function (n) { return ts.isIterationStatement(n, /*lookInLabeledStatements*/ true); }, getLoopBreakContinueOccurrences);
                case 135 /* SyntaxKind.ConstructorKeyword */:
                    return getFromAllDeclarations(ts.isConstructorDeclaration, [135 /* SyntaxKind.ConstructorKeyword */]);
                case 137 /* SyntaxKind.GetKeyword */:
                case 151 /* SyntaxKind.SetKeyword */:
                    return getFromAllDeclarations(ts.isAccessor, [137 /* SyntaxKind.GetKeyword */, 151 /* SyntaxKind.SetKeyword */]);
                case 133 /* SyntaxKind.AwaitKeyword */:
                    return useParent(node.parent, ts.isAwaitExpression, getAsyncAndAwaitOccurrences);
                case 132 /* SyntaxKind.AsyncKeyword */:
                    return highlightSpans(getAsyncAndAwaitOccurrences(node));
                case 125 /* SyntaxKind.YieldKeyword */:
                    return highlightSpans(getYieldOccurrences(node));
                case 101 /* SyntaxKind.InKeyword */:
                    return undefined;
                default:
                    return ts.isModifierKind(node.kind) && (ts.isDeclaration(node.parent) || ts.isVariableStatement(node.parent))
                        ? highlightSpans(getModifierOccurrences(node.kind, node.parent))
                        : undefined;
            }
            function getFromAllDeclarations(nodeTest, keywords) {
                return useParent(node.parent, nodeTest, function (decl) { return ts.mapDefined(decl.symbol.declarations, function (d) {
                    return nodeTest(d) ? ts.find(d.getChildren(sourceFile), function (c) { return ts.contains(keywords, c.kind); }) : undefined;
                }); });
            }
            function useParent(node, nodeTest, getNodes) {
                return nodeTest(node) ? highlightSpans(getNodes(node, sourceFile)) : undefined;
            }
            function highlightSpans(nodes) {
                return nodes && nodes.map(function (node) { return getHighlightSpanForNode(node, sourceFile); });
            }
        }
        /**
         * Aggregates all throw-statements within this node *without* crossing
         * into function boundaries and try-blocks with catch-clauses.
         */
        function aggregateOwnedThrowStatements(node) {
            if (ts.isThrowStatement(node)) {
                return [node];
            }
            else if (ts.isTryStatement(node)) {
                // Exceptions thrown within a try block lacking a catch clause are "owned" in the current context.
                return ts.concatenate(node.catchClause ? aggregateOwnedThrowStatements(node.catchClause) : node.tryBlock && aggregateOwnedThrowStatements(node.tryBlock), node.finallyBlock && aggregateOwnedThrowStatements(node.finallyBlock));
            }
            // Do not cross function boundaries.
            return ts.isFunctionLike(node) ? undefined : flatMapChildren(node, aggregateOwnedThrowStatements);
        }
        /**
         * For lack of a better name, this function takes a throw statement and returns the
         * nearest ancestor that is a try-block (whose try statement has a catch clause),
         * function-block, or source file.
         */
        function getThrowStatementOwner(throwStatement) {
            var child = throwStatement;
            while (child.parent) {
                var parent = child.parent;
                if (ts.isFunctionBlock(parent) || parent.kind === 308 /* SyntaxKind.SourceFile */) {
                    return parent;
                }
                // A throw-statement is only owned by a try-statement if the try-statement has
                // a catch clause, and if the throw-statement occurs within the try block.
                if (ts.isTryStatement(parent) && parent.tryBlock === child && parent.catchClause) {
                    return child;
                }
                child = parent;
            }
            return undefined;
        }
        function aggregateAllBreakAndContinueStatements(node) {
            return ts.isBreakOrContinueStatement(node) ? [node] : ts.isFunctionLike(node) ? undefined : flatMapChildren(node, aggregateAllBreakAndContinueStatements);
        }
        function flatMapChildren(node, cb) {
            var result = [];
            node.forEachChild(function (child) {
                var value = cb(child);
                if (value !== undefined) {
                    result.push.apply(result, ts.toArray(value));
                }
            });
            return result;
        }
        function ownsBreakOrContinueStatement(owner, statement) {
            var actualOwner = getBreakOrContinueOwner(statement);
            return !!actualOwner && actualOwner === owner;
        }
        function getBreakOrContinueOwner(statement) {
            return ts.findAncestor(statement, function (node) {
                switch (node.kind) {
                    case 252 /* SyntaxKind.SwitchStatement */:
                        if (statement.kind === 248 /* SyntaxKind.ContinueStatement */) {
                            return false;
                        }
                    // falls through
                    case 245 /* SyntaxKind.ForStatement */:
                    case 246 /* SyntaxKind.ForInStatement */:
                    case 247 /* SyntaxKind.ForOfStatement */:
                    case 244 /* SyntaxKind.WhileStatement */:
                    case 243 /* SyntaxKind.DoStatement */:
                        return !statement.label || isLabeledBy(node, statement.label.escapedText);
                    default:
                        // Don't cross function boundaries.
                        // TODO: GH#20090
                        return ts.isFunctionLike(node) && "quit";
                }
            });
        }
        function getModifierOccurrences(modifier, declaration) {
            return ts.mapDefined(getNodesToSearchForModifier(declaration, ts.modifierToFlag(modifier)), function (node) { return ts.findModifier(node, modifier); });
        }
        function getNodesToSearchForModifier(declaration, modifierFlag) {
            // Types of node whose children might have modifiers.
            var container = declaration.parent;
            switch (container.kind) {
                case 265 /* SyntaxKind.ModuleBlock */:
                case 308 /* SyntaxKind.SourceFile */:
                case 238 /* SyntaxKind.Block */:
                case 292 /* SyntaxKind.CaseClause */:
                case 293 /* SyntaxKind.DefaultClause */:
                    // Container is either a class declaration or the declaration is a classDeclaration
                    if (modifierFlag & 256 /* ModifierFlags.Abstract */ && ts.isClassDeclaration(declaration)) {
                        return __spreadArray(__spreadArray([], declaration.members, true), [declaration], false);
                    }
                    else {
                        return container.statements;
                    }
                case 173 /* SyntaxKind.Constructor */:
                case 171 /* SyntaxKind.MethodDeclaration */:
                case 259 /* SyntaxKind.FunctionDeclaration */:
                    return __spreadArray(__spreadArray([], container.parameters, true), (ts.isClassLike(container.parent) ? container.parent.members : []), true);
                case 260 /* SyntaxKind.ClassDeclaration */:
                case 228 /* SyntaxKind.ClassExpression */:
                case 261 /* SyntaxKind.InterfaceDeclaration */:
                case 184 /* SyntaxKind.TypeLiteral */:
                    var nodes = container.members;
                    // If we're an accessibility modifier, we're in an instance member and should search
                    // the constructor's parameter list for instance members as well.
                    if (modifierFlag & (28 /* ModifierFlags.AccessibilityModifier */ | 64 /* ModifierFlags.Readonly */)) {
                