} ...;
    // /**/export { propertyName as [|name|] } ...;
    // /**/export * from "[|module|]";
    // /**/export * as ... from "[|module|]";
    if (ts.isExportDeclaration(parent)) {
      var location = getAdjustedLocationForExportDeclaration(parent, forRename);
      if (location) {
        return location;
      }
    }
    // NOTE: We don't adjust the location of the `default` keyword as that is handled specially by `getSymbolAtLocation`.
    // /**/export default [|name|];
    // /**/export = [|name|];
    if (ts.isExportAssignment(parent)) {
      return ts.skipOuterExpressions(parent.expression);
    }
  }
  // import name = /**/require("[|module|]");
  if (node.kind === 147 /* SyntaxKind.RequireKeyword */ && ts.isExternalModuleReference(parent)) {
    return parent.expression;
  }
  // import ... /**/from "[|module|]";
  // export ... /**/from "[|module|]";
  if (node.kind === 158 /* SyntaxKind.FromKeyword */ &&
      (ts.isImportDeclaration(parent) || ts.isExportDeclaration(parent)) && parent.moduleSpecifier) {
    return parent.moduleSpecifier;
  }
  // class ... /**/extends [|name|] ...
  // class ... /**/implements [|name|] ...
  // class ... /**/implements name1, name2 ...
  // interface ... /**/extends [|name|] ...
  // interface ... /**/extends name1, name2 ...
  if ((node.kind === 94 /* SyntaxKind.ExtendsKeyword */ || node.kind === 117 /* SyntaxKind.ImplementsKeyword */) &&
      ts.isHeritageClause(parent) && parent.token === node.kind) {
    var location = getAdjustedLocationForHeritageClause(parent);
    if (location) {
      return location;
    }
  }
  if (node.kind === 94 /* SyntaxKind.ExtendsKeyword */) {
    // ... <T /**/extends [|U|]> ...
    if (ts.isTypeParameterDeclaration(parent) && parent.constraint && ts.isTypeReferenceNode(parent.constraint)) {
      return parent.constraint.typeName;
    }
    // ... T /**/extends [|U|] ? ...
    if (ts.isConditionalTypeNode(parent) && ts.isTypeReferenceNode(parent.extendsType)) {
      return parent.extendsType.typeName;
    }
  }
  // ... T extends /**/infer [|U|] ? ...
  if (node.kind === 138 /* SyntaxKind.InferKeyword */ && ts.isInferTypeNode(parent)) {
    return parent.typeParameter.name;
  }
  // { [ [|K|] /**/in keyof T]: ... }
  if (node.kind === 101 /* SyntaxKind.InKeyword */ && ts.isTypeParameterDeclaration(parent) &&
      ts.isMappedTypeNode(parent.parent)) {
    return parent.name;
  }
  // /**/keyof [|T|]
  if (node.kind === 141 /* SyntaxKind.KeyOfKeyword */ && ts.isTypeOperatorNode(parent) &&
      parent.operator === 141 /* SyntaxKind.KeyOfKeyword */ && ts.isTypeReferenceNode(parent.type)) {
    return parent.type.typeName;
  }
  // /**/readonly [|name|][]
  if (node.kind === 146 /* SyntaxKind.ReadonlyKeyword */ && ts.isTypeOperatorNode(parent) &&
      parent.operator === 146 /* SyntaxKind.ReadonlyKeyword */ && ts.isArrayTypeNode(parent.type) &&
      ts.isTypeReferenceNode(parent.type.elementType)) {
    return parent.type.elementType.typeName;
  }
  if (!forRename) {
    // /**/new [|name|]
    // /**/void [|name|]
    // /**/void obj.[|name|]
    // /**/typeof [|name|]
    // /**/typeof obj.[|name|]
    // /**/await [|name|]
    // /**/await obj.[|name|]
    // /**/yield [|name|]
    // /**/yield obj.[|name|]
    // /**/delete obj.[|name|]
    if (node.kind === 103 /* SyntaxKind.NewKeyword */ && ts.isNewExpression(parent) ||
        node.kind === 114 /* SyntaxKind.VoidKeyword */ && ts.isVoidExpression(parent) ||
        node.kind === 112 /* SyntaxKind.TypeOfKeyword */ && ts.isTypeOfExpression(parent) ||
        node.kind === 133 /* SyntaxKind.AwaitKeyword */ && ts.isAwaitExpression(parent) ||
        node.kind === 125 /* SyntaxKind.YieldKeyword */ && ts.isYieldExpression(parent) ||
        node.kind === 89 /* SyntaxKind.DeleteKeyword */ && ts.isDeleteExpression(parent)) {
      if (parent.expression) {
        return ts.skipOuterExpressions(parent.expression);
      }
    }
    // left /**/in [|name|]
    // left /**/instanceof [|name|]
    if ((node.kind === 101 /* SyntaxKind.InKeyword */ || node.kind === 102 /* SyntaxKind.InstanceOfKeyword */) &&
        ts.isBinaryExpression(parent) && parent.operatorToken === node) {
      return ts.skipOuterExpressions(parent.right);
    }
    // left /**/as [|name|]
    if (node.kind === 128 /* SyntaxKind.AsKeyword */ && ts.isAsExpression(parent) &&
        ts.isTypeReferenceNode(parent.type)) {
      return parent.type.typeName;
    }
    // for (... /**/in [|name|])
    // for (... /**/of [|name|])
    if (node.kind === 101 /* SyntaxKind.InKeyword */ && ts.isForInStatement(parent) ||
        node.kind === 162 /* SyntaxKind.OfKeyword */ && ts.isForOfStatement(parent)) {
      return ts.skipOuterExpressions(parent.expression);
    }
  }
  return node;
}
/**
 * Adjusts the location used for "find references" and "go to definition" when the cursor was not
 * on a property name.
 */
function getAdjustedReferenceLocation(node) {
  return getAdjustedLocation(node, /* forRename*/ false);
}
ts.getAdjustedReferenceLocation = getAdjustedReferenceLocation;
/**
 * Adjusts the location used for "rename" when the cursor was not on a property name.
 */
function getAdjustedRenameLocation(node) {
  return getAdjustedLocation(node, /* forRename*/ true);
}
ts.getAdjustedRenameLocation = getAdjustedRenameLocation;
/**
 * Gets the token whose text has range [start, end) and
 * position >= start and (position < end or (position === end && token is literal or keyword or identifier))
 */
function getTouchingPropertyName(sourceFile, position) {
  return getTouchingToken(sourceFile, position, function(n) {
    return ts.isPropertyNameLiteral(n) || ts.isKeyword(n.kind) || ts.isPrivateIdentifier(n);
  });
}
ts.getTouchingPropertyName = getTouchingPropertyName;
/**
 * Returns the token if position is in [start, end).
 * If position === end, returns the preceding token if includeItemAtEndPosition(previousToken) === true
 */
function getTouchingToken(sourceFile, position, includePrecedingTokenAtEndPosition) {
  return getTokenAtPositionWorker(
      sourceFile, position, /* allowPositionInLeadingTrivia*/ false, includePrecedingTokenAtEndPosition,
      /* includeEndPosition*/ false);
}
ts.getTouchingToken = getTouchingToken;
/** Returns a token if position is in [start-of-leading-trivia, end) */
function getTokenAtPosition(sourceFile, position) {
  return getTokenAtPositionWorker(
      sourceFile, position, /* allowPositionInLeadingTrivia*/ true, /* includePrecedingTokenAtEndPosition*/ undefined,
      /* includeEndPosition*/ false);
}
ts.getTokenAtPosition = getTokenAtPosition;
/** Get the token whose text contains the position */
function getTokenAtPositionWorker(
    sourceFile, position, allowPositionInLeadingTrivia, includePrecedingTokenAtEndPosition, includeEndPosition) {
  let current = sourceFile;
  let foundToken;
  const _loop_1 = function() {
    // find the child that contains 'position'
    const children = current.getChildren(sourceFile);
    const i = ts.binarySearchKey(
        children, position,
        function(_, i) {
          return i;
        },
        function(middle, _) {
          // This last callback is more of a selector than a comparator -
          // `EqualTo` causes the `middle` result to be returned
          // `GreaterThan` causes recursion on the left of the middle
          // `LessThan` causes recursion on the right of the middle
          // Let's say you have 3 nodes, spanning positons
          // pos: 1, end: 3
          // pos: 3, end: 3
          // pos: 3, end: 5
          // and you're looking for the token at positon 3 - all 3 of these nodes are overlapping with position 3.
          // In fact, there's a _good argument_ that node 2 shouldn't even be allowed to exist - depending on if
          // the start or end of the ranges are considered inclusive, it's either wholly subsumed by the first or the last node.
          // Unfortunately, such nodes do exist. :( - See fourslash/completionsImport_tsx.tsx - empty jsx attributes create
          // a zero-length node.
          // What also you may not expect is that which node we return depends on the includePrecedingTokenAtEndPosition flag.
          // Specifically, if includePrecedingTokenAtEndPosition is set, we return the 1-3 node, while if it's unset, we
          // return the 3-5 node. (The zero length node is never correct.) This is because the includePrecedingTokenAtEndPosition
          // flag causes us to return the first node whose end position matches the position and which produces and acceptable token
          // kind. Meanwhile, if includePrecedingTokenAtEndPosition is unset, we look for the first node whose start is <= the
          // position and whose end is greater than the position.
          // There are more sophisticated end tests later, but this one is very fast
          // and allows us to skip a bunch of work
          const end = children[middle].getEnd();
          if (end < position) {
            return -1 /* Comparison.LessThan */;
          }
          const start = allowPositionInLeadingTrivia ? children[middle].getFullStart() :
                                                     children[middle].getStart(sourceFile, /* includeJsDoc*/ true);
          if (start > position) {
            return 1 /* Comparison.GreaterThan */;
          }
          // first element whose start position is before the input and whose end position is after or equal to the input
          if (nodeContainsPosition(children[middle], start, end)) {
            if (children[middle - 1]) {
              // we want the _first_ element that contains the position, so left-recur if the prior node also contains the position
              if (nodeContainsPosition(children[middle - 1])) {
                return 1 /* Comparison.GreaterThan */;
              }
            }
            return 0 /* Comparison.EqualTo */;
          }
          // this complex condition makes us left-recur around a zero-length node when includePrecedingTokenAtEndPosition is set, rather than right-recur on it
          if (includePrecedingTokenAtEndPosition && start === position && children[middle - 1] &&
              children[middle - 1].getEnd() === position && nodeContainsPosition(children[middle - 1])) {
            return 1 /* Comparison.GreaterThan */;
          }
          return -1 /* Comparison.LessThan */;
        });
    if (foundToken) {
      return {value: foundToken};
    }
    if (i >= 0 && children[i]) {
      current = children[i];
      return 'continue-outer';
    }
    return {value: current};
  };
  outer: while (true) {
    const state_1 = _loop_1();
    if (typeof state_1 === 'object')
      {return state_1.value;}
    switch (state_1) {
      case 'continue-outer':
        continue outer;
    }
  }
  function nodeContainsPosition(node, start, end) {
    end !== null && end !== void 0 ? end : (end = node.getEnd());
    if (end < position) {
      return false;
    }
    start !== null && start !== void 0 ?
        start :
        (start = allowPositionInLeadingTrivia ? node.getFullStart() : node.getStart(sourceFile, /* includeJsDoc*/ true));
    if (start > position) {
      // If this child begins after position, then all subsequent children will as well.
      return false;
    }
    if (position < end ||
        (position === end && (node.kind === 1 /* SyntaxKind.EndOfFileToken */ || includeEndPosition))) {
      return true;
    } if (includePrecedingTokenAtEndPosition && end === position) {
      const previousToken = findPrecedingToken(position, sourceFile, node);
      if (previousToken && includePrecedingTokenAtEndPosition(previousToken)) {
        foundToken = previousToken;
        return true;
      }
    }
    return false;
  }
}
/**
 * Returns the first token where position is in [start, end),
 * excluding `JsxText` tokens containing only whitespace.
 */
function findFirstNonJsxWhitespaceToken(sourceFile, position) {
  let tokenAtPosition = getTokenAtPosition(sourceFile, position);
  while (isWhiteSpaceOnlyJsxText(tokenAtPosition)) {
    const nextToken = findNextToken(tokenAtPosition, tokenAtPosition.parent, sourceFile);
    if (!nextToken)
      {return;}
    tokenAtPosition = nextToken;
  }
  return tokenAtPosition;
}
ts.findFirstNonJsxWhitespaceToken = findFirstNonJsxWhitespaceToken;
/**
 * The token on the left of the position is the token that strictly includes the position
 * or sits to the left of the cursor if it is on a boundary. For example
 *
 *   fo|o               -> will return foo
 *   foo <comment> |bar -> will return foo
 *
 */
function findTokenOnLeftOfPosition(file, position) {
  // Ideally, getTokenAtPosition should return a token. However, it is currently
  // broken, so we do a check to make sure the result was indeed a token.
  const tokenAtPosition = getTokenAtPosition(file, position);
  if (ts.isToken(tokenAtPosition) && position > tokenAtPosition.getStart(file) && position < tokenAtPosition.getEnd()) {
    return tokenAtPosition;
  }
  return findPrecedingToken(position, file);
}
ts.findTokenOnLeftOfPosition = findTokenOnLeftOfPosition;
function findNextToken(previousToken, parent, sourceFile) {
  return find(parent);
  function find(n) {
    if (ts.isToken(n) && n.pos === previousToken.end) {
      // this is token that starts at the end of previous token - return it
      return n;
    }
    return ts.firstDefined(n.getChildren(sourceFile), function(child) {
      const shouldDiveInChildNode =
          // previous token is enclosed somewhere in the child
          (child.pos <= previousToken.pos && child.end > previousToken.end) ||
          // previous token ends exactly at the beginning of child
          (child.pos === previousToken.end);
      return shouldDiveInChildNode && nodeHasTokens(child, sourceFile) ? find(child) : undefined;
    });
  }
}
ts.findNextToken = findNextToken;
function findPrecedingToken(position, sourceFile, startNode, excludeJsdoc) {
  const result = find((startNode || sourceFile));
  ts.Debug.assert(!(result && isWhiteSpaceOnlyJsxText(result)));
  return result;
  function find(n) {
    if (isNonWhitespaceToken(n) && n.kind !== 1 /* SyntaxKind.EndOfFileToken */) {
      return n;
    }
    const children = n.getChildren(sourceFile);
    const i = ts.binarySearchKey(
        children, position,
        function(_, i) {
          return i;
        },
        function(middle, _) {
          // This last callback is more of a selector than a comparator -
          // `EqualTo` causes the `middle` result to be returned
          // `GreaterThan` causes recursion on the left of the middle
          // `LessThan` causes recursion on the right of the middle
          if (position < children[middle].end) {
            // first element whose end position is greater than the input position
            if (!children[middle - 1] || position >= children[middle - 1].end) {
              return 0 /* Comparison.EqualTo */;
            }
            return 1 /* Comparison.GreaterThan */;
          }
          return -1 /* Comparison.LessThan */;
        });
    if (i >= 0 && children[i]) {
      const child = children[i];
      // Note that the span of a node's tokens is [node.getStart(...), node.end).
      // Given that `position < child.end` and child has constituent tokens, we distinguish these cases:
      // 1) `position` precedes `child`'s tokens or `child` has no tokens (ie: in a comment or whitespace preceding `child`):
      // we need to find the last token in a previous child.
      // 2) `position` is within the same span: we recurse on `child`.
      if (position < child.end) {
        const start = child.getStart(sourceFile, /* includeJsDoc*/ !excludeJsdoc);
        const lookInPreviousChild = (start >= position) ||  // cursor in the leading trivia
            !nodeHasTokens(child, sourceFile) || isWhiteSpaceOnlyJsxText(child);
        if (lookInPreviousChild) {
          // actual start of the node is past the position - previous token should be at the end of previous child
          const candidate_1 =
              findRightmostChildNodeWithTokens(children, /* exclusiveStartPosition*/ i, sourceFile, n.kind);
          return candidate_1 && findRightmostToken(candidate_1, sourceFile);
        }
          // candidate should be in this node
          return find(child);

      }
    }
    ts.Debug.assert(
        startNode !== undefined || n.kind === 308 /* SyntaxKind.SourceFile */ ||
        n.kind === 1 /* SyntaxKind.EndOfFileToken */ || ts.isJSDocCommentContainingNode(n));
    // Here we know that none of child token nodes embrace the position,
    // the only known case is when position is at the end of the file.
    // Try to find the rightmost token in the file without filtering.
    // Namely we are skipping the check: 'position < node.end'
    const candidate =
        findRightmostChildNodeWithTokens(children, /* exclusiveStartPosition*/ children.length, sourceFile, n.kind);
    return candidate && findRightmostToken(candidate, sourceFile);
  }
}
ts.findPrecedingToken = findPrecedingToken;
function isNonWhitespaceToken(n) {
  return ts.isToken(n) && !isWhiteSpaceOnlyJsxText(n);
}
function findRightmostToken(n, sourceFile) {
  if (isNonWhitespaceToken(n)) {
    return n;
  }
  const children = n.getChildren(sourceFile);
  if (children.length === 0) {
    return n;
  }
  const candidate =
      findRightmostChildNodeWithTokens(children, /* exclusiveStartPosition*/ children.length, sourceFile, n.kind);
  return candidate && findRightmostToken(candidate, sourceFile);
}
/**
 * Finds the rightmost child to the left of `children[exclusiveStartPosition]` which is a non-all-whitespace token or has constituent tokens.
 */
function findRightmostChildNodeWithTokens(children, exclusiveStartPosition, sourceFile, parentKind) {
  for (let i = exclusiveStartPosition - 1; i >= 0; i--) {
    const child = children[i];
    if (isWhiteSpaceOnlyJsxText(child)) {
      if (i === 0 &&
          (parentKind === 11 /* SyntaxKind.JsxText */ || parentKind === 282 /* SyntaxKind.JsxSelfClosingElement */)) {
        ts.Debug.fail('`JsxText` tokens should not be the first child of `JsxElement | JsxSelfClosingElement`');
      }
    } else if (nodeHasTokens(children[i], sourceFile)) {
      return children[i];
    }
  }
}
function isInString(sourceFile, position, previousToken) {
  if (previousToken === void 0) {
    previousToken = findPrecedingToken(position, sourceFile);
  }
  if (previousToken && ts.isStringTextContainingNode(previousToken)) {
    const start = previousToken.getStart(sourceFile);
    const end = previousToken.getEnd();
    // To be "in" one of these literals, the position has to be:
    //   1. entirely within the token text.
    //   2. at the end position of an unterminated token.
    //   3. at the end of a regular expression (due to trailing flags like '/foo/g').
    if (start < position && position < end) {
      return true;
    }
    if (position === end) {
      return !!previousToken.isUnterminated;
    }
  }
  return false;
}
ts.isInString = isInString;
/**
 * returns true if the position is in between the open and close elements of an JSX expression.
 */
function isInsideJsxElementOrAttribute(sourceFile, position) {
  const token = getTokenAtPosition(sourceFile, position);
  if (!token) {
    return false;
  }
  if (token.kind === 11 /* SyntaxKind.JsxText */) {
    return true;
  }
  // <div>Hello |</div>
  if (token.kind === 29 /* SyntaxKind.LessThanToken */ && token.parent.kind === 11 /* SyntaxKind.JsxText */) {
    return true;
  }
  // <div> { | </div> or <div a={| </div>
  if (token.kind === 29 /* SyntaxKind.LessThanToken */ && token.parent.kind === 291 /* SyntaxKind.JsxExpression */) {
    return true;
  }
  // <div> {
  // |
  // } < /div>
  if (token && token.kind === 19 /* SyntaxKind.CloseBraceToken */ &&
      token.parent.kind === 291 /* SyntaxKind.JsxExpression */) {
    return true;
  }
  // <div>|</div>
  if (token.kind === 29 /* SyntaxKind.LessThanToken */ &&
      token.parent.kind === 284 /* SyntaxKind.JsxClosingElement */) {
    return true;
  }
  return false;
}
ts.isInsideJsxElementOrAttribute = isInsideJsxElementOrAttribute;
function isWhiteSpaceOnlyJsxText(node) {
  return ts.isJsxText(node) && node.containsOnlyTriviaWhiteSpaces;
}
function isInTemplateString(sourceFile, position) {
  const token = getTokenAtPosition(sourceFile, position);
  return ts.isTemplateLiteralKind(token.kind) && position > token.getStart(sourceFile);
}
ts.isInTemplateString = isInTemplateString;
function isInJSXText(sourceFile, position) {
  const token = getTokenAtPosition(sourceFile, position);
  if (ts.isJsxText(token)) {
    return true;
  }
  if (token.kind === 18 /* SyntaxKind.OpenBraceToken */ && ts.isJsxExpression(token.parent) &&
      ts.isJsxElement(token.parent.parent)) {
    return true;
  }
  if (token.kind === 29 /* SyntaxKind.LessThanToken */ && ts.isJsxOpeningLikeElement(token.parent) &&
      ts.isJsxElement(token.parent.parent)) {
    return true;
  }
  return false;
}
ts.isInJSXText = isInJSXText;
function isInsideJsxElement(sourceFile, position) {
  function isInsideJsxElementTraversal(node) {
    while (node) {
      if (node.kind >= 282 /* SyntaxKind.JsxSelfClosingElement */ && node.kind <= 291 /* SyntaxKind.JsxExpression */
          || node.kind === 11                                                         /* SyntaxKind.JsxText */
          || node.kind === 29                                                         /* SyntaxKind.LessThanToken */
          || node.kind === 31                                                         /* SyntaxKind.GreaterThanToken */
          || node.kind === 79                                                         /* SyntaxKind.Identifier */
          || node.kind === 19                                                         /* SyntaxKind.CloseBraceToken */
          || node.kind === 18                                                         /* SyntaxKind.OpenBraceToken */
          || node.kind === 43 /* SyntaxKind.SlashToken */) {
        node = node.parent;
      } else if (node.kind === 281 /* SyntaxKind.JsxElement */) {
        if (position > node.getStart(sourceFile))
          {return true;}
        node = node.parent;
      } else {
        return false;
      }
    }
    return false;
  }
  return isInsideJsxElementTraversal(getTokenAtPosition(sourceFile, position));
}
ts.isInsideJsxElement = isInsideJsxElement;
function findPrecedingMatchingToken(token, matchingTokenKind, sourceFile) {
  const closeTokenText = ts.tokenToString(token.kind);
  const matchingTokenText = ts.tokenToString(matchingTokenKind);
  const tokenFullStart = token.getFullStart();
  // Text-scan based fast path - can be bamboozled by comments and other trivia, but often provides
  // a good, fast approximation without too much extra work in the cases where it fails.
  const bestGuessIndex = sourceFile.text.lastIndexOf(matchingTokenText, tokenFullStart);
  if (bestGuessIndex === -1) {
    return undefined;  // if the token text doesn't appear in the file, there can't be a match - super fast bail
  }
  // we can only use the textual result directly if we didn't have to count any close tokens within the range
  if (sourceFile.text.lastIndexOf(closeTokenText, tokenFullStart - 1) < bestGuessIndex) {
    const nodeAtGuess = findPrecedingToken(bestGuessIndex + 1, sourceFile);
    if (nodeAtGuess && nodeAtGuess.kind === matchingTokenKind) {
      return nodeAtGuess;
    }
  }
  const tokenKind = token.kind;
  let remainingMatchingTokens = 0;
  while (true) {
    const preceding = findPrecedingToken(token.getFullStart(), sourceFile);
    if (!preceding) {
      return undefined;
    }
    token = preceding;
    if (token.kind === matchingTokenKind) {
      if (remainingMatchingTokens === 0) {
        return token;
      }
      remainingMatchingTokens--;
    } else if (token.kind === tokenKind) {
      remainingMatchingTokens++;
    }
  }
}
ts.findPrecedingMatchingToken = findPrecedingMatchingToken;
function removeOptionality(type, isOptionalExpression, isOptionalChain) {
  return isOptionalExpression ? type.getNonNullableType() : isOptionalChain ? type.getNonOptionalType() : type;
}
ts.removeOptionality = removeOptionality;
function isPossiblyTypeArgumentPosition(token, sourceFile, checker) {
  const info = getPossibleTypeArgumentsInfo(token, sourceFile);
  return info !== undefined &&
      (ts.isPartOfTypeNode(info.called) ||
       getPossibleGenericSignatures(info.called, info.nTypeArguments, checker).length !== 0 ||
       isPossiblyTypeArgumentPosition(info.called, sourceFile, checker));
}
ts.isPossiblyTypeArgumentPosition = isPossiblyTypeArgumentPosition;
function getPossibleGenericSignatures(called, typeArgumentCount, checker) {
  let type = checker.getTypeAtLocation(called);
  if (ts.isOptionalChain(called.parent)) {
    type = removeOptionality(type, ts.isOptionalChainRoot(called.parent), /* isOptionalChain*/ true);
  }
  const signatures = ts.isNewExpression(called.parent) ? type.getConstructSignatures() : type.getCallSignatures();
  return signatures.filter(function(candidate) {
    return !!candidate.typeParameters && candidate.typeParameters.length >= typeArgumentCount;
  });
}
ts.getPossibleGenericSignatures = getPossibleGenericSignatures;
// Get info for an expression like `f <` that may be the start of type arguments.
function getPossibleTypeArgumentsInfo(tokenIn, sourceFile) {
  // This is a rare case, but one that saves on a _lot_ of work if true - if the source file has _no_ `<` character,
  // then there obviously can't be any type arguments - no expensive brace-matching backwards scanning required
  if (sourceFile.text.lastIndexOf('<', tokenIn ? tokenIn.pos : sourceFile.text.length) === -1) {
    return undefined;
  }
  let token = tokenIn;
  // This function determines if the node could be type argument position
  // Since during editing, when type argument list is not complete,
  // the tree could be of any shape depending on the tokens parsed before current node,
  // scanning of the previous identifier followed by "<" before current node would give us better result
  // Note that we also balance out the already provided type arguments, arrays, object literals while doing so
  let remainingLessThanTokens = 0;
  let nTypeArguments = 0;
  while (token) {
    switch (token.kind) {
      case 29 /* SyntaxKind.LessThanToken */:
        // Found the beginning of the generic argument expression
        token = findPrecedingToken(token.getFullStart(), sourceFile);
        if (token && token.kind === 28 /* SyntaxKind.QuestionDotToken */) {
          token = findPrecedingToken(token.getFullStart(), sourceFile);
        }
        if (!token || !ts.isIdentifier(token))
          {return undefined;}
        if (!remainingLessThanTokens) {
          return ts.isDeclarationName(token) ? undefined : {called: token, nTypeArguments};
        }
        remainingLessThanTokens--;
        break;
      case 49 /* SyntaxKind.GreaterThanGreaterThanGreaterThanToken */:
        remainingLessThanTokens = +3;
        break;
      case 48 /* SyntaxKind.GreaterThanGreaterThanToken */:
        remainingLessThanTokens = +2;
        break;
      case 31 /* SyntaxKind.GreaterThanToken */:
        remainingLessThanTokens++;
        break;
      case 19 /* SyntaxKind.CloseBraceToken */:
        // This can be object type, skip until we find the matching open brace token
        // Skip until the matching open brace token
        token = findPrecedingMatchingToken(token, 18 /* SyntaxKind.OpenBraceToken */, sourceFile);
        if (!token)
          {return undefined;}
        break;
      case 21 /* SyntaxKind.CloseParenToken */:
        // This can be object type, skip until we find the matching open brace token
        // Skip until the matching open brace token
        token = findPrecedingMatchingToken(token, 20 /* SyntaxKind.OpenParenToken */, sourceFile);
        if (!token)
          {return undefined;}
        break;
      case 23 /* SyntaxKind.CloseBracketToken */:
        // This can be object type, skip until we find the matching open brace token
        // Skip until the matching open brace token
        token = findPrecedingMatchingToken(token, 22 /* SyntaxKind.OpenBracketToken */, sourceFile);
        if (!token)
          {return undefined;}
        break;
      // Valid tokens in a type name. Skip.
      case 27 /* SyntaxKind.CommaToken */:
        nTypeArguments++;
        break;
      case 38 /* SyntaxKind.EqualsGreaterThanToken */:
      // falls through
      case 79 /* SyntaxKind.Identifier */:
      case 10 /* SyntaxKind.StringLiteral */:
      case 8 /* SyntaxKind.NumericLiteral */:
      case 9 /* SyntaxKind.BigIntLiteral */:
      case 110 /* SyntaxKind.TrueKeyword */:
      case 95 /* SyntaxKind.FalseKeyword */:
      // falls through
      case 112 /* SyntaxKind.TypeOfKeyword */:
      case 94 /* SyntaxKind.ExtendsKeyword */:
      case 141 /* SyntaxKind.KeyOfKeyword */:
      case 24 /* SyntaxKind.DotToken */:
      case 51 /* SyntaxKind.BarToken */:
      case 57 /* SyntaxKind.QuestionToken */:
      case 58 /* SyntaxKind.ColonToken */:
        break;
      default:
        if (ts.isTypeNode(token)) {
          break;
        }
        // Invalid token in type
        return undefined;
    }
    token = findPrecedingToken(token.getFullStart(), sourceFile);
  }
  return undefined;
}
ts.getPossibleTypeArgumentsInfo = getPossibleTypeArgumentsInfo;
/**
 * Returns true if the cursor at position in sourceFile is within a comment.
 *
 * @param tokenAtPosition Must equal `getTokenAtPosition(sourceFile, position)`
 * @param predicate Additional predicate to test on the comment range.
 */
function isInComment(sourceFile, position, tokenAtPosition) {
  return ts.formatting.getRangeOfEnclosingComment(sourceFile, position, /* precedingToken*/ undefined, tokenAtPosition);
}
ts.isInComment = isInComment;
function hasDocComment(sourceFile, position) {
  const token = getTokenAtPosition(sourceFile, position);
  return !!ts.findAncestor(token, ts.isJSDoc);
}
ts.hasDocComment = hasDocComment;
function nodeHasTokens(n, sourceFile) {
  // If we have a token or node that has a non-zero width, it must have tokens.
  // Note: getWidth() does not take trivia into account.
  return n.kind === 1 /* SyntaxKind.EndOfFileToken */ ? !!n.jsDoc : n.getWidth(sourceFile) !== 0;
}
function getNodeModifiers(node, excludeFlags) {
  if (excludeFlags === void 0) {
    excludeFlags = 0 /* ModifierFlags.None */;
  }
  const result = [];
  const flags = ts.isDeclaration(node) ? ts.getCombinedNodeFlagsAlwaysIncludeJSDoc(node) & ~excludeFlags :
                                       0 /* ModifierFlags.None */;
  if (flags & 8 /* ModifierFlags.Private */)
    {result.push('private' /* ScriptElementKindModifier.privateMemberModifier */);}
  if (flags & 16 /* ModifierFlags.Protected */)
    {result.push('protected' /* ScriptElementKindModifier.protectedMemberModifier */);}
  if (flags & 4 /* ModifierFlags.Public */)
    {result.push('public' /* ScriptElementKindModifier.publicMemberModifier */);}
  if (flags & 32 /* ModifierFlags.Static */ || ts.isClassStaticBlockDeclaration(node))
    {result.push('static' /* ScriptElementKindModifier.staticModifier */);}
  if (flags & 256 /* ModifierFlags.Abstract */)
    {result.push('abstract' /* ScriptElementKindModifier.abstractModifier */);}
  if (flags & 1 /* ModifierFlags.Export */)
    {result.push('export' /* ScriptElementKindModifier.exportedModifier */);}
  if (flags & 8192 /* ModifierFlags.Deprecated */)
    {result.push('deprecated' /* ScriptElementKindModifier.deprecatedModifier */);}
  if (node.flags & 16777216 /* NodeFlags.Ambient */)
    {result.push('declare' /* ScriptElementKindModifier.ambientModifier */);}
  if (node.kind === 274 /* SyntaxKind.ExportAssignment */)
    {result.push('export' /* ScriptElementKindModifier.exportedModifier */);}
  return result.length > 0 ? result.join(',') : '' /* ScriptElementKindModifier.none */;
}
ts.getNodeModifiers = getNodeModifiers;
function getTypeArgumentOrTypeParameterList(node) {
  if (node.kind === 180 /* SyntaxKind.TypeReference */ || node.kind === 210 /* SyntaxKind.CallExpression */) {
    return node.typeArguments;
  }
  if (ts.isFunctionLike(node) || node.kind === 260 /* SyntaxKind.ClassDeclaration */ ||
      node.kind === 261 /* SyntaxKind.InterfaceDeclaration */) {
    return node.typeParameters;
  }
  return undefined;
}
ts.getTypeArgumentOrTypeParameterList = getTypeArgumentOrTypeParameterList;
function isComment(kind) {
  return kind === 2 /* SyntaxKind.SingleLineCommentTrivia */ || kind === 3 /* SyntaxKind.MultiLineCommentTrivia */;
}
ts.isComment = isComment;
function isStringOrRegularExpressionOrTemplateLiteral(kind) {
  if (kind === 10    /* SyntaxKind.StringLiteral */
      || kind === 13 /* SyntaxKind.RegularExpressionLiteral */
      || ts.isTemplateLiteralKind(kind)) {
    return true;
  }
  return false;
}
ts.isStringOrRegularExpressionOrTemplateLiteral = isStringOrRegularExpressionOrTemplateLiteral;
function isPunctuation(kind) {
  return 18 /* SyntaxKind.FirstPunctuation */ <= kind && kind <= 78 /* SyntaxKind.LastPunctuation */;
}
ts.isPunctuation = isPunctuation;
function isInsideTemplateLiteral(node, position, sourceFile) {
  return ts.isTemplateLiteralKind(node.kind) && (node.getStart(sourceFile) < position && position < node.end) ||
      (!!node.isUnterminated && position === node.end);
}
ts.isInsideTemplateLiteral = isInsideTemplateLiteral;
function isAccessibilityModifier(kind) {
  switch (kind) {
    case 123 /* SyntaxKind.PublicKeyword */:
    case 121 /* SyntaxKind.PrivateKeyword */:
    case 122 /* SyntaxKind.ProtectedKeyword */:
      return true;
  }
  return false;
}
ts.isAccessibilityModifier = isAccessibilityModifier;
function cloneCompilerOptions(options) {
  const result = ts.clone(options);
  ts.setConfigFileInOptions(result, options && options.configFile);
  return result;
}
ts.cloneCompilerOptions = cloneCompilerOptions;
function isArrayLiteralOrObjectLiteralDestructuringPattern(node) {
  if (node.kind === 206 /* SyntaxKind.ArrayLiteralExpression */ ||
      node.kind === 207 /* SyntaxKind.ObjectLiteralExpression */) {
    // [a,b,c] from:
    // [a, b, c] = someExpression;
    if (node.parent.kind === 223 /* SyntaxKind.BinaryExpression */ && node.parent.left === node &&
        node.parent.operatorToken.kind === 63 /* SyntaxKind.EqualsToken */) {
      return true;
    }
    // [a, b, c] from:
    // for([a, b, c] of expression)
    if (node.parent.kind === 247 /* SyntaxKind.ForOfStatement */ && node.parent.initializer === node) {
      return true;
    }
    // [a, b, c] of
    // [x, [a, b, c] ] = someExpression
    // or
    // {x, a: {a, b, c} } = someExpression
    if (isArrayLiteralOrObjectLiteralDestructuringPattern(
            node.parent.kind === 299 /* SyntaxKind.PropertyAssignment */ ? node.parent.parent : node.parent)) {
      return true;
    }
  }
  return false;
}
ts.isArrayLiteralOrObjectLiteralDestructuringPattern = isArrayLiteralOrObjectLiteralDestructuringPattern;
function isInReferenceComment(sourceFile, position) {
  return isInReferenceCommentWorker(sourceFile, position, /* shouldBeReference*/ true);
}
ts.isInReferenceComment = isInReferenceComment;
function isInNonReferenceComment(sourceFile, position) {
  return isInReferenceCommentWorker(sourceFile, position, /* shouldBeReference*/ false);
}
ts.isInNonReferenceComment = isInNonReferenceComment;
function isInReferenceCommentWorker(sourceFile, position, shouldBeReference) {
  const range = isInComment(sourceFile, position, /* tokenAtPosition*/ undefined);
  return !!range &&
      shouldBeReference === tripleSlashDirectivePrefixRegex.test(sourceFile.text.substring(range.pos, range.end));
}
function getReplacementSpanForContextToken(contextToken) {
  if (!contextToken)
    {return undefined;}
  switch (contextToken.kind) {
    case 10 /* SyntaxKind.StringLiteral */:
    case 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */:
      return createTextSpanFromStringLiteralLikeContent(contextToken);
    default:
      return createTextSpanFromNode(contextToken);
  }
}
ts.getReplacementSpanForContextToken = getReplacementSpanForContextToken;
function createTextSpanFromNode(node, sourceFile, endNode) {
  return ts.createTextSpanFromBounds(node.getStart(sourceFile), (endNode || node).getEnd());
}
ts.createTextSpanFromNode = createTextSpanFromNode;
function createTextSpanFromStringLiteralLikeContent(node) {
  if (node.isUnterminated)
    {return undefined;}
  return ts.createTextSpanFromBounds(node.getStart() + 1, node.getEnd() - 1);
}
ts.createTextSpanFromStringLiteralLikeContent = createTextSpanFromStringLiteralLikeContent;
function createTextRangeFromNode(node, sourceFile) {
  return ts.createRange(node.getStart(sourceFile), node.end);
}
ts.createTextRangeFromNode = createTextRangeFromNode;
function createTextSpanFromRange(range) {
  return ts.createTextSpanFromBounds(range.pos, range.end);
}
ts.createTextSpanFromRange = createTextSpanFromRange;
function createTextRangeFromSpan(span) {
  return ts.createRange(span.start, span.start + span.length);
}
ts.createTextRangeFromSpan = createTextRangeFromSpan;
function createTextChangeFromStartLength(start, length, newText) {
  return createTextChange(ts.createTextSpan(start, length), newText);
}
ts.createTextChangeFromStartLength = createTextChangeFromStartLength;
function createTextChange(span, newText) {
  return {span, newText};
}
ts.createTextChange = createTextChange;
ts.typeKeywords = [
  131 /* SyntaxKind.AnyKeyword */,     129 /* SyntaxKind.AssertsKeyword */,   160 /* SyntaxKind.BigIntKeyword */,
  134 /* SyntaxKind.BooleanKeyword */, 95 /* SyntaxKind.FalseKeyword */,      138 /* SyntaxKind.InferKeyword */,
  141 /* SyntaxKind.KeyOfKeyword */,   144 /* SyntaxKind.NeverKeyword */,     104 /* SyntaxKind.NullKeyword */,
  148 /* SyntaxKind.NumberKeyword */,  149 /* SyntaxKind.ObjectKeyword */,    146 /* SyntaxKind.ReadonlyKeyword */,
  152 /* SyntaxKind.StringKeyword */,  153 /* SyntaxKind.SymbolKeyword */,    110 /* SyntaxKind.TrueKeyword */,
  114 /* SyntaxKind.VoidKeyword */,    155 /* SyntaxKind.UndefinedKeyword */, 156 /* SyntaxKind.UniqueKeyword */,
  157 /* SyntaxKind.UnknownKeyword */,
];
function isTypeKeyword(kind) {
  return ts.contains(ts.typeKeywords, kind);
}
ts.isTypeKeyword = isTypeKeyword;
function isTypeKeywordToken(node) {
  return node.kind === 154 /* SyntaxKind.TypeKeyword */;
}
ts.isTypeKeywordToken = isTypeKeywordToken;
function isTypeKeywordTokenOrIdentifier(node) {
  return isTypeKeywordToken(node) || ts.isIdentifier(node) && node.text === 'type';
}
ts.isTypeKeywordTokenOrIdentifier = isTypeKeywordTokenOrIdentifier;
/** True if the symbol is for an external module, as opposed to a namespace. */
function isExternalModuleSymbol(moduleSymbol) {
  return !!(moduleSymbol.flags & 1536 /* SymbolFlags.Module */) &&
      moduleSymbol.name.charCodeAt(0) === 34 /* CharacterCodes.doubleQuote */;
}
ts.isExternalModuleSymbol = isExternalModuleSymbol;
function nodeSeenTracker() {
  const seen = [];
  return function(node) {
    const id = ts.getNodeId(node);
    return !seen[id] && (seen[id] = true);
  };
}
ts.nodeSeenTracker = nodeSeenTracker;
function getSnapshotText(snap) {
  return snap.getText(0, snap.getLength());
}
ts.getSnapshotText = getSnapshotText;
function repeatString(str, count) {
  let result = '';
  for (let i = 0; i < count; i++) {
    result += str;
  }
  return result;
}
ts.repeatString = repeatString;
function skipConstraint(type) {
  return type.isTypeParameter() ? type.getConstraint() || type : type;
}
ts.skipConstraint = skipConstraint;
function getNameFromPropertyName(name) {
  return name.kind === 164 /* SyntaxKind.ComputedPropertyName */
      // treat computed property names where expression is string/numeric literal as just string/numeric literal
      ?
      ts.isStringOrNumericLiteralLike(name.expression) ? name.expression.text : undefined :
      ts.isPrivateIdentifier(name) ? ts.idText(name) : ts.getTextOfIdentifierOrLiteral(name);
}
ts.getNameFromPropertyName = getNameFromPropertyName;
function programContainsModules(program) {
  return program.getSourceFiles().some(function(s) {
    return !s.isDeclarationFile && !program.isSourceFileFromExternalLibrary(s) &&
        !!(s.externalModuleIndicator || s.commonJsModuleIndicator);
  });
}
ts.programContainsModules = programContainsModules;
function programContainsEsModules(program) {
  return program.getSourceFiles().some(function(s) {
    return !s.isDeclarationFile && !program.isSourceFileFromExternalLibrary(s) && !!s.externalModuleIndicator;
  });
}
ts.programContainsEsModules = programContainsEsModules;
function compilerOptionsIndicateEsModules(compilerOptions) {
  return !!compilerOptions.module || ts.getEmitScriptTarget(compilerOptions) >= 2 /* ScriptTarget.ES2015 */ ||
      !!compilerOptions.noEmit;
}
ts.compilerOptionsIndicateEsModules = compilerOptionsIndicateEsModules;
function createModuleSpecifierResolutionHost(program, host) {
  // Mix in `getSymlinkCache` from Program when host doesn't have it
  // in order for non-Project hosts to have a symlinks cache.
  return {
    fileExists: function(fileName) {
      return program.fileExists(fileName);
    },
    getCurrentDirectory: function() {
      return host.getCurrentDirectory();
    },
    readFile: ts.maybeBind(host, host.readFile),
    useCaseSensitiveFileNames: ts.maybeBind(host, host.useCaseSensitiveFileNames),
    getSymlinkCache: ts.maybeBind(host, host.getSymlinkCache) || program.getSymlinkCache,
    getModuleSpecifierCache: ts.maybeBind(host, host.getModuleSpecifierCache),
    getPackageJsonInfoCache: function() {
      let _a;
      return (_a = program.getModuleResolutionCache()) === null || _a === void 0 ? void 0 :
                                                                                   _a.getPackageJsonInfoCache();
    },
    getGlobalTypingsCacheLocation: ts.maybeBind(host, host.getGlobalTypingsCacheLocation),
    redirectTargetsMap: program.redirectTargetsMap,
    getProjectReferenceRedirect: function(fileName) {
      return program.getProjectReferenceRedirect(fileName);
    },
    isSourceOfProjectReferenceRedirect: function(fileName) {
      return program.isSourceOfProjectReferenceRedirect(fileName);
    },
    getNearestAncestorDirectoryWithPackageJson: ts.maybeBind(host, host.getNearestAncestorDirectoryWithPackageJson),
    getFileIncludeReasons: function() {
      return program.getFileIncludeReasons();
    },
  };
}
ts.createModuleSpecifierResolutionHost = createModuleSpecifierResolutionHost;
function getModuleSpecifierResolverHost(program, host) {
  return __assign(__assign({}, createModuleSpecifierResolutionHost(program, host)), {
    getCommonSourceDirectory: function() {
      return program.getCommonSourceDirectory();
    }
  });
}
ts.getModuleSpecifierResolverHost = getModuleSpecifierResolverHost;
function moduleResolutionRespectsExports(moduleResolution) {
  return moduleResolution >= ts.ModuleResolutionKind.Node16 && moduleResolution <= ts.ModuleResolutionKind.NodeNext;
}
ts.moduleResolutionRespectsExports = moduleResolutionRespectsExports;
function moduleResolutionUsesNodeModules(moduleResolution) {
  return moduleResolution === ts.ModuleResolutionKind.NodeJs ||
      moduleResolution >= ts.ModuleResolutionKind.Node16 && moduleResolution <= ts.ModuleResolutionKind.NodeNext;
}
ts.moduleResolutionUsesNodeModules = moduleResolutionUsesNodeModules;
function makeImportIfNecessary(defaultImport, namedImports, moduleSpecifier, quotePreference) {
  return defaultImport || namedImports && namedImports.length ?
      makeImport(defaultImport, namedImports, moduleSpecifier, quotePreference) :
      undefined;
}
ts.makeImportIfNecessary = makeImportIfNecessary;
function makeImport(defaultImport, namedImports, moduleSpecifier, quotePreference, isTypeOnly) {
  return ts.factory.createImportDeclaration(
      /* modifiers*/ undefined,
      defaultImport || namedImports ?
          ts.factory.createImportClause(
              !!isTypeOnly, defaultImport,
              namedImports && namedImports.length ? ts.factory.createNamedImports(namedImports) : undefined) :
          undefined,
      typeof moduleSpecifier === 'string' ? makeStringLiteral(moduleSpecifier, quotePreference) : moduleSpecifier,
      /* assertClause*/ undefined);
}
ts.makeImport = makeImport;
function makeStringLiteral(text, quotePreference) {
  return ts.factory.createStringLiteral(text, quotePreference === 0 /* QuotePreference.Single */);
}
ts.makeStringLiteral = makeStringLiteral;
let QuotePreference;
(function(QuotePreference) {
QuotePreference[QuotePreference['Single'] = 0] = 'Single';
QuotePreference[QuotePreference['Double'] = 1] = 'Double';
})(QuotePreference = ts.QuotePreference || (ts.QuotePreference = {}));
function quotePreferenceFromString(str, sourceFile) {
  return ts.isStringDoubleQuoted(str, sourceFile) ? 1 /* QuotePreference.Double */ : 0 /* QuotePreference.Single */;
}
ts.quotePreferenceFromString = quotePreferenceFromString;
function getQuotePreference(sourceFile, preferences) {
  if (preferences.quotePreference && preferences.quotePreference !== 'auto') {
    return preferences.quotePreference === 'single' ? 0 /* QuotePreference.Single */ : 1 /* QuotePreference.Double */;
  }
    // ignore synthetic import added when importHelpers: true
    const firstModuleSpecifier = sourceFile.imports && ts.find(sourceFile.imports, function(n) {
      return ts.isStringLiteral(n) && !ts.nodeIsSynthesized(n.parent);
    });
    return firstModuleSpecifier ? quotePreferenceFromString(firstModuleSpecifier, sourceFile) :
                                  1 /* QuotePreference.Double */;

}
ts.getQuotePreference = getQuotePreference;
function getQuoteFromPreference(qp) {
  switch (qp) {
    case 0 /* QuotePreference.Single */:
      return '\'';
    case 1 /* QuotePreference.Double */:
      return '"';
    default:
      return ts.Debug.assertNever(qp);
  }
}
ts.getQuoteFromPreference = getQuoteFromPreference;
function symbolNameNoDefault(symbol) {
  const escaped = symbolEscapedNameNoDefault(symbol);
  return escaped === undefined ? undefined : ts.unescapeLeadingUnderscores(escaped);
}
ts.symbolNameNoDefault = symbolNameNoDefault;
function symbolEscapedNameNoDefault(symbol) {
  if (symbol.escapedName !== 'default' /* InternalSymbolName.Default */) {
    return symbol.escapedName;
  }
  return ts.firstDefined(symbol.declarations, function(decl) {
    const name = ts.getNameOfDeclaration(decl);
    return name && name.kind === 79 /* SyntaxKind.Identifier */ ? name.escapedText : undefined;
  });
}
ts.symbolEscapedNameNoDefault = symbolEscapedNameNoDefault;
function isModuleSpecifierLike(node) {
  return ts.isStringLiteralLike(node) &&
      (ts.isExternalModuleReference(node.parent) || ts.isImportDeclaration(node.parent) ||
       ts.isRequireCall(node.parent, /* requireStringLiteralLikeArgument*/ false) && node.parent.arguments[0] === node ||
       ts.isImportCall(node.parent) && node.parent.arguments[0] === node);
}
ts.isModuleSpecifierLike = isModuleSpecifierLike;
function isObjectBindingElementWithoutPropertyName(bindingElement) {
  return ts.isBindingElement(bindingElement) && ts.isObjectBindingPattern(bindingElement.parent) &&
      ts.isIdentifier(bindingElement.name) && !bindingElement.propertyName;
}
ts.isObjectBindingElementWithoutPropertyName = isObjectBindingElementWithoutPropertyName;
function getPropertySymbolFromBindingElement(checker, bindingElement) {
  const typeOfPattern = checker.getTypeAtLocation(bindingElement.parent);
  return typeOfPattern && checker.getPropertyOfType(typeOfPattern, bindingElement.name.text);
}
ts.getPropertySymbolFromBindingElement = getPropertySymbolFromBindingElement;
function getParentNodeInSpan(node, file, span) {
  if (!node)
    {return undefined;}
  while (node.parent) {
    if (ts.isSourceFile(node.parent) || !spanContainsNode(span, node.parent, file)) {
      return node;
    }
    node = node.parent;
  }
}
ts.getParentNodeInSpan = getParentNodeInSpan;
function spanContainsNode(span, node, file) {
  return ts.textSpanContainsPosition(span, node.getStart(file)) && node.getEnd() <= ts.textSpanEnd(span);
}
function findModifier(node, kind) {
  return ts.canHaveModifiers(node) ? ts.find(node.modifiers, function(m) {
    return m.kind === kind;
  }) : undefined;
}
ts.findModifier = findModifier;
function insertImports(changes, sourceFile, imports, blankLineBetween) {
  const decl = ts.isArray(imports) ? imports[0] : imports;
  const importKindPredicate =
      decl.kind === 240 /* SyntaxKind.VariableStatement */ ? ts.isRequireVariableStatement : ts.isAnyImportSyntax;
  const existingImportStatements = ts.filter(sourceFile.statements, importKindPredicate);
  const sortedNewImports =
      ts.isArray(imports) ? ts.stableSort(imports, ts.OrganizeImports.compareImportsOrRequireStatements) : [imports];
  if (!existingImportStatements.length) {
    changes.insertNodesAtTopOfFile(sourceFile, sortedNewImports, blankLineBetween);
  } else if (existingImportStatements && ts.OrganizeImports.importsAreSorted(existingImportStatements)) {
    for (let _i = 0, sortedNewImports_1 = sortedNewImports; _i < sortedNewImports_1.length; _i++) {
      const newImport = sortedNewImports_1[_i];
      const insertionIndex = ts.OrganizeImports.getImportDeclarationInsertionIndex(existingImportStatements, newImport);
      if (insertionIndex === 0) {
        // If the first import is top-of-file, insert after the leading comment which is likely the header.
        const options = existingImportStatements[0] === sourceFile.statements[0] ?
            {leadingTriviaOption: ts.textChanges.LeadingTriviaOption.Exclude} :
            {};
        changes.insertNodeBefore(
            sourceFile, existingImportStatements[0], newImport, /* blankLineBetween*/ false, options);
      } else {
        const prevImport = existingImportStatements[insertionIndex - 1];
        changes.insertNodeAfter(sourceFile, prevImport, newImport);
      }
    }
  } else {
    const lastExistingImport = ts.lastOrUndefined(existingImportStatements);
    if (lastExistingImport) {
      changes.insertNodesAfter(sourceFile, lastExistingImport, sortedNewImports);
    } else {
      changes.insertNodesAtTopOfFile(sourceFile, sortedNewImports, blankLineBetween);
    }
  }
}
ts.insertImports = insertImports;
function getTypeKeywordOfTypeOnlyImport(importClause, sourceFile) {
  ts.Debug.assert(importClause.isTypeOnly);
  return ts.cast(importClause.getChildAt(0, sourceFile), isTypeKeywordToken);
}
ts.getTypeKeywordOfTypeOnlyImport = getTypeKeywordOfTypeOnlyImport;
function textSpansEqual(a, b) {
  return !!a && !!b && a.start === b.start && a.length === b.length;
}
ts.textSpansEqual = textSpansEqual;
function documentSpansEqual(a, b) {
  return a.fileName === b.fileName && textSpansEqual(a.textSpan, b.textSpan);
}
ts.documentSpansEqual = documentSpansEqual;
/**
 * Iterates through 'array' by index and performs the callback on each element of array until the callback
 * returns a truthy value, then returns that value.
 * If no such value is found, the callback is applied to each element of array and undefined is returned.
 */
function forEachUnique(array, callback) {
  if (array) {
    for (let i = 0; i < array.length; i++) {
      if (array.indexOf(array[i]) === i) {
        const result = callback(array[i], i);
        if (result) {
          return result;
        }
      }
    }
  }
  return undefined;
}
ts.forEachUnique = forEachUnique;
function isTextWhiteSpaceLike(text, startPos, endPos) {
  for (let i = startPos; i < endPos; i++) {
    if (!ts.isWhiteSpaceLike(text.charCodeAt(i))) {
      return false;
    }
  }
  return true;
}
ts.isTextWhiteSpaceLike = isTextWhiteSpaceLike;
function getMappedLocation(location, sourceMapper, fileExists) {
  const mapsTo = sourceMapper.tryGetSourcePosition(location);
  return mapsTo && (!fileExists || fileExists(ts.normalizePath(mapsTo.fileName)) ? mapsTo : undefined);
}
ts.getMappedLocation = getMappedLocation;
function getMappedDocumentSpan(documentSpan, sourceMapper, fileExists) {
  const fileName = documentSpan.fileName, textSpan = documentSpan.textSpan;
  const newPosition = getMappedLocation({fileName, pos: textSpan.start}, sourceMapper, fileExists);
  if (!newPosition)
    {return undefined;}
  const newEndPosition =
      getMappedLocation({fileName, pos: textSpan.start + textSpan.length}, sourceMapper, fileExists);
  const newLength = newEndPosition ? newEndPosition.pos - newPosition.pos : textSpan.length;  // This shouldn't happen
  return {
    fileName: newPosition.fileName,
    textSpan: {
      start: newPosition.pos,
      length: newLength,
    },
    originalFileName: documentSpan.fileName,
    originalTextSpan: documentSpan.textSpan,
    contextSpan: getMappedContextSpan(documentSpan, sourceMapper, fileExists),
    originalContextSpan: documentSpan.contextSpan
  };
}
ts.getMappedDocumentSpan = getMappedDocumentSpan;
function getMappedContextSpan(documentSpan, sourceMapper, fileExists) {
  const contextSpanStart = documentSpan.contextSpan &&
      getMappedLocation({fileName: documentSpan.fileName, pos: documentSpan.contextSpan.start}, sourceMapper,
                        fileExists);
  const contextSpanEnd =
      documentSpan.contextSpan &&
      getMappedLocation(
          {fileName: documentSpan.fileName, pos: documentSpan.contextSpan.start + documentSpan.contextSpan.length},
          sourceMapper, fileExists);
  return contextSpanStart && contextSpanEnd ?
      {start: contextSpanStart.pos, length: contextSpanEnd.pos - contextSpanStart.pos} :
      undefined;
}
ts.getMappedContextSpan = getMappedContextSpan;
// #endregion
// Display-part writer helpers
// #region
function isFirstDeclarationOfSymbolParameter(symbol) {
  const declaration = symbol.declarations ? ts.firstOrUndefined(symbol.declarations) : undefined;
  return !!ts.findAncestor(declaration, function(n) {
    return ts.isParameter(n)                                                                  ? true :
        ts.isBindingElement(n) || ts.isObjectBindingPattern(n) || ts.isArrayBindingPattern(n) ? false :
                                                                                                'quit';
  });
}
ts.isFirstDeclarationOfSymbolParameter = isFirstDeclarationOfSymbolParameter;
const displayPartWriter = getDisplayPartWriter();
function getDisplayPartWriter() {
  const absoluteMaximumLength = ts.defaultMaximumTruncationLength *
      10;  // A hard cutoff to avoid overloading the messaging channel in worst-case scenarios
  let displayParts;
  let lineStart;
  let indent;
  let length;
  resetWriter();
  const unknownWrite = function(text) {
    return writeKind(text, ts.SymbolDisplayPartKind.text);
  };
  return {
    displayParts: function() {
      const finalText = displayParts.length && displayParts[displayParts.length - 1].text;
      if (length > absoluteMaximumLength && finalText && finalText !== '...') {
        if (!ts.isWhiteSpaceLike(finalText.charCodeAt(finalText.length - 1))) {
          displayParts.push(displayPart(' ', ts.SymbolDisplayPartKind.space));
        }
        displayParts.push(displayPart('...', ts.SymbolDisplayPartKind.punctuation));
      }
      return displayParts;
    },
    writeKeyword: function(text) {
      return writeKind(text, ts.SymbolDisplayPartKind.keyword);
    },
    writeOperator: function(text) {
      return writeKind(text, ts.SymbolDisplayPartKind.operator);
    },
    writePunctuation: function(text) {
      return writeKind(text, ts.SymbolDisplayPartKind.punctuation);
    },
    writeTrailingSemicolon: function(text) {
      return writeKind(text, ts.SymbolDisplayPartKind.punctuation);
    },
    writeSpace: function(text) {
      return writeKind(text, ts.SymbolDisplayPartKind.space);
    },
    writeStringLiteral: function(text) {
      return writeKind(text, ts.SymbolDisplayPartKind.stringLiteral);
    },
    writeParameter: function(text) {
      return writeKind(text, ts.SymbolDisplayPartKind.parameterName);
    },
    writeProperty: function(text) {
      return writeKind(text, ts.SymbolDisplayPartKind.propertyName);
    },
    writeLiteral: function(text) {
      return writeKind(text, ts.SymbolDisplayPartKind.stringLiteral);
    },
    writeSymbol,
    writeLine,
    write: unknownWrite,
    writeComment: unknownWrite,
    getText: function() {
      return '';
    },
    getTextPos: function() {
      return 0;
    },
    getColumn: function() {
      return 0;
    },
    getLine: function() {
      return 0;
    },
    isAtStartOfLine: function() {
      return false;
    },
    hasTrailingWhitespace: function() {
      return false;
    },
    hasTrailingComment: function() {
      return false;
    },
    rawWrite: ts.notImplemented,
    getIndent: function() {
      return indent;
    },
    increaseIndent: function() {
      indent++;
    },
    decreaseIndent: function() {
      indent--;
    },
    clear: resetWriter,
    trackSymbol: function() {
      return false;
    },
    reportInaccessibleThisError: ts.noop,
    reportInaccessibleUniqueSymbolError: ts.noop,
    reportPrivateInBaseOfClassExpression: ts.noop,
  };
  function writeIndent() {
    if (length > absoluteMaximumLength)
      {return;}
    if (lineStart) {
      const indentString = ts.getIndentString(indent);
      if (indentString) {
        length += indentString.length;
        displayParts.push(displayPart(indentString, ts.SymbolDisplayPartKind.space));
      }
      lineStart = false;
    }
  }
  function writeKind(text, kind) {
    if (length > absoluteMaximumLength)
      {return;}
    writeIndent();
    length += text.length;
    displayParts.push(displayPart(text, kind));
  }
  function writeSymbol(text, symbol) {
    if (length > absoluteMaximumLength)
      {return;}
    writeIndent();
    length += text.length;
    displayParts.push(symbolPart(text, symbol));
  }
  function writeLine() {
    if (length > absoluteMaximumLength)
      {return;}
    length += 1;
    displayParts.push(lineBreakPart());
    lineStart = true;
  }
  function resetWriter() {
    displayParts = [];
    lineStart = true;
    indent = 0;
    length = 0;
  }
}
function symbolPart(text, symbol) {
  return displayPart(text, displayPartKind(symbol));
  function displayPartKind(symbol) {
    const flags = symbol.flags;
    if (flags & 3 /* SymbolFlags.Variable */) {
      return isFirstDeclarationOfSymbolParameter(symbol) ? ts.SymbolDisplayPartKind.parameterName :
                                                           ts.SymbolDisplayPartKind.localName;
    }
    if (flags & 4 /* SymbolFlags.Property */)
      {return ts.SymbolDisplayPartKind.propertyName;}
    if (flags & 32768 /* SymbolFlags.GetAccessor */)
      {return ts.SymbolDisplayPartKind.propertyName;}
    if (flags & 65536 /* SymbolFlags.SetAccessor */)
      {return ts.SymbolDisplayPartKind.propertyName;}
    if (flags & 8 /* SymbolFlags.EnumMember */)
      {return ts.SymbolDisplayPartKind.enumMemberName;}
    if (flags & 16 /* SymbolFlags.Function */)
      {return ts.SymbolDisplayPartKind.functionName;}
    if (flags & 32 /* SymbolFlags.Class */)
      {return ts.SymbolDisplayPartKind.className;}
    if (flags & 64 /* SymbolFlags.Interface */)
      {return ts.SymbolDisplayPartKind.interfaceName;}
    if (flags & 384 /* SymbolFlags.Enum */)
      {return ts.SymbolDisplayPartKind.enumName;}
    if (flags & 1536 /* SymbolFlags.Module */)
      {return ts.SymbolDisplayPartKind.moduleName;}
    if (flags & 8192 /* SymbolFlags.Method */)
      {return ts.SymbolDisplayPartKind.methodName;}
    if (flags & 262144 /* SymbolFlags.TypeParameter */)
      {return ts.SymbolDisplayPartKind.typeParameterName;}
    if (flags & 524288 /* SymbolFlags.TypeAlias */)
      {return ts.SymbolDisplayPartKind.aliasName;}
    if (flags & 2097152 /* SymbolFlags.Alias */)
      {return ts.SymbolDisplayPartKind.aliasName;}
    return ts.SymbolDisplayPartKind.text;
  }
}
ts.symbolPart = symbolPart;
function displayPart(text, kind) {
  return {text, kind: ts.SymbolDisplayPartKind[kind]};
}
ts.displayPart = displayPart;
function spacePart() {
  return displayPart(' ', ts.SymbolDisplayPartKind.space);
}
ts.spacePart = spacePart;
function keywordPart(kind) {
  return displayPart(ts.tokenToString(kind), ts.SymbolDisplayPartKind.keyword);
}
ts.keywordPart = keywordPart;
function punctuationPart(kind) {
  return displayPart(ts.tokenToString(kind), ts.SymbolDisplayPartKind.punctuation);
}
ts.punctuationPart = punctuationPart;
function operatorPart(kind) {
  return displayPart(ts.tokenToString(kind), ts.SymbolDisplayPartKind.operator);
}
ts.operatorPart = operatorPart;
function parameterNamePart(text) {
  return displayPart(text, ts.SymbolDisplayPartKind.parameterName);
}
ts.parameterNamePart = parameterNamePart;
function propertyNamePart(text) {
  return displayPart(text, ts.SymbolDisplayPartKind.propertyName);
}
ts.propertyNamePart = propertyNamePart;
function textOrKeywordPart(text) {
  const kind = ts.stringToToken(text);
  return kind === undefined ? textPart(text) : keywordPart(kind);
}
ts.textOrKeywordPart = textOrKeywordPart;
function textPart(text) {
  return displayPart(text, ts.SymbolDisplayPartKind.text);
}
ts.textPart = textPart;
function typeAliasNamePart(text) {
  return displayPart(text, ts.SymbolDisplayPartKind.aliasName);
}
ts.typeAliasNamePart = typeAliasNamePart;
function typeParameterNamePart(text) {
  return displayPart(text, ts.SymbolDisplayPartKind.typeParameterName);
}
ts.typeParameterNamePart = typeParameterNamePart;
function linkTextPart(text) {
  return displayPart(text, ts.SymbolDisplayPartKind.linkText);
}
ts.linkTextPart = linkTextPart;
function linkNamePart(text, target) {
  return {
    text,
    kind: ts.SymbolDisplayPartKind[ts.SymbolDisplayPartKind.linkName],
    target: {
      fileName: ts.getSourceFileOfNode(target).fileName,
      textSpan: createTextSpanFromNode(target),
    },
  };
}
ts.linkNamePart = linkNamePart;
function linkPart(text) {
  return displayPart(text, ts.SymbolDisplayPartKind.link);
}
ts.linkPart = linkPart;
function buildLinkParts(link, checker) {
  let _a;
  const prefix = ts.isJSDocLink(link) ? 'link' : ts.isJSDocLinkCode(link) ? 'linkcode' : 'linkplain';
  const parts = [linkPart('{@'.concat(prefix, ' '))];
  if (!link.name) {
    if (link.text) {
      parts.push(linkTextPart(link.text));
    }
  } else {
    const symbol = checker === null || checker === void 0 ? void 0 : checker.getSymbolAtLocation(link.name);
    const suffix = findLinkNameEnd(link.text);
    const name = ts.getTextOfNode(link.name) + link.text.slice(0, suffix);
    const text = skipSeparatorFromLinkText(link.text.slice(suffix));
    const decl = (symbol === null || symbol === void 0 ? void 0 : symbol.valueDeclaration) ||
        ((_a = symbol === null || symbol === void 0 ? void 0 : symbol.declarations) === null || _a === void 0 ? void 0 :
                                                                                                                _a[0]);
    if (decl) {
      parts.push(linkNamePart(name, decl));
      if (text)
        {parts.push(linkTextPart(text));}
    } else {
      parts.push(linkTextPart(name + (suffix || text.indexOf('://') === 0 ? '' : ' ') + text));
    }
  }
  parts.push(linkPart('}'));
  return parts;
}
ts.buildLinkParts = buildLinkParts;
function skipSeparatorFromLinkText(text) {
  let pos = 0;
  if (text.charCodeAt(pos++) === 124 /* CharacterCodes.bar */) {
    while (pos < text.length && text.charCodeAt(pos) === 32 /* CharacterCodes.space */)
      {pos++;}
    return text.slice(pos);
  }
  return text;
}
function findLinkNameEnd(text) {
  if (text.indexOf('()') === 0)
    {return 2;}
  if (text[0] !== '<')
    {return 0;}
  let brackets = 0;
  let i = 0;
  while (i < text.length) {
    if (text[i] === '<')
      {brackets++;}
    if (text[i] === '>')
      {brackets--;}
    i++;
    if (!brackets)
      {return i;}
  }
  return 0;
}
const carriageReturnLineFeed = '\r\n';
/**
 * The default is CRLF.
 */
function getNewLineOrDefaultFromHost(host, formatSettings) {
  let _a;
  return (formatSettings === null || formatSettings === void 0 ? void 0 : formatSettings.newLineCharacter) ||
      ((_a = host.getNewLine) === null || _a === void 0 ? void 0 : _a.call(host)) || carriageReturnLineFeed;
}
ts.getNewLineOrDefaultFromHost = getNewLineOrDefaultFromHost;
function lineBreakPart() {
  return displayPart('\n', ts.SymbolDisplayPartKind.lineBreak);
}
ts.lineBreakPart = lineBreakPart;
function mapToDisplayParts(writeDisplayParts) {
  try {
    writeDisplayParts(displayPartWriter);
    return displayPartWriter.displayParts();
  } finally {
    displayPartWriter.clear();
  }
}
ts.mapToDisplayParts = mapToDisplayParts;
function typeToDisplayParts(typechecker, type, enclosingDeclaration, flags) {
  if (flags === void 0) {
    flags = 0 /* TypeFormatFlags.None */;
  }
  return mapToDisplayParts(function(writer) {
    typechecker.writeType(
        type, enclosingDeclaration,
        flags | 1024 /* TypeFormatFlags.MultilineObjectLiterals */ |
            16384 /* TypeFormatFlags.UseAliasDefinedOutsideCurrentScope */,
        writer);
  });
}
ts.typeToDisplayParts = typeToDisplayParts;
function symbolToDisplayParts(typeChecker, symbol, enclosingDeclaration, meaning, flags) {
  if (flags === void 0) {
    flags = 0 /* SymbolFormatFlags.None */;
  }
  return mapToDisplayParts(function(writer) {
    typeChecker.writeSymbol(
        symbol, enclosingDeclaration, meaning, flags | 8 /* SymbolFormatFlags.UseAliasDefinedOutsideCurrentScope */,
        writer);
  });
}
ts.symbolToDisplayParts = symbolToDisplayParts;
function signatureToDisplayParts(typechecker, signature, enclosingDeclaration, flags) {
  if (flags === void 0) {
    flags = 0 /* TypeFormatFlags.None */;
  }
  flags |= 16384 /* TypeFormatFlags.UseAliasDefinedOutsideCurrentScope */ |
      1024 /* TypeFormatFlags.MultilineObjectLiterals */ | 32 /* TypeFormatFlags.WriteTypeArgumentsOfSignature */ |
      8192 /* TypeFormatFlags.OmitParameterModifiers */;
  return mapToDisplayParts(function(writer) {
    typechecker.writeSignature(signature, enclosingDeclaration, flags, /* signatureKind*/ undefined, writer);
  });
}
ts.signatureToDisplayParts = signatureToDisplayParts;
function nodeToDisplayParts(node, enclosingDeclaration) {
  const file = enclosingDeclaration.getSourceFile();
  return mapToDisplayParts(function(writer) {
    const printer = ts.createPrinter({removeComments: true, omitTrailingSemicolon: true});
    printer.writeNode(4 /* EmitHint.Unspecified */, node, file, writer);
  });
}
ts.nodeToDisplayParts = nodeToDisplayParts;
function isImportOrExportSpecifierName(location) {
  return !!location.parent && ts.isImportOrExportSpecifier(location.parent) &&
      location.parent.propertyName === location;
}
ts.isImportOrExportSpecifierName = isImportOrExportSpecifierName;
function getScriptKind(fileName, host) {
  // First check to see if the script kind was specified by the host. Chances are the host
  // may override the default script kind for the file extension.
  return ts.ensureScriptKind(fileName, host.getScriptKind && host.getScriptKind(fileName));
}
ts.getScriptKind = getScriptKind;
function getSymbolTarget(symbol, checker) {
  let next = symbol;
  while (isAliasSymbol(next) || (isTransientSymbol(next) && next.target)) {
    if (isTransientSymbol(next) && next.target) {
      next = next.target;
    } else {
      next = ts.skipAlias(next, checker);
    }
  }
  return next;
}
ts.getSymbolTarget = getSymbolTarget;
function isTransientSymbol(symbol) {
  return (symbol.flags & 33554432 /* SymbolFlags.Transient */) !== 0;
}
function isAliasSymbol(symbol) {
  return (symbol.flags & 2097152 /* SymbolFlags.Alias */) !== 0;
}
function getUniqueSymbolId(symbol, checker) {
  return ts.getSymbolId(ts.skipAlias(symbol, checker));
}
ts.getUniqueSymbolId = getUniqueSymbolId;
function getFirstNonSpaceCharacterPosition(text, position) {
  while (ts.isWhiteSpaceLike(text.charCodeAt(position))) {
    position += 1;
  }
  return position;
}
ts.getFirstNonSpaceCharacterPosition = getFirstNonSpaceCharacterPosition;
function getPrecedingNonSpaceCharacterPosition(text, position) {
  while (position > -1 && ts.isWhiteSpaceSingleLine(text.charCodeAt(position))) {
    position -= 1;
  }
  return position + 1;
}
ts.getPrecedingNonSpaceCharacterPosition = getPrecedingNonSpaceCharacterPosition;
/**
 * Creates a deep, memberwise clone of a node with no source map location.
 *
 * WARNING: This is an expensive operation and is only intended to be used in refactorings
 * and code fixes (because those are triggered by explicit user actions).
 */
function getSynthesizedDeepClone(node, includeTrivia) {
  if (includeTrivia === void 0) {
    includeTrivia = true;
  }
  const clone = node && getSynthesizedDeepCloneWorker(node);
  if (clone && !includeTrivia)
    {suppressLeadingAndTrailingTrivia(clone);}
  return clone;
}
ts.getSynthesizedDeepClone = getSynthesizedDeepClone;
function getSynthesizedDeepCloneWithReplacements(node, includeTrivia, replaceNode) {
  let clone = replaceNode(node);
  if (clone) {
    ts.setOriginalNode(clone, node);
  } else {
    clone = getSynthesizedDeepCloneWorker(node, replaceNode);
  }
  if (clone && !includeTrivia)
    {suppressLeadingAndTrailingTrivia(clone);}
  return clone;
}
ts.getSynthesizedDeepCloneWithReplacements = getSynthesizedDeepCloneWithReplacements;
function getSynthesizedDeepCloneWorker(node, replaceNode) {
  const nodeClone = replaceNode ? function(n) {
    return getSynthesizedDeepCloneWithReplacements(n, /* includeTrivia*/ true, replaceNode);
  } : getSynthesizedDeepClone;
  const nodesClone = replaceNode ? function(ns) {
    return ns && getSynthesizedDeepClonesWithReplacements(ns, /* includeTrivia*/ true, replaceNode);
  } : function(ns) {
    return ns && getSynthesizedDeepClones(ns);
  };
  const visited = ts.visitEachChild(node, nodeClone, ts.nullTransformationContext, nodesClone, nodeClone);
  if (visited === node) {
    // This only happens for leaf nodes - internal nodes always see their children change.
    const clone_1 = ts.isStringLiteral(node) ?
        ts.setOriginalNode(ts.factory.createStringLiteralFromNode(node), node) :
        ts.isNumericLiteral(node) ?
        ts.setOriginalNode(ts.factory.createNumericLiteral(node.text, node.numericLiteralFlags), node) :
        ts.factory.cloneNode(node);
    return ts.setTextRange(clone_1, node);
  }
  // PERF: As an optimization, rather than calling factory.cloneNode, we'll update
  // the new node created by visitEachChild with the extra changes factory.cloneNode
  // would have made.
  visited.parent = undefined;
  return visited;
}
function getSynthesizedDeepClones(nodes, includeTrivia) {
  if (includeTrivia === void 0) {
    includeTrivia = true;
  }
  return nodes &&
      ts.factory.createNodeArray(
          nodes.map(function(n) {
            return getSynthesizedDeepClone(n, includeTrivia);
          }),
          nodes.hasTrailingComma);
}
ts.getSynthesizedDeepClones = getSynthesizedDeepClones;
function getSynthesizedDeepClonesWithReplacements(nodes, includeTrivia, replaceNode) {
  return ts.factory.createNodeArray(
      nodes.map(function(n) {
        return getSynthesizedDeepCloneWithReplacements(n, includeTrivia, replaceNode);
      }),
      nodes.hasTrailingComma);
}
ts.getSynthesizedDeepClonesWithReplacements = getSynthesizedDeepClonesWithReplacements;
/**
 * Sets EmitFlags to suppress leading and trailing trivia on the node.
 */
function suppressLeadingAndTrailingTrivia(node) {
  suppressLeadingTrivia(node);
  suppressTrailingTrivia(node);
}
ts.suppressLeadingAndTrailingTrivia = suppressLeadingAndTrailingTrivia;
/**
 * Sets EmitFlags to suppress leading trivia on the node.
 */
function suppressLeadingTrivia(node) {
  addEmitFlagsRecursively(node, 512 /* EmitFlags.NoLeadingComments */, getFirstChild);
}
ts.suppressLeadingTrivia = suppressLeadingTrivia;
/**
 * Sets EmitFlags to suppress trailing trivia on the node.
 */
function suppressTrailingTrivia(node) {
  addEmitFlagsRecursively(node, 1024 /* EmitFlags.NoTrailingComments */, ts.getLastChild);
}
ts.suppressTrailingTrivia = suppressTrailingTrivia;
function copyComments(sourceNode, targetNode) {
  const sourceFile = sourceNode.getSourceFile();
  const text = sourceFile.text;
  if (hasLeadingLineBreak(sourceNode, text)) {
    copyLeadingComments(sourceNode, targetNode, sourceFile);
  } else {
    copyTrailingAsLeadingComments(sourceNode, targetNode, sourceFile);
  }
  copyTrailingComments(sourceNode, targetNode, sourceFile);
}
ts.copyComments = copyComments;
function hasLeadingLineBreak(node, text) {
  const start = node.getFullStart();
  const end = node.getStart();
  for (let i = start; i < end; i++) {
    if (text.charCodeAt(i) === 10 /* CharacterCodes.lineFeed */)
      {return true;}
  }
  return false;
}
function addEmitFlagsRecursively(node, flag, getChild) {
  ts.addEmitFlags(node, flag);
  const child = getChild(node);
  if (child)
    {addEmitFlagsRecursively(child, flag, getChild);}
}
function getFirstChild(node) {
  return node.forEachChild(function(child) {
    return child;
  });
}
function getUniqueName(baseName, sourceFile) {
  let nameText = baseName;
  for (let i = 1; !ts.isFileLevelUniqueName(sourceFile, nameText); i++) {
    nameText = ''.concat(baseName, '_').concat(i);
  }
  return nameText;
}
ts.getUniqueName = getUniqueName;
/**
 * @return The index of the (only) reference to the extracted symbol.  We want the cursor
 * to be on the reference, rather than the declaration, because it's closer to where the
 * user was before extracting it.
 */
function getRenameLocation(edits, renameFilename, name, preferLastLocation) {
  let delta = 0;
  let lastPos = -1;
  for (let _i = 0, edits_1 = edits; _i < edits_1.length; _i++) {
    const _a = edits_1[_i], fileName = _a.fileName, textChanges_2 = _a.textChanges;
    ts.Debug.assert(fileName === renameFilename);
    for (let _b = 0, textChanges_1 = textChanges_2; _b < textChanges_1.length; _b++) {
      const change = textChanges_1[_b];
      const span = change.span, newText = change.newText;
      const index = indexInTextChange(newText, ts.escapeString(name));
      if (index !== -1) {
        lastPos = span.start + delta + index;
        // If the reference comes first, return immediately.
        if (!preferLastLocation) {
          return lastPos;
        }
      }
      delta += newText.length - span.length;
    }
  }
  // If the declaration comes first, return the position of the last occurrence.
  ts.Debug.assert(preferLastLocation);
  ts.Debug.assert(lastPos >= 0);
  return lastPos;
}
ts.getRenameLocation = getRenameLocation;
function copyLeadingComments(sourceNode, targetNode, sourceFile, commentKind, hasTrailingNewLine) {
  ts.forEachLeadingCommentRange(
      sourceFile.text, sourceNode.pos,
      getAddCommentsFunction(targetNode, sourceFile, commentKind, hasTrailingNewLine, ts.addSyntheticLeadingComment));
}
ts.copyLeadingComments = copyLeadingComments;
function copyTrailingComments(sourceNode, targetNode, sourceFile, commentKind, hasTrailingNewLine) {
  ts.forEachTrailingCommentRange(
      sourceFile.text, sourceNode.end,
      getAddCommentsFunction(targetNode, sourceFile, commentKind, hasTrailingNewLine, ts.addSyntheticTrailingComment));
}
ts.copyTrailingComments = copyTrailingComments;
/**
 * This function copies the trailing comments for the token that comes before `sourceNode`, as leading comments of `targetNode`.
 * This is useful because sometimes a comment that refers to `sourceNode` will be a leading comment for `sourceNode`, according to the
 * notion of trivia ownership, and instead will be a trailing comment for the token before `sourceNode`, e.g.:
 * `function foo(\* not leading comment for a *\ a: string) {}`
 * The comment refers to `a` but belongs to the `(` token, but we might want to copy it.
 */
function copyTrailingAsLeadingComments(sourceNode, targetNode, sourceFile, commentKind, hasTrailingNewLine) {
  ts.forEachTrailingCommentRange(
      sourceFile.text, sourceNode.pos,
      getAddCommentsFunction(targetNode, sourceFile, commentKind, hasTrailingNewLine, ts.addSyntheticLeadingComment));
}
ts.copyTrailingAsLeadingComments = copyTrailingAsLeadingComments;
function getAddCommentsFunction(targetNode, sourceFile, commentKind, hasTrailingNewLine, cb) {
  return function(pos, end, kind, htnl) {
    if (kind === 3 /* SyntaxKind.MultiLineCommentTrivia */) {
      // Remove leading /*
      pos += 2;
      // Remove trailing */
      end -= 2;
    } else {
      // Remove leading //
      pos += 2;
    }
    cb(targetNode, commentKind || kind, sourceFile.text.slice(pos, end),
       hasTrailingNewLine !== undefined ? hasTrailingNewLine : htnl);
  };
}
function indexInTextChange(change, name) {
  if (ts.startsWith(change, name))
    {return 0;}
  // Add a " " to avoid references inside words
  let idx = change.indexOf(' ' + name);
  if (idx === -1)
    {idx = change.indexOf('.' + name);}
  if (idx === -1)
    {idx = change.indexOf('"' + name);}
  return idx === -1 ? -1 : idx + 1;
}
/* @internal */
function needsParentheses(expression) {
  return ts.isBinaryExpression(expression) && expression.operatorToken.kind === 27 /* SyntaxKind.CommaToken */
      || ts.isObjectLiteralExpression(expression) ||
      ts.isAsExpression(expression) && ts.isObjectLiteralExpression(expression.expression);
}
ts.needsParentheses = needsParentheses;
function getContextualTypeFromParent(node, checker) {
  const parent = node.parent;
  switch (parent.kind) {
    case 211 /* SyntaxKind.NewExpression */:
      return checker.getContextualType(parent);
    case 223 /* SyntaxKind.BinaryExpression */: {
      const _a = parent, left = _a.left, operatorToken = _a.operatorToken, right = _a.right;
      return isEqualityOperatorKind(operatorToken.kind) ? checker.getTypeAtLocation(node === right ? left : right) :
                                                          checker.getContextualType(node);
    }
    case 292 /* SyntaxKind.CaseClause */:
      return parent.expression === node ? getSwitchedType(parent, checker) : undefined;
    default:
      return checker.getContextualType(node);
  }
}
ts.getContextualTypeFromParent = getContextualTypeFromParent;
function quote(sourceFile, preferences, text) {
  // Editors can pass in undefined or empty string - we want to infer the preference in those cases.
  const quotePreference = getQuotePreference(sourceFile, preferences);
  const quoted = JSON.stringify(text);
  return quotePreference === 0 /* QuotePreference.Single */ ?
      '\''.concat(ts.stripQuotes(quoted).replace(/'/g, '\\\'').replace(/\\"/g, '"'), '\'') :
      quoted;
}
ts.quote = quote;
function isEqualityOperatorKind(kind) {
  switch (kind) {
    case 36 /* SyntaxKind.EqualsEqualsEqualsToken */:
    case 34 /* SyntaxKind.EqualsEqualsToken */:
    case 37 /* SyntaxKind.ExclamationEqualsEqualsToken */:
    case 35 /* SyntaxKind.ExclamationEqualsToken */:
      return true;
    default:
      return false;
  }
}
ts.isEqualityOperatorKind = isEqualityOperatorKind;
function isStringLiteralOrTemplate(node) {
  switch (node.kind) {
    case 10 /* SyntaxKind.StringLiteral */:
    case 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */:
    case 225 /* SyntaxKind.TemplateExpression */:
    case 212 /* SyntaxKind.TaggedTemplateExpression */:
      return true;
    default:
      return false;
  }
}
ts.isStringLiteralOrTemplate = isStringLiteralOrTemplate;
function hasIndexSignature(type) {
  return !!type.getStringIndexType() || !!type.getNumberIndexType();
}
ts.hasIndexSignature = hasIndexSignature;
function getSwitchedType(caseClause, checker) {
  return checker.getTypeAtLocation(caseClause.parent.parent.expression);
}
ts.getSwitchedType = getSwitchedType;
ts.ANONYMOUS = 'anonymous function';
function getTypeNodeIfAccessible(type, enclosingScope, program, host) {
  const checker = program.getTypeChecker();
  let typeIsAccessible = true;
  const notAccessible = function() {
    return typeIsAccessible = false;
  };
  const res = checker.typeToTypeNode(type, enclosingScope, 1 /* NodeBuilderFlags.NoTruncation */, {
    trackSymbol: function(symbol, declaration, meaning) {
      typeIsAccessible = typeIsAccessible &&
          checker.isSymbolAccessible(symbol, declaration, meaning, /* shouldComputeAliasToMarkVisible*/ false)
                  .accessibility === 0 /* SymbolAccessibility.Accessible */;
      return !typeIsAccessible;
    },
    reportInaccessibleThisError: notAccessible,
    reportPrivateInBaseOfClassExpression: notAccessible,
    reportInaccessibleUniqueSymbolError: notAccessible,
    moduleResolverHost: getModuleSpecifierResolverHost(program, host)
  });
  return typeIsAccessible ? res : undefined;
}
ts.getTypeNodeIfAccessible = getTypeNodeIfAccessible;
function syntaxRequiresTrailingCommaOrSemicolonOrASI(kind) {
  return kind === 176 /* SyntaxKind.CallSignature */
      || kind === 177 /* SyntaxKind.ConstructSignature */
      || kind === 178 /* SyntaxKind.IndexSignature */
      || kind === 168 /* SyntaxKind.PropertySignature */
      || kind === 170 /* SyntaxKind.MethodSignature */;
}
function syntaxRequiresTrailingFunctionBlockOrSemicolonOrASI(kind) {
  return kind === 259 /* SyntaxKind.FunctionDeclaration */
      || kind === 173 /* SyntaxKind.Constructor */
      || kind === 171 /* SyntaxKind.MethodDeclaration */
      || kind === 174 /* SyntaxKind.GetAccessor */
      || kind === 175 /* SyntaxKind.SetAccessor */;
}
function syntaxRequiresTrailingModuleBlockOrSemicolonOrASI(kind) {
  return kind === 264 /* SyntaxKind.ModuleDeclaration */;
}
function syntaxRequiresTrailingSemicolonOrASI(kind) {
  return kind === 240 /* SyntaxKind.VariableStatement */
      || kind === 241 /* SyntaxKind.ExpressionStatement */
      || kind === 243 /* SyntaxKind.DoStatement */
      || kind === 248 /* SyntaxKind.ContinueStatement */
      || kind === 249 /* SyntaxKind.BreakStatement */
      || kind === 250 /* SyntaxKind.ReturnStatement */
      || kind === 254 /* SyntaxKind.ThrowStatement */
      || kind === 256 /* SyntaxKind.DebuggerStatement */
      || kind === 169 /* SyntaxKind.PropertyDeclaration */
      || kind === 262 /* SyntaxKind.TypeAliasDeclaration */
      || kind === 269 /* SyntaxKind.ImportDeclaration */
      || kind === 268 /* SyntaxKind.ImportEqualsDeclaration */
      || kind === 275 /* SyntaxKind.ExportDeclaration */
      || kind === 267 /* SyntaxKind.NamespaceExportDeclaration */
      || kind === 274 /* SyntaxKind.ExportAssignment */;
}
ts.syntaxRequiresTrailingSemicolonOrASI = syntaxRequiresTrailingSemicolonOrASI;
ts.syntaxMayBeASICandidate = ts.or(
    syntaxRequiresTrailingCommaOrSemicolonOrASI, syntaxRequiresTrailingFunctionBlockOrSemicolonOrASI,
    syntaxRequiresTrailingModuleBlockOrSemicolonOrASI, syntaxRequiresTrailingSemicolonOrASI);
function nodeIsASICandidate(node, sourceFile) {
  const lastToken = node.getLastToken(sourceFile);
  if (lastToken && lastToken.kind === 26 /* SyntaxKind.SemicolonToken */) {
    return false;
  }
  if (syntaxRequiresTrailingCommaOrSemicolonOrASI(node.kind)) {
    if (lastToken && lastToken.kind === 27 /* SyntaxKind.CommaToken */) {
      return false;
    }
  } else if (syntaxRequiresTrailingModuleBlockOrSemicolonOrASI(node.kind)) {
    var lastChild = ts.last(node.getChildren(sourceFile));
    if (lastChild && ts.isModuleBlock(lastChild)) {
      return false;
    }
  } else if (syntaxRequiresTrailingFunctionBlockOrSemicolonOrASI(node.kind)) {
    var lastChild = ts.last(node.getChildren(sourceFile));
    if (lastChild && ts.isFunctionBlock(lastChild)) {
      return false;
    }
  } else if (!syntaxRequiresTrailingSemicolonOrASI(node.kind)) {
    return false;
  }
  // See comment in parsers `parseDoStatement`
  if (node.kind === 243 /* SyntaxKind.DoStatement */) {
    return true;
  }
  const topNode = ts.findAncestor(node, function(ancestor) {
    return !ancestor.parent;
  });
  const nextToken = findNextToken(node, topNode, sourceFile);
  if (!nextToken || nextToken.kind === 19 /* SyntaxKind.CloseBraceToken */) {
    return true;
  }
  const startLine = sourceFile.getLineAndCharacterOfPosition(node.getEnd()).line;
  const endLine = sourceFile.getLineAndCharacterOfPosition(nextToken.getStart(sourceFile)).line;
  return startLine !== endLine;
}
function positionIsASICandidate(pos, context, sourceFile) {
  const contextAncestor = ts.findAncestor(context, function(ancestor) {
    if (ancestor.end !== pos) {
      return 'quit';
    }
    return ts.syntaxMayBeASICandidate(ancestor.kind);
  });
  return !!contextAncestor && nodeIsASICandidate(contextAncestor, sourceFile);
}
ts.positionIsASICandidate = positionIsASICandidate;
function probablyUsesSemicolons(sourceFile) {
  let withSemicolon = 0;
  let withoutSemicolon = 0;
  const nStatementsToObserve = 5;
  ts.forEachChild(sourceFile, function visit(node) {
    if (syntaxRequiresTrailingSemicolonOrASI(node.kind)) {
      var lastToken = node.getLastToken(sourceFile);
      if ((lastToken === null || lastToken === void 0 ? void 0 : lastToken.kind) ===
          26 /* SyntaxKind.SemicolonToken */) {
        withSemicolon++;
      } else {
        withoutSemicolon++;
      }
    } else if (syntaxRequiresTrailingCommaOrSemicolonOrASI(node.kind)) {
      var lastToken = node.getLastToken(sourceFile);
      if ((lastToken === null || lastToken === void 0 ? void 0 : lastToken.kind) ===
          26 /* SyntaxKind.SemicolonToken */) {
        withSemicolon++;
      } else if (lastToken && lastToken.kind !== 27 /* SyntaxKind.CommaToken */) {
        const lastTokenLine = ts.getLineAndCharacterOfPosition(sourceFile, lastToken.getStart(sourceFile)).line;
        const nextTokenLine =
            ts.getLineAndCharacterOfPosition(sourceFile, ts.getSpanOfTokenAtPosition(sourceFile, lastToken.end).start)
                .line;
        // Avoid counting missing semicolon in single-line objects:
        // `function f(p: { x: string /*no semicolon here is insignificant*/ }) {`
        if (lastTokenLine !== nextTokenLine) {
          withoutSemicolon++;
        }
      }
    }
    if (withSemicolon + withoutSemicolon >= nStatementsToObserve) {
      return true;
    }
    return ts.forEachChild(node, visit);
  });
  // One statement missing a semicolon isn't sufficient evidence to say the user
  // doesnt want semicolons, because they may not even be done writing that statement.
  if (withSemicolon === 0 && withoutSemicolon <= 1) {
    return true;
  }
  // If even 2/5 places have a semicolon, the user probably wants semicolons
  return withSemicolon / withoutSemicolon > 1 / nStatementsToObserve;
}
ts.probablyUsesSemicolons = probablyUsesSemicolons;
function tryGetDirectories(host, directoryName) {
  return tryIOAndConsumeErrors(host, host.getDirectories, directoryName) || [];
}
ts.tryGetDirectories = tryGetDirectories;
function tryReadDirectory(host, path, extensions, exclude, include) {
  return tryIOAndConsumeErrors(host, host.readDirectory, path, extensions, exclude, include) || ts.emptyArray;
}
ts.tryReadDirectory = tryReadDirectory;
function tryFileExists(host, path) {
  return tryIOAndConsumeErrors(host, host.fileExists, path);
}
ts.tryFileExists = tryFileExists;
function tryDirectoryExists(host, path) {
  return tryAndIgnoreErrors(function() {
           return ts.directoryProbablyExists(path, host);
         }) ||
      false;
}
ts.tryDirectoryExists = tryDirectoryExists;
function tryAndIgnoreErrors(cb) {
  try {
    return cb();
  } catch (_a) {
    return undefined;
  }
}
ts.tryAndIgnoreErrors = tryAndIgnoreErrors;
function tryIOAndConsumeErrors(host, toApply) {
  const args = [];
  for (let _i = 2; _i < arguments.length; _i++) {
    args[_i - 2] = arguments[_i];
  }
  return tryAndIgnoreErrors(function() {
    return toApply && toApply.apply(host, args);
  });
}
ts.tryIOAndConsumeErrors = tryIOAndConsumeErrors;
function findPackageJsons(startDirectory, host, stopDirectory) {
  const paths = [];
  ts.forEachAncestorDirectory(startDirectory, function(ancestor) {
    if (ancestor === stopDirectory) {
      return true;
    }
    const currentConfigPath = ts.combinePaths(ancestor, 'package.json');
    if (tryFileExists(host, currentConfigPath)) {
      paths.push(currentConfigPath);
    }
  });
  return paths;
}
ts.findPackageJsons = findPackageJsons;
function findPackageJson(directory, host) {
  let packageJson;
  ts.forEachAncestorDirectory(directory, function(ancestor) {
    if (ancestor === 'node_modules')
      {return true;}
    packageJson = ts.findConfigFile(ancestor, function(f) {
      return tryFileExists(host, f);
    }, 'package.json');
    if (packageJson) {
      return true;  // break out
    }
  });
  return packageJson;
}
ts.findPackageJson = findPackageJson;
function getPackageJsonsVisibleToFile(fileName, host) {
  if (!host.fileExists) {
    return [];
  }
  const packageJsons = [];
  ts.forEachAncestorDirectory(ts.getDirectoryPath(fileName), function(ancestor) {
    const packageJsonFileName = ts.combinePaths(ancestor, 'package.json');
    if (host.fileExists(packageJsonFileName)) {
      const info = createPackageJsonInfo(packageJsonFileName, host);
      if (info) {
        packageJsons.push(info);
      }
    }
  });
  return packageJsons;
}
ts.getPackageJsonsVisibleToFile = getPackageJsonsVisibleToFile;
function createPackageJsonInfo(fileName, host) {
  if (!host.readFile) {
    return undefined;
  }
  const dependencyKeys = ['dependencies', 'devDependencies', 'optionalDependencies', 'peerDependencies'];
  const stringContent = host.readFile(fileName) || '';
  const content = tryParseJson(stringContent);
  const info = {};
  if (content) {
    for (let _i = 0, dependencyKeys_1 = dependencyKeys; _i < dependencyKeys_1.length; _i++) {
      const key = dependencyKeys_1[_i];
      const dependencies = content[key];
      if (!dependencies) {
        continue;
      }
      const dependencyMap = new ts.Map();
      for (const packageName in dependencies) {
        dependencyMap.set(packageName, dependencies[packageName]);
      }
      info[key] = dependencyMap;
    }
  }
  const dependencyGroups = [
    [1 /* PackageJsonDependencyGroup.Dependencies */, info.dependencies],
    [2 /* PackageJsonDependencyGroup.DevDependencies */, info.devDependencies],
    [8 /* PackageJsonDependencyGroup.OptionalDependencies */, info.optionalDependencies],
    [4 /* PackageJsonDependencyGroup.PeerDependencies */, info.peerDependencies],
  ];
  return __assign(__assign({}, info), {
    parseable: !!content,
    fileName,
    get,
    has: function(dependencyName, inGroups) {
      return !!get(dependencyName, inGroups);
    }
  });
  function get(dependencyName, inGroups) {
    if (inGroups === void 0) {
      inGroups = 15 /* PackageJsonDependencyGroup.All */;
    }
    for (let _i = 0, dependencyGroups_1 = dependencyGroups; _i < dependencyGroups_1.length; _i++) {
      const _a = dependencyGroups_1[_i], group_1 = _a[0], deps = _a[1];
      if (deps && (inGroups & group_1)) {
        const dep = deps.get(dependencyName);
        if (dep !== undefined) {
          return dep;
        }
      }
    }
  }
}
ts.createPackageJsonInfo = createPackageJsonInfo;
function createPackageJsonImportFilter(fromFile, preferences, host) {
  const packageJsons = ((host.getPackageJsonsVisibleToFile && host.getPackageJsonsVisibleToFile(fromFile.fileName)) ||
                      getPackageJsonsVisibleToFile(fromFile.fileName, host))
                         .filter(function(p) {
                           return p.parseable;
                         });
  let usesNodeCoreModules;
  return {
    allowsImportingAmbientModule,
    allowsImportingSourceFile,
    allowsImportingSpecifier
  };
  function moduleSpecifierIsCoveredByPackageJson(specifier) {
    const packageName = getNodeModuleRootSpecifier(specifier);
    for (let _i = 0, packageJsons_1 = packageJsons; _i < packageJsons_1.length; _i++) {
      const packageJson = packageJsons_1[_i];
      if (packageJson.has(packageName) || packageJson.has(ts.getTypesPackageName(packageName))) {
        return true;
      }
    }
    return false;
  }
  function allowsImportingAmbientModule(moduleSymbol, moduleSpecifierResolutionHost) {
    if (!packageJsons.length || !moduleSymbol.valueDeclaration) {
      return true;
    }
    const declaringSourceFile = moduleSymbol.valueDeclaration.getSourceFile();
    const declaringNodeModuleName =
        getNodeModulesPackageNameFromFileName(declaringSourceFile.fileName, moduleSpecifierResolutionHost);
    if (typeof declaringNodeModuleName === 'undefined') {
      return true;
    }
    const declaredModuleSpecifier = ts.stripQuotes(moduleSymbol.getName());
    if (isAllowedCoreNodeModulesImport(declaredModuleSpecifier)) {
      return true;
    }
    return moduleSpecifierIsCoveredByPackageJson(declaringNodeModuleName) ||
        moduleSpecifierIsCoveredByPackageJson(declaredModuleSpecifier);
  }
  function allowsImportingSourceFile(sourceFile, moduleSpecifierResolutionHost) {
    if (!packageJsons.length) {
      return true;
    }
    const moduleSpecifier = getNodeModulesPackageNameFromFileName(sourceFile.fileName, moduleSpecifierResolutionHost);
    if (!moduleSpecifier) {
      return true;
    }
    return moduleSpecifierIsCoveredByPackageJson(moduleSpecifier);
  }
  function allowsImportingSpecifier(moduleSpecifier) {
    if (!packageJsons.length || isAllowedCoreNodeModulesImport(moduleSpecifier)) {
      return true;
    }
    if (ts.pathIsRelative(moduleSpecifier) || ts.isRootedDiskPath(moduleSpecifier)) {
      return true;
    }
    return moduleSpecifierIsCoveredByPackageJson(moduleSpecifier);
  }
  function isAllowedCoreNodeModulesImport(moduleSpecifier) {
    // If were in JavaScript, it can be difficult to tell whether the user wants to import
    // from Node core modules or not. We can start by seeing if the user is actually using
    // any node core modules, as opposed to simply having @types/node accidentally as a
    // dependency of a dependency.
    if (ts.isSourceFileJS(fromFile) && ts.JsTyping.nodeCoreModules.has(moduleSpecifier)) {
      if (usesNodeCoreModules === undefined) {
        usesNodeCoreModules = consumesNodeCoreModules(fromFile);
      }
      if (usesNodeCoreModules) {
        return true;
      }
    }
    return false;
  }
  function getNodeModulesPackageNameFromFileName(importedFileName, moduleSpecifierResolutionHost) {
    if (!ts.stringContains(importedFileName, 'node_modules')) {
      return undefined;
    }
    const specifier = ts.moduleSpecifiers.getNodeModulesPackageName(
        host.getCompilationSettings(), fromFile, importedFileName, moduleSpecifierResolutionHost, preferences);
    if (!specifier) {
      return undefined;
    }
    // Paths here are not node_modules, so we dont care about them;
    // returning anything will trigger a lookup in package.json.
    if (!ts.pathIsRelative(specifier) && !ts.isRootedDiskPath(specifier)) {
      return getNodeModuleRootSpecifier(specifier);
    }
  }
  function getNodeModuleRootSpecifier(fullSpecifier) {
    const components = ts.getPathComponents(ts.getPackageNameFromTypesPackageName(fullSpecifier)).slice(1);
    // Scoped packages
    if (ts.startsWith(components[0], '@')) {
      return ''.concat(components[0], '/').concat(components[1]);
    }
    return components[0];
  }
}
ts.createPackageJsonImportFilter = createPackageJsonImportFilter;
function tryParseJson(text) {
  try {
    return JSON.parse(text);
  } catch (_a) {
    return undefined;
  }
}
function consumesNodeCoreModules(sourceFile) {
  return ts.some(sourceFile.imports, function(_a) {
    const text = _a.text;
    return ts.JsTyping.nodeCoreModules.has(text);
  });
}
ts.consumesNodeCoreModules = consumesNodeCoreModules;
function isInsideNodeModules(fileOrDirectory) {
  return ts.contains(ts.getPathComponents(fileOrDirectory), 'node_modules');
}
ts.isInsideNodeModules = isInsideNodeModules;
function isDiagnosticWithLocation(diagnostic) {
  return diagnostic.file !== undefined && diagnostic.start !== undefined && diagnostic.length !== undefined;
}
ts.isDiagnosticWithLocation = isDiagnosticWithLocation;
function findDiagnosticForNode(node, sortedFileDiagnostics) {
  const span = createTextSpanFromNode(node);
  const index = ts.binarySearchKey(sortedFileDiagnostics, span, ts.identity, ts.compareTextSpans);
  if (index >= 0) {
    const diagnostic = sortedFileDiagnostics[index];
    ts.Debug.assertEqual(
        diagnostic.file, node.getSourceFile(),
        'Diagnostics proided to \'findDiagnosticForNode\' must be from a single SourceFile');
    return ts.cast(diagnostic, isDiagnosticWithLocation);
  }
}
ts.findDiagnosticForNode = findDiagnosticForNode;
function getDiagnosticsWithinSpan(span, sortedFileDiagnostics) {
  let _a;
  let index = ts.binarySearchKey(sortedFileDiagnostics, span.start, function(diag) {
    return diag.start;
  }, ts.compareValues);
  if (index < 0) {
    index = ~index;
  }
  while (((_a = sortedFileDiagnostics[index - 1]) === null || _a === void 0 ? void 0 : _a.start) === span.start) {
    index--;
  }
  const result = [];
  const end = ts.textSpanEnd(span);
  while (true) {
    const diagnostic = ts.tryCast(sortedFileDiagnostics[index], isDiagnosticWithLocation);
    if (!diagnostic || diagnostic.start > end) {
      break;
    }
    if (ts.textSpanContainsTextSpan(span, diagnostic)) {
      result.push(diagnostic);
    }
    index++;
  }
  return result;
}
ts.getDiagnosticsWithinSpan = getDiagnosticsWithinSpan;
/* @internal */
function getRefactorContextSpan(_a) {
  const startPosition = _a.startPosition, endPosition = _a.endPosition;
  return ts.createTextSpanFromBounds(startPosition, endPosition === undefined ? startPosition : endPosition);
}
ts.getRefactorContextSpan = getRefactorContextSpan;
/* @internal */
function getFixableErrorSpanExpression(sourceFile, span) {
  const token = getTokenAtPosition(sourceFile, span.start);
  // Checker has already done work to determine that await might be possible, and has attached
  // related info to the node, so start by finding the expression that exactly matches up
  // with the diagnostic range.
  const expression = ts.findAncestor(token, function(node) {
    if (node.getStart(sourceFile) < span.start || node.getEnd() > ts.textSpanEnd(span)) {
      return 'quit';
    }
    return ts.isExpression(node) && textSpansEqual(span, createTextSpanFromNode(node, sourceFile));
  });
  return expression;
}
ts.getFixableErrorSpanExpression = getFixableErrorSpanExpression;
function mapOneOrMany(valueOrArray, f, resultSelector) {
  if (resultSelector === void 0) {
    resultSelector = ts.identity;
  }
  return valueOrArray ? ts.isArray(valueOrArray) ? resultSelector(ts.map(valueOrArray, f)) : f(valueOrArray, 0) :
                        undefined;
}
ts.mapOneOrMany = mapOneOrMany;
/**
 * If the provided value is an array, the first element of the array is returned; otherwise, the provided value is returned instead.
 */
function firstOrOnly(valueOrArray) {
  return ts.isArray(valueOrArray) ? ts.first(valueOrArray) : valueOrArray;
}
ts.firstOrOnly = firstOrOnly;
function getNamesForExportedSymbol(symbol, scriptTarget) {
  if (needsNameFromDeclaration(symbol)) {
    const fromDeclaration = getDefaultLikeExportNameFromDeclaration(symbol);
    if (fromDeclaration)
      {return fromDeclaration;}
    const fileNameCase = ts.codefix.moduleSymbolToValidIdentifier(
        getSymbolParentOrFail(symbol), scriptTarget, /* preferCapitalized*/ false);
    const capitalized = ts.codefix.moduleSymbolToValidIdentifier(
        getSymbolParentOrFail(symbol), scriptTarget, /* preferCapitalized*/ true);
    if (fileNameCase === capitalized)
      {return fileNameCase;}
    return [fileNameCase, capitalized];
  }
  return symbol.name;
}
ts.getNamesForExportedSymbol = getNamesForExportedSymbol;
function getNameForExportedSymbol(symbol, scriptTarget, preferCapitalized) {
  if (needsNameFromDeclaration(symbol)) {
    // Name of "export default foo;" is "foo". Name of "export default 0" is the filename converted to camelCase.
    return getDefaultLikeExportNameFromDeclaration(symbol) ||
        ts.codefix.moduleSymbolToValidIdentifier(getSymbolParentOrFail(symbol), scriptTarget, !!preferCapitalized);
  }
  return symbol.name;
}
ts.getNameForExportedSymbol = getNameForExportedSymbol;
function needsNameFromDeclaration(symbol) {
  return !(symbol.flags & 33554432 /* SymbolFlags.Transient */) &&
      (symbol.escapedName === 'export=' /* InternalSymbolName.ExportEquals */ ||
       symbol.escapedName === 'default' /* InternalSymbolName.Default */);
}
function getDefaultLikeExportNameFromDeclaration(symbol) {
  return ts.firstDefined(symbol.declarations, function(d) {
    let _a;
    return ts.isExportAssignment(d) ?
        (_a = ts.tryCast(ts.skipOuterExpressions(d.expression), ts.isIdentifier)) === null || _a === void 0 ? void 0 :
                                                                                                              _a.text :
        undefined;
  });
}
function getSymbolParentOrFail(symbol) {
  let _a;
  return ts.Debug.checkDefined(
      symbol.parent,
      'Symbol parent was undefined. Flags: '.concat(ts.Debug.formatSymbolFlags(symbol.flags), '. ') +
          'Declarations: '.concat(
              (_a = symbol.declarations) === null || _a === void 0 ?
                  void 0 :
                  _a.map(function(d) {
                      const kind = ts.Debug.formatSyntaxKind(d.kind);
                      const inJS = ts.isInJSFile(d);
                      const expression = d.expression;
                      return (inJS ? '[JS]' : '') + kind +
                          (expression ? ' (expression: '.concat(ts.Debug.formatSyntaxKind(expression.kind), ')') : '');
                    }).join(', '),
              '.'));
}
/**
 * Useful to check whether a string contains another string at a specific index
 * without allocating another string or traversing the entire contents of the outer string.
 *
 * This function is useful in place of either of the following:
 *
 * ```ts
 * // Allocates
 * haystack.substr(startIndex, needle.length) === needle
 *
 * // Full traversal
 * haystack.indexOf(needle, startIndex) === startIndex
 * ```
 *
 * @param haystack The string that potentially contains `needle`.
 * @param needle The string whose content might sit within `haystack`.
 * @param startIndex The index within `haystack` to start searching for `needle`.
 */
function stringContainsAt(haystack, needle, startIndex) {
  const needleLength = needle.length;
  if (needleLength + startIndex > haystack.length) {
    return false;
  }
  for (let i = 0; i < needleLength; i++) {
    if (needle.charCodeAt(i) !== haystack.charCodeAt(i + startIndex))
      {return false;}
  }
  return true;
}
ts.stringContainsAt = stringContainsAt;
function startsWithUnderscore(name) {
  return name.charCodeAt(0) === 95 /* CharacterCodes._ */;
}
ts.startsWithUnderscore = startsWithUnderscore;
function isGlobalDeclaration(declaration) {
  return !isNonGlobalDeclaration(declaration);
}
ts.isGlobalDeclaration = isGlobalDeclaration;
function isNonGlobalDeclaration(declaration) {
  const sourceFile = declaration.getSourceFile();
  // If the file is not a module, the declaration is global
  if (!sourceFile.externalModuleIndicator && !sourceFile.commonJsModuleIndicator) {
    return false;
  }
  // If the file is a module written in TypeScript, it still might be in a `declare global` augmentation
  return ts.isInJSFile(declaration) || !ts.findAncestor(declaration, ts.isGlobalScopeAugmentation);
}
ts.isNonGlobalDeclaration = isNonGlobalDeclaration;
function isDeprecatedDeclaration(decl) {
  return !!(ts.getCombinedNodeFlagsAlwaysIncludeJSDoc(decl) & 8192 /* ModifierFlags.Deprecated */);
}
ts.isDeprecatedDeclaration = isDeprecatedDeclaration;
function shouldUseUriStyleNodeCoreModules(file, program) {
  const decisionFromFile = ts.firstDefined(file.imports, function(node) {
    if (ts.JsTyping.nodeCoreModules.has(node.text)) {
      return ts.startsWith(node.text, 'node:');
    }
  });
  return decisionFromFile !== null && decisionFromFile !== void 0 ? decisionFromFile :
                                                                    program.usesUriStyleNodeCoreModules;
}
ts.shouldUseUriStyleNodeCoreModules = shouldUseUriStyleNodeCoreModules;
function getNewLineKind(newLineCharacter) {
  return newLineCharacter === '\n' ? 1 /* NewLineKind.LineFeed */ : 0 /* NewLineKind.CarriageReturnLineFeed */;
}
ts.getNewLineKind = getNewLineKind;
function diagnosticToString(diag) {
  return ts.isArray(diag) ? ts.formatStringFromArgs(ts.getLocaleSpecificMessage(diag[0]), diag.slice(1)) :
                            ts.getLocaleSpecificMessage(diag);
}
ts.diagnosticToString = diagnosticToString;
/**
 * Get format code settings for a code writing context (e.g. when formatting text changes or completions code).
 */
function getFormatCodeSettingsForWriting(_a, sourceFile) {
  const options = _a.options;
  const shouldAutoDetectSemicolonPreference = !options.semicolons || options.semicolons === ts.SemicolonPreference.Ignore;
  const shouldRemoveSemicolons = options.semicolons === ts.SemicolonPreference.Remove ||
      shouldAutoDetectSemicolonPreference && !probablyUsesSemicolons(sourceFile);
  return __assign(
      __assign({}, options),
      {semicolons: shouldRemoveSemicolons ? ts.SemicolonPreference.Remove : ts.SemicolonPreference.Ignore});
}
ts.getFormatCodeSettingsForWriting = getFormatCodeSettingsForWriting;
function jsxModeNeedsExplicitImport(jsx) {
  return jsx === 2 /* JsxEmit.React */ || jsx === 3 /* JsxEmit.ReactNative */;
}
ts.jsxModeNeedsExplicitImport = jsxModeNeedsExplicitImport;
function isSourceFileFromLibrary(program, node) {
  return program.isSourceFileFromExternalLibrary(node) || program.isSourceFileDefaultLibrary(node);
}
ts.isSourceFileFromLibrary = isSourceFileFromLibrary;
// #endregion
})(ts || (ts = {}));
/* @internal*/
var ts;
(function(ts) {
let ImportKind;
(function(ImportKind) {
ImportKind[ImportKind['Named'] = 0] = 'Named';
ImportKind[ImportKind['Default'] = 1] = 'Default';
ImportKind[ImportKind['Namespace'] = 2] = 'Namespace';
ImportKind[ImportKind['CommonJS'] = 3] = 'CommonJS';
})(ImportKind = ts.ImportKind || (ts.ImportKind = {}));
let ExportKind;
(function(ExportKind) {
ExportKind[ExportKind['Named'] = 0] = 'Named';
ExportKind[ExportKind['Default'] = 1] = 'Default';
ExportKind[ExportKind['ExportEquals'] = 2] = 'ExportEquals';
ExportKind[ExportKind['UMD'] = 3] = 'UMD';
})(ExportKind = ts.ExportKind || (ts.ExportKind = {}));
function createCacheableExportInfoMap(host) {
  let exportInfoId = 1;
  const exportInfo = ts.createMultiMap();
  const symbols = new ts.Map();
  /**
   * Key: node_modules package name (no @types).
   * Value: path to deepest node_modules folder seen that is
   * both visible to `usableByFileName` and contains the package.
   *
   * Later, we can see if a given SymbolExportInfo is shadowed by
   * a another installation of the same package in a deeper
   * node_modules folder by seeing if its path starts with the
   * value stored here.
   */
  const packages = new ts.Map();
  let usableByFileName;
  var cache = {
    isUsableByFile: function(importingFile) {
      return importingFile === usableByFileName;
    },
    isEmpty: function() {
      return !exportInfo.size;
    },
    clear: function() {
      exportInfo.clear();
      symbols.clear();
      usableByFileName = undefined;
    },
    add: function(
        importingFile, symbol, symbolTableKey, moduleSymbol, moduleFile, exportKind, isFromPackageJson, checker) {
      if (importingFile !== usableByFileName) {
        cache.clear();
        usableByFileName = importingFile;
      }
      let packageName;
      if (moduleFile) {
        const nodeModulesPathParts = ts.getNodeModulePathParts(moduleFile.fileName);
        if (nodeModulesPathParts) {
          const topLevelNodeModulesIndex = nodeModulesPathParts.topLevelNodeModulesIndex,
              topLevelPackageNameIndex = nodeModulesPathParts.topLevelPackageNameIndex,
              packageRootIndex = nodeModulesPathParts.packageRootIndex;
          packageName = ts.unmangleScopedPackageName(ts.getPackageNameFromTypesPackageName(
              moduleFile.fileName.substring(topLevelPackageNameIndex + 1, packageRootIndex)));
          if (ts.startsWith(importingFile, moduleFile.path.substring(0, topLevelNodeModulesIndex))) {
            const prevDeepestNodeModulesPath = packages.get(packageName);
            const nodeModulesPath = moduleFile.fileName.substring(0, topLevelPackageNameIndex + 1);
            if (prevDeepestNodeModulesPath) {
              const prevDeepestNodeModulesIndex = prevDeepestNodeModulesPath.indexOf(ts.nodeModulesPathPart);
              if (topLevelNodeModulesIndex > prevDeepestNodeModulesIndex) {
                packages.set(packageName, nodeModulesPath);
              }
            } else {
              packages.set(packageName, nodeModulesPath);
            }
          }
        }
      }
      const isDefault = exportKind === 1 /* ExportKind.Default */;
      const namedSymbol = isDefault && ts.getLocalSymbolForExportDefault(symbol) || symbol;
      // 1. A named export must be imported by its key in `moduleSymbol.exports` or `moduleSymbol.members`.
      // 2. A re-export merged with an export from a module augmentation can result in `symbol`
      //    being an external module symbol; the name it is re-exported by will be `symbolTableKey`
      //    (which comes from the keys of `moduleSymbol.exports`.)
      // 3. Otherwise, we have a default/namespace import that can be imported by any name, and
      //    `symbolTableKey` will be something undesirable like `export=` or `default`, so we try to
      //    get a better name.
      const names = exportKind === 0 /* ExportKind.Named */ || ts.isExternalModuleSymbol(namedSymbol) ?
          ts.unescapeLeadingUnderscores(symbolTableKey) :
          ts.getNamesForExportedSymbol(namedSymbol, /* scriptTarget*/ undefined);
      const symbolName = typeof names === 'string' ? names : names[0];
      const capitalizedSymbolName = typeof names === 'string' ? undefined : names[1];
      const moduleName = ts.stripQuotes(moduleSymbol.name);
      const id = exportInfoId++;
      const target = ts.skipAlias(symbol, checker);
      const storedSymbol = symbol.flags & 33554432 /* SymbolFlags.Transient */ ? undefined : symbol;
      const storedModuleSymbol = moduleSymbol.flags & 33554432 /* SymbolFlags.Transient */ ? undefined : moduleSymbol;
      if (!storedSymbol || !storedModuleSymbol)
        {symbols.set(id, [symbol, moduleSymbol]);}
      exportInfo.add(
          key(symbolName, symbol, ts.isExternalModuleNameRelative(moduleName) ? undefined : moduleName, checker), {
            id,
            symbolTableKey,
            symbolName,
            capitalizedSymbolName,
            moduleName,
            moduleFile,
            moduleFileName: moduleFile === null || moduleFile === void 0 ? void 0 : moduleFile.fileName,
            packageName,
            exportKind,
            targetFlags: target.flags,
            isFromPackageJson,
            symbol: storedSymbol,
            moduleSymbol: storedModuleSymbol,
          });
    },
    get: function(importingFile, key) {
      if (importingFile !== usableByFileName)
        {return;}
      const result = exportInfo.get(key);
      return result === null || result === void 0 ? void 0 : result.map(rehydrateCachedInfo);
    },
    search: function(importingFile, preferCapitalized, matches, action) {
      if (importingFile !== usableByFileName)
        {return;}
      return ts.forEachEntry(exportInfo, function(info, key) {
        const _a = parseKey(key), symbolName = _a.symbolName, ambientModuleName = _a.ambientModuleName;
        const name = preferCapitalized && info[0].capitalizedSymbolName || symbolName;
        if (matches(name, info[0].targetFlags)) {
          const rehydrated = info.map(rehydrateCachedInfo);
          const filtered = rehydrated.filter(function(r, i) {
            return isNotShadowedByDeeperNodeModulesPackage(r, info[i].packageName);
          });
          if (filtered.length) {
            const res = action(filtered, name, !!ambientModuleName, key);
            if (res !== undefined)
              {return res;}
          }
        }
      });
    },
    releaseSymbols: function() {
      symbols.clear();
    },
    onFileChanged: function(oldSourceFile, newSourceFile, typeAcquisitionEnabled) {
      if (fileIsGlobalOnly(oldSourceFile) && fileIsGlobalOnly(newSourceFile)) {
        // File is purely global; doesn't affect export map
        return false;
      }
      if (usableByFileName && usableByFileName !== newSourceFile.path ||
          // If ATA is enabled, auto-imports uses existing imports to guess whether you want auto-imports from node.
          // Adding or removing imports from node could change the outcome of that guess, so could change the suggestions list.
          typeAcquisitionEnabled &&
              ts.consumesNodeCoreModules(oldSourceFile) !== ts.consumesNodeCoreModules(newSourceFile) ||
          // Module agumentation and ambient module changes can add or remove exports available to be auto-imported.
          // Changes elsewhere in the file can change the *type* of an export in a module augmentation,
          // but type info is gathered in getCompletionEntryDetails, which doesnt use the cache.
          !ts.arrayIsEqualTo(oldSourceFile.moduleAugmentations, newSourceFile.moduleAugmentations) ||
          !ambientModuleDeclarationsAreEqual(oldSourceFile, newSourceFile)) {
        cache.clear();
        return true;
      }
      usableByFileName = newSourceFile.path;
      return false;
    },
  };
  if (ts.Debug.isDebugging) {
    Object.defineProperty(cache, '__cache', {
      get: function() {
        return exportInfo;
      }
    });
  }
  return cache;
  function rehydrateCachedInfo(info) {
    if (info.symbol && info.moduleSymbol)
      {return info;}
    const id = info.id, exportKind = info.exportKind, targetFlags = info.targetFlags,
        isFromPackageJson = info.isFromPackageJson, moduleFileName = info.moduleFileName;
    const _a = symbols.get(id) || ts.emptyArray, cachedSymbol = _a[0], cachedModuleSymbol = _a[1];
    if (cachedSymbol && cachedModuleSymbol) {
      return {
        symbol: cachedSymbol,
        moduleSymbol: cachedModuleSymbol,
        moduleFileName,
        exportKind,
        targetFlags,
        isFromPackageJson,
      };
    }
    const checker =
        (isFromPackageJson ? host.getPackageJsonAutoImportProvider() : host.getCurrentProgram()).getTypeChecker();
    const moduleSymbol = info.moduleSymbol || cachedModuleSymbol ||
        ts.Debug.checkDefined(
            info.moduleFile ? checker.getMergedSymbol(info.moduleFile.symbol) :
                              checker.tryFindAmbientModule(info.moduleName));
    const symbol = info.symbol || cachedSymbol ||
        ts.Debug.checkDefined(
            exportKind === 2 /* ExportKind.ExportEquals */
                ?
                checker.resolveExternalModuleSymbol(moduleSymbol) :
                checker.tryGetMemberInModuleExportsAndProperties(
                    ts.unescapeLeadingUnderscores(info.symbolTableKey), moduleSymbol),
            'Could not find symbol \''.concat(info.symbolName, '\' by key \'')
                .concat(info.symbolTableKey, '\' in module ')
                .concat(moduleSymbol.name));
    symbols.set(id, [symbol, moduleSymbol]);
    return {
      symbol,
      moduleSymbol,
      moduleFileName,
      exportKind,
      targetFlags,
      isFromPackageJson,
    };
  }
  function key(importedName, symbol, ambientModuleName, checker) {
    const moduleKey = ambientModuleName || '';
    return ''.concat(importedName, '|').concat(ts.getSymbolId(ts.skipAlias(symbol, checker)), '|').concat(moduleKey);
  }
  function parseKey(key) {
    const symbolName = key.substring(0, key.indexOf('|'));
    const moduleKey = key.substring(key.lastIndexOf('|') + 1);
    const ambientModuleName = moduleKey === '' ? undefined : moduleKey;
    return {symbolName, ambientModuleName};
  }
  function fileIsGlobalOnly(file) {
    return !file.commonJsModuleIndicator && !file.externalModuleIndicator && !file.moduleAugmentations &&
        !file.ambientModuleNames;
  }
  function ambientModuleDeclarationsAreEqual(oldSourceFile, newSourceFile) {
    if (!ts.arrayIsEqualTo(oldSourceFile.ambientModuleNames, newSourceFile.ambientModuleNames)) {
      return false;
    }
    let oldFileStatementIndex = -1;
    let newFileStatementIndex = -1;
    const _loop_2 = function(ambientModuleName) {
      const isMatchingModuleDeclaration = function(node) {
        return ts.isNonGlobalAmbientModule(node) && node.name.text === ambientModuleName;
      };
      oldFileStatementIndex =
          ts.findIndex(oldSourceFile.statements, isMatchingModuleDeclaration, oldFileStatementIndex + 1);
      newFileStatementIndex =
          ts.findIndex(newSourceFile.statements, isMatchingModuleDeclaration, newFileStatementIndex + 1);
      if (oldSourceFile.statements[oldFileStatementIndex] !== newSourceFile.statements[newFileStatementIndex]) {
        return {value: false};
      }
    };
    for (let _i = 0, _a = newSourceFile.ambientModuleNames; _i < _a.length; _i++) {
      const ambientModuleName = _a[_i];
      const state_2 = _loop_2(ambientModuleName);
      if (typeof state_2 === 'object')
        {return state_2.value;}
    }
    return true;
  }
  function isNotShadowedByDeeperNodeModulesPackage(info, packageName) {
    if (!packageName || !info.moduleFileName)
      {return true;}
    const typingsCacheLocation = host.getGlobalTypingsCacheLocation();
    if (typingsCacheLocation && ts.startsWith(info.moduleFileName, typingsCacheLocation))
      {return true;}
    const packageDeepestNodeModulesPath = packages.get(packageName);
    return !packageDeepestNodeModulesPath || ts.startsWith(info.moduleFileName, packageDeepestNodeModulesPath);
  }
}
ts.createCacheableExportInfoMap = createCacheableExportInfoMap;
function isImportableFile(
    program, from, to, preferences, packageJsonFilter, moduleSpecifierResolutionHost, moduleSpecifierCache) {
  let _a;
  if (from === to)
    {return false;}
  const cachedResult = moduleSpecifierCache === null || moduleSpecifierCache === void 0 ?
      void 0 :
      moduleSpecifierCache.get(from.path, to.path, preferences, {});
  if ((cachedResult === null || cachedResult === void 0 ? void 0 : cachedResult.isBlockedByPackageJsonDependencies) !==
      undefined) {
    return !cachedResult.isBlockedByPackageJsonDependencies;
  }
  const getCanonicalFileName = ts.hostGetCanonicalFileName(moduleSpecifierResolutionHost);
  const globalTypingsCache =
      (_a = moduleSpecifierResolutionHost.getGlobalTypingsCacheLocation) === null || _a === void 0 ?
      void 0 :
      _a.call(moduleSpecifierResolutionHost);
  const hasImportablePath = !!ts.moduleSpecifiers.forEachFileNameOfModule(
      from.fileName, to.fileName, moduleSpecifierResolutionHost,
      /* preferSymlinks*/ false, function(toPath) {
        const toFile = program.getSourceFile(toPath);
        // Determine to import using toPath only if toPath is what we were looking at
        // or there doesnt exist the file in the program by the symlink
        return (toFile === to || !toFile) &&
            isImportablePath(from.fileName, toPath, getCanonicalFileName, globalTypingsCache);
      });
  if (packageJsonFilter) {
    const isAutoImportable =
        hasImportablePath && packageJsonFilter.allowsImportingSourceFile(to, moduleSpecifierResolutionHost);
    moduleSpecifierCache === null || moduleSpecifierCache === void 0 ?
        void 0 :
        moduleSpecifierCache.setBlockedByPackageJsonDependencies(
            from.path, to.path, preferences, {}, !isAutoImportable);
    return isAutoImportable;
  }
  return hasImportablePath;
}
ts.isImportableFile = isImportableFile;
/**
 * Don't include something from a `node_modules` that isn't actually reachable by a global import.
 * A relative import to node_modules is usually a bad idea.
 */
function isImportablePath(fromPath, toPath, getCanonicalFileName, globalCachePath) {
  // If it's in a `node_modules` but is not reachable from here via a global import, don't bother.
  const toNodeModules = ts.forEachAncestorDirectory(toPath, function(ancestor) {
    return ts.getBaseFileName(ancestor) === 'node_modules' ? ancestor : undefined;
  });
  const toNodeModulesParent = toNodeModules && ts.getDirectoryPath(getCanonicalFileName(toNodeModules));
  return toNodeModulesParent === undefined || ts.startsWith(getCanonicalFileName(fromPath), toNodeModulesParent) ||
      (!!globalCachePath && ts.startsWith(getCanonicalFileName(globalCachePath), toNodeModulesParent));
}
function forEachExternalModuleToImportFrom(program, host, preferences, useAutoImportProvider, cb) {
  let _a, _b;
  const useCaseSensitiveFileNames = ts.hostUsesCaseSensitiveFileNames(host);
  const excludePatterns = preferences.autoImportFileExcludePatterns &&
      ts.mapDefined(preferences.autoImportFileExcludePatterns, function(spec) {
        // The client is expected to send rooted path specs since we don't know
        // what directory a relative path is relative to.
        const pattern = ts.getPatternFromSpec(spec, '', 'exclude');
        return pattern ? ts.getRegexFromPattern(pattern, useCaseSensitiveFileNames) : undefined;
      });
  forEachExternalModule(program.getTypeChecker(), program.getSourceFiles(), excludePatterns, function(module, file) {
    return cb(module, file, program, /* isFromPackageJson*/ false);
  });
  const autoImportProvider = useAutoImportProvider &&
      ((_a = host.getPackageJsonAutoImportProvider) === null || _a === void 0 ? void 0 : _a.call(host));
  if (autoImportProvider) {
    const start = ts.timestamp();
    forEachExternalModule(
        autoImportProvider.getTypeChecker(), autoImportProvider.getSourceFiles(), excludePatterns,
        function(module, file) {
          return cb(module, file, autoImportProvider, /* isFromPackageJson*/ true);
        });
    (_b = host.log) === null || _b === void 0 ?
        void 0 :
        _b.call(host, 'forEachExternalModuleToImportFrom autoImportProvider: '.concat(ts.timestamp() - start));
  }
}
ts.forEachExternalModuleToImportFrom = forEachExternalModuleToImportFrom;
function forEachExternalModule(checker, allSourceFiles, excludePatterns, cb) {
  let _a;
  const isExcluded = function(fileName) {
    return excludePatterns === null || excludePatterns === void 0 ? void 0 : excludePatterns.some(function(p) {
      return p.test(fileName);
    });
  };
  for (let _i = 0, _b = checker.getAmbientModules(); _i < _b.length; _i++) {
    const ambient = _b[_i];
    if (!ts.stringContains(ambient.name, '*') &&
        !(excludePatterns && ((_a = ambient.declarations) === null || _a === void 0 ? void 0 : _a.every(function(d) {
            return isExcluded(d.getSourceFile().fileName);
          })))) {
      cb(ambient, /* sourceFile*/ undefined);
    }
  }
  for (let _c = 0, allSourceFiles_1 = allSourceFiles; _c < allSourceFiles_1.length; _c++) {
    const sourceFile = allSourceFiles_1[_c];
    if (ts.isExternalOrCommonJsModule(sourceFile) && !isExcluded(sourceFile.fileName)) {
      cb(checker.getMergedSymbol(sourceFile.symbol), sourceFile);
    }
  }
}
function getExportInfoMap(importingFile, host, program, preferences, cancellationToken) {
  let _a, _b, _c, _d, _e;
  const start = ts.timestamp();
  // Pulling the AutoImportProvider project will trigger its updateGraph if pending,
  // which will invalidate the export map cache if things change, so pull it before
  // checking the cache.
  (_a = host.getPackageJsonAutoImportProvider) === null || _a === void 0 ? void 0 : _a.call(host);
  const cache =
      ((_b = host.getCachedExportInfoMap) === null || _b === void 0 ? void 0 : _b.call(host)) ||
      createCacheableExportInfoMap({
        getCurrentProgram: function() {
          return program;
        },
        getPackageJsonAutoImportProvider: function() {
          let _a;
          return (_a = host.getPackageJsonAutoImportProvider) === null || _a === void 0 ? void 0 : _a.call(host);
        },
        getGlobalTypingsCacheLocation: function() {
          let _a;
          return (_a = host.getGlobalTypingsCacheLocation) === null || _a === void 0 ? void 0 : _a.call(host);
        },
      });
  if (cache.isUsableByFile(importingFile.path)) {
    (_c = host.log) === null || _c === void 0 ? void 0 : _c.call(host, 'getExportInfoMap: cache hit');
    return cache;
  }
  (_d = host.log) === null || _d === void 0 ?
      void 0 :
      _d.call(host, 'getExportInfoMap: cache miss or empty; calculating new results');
  const compilerOptions = program.getCompilerOptions();
  let moduleCount = 0;
  try {
    forEachExternalModuleToImportFrom(
        program, host, preferences, /* useAutoImportProvider*/ true,
        function(moduleSymbol, moduleFile, program, isFromPackageJson) {
          if (++moduleCount % 100 === 0)
            {cancellationToken === null || cancellationToken === void 0 ?
                void 0 :
                cancellationToken.throwIfCancellationRequested();}
          const seenExports = new ts.Map();
          const checker = program.getTypeChecker();
          const defaultInfo = getDefaultLikeExportInfo(moduleSymbol, checker, compilerOptions);
          // Note: I think we shouldn't actually see resolved module symbols here, but weird merges
          // can cause it to happen: see 'completionsImport_mergedReExport.ts'
          if (defaultInfo && isImportableSymbol(defaultInfo.symbol, checker)) {
            cache.add(
                importingFile.path, defaultInfo.symbol,
                defaultInfo.exportKind === 1 /* ExportKind.Default */ ? 'default' /* InternalSymbolName.Default */ :
                                                                        'export=' /* InternalSymbolName.ExportEquals */,
                moduleSymbol, moduleFile, defaultInfo.exportKind, isFromPackageJson, checker);
          }
          checker.forEachExportAndPropertyOfModule(moduleSymbol, function(exported, key) {
            if (exported !== (defaultInfo === null || defaultInfo === void 0 ? void 0 : defaultInfo.symbol) &&
                isImportableSymbol(exported, checker) && ts.addToSeen(seenExports, key)) {
              cache.add(
                  importingFile.path, exported, key, moduleSymbol, moduleFile, 0 /* ExportKind.Named */,
                  isFromPackageJson, checker);
            }
          });
        });
  } catch (err) {
    // Ensure cache is reset if operation is cancelled
    cache.clear();
    throw err;
  }
  (_e = host.log) === null || _e === void 0 ?
      void 0 :
      _e.call(host, 'getExportInfoMap: done in '.concat(ts.timestamp() - start, ' ms'));
  return cache;
}
ts.getExportInfoMap = getExportInfoMap;
function getDefaultLikeExportInfo(moduleSymbol, checker, compilerOptions) {
  const exported = getDefaultLikeExportWorker(moduleSymbol, checker);
  if (!exported)
    {return undefined;}
  const symbol = exported.symbol, exportKind = exported.exportKind;
  const info = getDefaultExportInfoWorker(symbol, checker, compilerOptions);
  return info && __assign({symbol, exportKind}, info);
}
ts.getDefaultLikeExportInfo = getDefaultLikeExportInfo;
function isImportableSymbol(symbol, checker) {
  return !checker.isUndefinedSymbol(symbol) && !checker.isUnknownSymbol(symbol) && !ts.isKnownSymbol(symbol) &&
      !ts.isPrivateIdentifierSymbol(symbol);
}
function getDefaultLikeExportWorker(moduleSymbol, checker) {
  const exportEquals = checker.resolveExternalModuleSymbol(moduleSymbol);
  if (exportEquals !== moduleSymbol)
    {return {symbol: exportEquals, exportKind: 2 /* ExportKind.ExportEquals */};}
  const defaultExport = checker.tryGetMemberInModuleExports('default' /* InternalSymbolName.Default */, moduleSymbol);
  if (defaultExport)
    {return {symbol: defaultExport, exportKind: 1 /* ExportKind.Default */};}
}
function getDefaultExportInfoWorker(defaultExport, checker, compilerOptions) {
  const localSymbol = ts.getLocalSymbolForExportDefault(defaultExport);
  if (localSymbol)
    {return {symbolForMeaning: localSymbol, name: localSymbol.name};}
  const name = getNameForExportDefault(defaultExport);
  if (name !== undefined)
    {return {symbolForMeaning: defaultExport, name};}
  if (defaultExport.flags & 2097152 /* SymbolFlags.Alias */) {
    const aliased = checker.getImmediateAliasedSymbol(defaultExport);
    if (aliased && aliased.parent) {
      // - `aliased` will be undefined if the module is exporting an unresolvable name,
      //    but we can still offer completions for it.
      // - `aliased.parent` will be undefined if the module is exporting `globalThis.something`,
      //    or another expression that resolves to a global.
      return getDefaultExportInfoWorker(aliased, checker, compilerOptions);
    }
  }
  if (defaultExport.escapedName !== 'default' /* InternalSymbolName.Default */ &&
      defaultExport.escapedName !== 'export=' /* InternalSymbolName.ExportEquals */) {
    return {symbolForMeaning: defaultExport, name: defaultExport.getName()};
  }
  return {symbolForMeaning: defaultExport, name: ts.getNameForExportedSymbol(defaultExport, compilerOptions.target)};
}
function getNameForExportDefault(symbol) {
  return symbol.declarations && ts.firstDefined(symbol.declarations, function(declaration) {
    let _a;
    if (ts.isExportAssignment(declaration)) {
      return (_a = ts.tryCast(ts.skipOuterExpressions(declaration.expression), ts.isIdentifier)) === null ||
              _a === void 0 ?
          void 0 :
          _a.text;
    } if (ts.isExportSpecifier(declaration)) {
      ts.Debug.assert(
          declaration.name.text === 'default' /* InternalSymbolName.Default */,
          'Expected the specifier to be a default export');
      return declaration.propertyName && declaration.propertyName.text;
    }
  });
}
})(ts || (ts = {}));
var ts;
(function(ts) {
/** The classifier is used for syntactic highlighting in editors via the TSServer */
function createClassifier() {
  const scanner = ts.createScanner(99 /* ScriptTarget.Latest */, /* skipTrivia*/ false);
  function getClassificationsForLine(text, lexState, syntacticClassifierAbsent) {
    return convertClassificationsToResult(
        getEncodedLexicalClassifications(text, lexState, syntacticClassifierAbsent), text);
  }
  // If there is a syntactic classifier ('syntacticClassifierAbsent' is false),
  // we will be more conservative in order to avoid conflicting with the syntactic classifier.
  function getEncodedLexicalClassifications(text, lexState, syntacticClassifierAbsent) {
    let token = 0 /* SyntaxKind.Unknown */;
    let lastNonTriviaToken = 0 /* SyntaxKind.Unknown */;
    // Just a stack of TemplateHeads and OpenCurlyBraces, used to perform rudimentary (inexact)
    // classification on template strings. Because of the context free nature of templates,
    // the only precise way to classify a template portion would be by propagating the stack across
    // lines, just as we do with the end-of-line state. However, this is a burden for implementers,
    // and the behavior is entirely subsumed by the syntactic classifier anyway, so we instead
    // flatten any nesting when the template stack is non-empty and encode it in the end-of-line state.
    // Situations in which this fails are
    //  1) When template strings are nested across different lines:
    //          `hello ${ `world
    //          ` }`
    //
    //     Where on the second line, you will get the closing of a template,
    //     a closing curly, and a new template.
    //
    //  2) When substitution expressions have curly braces and the curly brace falls on the next line:
    //          `hello ${ () => {
    //          return "world" } } `
    //
    //     Where on the second line, you will get the 'return' keyword,
    //     a string literal, and a template end consisting of '} } `'.
    const templateStack = [];
    const _a = getPrefixFromLexState(lexState), prefix = _a.prefix, pushTemplate = _a.pushTemplate;
    text = prefix + text;
    const offset = prefix.length;
    if (pushTemplate) {
      templateStack.push(15 /* SyntaxKind.TemplateHead */);
    }
    scanner.setText(text);
    let endOfLineState = 0 /* EndOfLineState.None */;
    const spans = [];
    // We can run into an unfortunate interaction between the lexical and syntactic classifier
    // when the user is typing something generic.  Consider the case where the user types:
    //
    //      Foo<number
    //
    // From the lexical classifier's perspective, 'number' is a keyword, and so the word will
    // be classified as such.  However, from the syntactic classifier's tree-based perspective
    // this is simply an expression with the identifier 'number' on the RHS of the less than
    // token.  So the classification will go back to being an identifier.  The moment the user
    // types again, number will become a keyword, then an identifier, etc. etc.
    //
    // To try to avoid this problem, we avoid classifying contextual keywords as keywords
    // when the user is potentially typing something generic.  We just can't do a good enough
    // job at the lexical level, and so well leave it up to the syntactic classifier to make
    // the determination.
    //
    // In order to determine if the user is potentially typing something generic, we use a
    // weak heuristic where we track < and > tokens.  It's a weak heuristic, but should
    // work well enough in practice.
    let angleBracketStack = 0;
    do {
      token = scanner.scan();
      if (!ts.isTrivia(token)) {
        handleToken();
        lastNonTriviaToken = token;
      }
      const end = scanner.getTextPos();
      pushEncodedClassification(scanner.getTokenPos(), end, offset, classFromKind(token), spans);
      if (end >= text.length) {
        const end_1 = getNewEndOfLineState(scanner, token, ts.lastOrUndefined(templateStack));
        if (end_1 !== undefined) {
          endOfLineState = end_1;
        }
      }
    } while (token !== 1 /* SyntaxKind.EndOfFileToken */);
    function handleToken() {
      switch (token) {
        case 43 /* SyntaxKind.SlashToken */:
        case 68 /* SyntaxKind.SlashEqualsToken */:
          if (!noRegexTable[lastNonTriviaToken] &&
              scanner.reScanSlashToken() === 13 /* SyntaxKind.RegularExpressionLiteral */) {
            token = 13 /* SyntaxKind.RegularExpressionLiteral */;
          }
          break;
        case 29 /* SyntaxKind.LessThanToken */:
          if (lastNonTriviaToken === 79 /* SyntaxKind.Identifier */) {
            // Could be the start of something generic.  Keep track of that by bumping
            // up the current count of generic contexts we may be in.
            angleBracketStack++;
          }
          break;
        case 31 /* SyntaxKind.GreaterThanToken */:
          if (angleBracketStack > 0) {
            // If we think we're currently in something generic, then mark that that
            // generic entity is complete.
            angleBracketStack--;
          }
          break;
        case 131 /* SyntaxKind.AnyKeyword */:
        case 152 /* SyntaxKind.StringKeyword */:
        case 148 /* SyntaxKind.NumberKeyword */:
        case 134 /* SyntaxKind.BooleanKeyword */:
        case 153 /* SyntaxKind.SymbolKeyword */:
          if (angleBracketStack > 0 && !syntacticClassifierAbsent) {
            // If it looks like we're could be in something generic, don't classify this
            // as a keyword.  We may just get overwritten by the syntactic classifier,
            // causing a noisy experience for the user.
            token = 79 /* SyntaxKind.Identifier */;
          }
          break;
        case 15 /* SyntaxKind.TemplateHead */:
          templateStack.push(token);
          break;
        case 18 /* SyntaxKind.OpenBraceToken */:
          // If we don't have anything on the template stack,
          // then we aren't trying to keep track of a previously scanned template head.
          if (templateStack.length > 0) {
            templateStack.push(token);
          }
          break;
        case 19 /* SyntaxKind.CloseBraceToken */:
          // If we don't have anything on the template stack,
          // then we aren't trying to keep track of a previously scanned template head.
          if (templateStack.length > 0) {
            const lastTemplateStackToken = ts.lastOrUndefined(templateStack);
            if (lastTemplateStackToken === 15 /* SyntaxKind.TemplateHead */) {
              token = scanner.reScanTemplateToken(/* isTaggedTemplate */ false);
              // Only pop on a TemplateTail; a TemplateMiddle indicates there is more for us.
              if (token === 17 /* SyntaxKind.TemplateTail */) {
                templateStack.pop();
              } else {
                ts.Debug.assertEqual(token, 16 /* SyntaxKind.TemplateMiddle */, 'Should have been a template middle.');
              }
            } else {
              ts.Debug.assertEqual(
                  lastTemplateStackToken, 18 /* SyntaxKind.OpenBraceToken */, 'Should have been an open brace');
              templateStack.pop();
            }
          }
          break;
        default:
          if (!ts.isKeyword(token)) {
            break;
          }
          if (lastNonTriviaToken === 24 /* SyntaxKind.DotToken */) {
            token = 79 /* SyntaxKind.Identifier */;
          } else if (ts.isKeyword(lastNonTriviaToken) && ts.isKeyword(token) && !canFollow(lastNonTriviaToken, token)) {
            // We have two keywords in a row.  Only treat the second as a keyword if
            // it's a sequence that could legally occur in the language.  Otherwise
            // treat it as an identifier.  This way, if someone writes "private var"
            // we recognize that 'var' is actually an identifier here.
            token = 79 /* SyntaxKind.Identifier */;
          }
      }
    }
    return {endOfLineState, spans};
  }
  return {
    getClassificationsForLine,
    getEncodedLexicalClassifications
  };
}
ts.createClassifier = createClassifier;
// / We do not have a full parser support to know when we should parse a regex or not
// / If we consider every slash token to be a regex, we could be missing cases like "1/2/3", where
// / we have a series of divide operator. this list allows us to be more accurate by ruling out
// / locations where a regexp cannot exist.
var noRegexTable = ts.arrayToNumericMap(
    [
      79 /* SyntaxKind.Identifier */,
      10 /* SyntaxKind.StringLiteral */,
      8 /* SyntaxKind.NumericLiteral */,
      9 /* SyntaxKind.BigIntLiteral */,
      13 /* SyntaxKind.RegularExpressionLiteral */,
      108 /* SyntaxKind.ThisKeyword */,
      45 /* SyntaxKind.PlusPlusToken */,
      46 /* SyntaxKind.MinusMinusToken */,
      21 /* SyntaxKind.CloseParenToken */,
      23 /* SyntaxKind.CloseBracketToken */,
      19 /* SyntaxKind.CloseBraceToken */,
      110 /* SyntaxKind.TrueKeyword */,
      95 /* SyntaxKind.FalseKeyword */,
    ],
    function(token) {
      return token;
    },
    function() {
      return true;
    });
function getNewEndOfLineState(scanner, token, lastOnTemplateStack) {
  switch (token) {
    case 10 /* SyntaxKind.StringLiteral */: {
      // Check to see if we finished up on a multiline string literal.
      if (!scanner.isUnterminated())
        {return undefined;}
      const tokenText = scanner.getTokenText();
      const lastCharIndex = tokenText.length - 1;
      let numBackslashes = 0;
      while (tokenText.charCodeAt(lastCharIndex - numBackslashes) === 92 /* CharacterCodes.backslash */) {
        numBackslashes++;
      }
      // If we have an odd number of backslashes, then the multiline string is unclosed
      if ((numBackslashes & 1) === 0)
        {return undefined;}
      return tokenText.charCodeAt(0) === 34 /* CharacterCodes.doubleQuote */ ?
          3 /* EndOfLineState.InDoubleQuoteStringLiteral */ :
          2 /* EndOfLineState.InSingleQuoteStringLiteral */;
    }
    case 3 /* SyntaxKind.MultiLineCommentTrivia */:
      // Check to see if the multiline comment was unclosed.
      return scanner.isUnterminated() ? 1 /* EndOfLineState.InMultiLineCommentTrivia */ : undefined;
    default:
      if (ts.isTemplateLiteralKind(token)) {
        if (!scanner.isUnterminated()) {
          return undefined;
        }
        switch (token) {
          case 17 /* SyntaxKind.TemplateTail */:
            return 5 /* EndOfLineState.InTemplateMiddleOrTail */;
          case 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */:
            return 4 /* EndOfLineState.InTemplateHeadOrNoSubstitutionTemplate */;
          default:
            return ts.Debug.fail(
                'Only \'NoSubstitutionTemplateLiteral\'s and \'TemplateTail\'s can be unterminated; got SyntaxKind #' +
                token);
        }
      }
      return lastOnTemplateStack === 15 /* SyntaxKind.TemplateHead */ ?
          6 /* EndOfLineState.InTemplateSubstitutionPosition */ :
          undefined;
  }
}
function pushEncodedClassification(start, end, offset, classification, result) {
  if (classification === 8 /* ClassificationType.whiteSpace */) {
    // Don't bother with whitespace classifications.  They're not needed.
    return;
  }
  if (start === 0 && offset > 0) {
    // We're classifying the first token, and this was a case where we prepended text.
    // We should consider the start of this token to be at the start of the original text.
    start += offset;
  }
  const length = end - start;
  if (length > 0) {
    // All our tokens are in relation to the augmented text.  Move them back to be
    // relative to the original text.
    result.push(start - offset, length, classification);
  }
}
function convertClassificationsToResult(classifications, text) {
  const entries = [];
  const dense = classifications.spans;
  let lastEnd = 0;
  for (let i = 0; i < dense.length; i += 3) {
    const start = dense[i];
    const length_1 = dense[i + 1];
    const type = dense[i + 2];
    // Make a whitespace entry between the last item and this one.
    if (lastEnd >= 0) {
      const whitespaceLength_1 = start - lastEnd;
      if (whitespaceLength_1 > 0) {
        entries.push({length: whitespaceLength_1, classification: ts.TokenClass.Whitespace});
      }
    }
    entries.push({length: length_1, classification: convertClassification(type)});
    lastEnd = start + length_1;
  }
  const whitespaceLength = text.length - lastEnd;
  if (whitespaceLength > 0) {
    entries.push({length: whitespaceLength, classification: ts.TokenClass.Whitespace});
  }
  return {entries, finalLexState: classifications.endOfLineState};
}
function convertClassification(type) {
  switch (type) {
    case 1 /* ClassificationType.comment */:
      return ts.TokenClass.Comment;
    case 3 /* ClassificationType.keyword */:
      return ts.TokenClass.Keyword;
    case 4 /* ClassificationType.numericLiteral */:
      return ts.TokenClass.NumberLiteral;
    case 25 /* ClassificationType.bigintLiteral */:
      return ts.TokenClass.BigIntLiteral;
    case 5 /* ClassificationType.operator */:
      return ts.TokenClass.Operator;
    case 6 /* ClassificationType.stringLiteral */:
      return ts.TokenClass.StringLiteral;
    case 8 /* ClassificationType.whiteSpace */:
      return ts.TokenClass.Whitespace;
    case 10 /* ClassificationType.punctuation */:
      return ts.TokenClass.Punctuation;
    case 2 /* ClassificationType.identifier */:
    case 11 /* ClassificationType.className */:
    case 12 /* ClassificationType.enumName */:
    case 13 /* ClassificationType.interfaceName */:
    case 14 /* ClassificationType.moduleName */:
    case 15 /* ClassificationType.typeParameterName */:
    case 16 /* ClassificationType.typeAliasName */:
    case 9 /* ClassificationType.text */:
    case 17 /* ClassificationType.parameterName */:
      return ts.TokenClass.Identifier;
    default:
      return undefined;  // TODO: GH#18217 Debug.assertNever(type);
  }
}
/** Returns true if 'keyword2' can legally follow 'keyword1' in any language construct. */
function canFollow(keyword1, keyword2) {
  if (!ts.isAccessibilityModifier(keyword1)) {
    // Assume any other keyword combination is legal.
    // This can be refined in the future if there are more cases we want the classifier to be better at.
    return true;
  }
  switch (keyword2) {
    case 137 /* SyntaxKind.GetKeyword */:
    case 151 /* SyntaxKind.SetKeyword */:
    case 135 /* SyntaxKind.ConstructorKeyword */:
    case 124 /* SyntaxKind.StaticKeyword */:
    case 127 /* SyntaxKind.AccessorKeyword */:
      return true;  // Allow things like "public get", "public constructor" and "public static".
    default:
      return false;  // Any other keyword following "public" is actually an identifier, not a real keyword.
  }
}
function getPrefixFromLexState(lexState) {
  // If we're in a string literal, then prepend: "\
  // (and a newline).  That way when we lex we'll think we're still in a string literal.
  //
  // If we're in a multiline comment, then prepend: /*
  // (and a newline).  That way when we lex we'll think we're still in a multiline comment.
  switch (lexState) {
    case 3 /* EndOfLineState.InDoubleQuoteStringLiteral */:
      return {prefix: '"\\\n'};
    case 2 /* EndOfLineState.InSingleQuoteStringLiteral */:
      return {prefix: '\'\\\n'};
    case 1 /* EndOfLineState.InMultiLineCommentTrivia */:
      return {prefix: '/*\n'};
    case 4 /* EndOfLineState.InTemplateHeadOrNoSubstitutionTemplate */:
      return {prefix: '`\n'};
    case 5 /* EndOfLineState.InTemplateMiddleOrTail */:
      return {prefix: '}\n', pushTemplate: true};
    case 6 /* EndOfLineState.InTemplateSubstitutionPosition */:
      return {prefix: '', pushTemplate: true};
    case 0 /* EndOfLineState.None */:
      return {prefix: ''};
    default:
      return ts.Debug.assertNever(lexState);
  }
}
function isBinaryExpressionOperatorToken(token) {
  switch (token) {
    case 41 /* SyntaxKind.AsteriskToken */:
    case 43 /* SyntaxKind.SlashToken */:
    case 44 /* SyntaxKind.PercentToken */:
    case 39 /* SyntaxKind.PlusToken */:
    case 40 /* SyntaxKind.MinusToken */:
    case 47 /* SyntaxKind.LessThanLessThanToken */:
    case 48 /* SyntaxKind.GreaterThanGreaterThanToken */:
    case 49 /* SyntaxKind.GreaterThanGreaterThanGreaterThanToken */:
    case 29 /* SyntaxKind.LessThanToken */:
    case 31 /* SyntaxKind.GreaterThanToken */:
    case 32 /* SyntaxKind.LessThanEqualsToken */:
    case 33 /* SyntaxKind.GreaterThanEqualsToken */:
    case 102 /* SyntaxKind.InstanceOfKeyword */:
    case 101 /* SyntaxKind.InKeyword */:
    case 128 /* SyntaxKind.AsKeyword */:
    case 150 /* SyntaxKind.SatisfiesKeyword */:
    case 34 /* SyntaxKind.EqualsEqualsToken */:
    case 35 /* SyntaxKind.ExclamationEqualsToken */:
    case 36 /* SyntaxKind.EqualsEqualsEqualsToken */:
    case 37 /* SyntaxKind.ExclamationEqualsEqualsToken */:
    case 50 /* SyntaxKind.AmpersandToken */:
    case 52 /* SyntaxKind.CaretToken */:
    case 51 /* SyntaxKind.BarToken */:
    case 55 /* SyntaxKind.AmpersandAmpersandToken */:
    case 56 /* SyntaxKind.BarBarToken */:
    case 74 /* SyntaxKind.BarEqualsToken */:
    case 73 /* SyntaxKind.AmpersandEqualsToken */:
    case 78 /* SyntaxKind.CaretEqualsToken */:
    case 70 /* SyntaxKind.LessThanLessThanEqualsToken */:
    case 71 /* SyntaxKind.GreaterThanGreaterThanEqualsToken */:
    case 72 /* SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken */:
    case 64 /* SyntaxKind.PlusEqualsToken */:
    case 65 /* SyntaxKind.MinusEqualsToken */:
    case 66 /* SyntaxKind.AsteriskEqualsToken */:
    case 68 /* SyntaxKind.SlashEqualsToken */:
    case 69 /* SyntaxKind.PercentEqualsToken */:
    case 63 /* SyntaxKind.EqualsToken */:
    case 27 /* SyntaxKind.CommaToken */:
    case 60 /* SyntaxKind.QuestionQuestionToken */:
    case 75 /* SyntaxKind.BarBarEqualsToken */:
    case 76 /* SyntaxKind.AmpersandAmpersandEqualsToken */:
    case 77 /* SyntaxKind.QuestionQuestionEqualsToken */:
      return true;
    default:
      return false;
  }
}
function isPrefixUnaryExpressionOperatorToken(token) {
  switch (token) {
    case 39 /* SyntaxKind.PlusToken */:
    case 40 /* SyntaxKind.MinusToken */:
    case 54 /* SyntaxKind.TildeToken */:
    case 53 /* SyntaxKind.ExclamationToken */:
    case 45 /* SyntaxKind.PlusPlusToken */:
    case 46 /* SyntaxKind.MinusMinusToken */:
      return true;
    default:
      return false;
  }
}
function classFromKind(token) {
  if (ts.isKeyword(token)) {
    return 3 /* ClassificationType.keyword */;
  } if (isBinaryExpressionOperatorToken(token) || isPrefixUnaryExpressionOperatorToken(token)) {
    return 5 /* ClassificationType.operator */;
  } if (token >= 18 /* SyntaxKind.FirstPunctuation */ && token <= 78 /* SyntaxKind.LastPunctuation */) {
    return 10 /* ClassificationType.punctuation */;
  }
  switch (token) {
    case 8 /* SyntaxKind.NumericLiteral */:
      return 4 /* ClassificationType.numericLiteral */;
    case 9 /* SyntaxKind.BigIntLiteral */:
      return 25 /* ClassificationType.bigintLiteral */;
    case 10 /* SyntaxKind.StringLiteral */:
      return 6 /* ClassificationType.stringLiteral */;
    case 13 /* SyntaxKind.RegularExpressionLiteral */:
      return 7 /* ClassificationType.regularExpressionLiteral */;
    case 7 /* SyntaxKind.ConflictMarkerTrivia */:
    case 3 /* SyntaxKind.MultiLineCommentTrivia */:
    case 2 /* SyntaxKind.SingleLineCommentTrivia */:
      return 1 /* ClassificationType.comment */;
    case 5 /* SyntaxKind.WhitespaceTrivia */:
    case 4 /* SyntaxKind.NewLineTrivia */:
      return 8 /* ClassificationType.whiteSpace */;
    case 79 /* SyntaxKind.Identifier */:
    default:
      if (ts.isTemplateLiteralKind(token)) {
        return 6 /* ClassificationType.stringLiteral */;
      }
      return 2 /* ClassificationType.identifier */;
  }
}
/* @internal */
function getSemanticClassifications(typeChecker, cancellationToken, sourceFile, classifiableNames, span) {
  return convertClassificationsToSpans(
      getEncodedSemanticClassifications(typeChecker, cancellationToken, sourceFile, classifiableNames, span));
}
ts.getSemanticClassifications = getSemanticClassifications;
function checkForClassificationCancellation(cancellationToken, kind) {
  // We don't want to actually call back into our host on every node to find out if we've
  // been canceled.  That would be an enormous amount of chattyness, along with the all
  // the overhead of marshalling the data to/from the host.  So instead we pick a few
  // reasonable node kinds to bother checking on.  These node kinds represent high level
  // constructs that we would expect to see commonly, but just at a far less frequent
  // interval.
  //
  // For example, in checker.ts (around 750k) we only have around 600 of these constructs.
  // That means we're calling back into the host around every 1.2k of the file we process.
  // Lib.d.ts has similar numbers.
  switch (kind) {
    case 264 /* SyntaxKind.ModuleDeclaration */:
    case 260 /* SyntaxKind.ClassDeclaration */:
    case 261 /* SyntaxKind.InterfaceDeclaration */:
    case 259 /* SyntaxKind.FunctionDeclaration */:
    case 228 /* SyntaxKind.ClassExpression */:
    case 215 /* SyntaxKind.FunctionExpression */:
    case 216 /* SyntaxKind.ArrowFunction */:
      cancellationToken.throwIfCancellationRequested();
  }
}
/* @internal */
function getEncodedSemanticClassifications(typeChecker, cancellationToken, sourceFile, classifiableNames, span) {
  const spans = [];
  sourceFile.forEachChild(function cb(node) {
    // Only walk into nodes that intersect the requested span.
    if (!node || !ts.textSpanIntersectsWith(span, node.pos, node.getFullWidth())) {
      return;
    }
    checkForClassificationCancellation(cancellationToken, node.kind);
    // Only bother calling into the typechecker if this is an identifier that
    // could possibly resolve to a type name.  This makes classification run
    // in a third of the time it would normally take.
    if (ts.isIdentifier(node) && !ts.nodeIsMissing(node) && classifiableNames.has(node.escapedText)) {
      const symbol = typeChecker.getSymbolAtLocation(node);
      const type = symbol && classifySymbol(symbol, ts.getMeaningFromLocation(node), typeChecker);
      if (type) {
        pushClassification(node.getStart(sourceFile), node.getEnd(), type);
      }
    }
    node.forEachChild(cb);
  });
  return {spans, endOfLineState: 0 /* EndOfLineState.None */};
  function pushClassification(start, end, type) {
    const length = end - start;
    ts.Debug.assert(length > 0, 'Classification had non-positive length of '.concat(length));
    spans.push(start);
    spans.push(length);
    spans.push(type);
  }
}
ts.getEncodedSemanticClassifications = getEncodedSemanticClassifications;
function classifySymbol(symbol, meaningAtPosition, checker) {
  const flags = symbol.getFlags();
  if ((flags & 2885600 /* SymbolFlags.Classifiable */) === 0 /* SymbolFlags.None */) {
    return undefined;
  } if (flags & 32 /* SymbolFlags.Class */) {
    return 11 /* ClassificationType.className */;
  } if (flags & 384 /* SymbolFlags.Enum */) {
    return 12 /* ClassificationType.enumName */;
  } if (flags & 524288 /* SymbolFlags.TypeAlias */) {
    return 16 /* ClassificationType.typeAliasName */;
  } if (flags & 1536 /* SymbolFlags.Module */) {
    // Only classify a module as such if
    //  - It appears in a namespace context.
    //  - There exists a module declaration which actually impacts the value side.
    return meaningAtPosition & 4 /* SemanticMeaning.Namespace */ ||
            meaningAtPosition & 1 /* SemanticMeaning.Value */ && hasValueSideModule(symbol) ?
        14 /* ClassificationType.moduleName */ :
        undefined;
  } if (flags & 2097152 /* SymbolFlags.Alias */) {
    return classifySymbol(checker.getAliasedSymbol(symbol), meaningAtPosition, checker);
  } if (meaningAtPosition & 2 /* SemanticMeaning.Type */) {
    return flags & 64 /* SymbolFlags.Interface */      ? 13 /* ClassificationType.interfaceName */ :
        flags & 262144 /* SymbolFlags.TypeParameter */ ? 15 /* ClassificationType.typeParameterName */ :
                                                         undefined;
  }
    return undefined;

}
/** Returns true if there exists a module that introduces entities on the value side. */
function hasValueSideModule(symbol) {
  return ts.some(symbol.declarations, function(declaration) {
    return ts.isModuleDeclaration(declaration) &&
        ts.getModuleInstanceState(declaration) === 1 /* ModuleInstanceState.Instantiated */;
  });
}
function getClassificationTypeName(type) {
  switch (type) {
    case 1 /* ClassificationType.comment */:
      return 'comment' /* ClassificationTypeNames.comment */;
    case 2 /* ClassificationType.identifier */:
      return 'identifier' /* ClassificationTypeNames.identifier */;
    case 3 /* ClassificationType.keyword */:
      return 'keyword' /* ClassificationTypeNames.keyword */;
    case 4 /* ClassificationType.numericLiteral */:
      return 'number' /* ClassificationTypeNames.numericLiteral */;
    case 25 /* ClassificationType.bigintLiteral */:
      return 'bigint' /* ClassificationTypeNames.bigintLiteral */;
    case 5 /* ClassificationType.operator */:
      return 'operator' /* ClassificationTypeNames.operator */;
    case 6 /* ClassificationType.stringLiteral */:
      return 'string' /* ClassificationTypeNames.stringLiteral */;
    case 8 /* ClassificationType.whiteSpace */:
      return 'whitespace' /* ClassificationTypeNames.whiteSpace */;
    case 9 /* ClassificationType.text */:
      return 'text' /* ClassificationTypeNames.text */;
    case 10 /* ClassificationType.punctuation */:
      return 'punctuation' /* ClassificationTypeNames.punctuation */;
    case 11 /* ClassificationType.className */:
      return 'class name' /* ClassificationTypeNames.className */;
    case 12 /* ClassificationType.enumName */:
      return 'enum name' /* ClassificationTypeNames.enumName */;
    case 13 /* ClassificationType.interfaceName */:
      return 'interface name' /* ClassificationTypeNames.interfaceName */;
    case 14 /* ClassificationType.moduleName */:
      return 'module name' /* ClassificationTypeNames.moduleName */;
    case 15 /* ClassificationType.typeParameterName */:
      return 'type parameter name' /* ClassificationTypeNames.typeParameterName */;
    case 16 /* ClassificationType.typeAliasName */:
      return 'type alias name' /* ClassificationTypeNames.typeAliasName */;
    case 17 /* ClassificationType.parameterName */:
      return 'parameter name' /* ClassificationTypeNames.parameterName */;
    case 18 /* ClassificationType.docCommentTagName */:
      return 'doc comment tag name' /* ClassificationTypeNames.docCommentTagName */;
    case 19 /* ClassificationType.jsxOpenTagName */:
      return 'jsx open tag name' /* ClassificationTypeNames.jsxOpenTagName */;
    case 20 /* ClassificationType.jsxCloseTagName */:
      return 'jsx close tag name' /* ClassificationTypeNames.jsxCloseTagName */;
    case 21 /* ClassificationType.jsxSelfClosingTagName */:
      return 'jsx self closing tag name' /* ClassificationTypeNames.jsxSelfClosingTagName */;
    case 22 /* ClassificationType.jsxAttribute */:
      return 'jsx attribute' /* ClassificationTypeNames.jsxAttribute */;
    case 23 /* ClassificationType.jsxText */:
      return 'jsx text' /* ClassificationTypeNames.jsxText */;
    case 24 /* ClassificationType.jsxAttributeStringLiteralValue */:
      return 'jsx attribute string literal value' /* ClassificationTypeNames.jsxAttributeStringLiteralValue */;
    default:
      return undefined;  // TODO: GH#18217 throw Debug.assertNever(type);
  }
}
function convertClassificationsToSpans(classifications) {
  ts.Debug.assert(classifications.spans.length % 3 === 0);
  const dense = classifications.spans;
  const result = [];
  for (let i = 0; i < dense.length; i += 3) {
    result.push({
      textSpan: ts.createTextSpan(dense[i], dense[i + 1]),
      classificationType: getClassificationTypeName(dense[i + 2])
    });
  }
  return result;
}
/* @internal */
function getSyntacticClassifications(cancellationToken, sourceFile, span) {
  return convertClassificationsToSpans(getEncodedSyntacticClassifications(cancellationToken, sourceFile, span));
}
ts.getSyntacticClassifications = getSyntacticClassifications;
/* @internal */
function getEncodedSyntacticClassifications(cancellationToken, sourceFile, span) {
  const spanStart = span.start;
  const spanLength = span.length;
  // Make a scanner we can get trivia from.
  const triviaScanner =
      ts.createScanner(99 /* ScriptTarget.Latest */, /* skipTrivia*/ false, sourceFile.languageVariant, sourceFile.text);
  const mergeConflictScanner =
      ts.createScanner(99 /* ScriptTarget.Latest */, /* skipTrivia*/ false, sourceFile.languageVariant, sourceFile.text);
  const result = [];
  processElement(sourceFile);
  return {spans: result, endOfLineState: 0 /* EndOfLineState.None */};
  function pushClassification(start, length, type) {
    result.push(start);
    result.push(length);
    result.push(type);
  }
  function classifyLeadingTriviaAndGetTokenStart(token) {
    triviaScanner.setTextPos(token.pos);
    while (true) {
      const start = triviaScanner.getTextPos();
      // only bother scanning if we have something that could be trivia.
      if (!ts.couldStartTrivia(sourceFile.text, start)) {
        return start;
      }
      const kind = triviaScanner.scan();
      const end = triviaScanner.getTextPos();
      const width = end - start;
      // The moment we get something that isn't trivia, then stop processing.
      if (!ts.isTrivia(kind)) {
        return start;
      }
      switch (kind) {
        case 4 /* SyntaxKind.NewLineTrivia */:
        case 5 /* SyntaxKind.WhitespaceTrivia */:
          // Don't bother with newlines/whitespace.
          continue;
        case 2 /* SyntaxKind.SingleLineCommentTrivia */:
        case 3 /* SyntaxKind.MultiLineCommentTrivia */:
          // Only bother with the trivia if it at least intersects the span of interest.
          classifyComment(token, kind, start, width);
          // Classifying a comment might cause us to reuse the trivia scanner
          // (because of jsdoc comments).  So after we classify the comment make
          // sure we set the scanner position back to where it needs to be.
          triviaScanner.setTextPos(end);
          continue;
        case 7 /* SyntaxKind.ConflictMarkerTrivia */:
          var text = sourceFile.text;
          var ch = text.charCodeAt(start);
          // for the <<<<<<< and >>>>>>> markers, we just add them in as comments
          // in the classification stream.
          if (ch === 60 /* CharacterCodes.lessThan */ || ch === 62 /* CharacterCodes.greaterThan */) {
            pushClassification(start, width, 1 /* ClassificationType.comment */);
            continue;
          }
          // for the ||||||| and ======== markers, add a comment for the first line,
          // and then lex all subsequent lines up until the end of the conflict marker.
          ts.Debug.assert(ch === 124 /* CharacterCodes.bar */ || ch === 61 /* CharacterCodes.equals */);
          classifyDisabledMergeCode(text, start, end);
          break;
        case 6 /* SyntaxKind.ShebangTrivia */:
          // TODO: Maybe we should classify these.
          break;
        default:
          ts.Debug.assertNever(kind);
      }
    }
  }
  function classifyComment(token, kind, start, width) {
    if (kind === 3 /* SyntaxKind.MultiLineCommentTrivia */) {
      // See if this is a doc comment.  If so, we'll classify certain portions of it
      // specially.
      const docCommentAndDiagnostics = ts.parseIsolatedJSDocComment(sourceFile.text, start, width);
      if (docCommentAndDiagnostics && docCommentAndDiagnostics.jsDoc) {
        // TODO: This should be predicated on `token["kind"]` being compatible with `HasJSDoc["kind"]`
        ts.setParent(docCommentAndDiagnostics.jsDoc, token);
        classifyJSDocComment(docCommentAndDiagnostics.jsDoc);
        return;
      }
    } else if (kind === 2 /* SyntaxKind.SingleLineCommentTrivia */) {
      if (tryClassifyTripleSlashComment(start, width)) {
        return;
      }
    }
    // Simple comment.  Just add as is.
    pushCommentRange(start, width);
  }
  function pushCommentRange(start, width) {
    pushClassification(start, width, 1 /* ClassificationType.comment */);
  }
  function classifyJSDocComment(docComment) {
    let _a, _b, _c, _d, _e, _f, _g;
    let pos = docComment.pos;
    if (docComment.tags) {
      for (let _i = 0, _h = docComment.tags; _i < _h.length; _i++) {
        const tag = _h[_i];
        // As we walk through each tag, classify the portion of text from the end of
        // the last tag (or the start of the entire doc comment) as 'comment'.
        if (tag.pos !== pos) {
          pushCommentRange(pos, tag.pos - pos);
        }
        pushClassification(tag.pos, 1, 10 /* ClassificationType.punctuation */);  // "@"
        pushClassification(
            tag.tagName.pos, tag.tagName.end - tag.tagName.pos,
            18 /* ClassificationType.docCommentTagName */);  // e.g. "param"
        pos = tag.tagName.end;
        let commentStart = tag.tagName.end;
        switch (tag.kind) {
          case 343 /* SyntaxKind.JSDocParameterTag */:
            var param = tag;
            processJSDocParameterTag(param);
            commentStart =
                param.isNameFirst && ((_a = param.typeExpression) === null || _a === void 0 ? void 0 : _a.end) ||
                param.name.end;
            break;
          case 350 /* SyntaxKind.JSDocPropertyTag */:
            var prop = tag;
            commentStart =
                prop.isNameFirst && ((_b = prop.typeExpression) === null || _b === void 0 ? void 0 : _b.end) ||
                prop.name.end;
            break;
          case 347 /* SyntaxKind.JSDocTemplateTag */:
            processJSDocTemplateTag(tag);
            pos = tag.end;
            commentStart = tag.typeParameters.end;
            break;
          case 348 /* SyntaxKind.JSDocTypedefTag */:
            var type = tag;
            commentStart = ((_c = type.typeExpression) === null || _c === void 0 ? void 0 : _c.kind) ===
                        312 /* SyntaxKind.JSDocTypeExpression */
                    && ((_d = type.fullName) === null || _d === void 0 ? void 0 : _d.end) ||
                ((_e = type.typeExpression) === null || _e === void 0 ? void 0 : _e.end) || commentStart;
            break;
          case 341 /* SyntaxKind.JSDocCallbackTag */:
            commentStart = tag.typeExpression.end;
            break;
          case 346 /* SyntaxKind.JSDocTypeTag */:
            processElement(tag.typeExpression);
            pos = tag.end;
            commentStart = tag.typeExpression.end;
            break;
          case 345 /* SyntaxKind.JSDocThisTag */:
          case 342 /* SyntaxKind.JSDocEnumTag */:
            commentStart = tag.typeExpression.end;
            break;
          case 344 /* SyntaxKind.JSDocReturnTag */:
            processElement(tag.typeExpression);
            pos = tag.end;
            commentStart = ((_f = tag.typeExpression) === null || _f === void 0 ? void 0 : _f.end) || commentStart;
            break;
          case 349 /* SyntaxKind.JSDocSeeTag */:
            commentStart = ((_g = tag.name) === null || _g === void 0 ? void 0 : _g.end) || commentStart;
            break;
          case 331 /* SyntaxKind.JSDocAugmentsTag */:
          case 332 /* SyntaxKind.JSDocImplementsTag */:
            commentStart = tag.class.end;
            break;
        }
        if (typeof tag.comment === 'object') {
          pushCommentRange(tag.comment.pos, tag.comment.end - tag.comment.pos);
        } else if (typeof tag.comment === 'string') {
          pushCommentRange(commentStart, tag.end - commentStart);
        }
      }
    }
    if (pos !== docComment.end) {
      pushCommentRange(pos, docComment.end - pos);
    }
    return;
    function processJSDocParameterTag(tag) {
      if (tag.isNameFirst) {
        pushCommentRange(pos, tag.name.pos - pos);
        pushClassification(tag.name.pos, tag.name.end - tag.name.pos, 17 /* ClassificationType.parameterName */);
        pos = tag.name.end;
      }
      if (tag.typeExpression) {
        pushCommentRange(pos, tag.typeExpression.pos - pos);
        processElement(tag.typeExpression);
        pos = tag.typeExpression.end;
      }
      if (!tag.isNameFirst) {
        pushCommentRange(pos, tag.name.pos - pos);
        pushClassification(tag.name.pos, tag.name.end - tag.name.pos, 17 /* ClassificationType.parameterName */);
        pos = tag.name.end;
      }
    }
  }
  function tryClassifyTripleSlashComment(start, width) {
    const tripleSlashXMLCommentRegEx = /^(\/\/\/\s*)(<)(?:(\S+)((?:[^/]|\/[^>])*)(\/>)?)?/im;
    // Require a leading whitespace character (the parser already does) to prevent terrible backtracking performance
    const attributeRegex = /(\s)(\S+)(\s*)(=)(\s*)('[^']+'|"[^"]+")/img;
    const text = sourceFile.text.substr(start, width);
    const match = tripleSlashXMLCommentRegEx.exec(text);
    if (!match) {
      return false;
    }
    // Limiting classification to exactly the elements and attributes
    // defined in `ts.commentPragmas` would be excessive, but we can avoid
    // some obvious false positives (e.g. in XML-like doc comments) by
    // checking the element name.
    // eslint-disable-next-line local/no-in-operator
    if (!match[3] || !(match[3] in ts.commentPragmas)) {
      return false;
    }
    let pos = start;
    pushCommentRange(pos, match[1].length);  // ///
    pos += match[1].length;
    pushClassification(pos, match[2].length, 10 /* ClassificationType.punctuation */);  // <
    pos += match[2].length;
    pushClassification(pos, match[3].length, 21 /* ClassificationType.jsxSelfClosingTagName */);  // element name
    pos += match[3].length;
    const attrText = match[4];
    let attrPos = pos;
    while (true) {
      const attrMatch = attributeRegex.exec(attrText);
      if (!attrMatch) {
        break;
      }
      const newAttrPos = pos + attrMatch.index + attrMatch[1].length;  // whitespace
      if (newAttrPos > attrPos) {
        pushCommentRange(attrPos, newAttrPos - attrPos);
        attrPos = newAttrPos;
      }
      pushClassification(attrPos, attrMatch[2].length, 22 /* ClassificationType.jsxAttribute */);  // attribute name
      attrPos += attrMatch[2].length;
      if (attrMatch[3].length) {
        pushCommentRange(attrPos, attrMatch[3].length);  // whitespace
        attrPos += attrMatch[3].length;
      }
      pushClassification(attrPos, attrMatch[4].length, 5 /* ClassificationType.operator */);  // =
      attrPos += attrMatch[4].length;
      if (attrMatch[5].length) {
        pushCommentRange(attrPos, attrMatch[5].length);  // whitespace
        attrPos += attrMatch[5].length;
      }
      pushClassification(
          attrPos, attrMatch[6].length, 24 /* ClassificationType.jsxAttributeStringLiteralValue */);  // attribute value
      attrPos += attrMatch[6].length;
    }
    pos += match[4].length;
    if (pos > attrPos) {
      pushCommentRange(attrPos, pos - attrPos);
    }
    if (match[5]) {
      pushClassification(pos, match[5].length, 10 /* ClassificationType.punctuation */);  // />
      pos += match[5].length;
    }
    const end = start + width;
    if (pos < end) {
      pushCommentRange(pos, end - pos);
    }
    return true;
  }
  function processJSDocTemplateTag(tag) {
    for (let _i = 0, _a = tag.getChildren(); _i < _a.length; _i++) {
      const child = _a[_i];
      processElement(child);
    }
  }
  function classifyDisabledMergeCode(text, start, end) {
    // Classify the line that the ||||||| or ======= marker is on as a comment.
    // Then just lex all further tokens and add them to the result.
    let i;
    for (i = start; i < end; i++) {
      if (ts.isLineBreak(text.charCodeAt(i))) {
        break;
      }
    }
    pushClassification(start, i - start, 1 /* ClassificationType.comment */);
    mergeConflictScanner.setTextPos(i);
    while (mergeConflictScanner.getTextPos() < end) {
      classifyDisabledCodeToken();
    }
  }
  function classifyDisabledCodeToken() {
    const start = mergeConflictScanner.getTextPos();
    const tokenKind = mergeConflictScanner.scan();
    const end = mergeConflictScanner.getTextPos();
    const type = classifyTokenType(tokenKind);
    if (type) {
      pushClassification(start, end - start, type);
    }
  }
  /**
   * Returns true if node should be treated as classified and no further processing is required.
   * False will mean that node is not classified and traverse routine should recurse into node contents.
   */
  function tryClassifyNode(node) {
    if (ts.isJSDoc(node)) {
      return true;
    }
    if (ts.nodeIsMissing(node)) {
      return true;
    }
    const classifiedElementName = tryClassifyJsxElementName(node);
    if (!ts.isToken(node) && node.kind !== 11 /* SyntaxKind.JsxText */ && classifiedElementName === undefined) {
      return false;
    }
    const tokenStart = node.kind === 11 /* SyntaxKind.JsxText */ ? node.pos : classifyLeadingTriviaAndGetTokenStart(node);
    const tokenWidth = node.end - tokenStart;
    ts.Debug.assert(tokenWidth >= 0);
    if (tokenWidth > 0) {
      const type = classifiedElementName || classifyTokenType(node.kind, node);
      if (type) {
        pushClassification(tokenStart, tokenWidth, type);
      }
    }
    return true;
  }
  function tryClassifyJsxElementName(token) {
    switch (token.parent && token.parent.kind) {
      case 283 /* SyntaxKind.JsxOpeningElement */:
        if (token.parent.tagName === token) {
          return 19 /* ClassificationType.jsxOpenTagName */;
        }
        break;
      case 284 /* SyntaxKind.JsxClosingElement */:
        if (token.parent.tagName === token) {
          return 20 /* ClassificationType.jsxCloseTagName */;
        }
        break;
      case 282 /* SyntaxKind.JsxSelfClosingElement */:
        if (token.parent.tagName === token) {
          return 21 /* ClassificationType.jsxSelfClosingTagName */;
        }
        break;
      case 288 /* SyntaxKind.JsxAttribute */:
        if (token.parent.name === token) {
          return 22 /* ClassificationType.jsxAttribute */;
        }
        break;
    }
    return undefined;
  }
  // for accurate classification, the actual token should be passed in.  however, for
  // cases like 'disabled merge code' classification, we just get the token kind and
  // classify based on that instead.
  function classifyTokenType(tokenKind, token) {
    if (ts.isKeyword(tokenKind)) {
      return 3 /* ClassificationType.keyword */;
    }
    // Special case `<` and `>`: If they appear in a generic context they are punctuation,
    // not operators.
    if (tokenKind === 29 /* SyntaxKind.LessThanToken */ || tokenKind === 31 /* SyntaxKind.GreaterThanToken */) {
      // If the node owning the token has a type argument list or type parameter list, then
      // we can effectively assume that a '<' and '>' belong to those lists.
      if (token && ts.getTypeArgumentOrTypeParameterList(token.parent)) {
        return 10 /* ClassificationType.punctuation */;
      }
    }
    if (ts.isPunctuation(tokenKind)) {
      if (token) {
        const parent = token.parent;
        if (tokenKind === 63 /* SyntaxKind.EqualsToken */) {
          // the '=' in a variable declaration is special cased here.
          if (parent.kind === 257 /* SyntaxKind.VariableDeclaration */ ||
              parent.kind === 169 /* SyntaxKind.PropertyDeclaration */ ||
              parent.kind === 166 /* SyntaxKind.Parameter */ || parent.kind === 288 /* SyntaxKind.JsxAttribute */) {
            return 5 /* ClassificationType.operator */;
          }
        }
        if (parent.kind === 223 /* SyntaxKind.BinaryExpression */ ||
            parent.kind === 221 /* SyntaxKind.PrefixUnaryExpression */ ||
            parent.kind === 222 /* SyntaxKind.PostfixUnaryExpression */ ||
            parent.kind === 224 /* SyntaxKind.ConditionalExpression */) {
          return 5 /* ClassificationType.operator */;
        }
      }
      return 10 /* ClassificationType.punctuation */;
    } if (tokenKind === 8 /* SyntaxKind.NumericLiteral */) {
      return 4 /* ClassificationType.numericLiteral */;
    } if (tokenKind === 9 /* SyntaxKind.BigIntLiteral */) {
      return 25 /* ClassificationType.bigintLiteral */;
    } if (tokenKind === 10 /* SyntaxKind.StringLiteral */) {
      return token && token.parent.kind === 288 /* SyntaxKind.JsxAttribute */ ?
          24 /* ClassificationType.jsxAttributeStringLiteralValue */ :
          6 /* ClassificationType.stringLiteral */;
    } if (tokenKind === 13 /* SyntaxKind.RegularExpressionLiteral */) {
      // TODO: we should get another classification type for these literals.
      return 6 /* ClassificationType.stringLiteral */;
    } if (ts.isTemplateLiteralKind(tokenKind)) {
      // TODO (drosen): we should *also* get another classification type for these literals.
      return 6 /* ClassificationType.stringLiteral */;
    } if (tokenKind === 11 /* SyntaxKind.JsxText */) {
      return 23 /* ClassificationType.jsxText */;
    } if (tokenKind === 79 /* SyntaxKind.Identifier */) {
      if (token) {
        switch (token.parent.kind) {
          case 260 /* SyntaxKind.ClassDeclaration */:
            if (token.parent.name === token) {
              return 11 /* ClassificationType.className */;
            }
            return;
          case 165 /* SyntaxKind.TypeParameter */:
            if (token.parent.name === token) {
              return 15 /* ClassificationType.typeParameterName */;
            }
            return;
          case 261 /* SyntaxKind.InterfaceDeclaration */:
            if (token.parent.name === token) {
              return 13 /* ClassificationType.interfaceName */;
            }
            return;
          case 263 /* SyntaxKind.EnumDeclaration */:
            if (token.parent.name === token) {
              return 12 /* ClassificationType.enumName */;
            }
            return;
          case 264 /* SyntaxKind.ModuleDeclaration */:
            if (token.parent.name === token) {
              return 14 /* ClassificationType.moduleName */;
            }
            return;
          case 166 /* SyntaxKind.Parameter */:
            if (token.parent.name === token) {
              return ts.isThisIdentifier(token) ? 3 /* ClassificationType.keyword */ :
                                                  17 /* ClassificationType.parameterName */;
            }
            return;
        }
        if (ts.isConstTypeReference(token.parent)) {
          return 3 /* ClassificationType.keyword */;
        }
      }
      return 2 /* ClassificationType.identifier */;
    }
  }
  function processElement(element) {
    if (!element) {
      return;
    }
    // Ignore nodes that don't intersect the original span to classify.
    if (ts.decodedTextSpanIntersectsWith(spanStart, spanLength, element.pos, element.getFullWidth())) {
      checkForClassificationCancellation(cancellationToken, element.kind);
      for (let _i = 0, _a = element.getChildren(sourceFile); _i < _a.length; _i++) {
        const child = _a[_i];
        if (!tryClassifyNode(child)) {
          // Recurse into our child nodes.
          processElement(child);
        }
      }
    }
  }
}
ts.getEncodedSyntacticClassifications = getEncodedSyntacticClassifications;
})(ts || (ts = {}));
/** @internal */
var ts;
(function(ts) {
let classifier;
(function(classifier) {
let v2020;
(function(v2020) {
let TokenEncodingConsts;
(function(TokenEncodingConsts) {
TokenEncodingConsts[TokenEncodingConsts['typeOffset'] = 8] = 'typeOffset';
TokenEncodingConsts[TokenEncodingConsts['modifierMask'] = 255] = 'modifierMask';
})(TokenEncodingConsts = v2020.TokenEncodingConsts || (v2020.TokenEncodingConsts = {}));
let TokenType;
(function(TokenType) {
TokenType[TokenType['class'] = 0] = 'class';
TokenType[TokenType['enum'] = 1] = 'enum';
TokenType[TokenType['interface'] = 2] = 'interface';
TokenType[TokenType['namespace'] = 3] = 'namespace';
TokenType[TokenType['typeParameter'] = 4] = 'typeParameter';
TokenType[TokenType['type'] = 5] = 'type';
TokenType[TokenType['parameter'] = 6] = 'parameter';
TokenType[TokenType['variable'] = 7] = 'variable';
TokenType[TokenType['enumMember'] = 8] = 'enumMember';
TokenType[TokenType['property'] = 9] = 'property';
TokenType[TokenType['function'] = 10] = 'function';
TokenType[TokenType['member'] = 11] = 'member';
})(TokenType = v2020.TokenType || (v2020.TokenType = {}));
let TokenModifier;
(function(TokenModifier) {
TokenModifier[TokenModifier['declaration'] = 0] = 'declaration';
TokenModifier[TokenModifier['static'] = 1] = 'static';
TokenModifier[TokenModifier['async'] = 2] = 'async';
TokenModifier[TokenModifier['readonly'] = 3] = 'readonly';
TokenModifier[TokenModifier['defaultLibrary'] = 4] = 'defaultLibrary';
TokenModifier[TokenModifier['local'] = 5] = 'local';
})(TokenModifier = v2020.TokenModifier || (v2020.TokenModifier = {}));
/** This is mainly used internally for testing */
function getSemanticClassifications(program, cancellationToken, sourceFile, span) {
  const classifications = getEncodedSemanticClassifications(program, cancellationToken, sourceFile, span);
  ts.Debug.assert(classifications.spans.length % 3 === 0);
  const dense = classifications.spans;
  const result = [];
  for (let i = 0; i < dense.length; i += 3) {
    result.push({textSpan: ts.createTextSpan(dense[i], dense[i + 1]), classificationType: dense[i + 2]});
  }
  return result;
}
v2020.getSemanticClassifications = getSemanticClassifications;
function getEncodedSemanticClassifications(program, cancellationToken, sourceFile, span) {
  return {
    spans: getSemanticTokens(program, sourceFile, span, cancellationToken),
    endOfLineState: 0 /* EndOfLineState.None */
  };
}
v2020.getEncodedSemanticClassifications = getEncodedSemanticClassifications;
function getSemanticTokens(program, sourceFile, span, cancellationToken) {
  const resultTokens = [];
  const collector = function(node, typeIdx, modifierSet) {
    resultTokens.push(
        node.getStart(sourceFile), node.getWidth(sourceFile),
        ((typeIdx + 1) << 8 /* TokenEncodingConsts.typeOffset */) + modifierSet);
  };
  if (program && sourceFile) {
    collectTokens(program, sourceFile, span, collector, cancellationToken);
  }
  return resultTokens;
}
function collectTokens(program, sourceFile, span, collector, cancellationToken) {
  const typeChecker = program.getTypeChecker();
  let inJSXElement = false;
  function visit(node) {
    switch (node.kind) {
      case 264 /* SyntaxKind.ModuleDeclaration */:
      case 260 /* SyntaxKind.ClassDeclaration */:
      case 261 /* SyntaxKind.InterfaceDeclaration */:
      case 259 /* SyntaxKind.FunctionDeclaration */:
      case 228 /* SyntaxKind.ClassExpression */:
      case 215 /* SyntaxKind.FunctionExpression */:
      case 216 /* SyntaxKind.ArrowFunction */:
        cancellationToken.throwIfCancellationRequested();
    }
    if (!node || !ts.textSpanIntersectsWith(span, node.pos, node.getFullWidth()) || node.getFullWidth() === 0) {
      return;
    }
    const prevInJSXElement = inJSXElement;
    if (ts.isJsxElement(node) || ts.isJsxSelfClosingElement(node)) {
      inJSXElement = true;
    }
    if (ts.isJsxExpression(node)) {
      inJSXElement = false;
    }
    if (ts.isIdentifier(node) && !inJSXElement && !inImportClause(node) &&
        !ts.isInfinityOrNaNString(node.escapedText)) {
      let symbol = typeChecker.getSymbolAtLocation(node);
      if (symbol) {
        if (symbol.flags & 2097152 /* SymbolFlags.Alias */) {
          symbol = typeChecker.getAliasedSymbol(symbol);
        }
        let typeIdx = classifySymbol(symbol, ts.getMeaningFromLocation(node));
        if (typeIdx !== undefined) {
          let modifierSet = 0;
          if (node.parent) {
            const parentIsDeclaration =
                (ts.isBindingElement(node.parent) || tokenFromDeclarationMapping.get(node.parent.kind) === typeIdx);
            if (parentIsDeclaration && node.parent.name === node) {
              modifierSet = 1 << 0 /* TokenModifier.declaration */;
            }
          }
          // property declaration in constructor
          if (typeIdx === 6 /* TokenType.parameter */ && isRightSideOfQualifiedNameOrPropertyAccess(node)) {
            typeIdx = 9 /* TokenType.property */;
          }
          typeIdx = reclassifyByType(typeChecker, node, typeIdx);
          const decl = symbol.valueDeclaration;
          if (decl) {
            const modifiers = ts.getCombinedModifierFlags(decl);
            const nodeFlags = ts.getCombinedNodeFlags(decl);
            if (modifiers & 32 /* ModifierFlags.Static */) {
              modifierSet |= 1 << 1 /* TokenModifier.static */;
            }
            if (modifiers & 512 /* ModifierFlags.Async */) {
              modifierSet |= 1 << 2 /* TokenModifier.async */;
            }
            if (typeIdx !== 0 /* TokenType.class */ && typeIdx !== 2 /* TokenType.interface */) {
              if ((modifiers & 64 /* ModifierFlags.Readonly */) || (nodeFlags & 2 /* NodeFlags.Const */) ||
                  (symbol.getFlags() & 8 /* SymbolFlags.EnumMember */)) {
                modifierSet |= 1 << 3 /* TokenModifier.readonly */;
              }
            }
            if ((typeIdx === 7 /* TokenType.variable */ || typeIdx === 10 /* TokenType.function */) &&
                isLocalDeclaration(decl, sourceFile)) {
              modifierSet |= 1 << 5 /* TokenModifier.local */;
            }
            if (program.isSourceFileDefaultLibrary(decl.getSourceFile())) {
              modifierSet |= 1 << 4 /* TokenModifier.defaultLibrary */;
            }
          } else if (symbol.declarations && symbol.declarations.some(function(d) {
                       return program.isSourceFileDefaultLibrary(d.getSourceFile());
                     })) {
            modifierSet |= 1 << 4 /* TokenModifier.defaultLibrary */;
          }
          collector(node, typeIdx, modifierSet);
        }
      }
    }
    ts.forEachChild(node, visit);
    inJSXElement = prevInJSXElement;
  }
  visit(sourceFile);
}
function classifySymbol(symbol, meaning) {
  const flags = symbol.getFlags();
  if (flags & 32 /* SymbolFlags.Class */) {
    return 0 /* TokenType.class */;
  } if (flags & 384 /* SymbolFlags.Enum */) {
    return 1 /* TokenType.enum */;
  } if (flags & 524288 /* SymbolFlags.TypeAlias */) {
    return 5 /* TokenType.type */;
  } if (flags & 64 /* SymbolFlags.Interface */) {
    if (meaning & 2 /* SemanticMeaning.Type */) {
      return 2 /* TokenType.interface */;
    }
  } else if (flags & 262144 /* SymbolFlags.TypeParameter */) {
    return 4 /* TokenType.typeParameter */;
  }
  let decl = symbol.valueDeclaration || symbol.declarations && symbol.declarations[0];
  if (decl && ts.isBindingElement(decl)) {
    decl = getDeclarationForBindingElement(decl);
  }
  return decl && tokenFromDeclarationMapping.get(decl.kind);
}
function reclassifyByType(typeChecker, node, typeIdx) {
  // type based classifications
  if (typeIdx === 7 /* TokenType.variable */ || typeIdx === 9 /* TokenType.property */ ||
      typeIdx === 6 /* TokenType.parameter */) {
    const type_1 = typeChecker.getTypeAtLocation(node);
    if (type_1) {
      const test = function(condition) {
        return condition(type_1) || type_1.isUnion() && type_1.types.some(condition);
      };
      if (typeIdx !== 6 /* TokenType.parameter */ && test(function(t) {
            return t.getConstructSignatures().length > 0;
          })) {
        return 0 /* TokenType.class */;
      }
      if (test(function(t) {
            return t.getCallSignatures().length > 0;
          }) &&
              !test(function(t) {
                return t.getProperties().length > 0;
              }) ||
          isExpressionInCallExpression(node)) {
        return typeIdx === 9 /* TokenType.property */ ? 11 /* TokenType.member */ : 10 /* TokenType.function */;
      }
    }
  }
  return typeIdx;
}
function isLocalDeclaration(decl, sourceFile) {
  if (ts.isBindingElement(decl)) {
    decl = getDeclarationForBindingElement(decl);
  }
  if (ts.isVariableDeclaration(decl)) {
    return (!ts.isSourceFile(decl.parent.parent.parent) || ts.isCatchClause(decl.parent)) &&
        decl.getSourceFile() === sourceFile;
  } if (ts.isFunctionDeclaration(decl)) {
    return !ts.isSourceFile(decl.parent) && decl.getSourceFile() === sourceFile;
  }
  return false;
}
function getDeclarationForBindingElement(element) {
  while (true) {
    if (ts.isBindingElement(element.parent.parent)) {
      element = element.parent.parent;
    } else {
      return element.parent.parent;
    }
  }
}
function inImportClause(node) {
  const parent = node.parent;
  return parent && (ts.isImportClause(parent) || ts.isImportSpecifier(parent) || ts.isNamespaceImport(parent));
}
function isExpressionInCallExpression(node) {
  while (isRightSideOfQualifiedNameOrPropertyAccess(node)) {
    node = node.parent;
  }
  return ts.isCallExpression(node.parent) && node.parent.expression === node;
}
function isRightSideOfQualifiedNameOrPropertyAccess(node) {
  return (ts.isQualifiedName(node.parent) && node.parent.right === node) ||
      (ts.isPropertyAccessExpression(node.parent) && node.parent.name === node);
}
var tokenFromDeclarationMapping = new ts.Map([
  [257 /* SyntaxKind.VariableDeclaration */, 7 /* TokenType.variable */],
  [166 /* SyntaxKind.Parameter */, 6 /* TokenType.parameter */],
  [169 /* SyntaxKind.PropertyDeclaration */, 9 /* TokenType.property */],
  [264 /* SyntaxKind.ModuleDeclaration */, 3 /* TokenType.namespace */],
  [263 /* SyntaxKind.EnumDeclaration */, 1 /* TokenType.enum */],
  [302 /* SyntaxKind.EnumMember */, 8 /* TokenType.enumMember */],
  [260 /* SyntaxKind.ClassDeclaration */, 0 /* TokenType.class */],
  [171 /* SyntaxKind.MethodDeclaration */, 11 /* TokenType.member */],
  [259 /* SyntaxKind.FunctionDeclaration */, 10 /* TokenType.function */],
  [215 /* SyntaxKind.FunctionExpression */, 10 /* TokenType.function */],
  [170 /* SyntaxKind.MethodSignature */, 11 /* TokenType.member */],
  [174 /* SyntaxKind.GetAccessor */, 9 /* TokenType.property */],
  [175 /* SyntaxKind.SetAccessor */, 9 /* TokenType.property */],
  [168 /* SyntaxKind.PropertySignature */, 9 /* TokenType.property */],
  [261 /* SyntaxKind.InterfaceDeclaration */, 2 /* TokenType.interface */],
  [262 /* SyntaxKind.TypeAliasDeclaration */, 5 /* TokenType.type */],
  [165 /* SyntaxKind.TypeParameter */, 4 /* TokenType.typeParameter */],
  [299 /* SyntaxKind.PropertyAssignment */, 9 /* TokenType.property */],
  [300 /* SyntaxKind.ShorthandPropertyAssignment */, 9 /* TokenType.property */]
]);
})(v2020 = classifier.v2020 || (classifier.v2020 = {}));
})(classifier = ts.classifier || (ts.classifier = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let Completions;
(function(Completions) {
let StringCompletions;
(function(StringCompletions) {
let _a;
const kindPrecedence =
    (_a = {}, _a['directory' /* ScriptElementKind.directory */] = 0,
     _a['script' /* ScriptElementKind.scriptElement */] = 1,
     _a['external module name' /* ScriptElementKind.externalModuleName */] = 2, _a);
function createNameAndKindSet() {
  const map = new ts.Map();
  function add(value) {
    const existing = map.get(value.name);
    if (!existing || kindPrecedence[existing.kind] < kindPrecedence[value.kind]) {
      map.set(value.name, value);
    }
  }
  return {
    add,
    has: map.has.bind(map),
    values: map.values.bind(map),
  };
}
function getStringLiteralCompletions(sourceFile, position, contextToken, options, host, program, log, preferences) {
  if (ts.isInReferenceComment(sourceFile, position)) {
    var entries = getTripleSlashReferenceCompletion(sourceFile, position, options, host);
    return entries && convertPathCompletions(entries);
  }
  if (ts.isInString(sourceFile, position, contextToken)) {
    if (!contextToken || !ts.isStringLiteralLike(contextToken))
      {return undefined;}
    var entries = getStringLiteralCompletionEntries(
        sourceFile, contextToken, position, program.getTypeChecker(), options, host, preferences);
    return convertStringLiteralCompletions(entries, contextToken, sourceFile, host, program, log, options, preferences);
  }
}
StringCompletions.getStringLiteralCompletions = getStringLiteralCompletions;
function convertStringLiteralCompletions(
    completion, contextToken, sourceFile, host, program, log, options, preferences) {
  if (completion === undefined) {
    return undefined;
  }
  const optionalReplacementSpan = ts.createTextSpanFromStringLiteralLikeContent(contextToken);
  switch (completion.kind) {
    case 0 /* StringLiteralCompletionKind.Paths */:
      return convertPathCompletions(completion.paths);
    case 1 /* StringLiteralCompletionKind.Properties */: {
      var entries = ts.createSortedArray();
      Completions.getCompletionEntriesFromSymbols(
          completion.symbols, entries, contextToken, contextToken, sourceFile, sourceFile, host, program,
          99 /* ScriptTarget.ESNext */, log, 4 /* CompletionKind.String */, preferences, options,
          /* formatContext*/ undefined);  // Target will not be used, so arbitrary
      return {
        isGlobalCompletion: false,
        isMemberCompletion: true,
        isNewIdentifierLocation: completion.hasIndexSignature,
        optionalReplacementSpan,
        entries
      };
    }
    case 2 /* StringLiteralCompletionKind.Types */: {
      var entries = completion.types.map(function(type) {
        return ({
          name: type.value,
          kindModifiers: '' /* ScriptElementKindModifier.none */,
          kind: 'string' /* ScriptElementKind.string */,
          sortText: Completions.SortText.LocationPriority,
          replacementSpan: ts.getReplacementSpanForContextToken(contextToken)
        });
      });
      return {
        isGlobalCompletion: false,
        isMemberCompletion: false,
        isNewIdentifierLocation: completion.isNewIdentifier,
        optionalReplacementSpan,
        entries
      };
    }
    default:
      return ts.Debug.assertNever(completion);
  }
}
function getStringLiteralCompletionDetails(
    name, sourceFile, position, contextToken, checker, options, host, cancellationToken, preferences) {
  if (!contextToken || !ts.isStringLiteralLike(contextToken))
    {return undefined;}
  const completions =
      getStringLiteralCompletionEntries(sourceFile, contextToken, position, checker, options, host, preferences);
  return completions &&
      stringLiteralCompletionDetails(name, contextToken, completions, sourceFile, checker, cancellationToken);
}
StringCompletions.getStringLiteralCompletionDetails = getStringLiteralCompletionDetails;
function stringLiteralCompletionDetails(name, location, completion, sourceFile, checker, cancellationToken) {
  switch (completion.kind) {
    case 0 /* StringLiteralCompletionKind.Paths */: {
      var match = ts.find(completion.paths, function(p) {
        return p.name === name;
      });
      return match &&
          Completions.createCompletionDetails(
              name, kindModifiersFromExtension(match.extension), match.kind, [ts.textPart(name)]);
    }
    case 1 /* StringLiteralCompletionKind.Properties */: {
      var match = ts.find(completion.symbols, function(s) {
        return s.name === name;
      });
      return match &&
          Completions.createCompletionDetailsForSymbol(match, checker, sourceFile, location, cancellationToken);
    }
    case 2 /* StringLiteralCompletionKind.Types */:
      return ts.find(
                 completion.types,
                 function(t) {
                   return t.value === name;
                 }) ?
          Completions.createCompletionDetails(
              name, '' /* ScriptElementKindModifier.none */, 'type' /* ScriptElementKind.typeElement */,
              [ts.textPart(name)]) :
          undefined;
    default:
      return ts.Debug.assertNever(completion);
  }
}
function convertPathCompletions(pathCompletions) {
  const isGlobalCompletion =
      false;  // We don't want the editor to offer any other completions, such as snippets, inside a comment.
  const isNewIdentifierLocation =
      true;  // The user may type in a path that doesn't yet exist, creating a "new identifier" with respect to the collection of identifiers the server is aware of.
  const entries = pathCompletions.map(function(_a) {
    const name = _a.name, kind = _a.kind, span = _a.span, extension = _a.extension;
    return ({
      name,
      kind,
      kindModifiers: kindModifiersFromExtension(extension),
      sortText: Completions.SortTex