Element(node) {
    const textSpan = ts.createTextSpanFromBounds(node.openingElement.getStart(sourceFile), node.closingElement.getEnd());
    const tagName = node.openingElement.tagName.getText(sourceFile);
    const bannerText = '<' + tagName + '>...</' + tagName + '>';
    return createOutliningSpan(
        textSpan, 'code' /* OutliningSpanKind.Code */, textSpan, /* autoCollapse*/ false, bannerText);
  }
  function spanForJSXFragment(node) {
    const textSpan =
        ts.createTextSpanFromBounds(node.openingFragment.getStart(sourceFile), node.closingFragment.getEnd());
    const bannerText = '<>...</>';
    return createOutliningSpan(
        textSpan, 'code' /* OutliningSpanKind.Code */, textSpan, /* autoCollapse*/ false, bannerText);
  }
  function spanForJSXAttributes(node) {
    if (node.properties.length === 0) {
      return undefined;
    }
    return createOutliningSpanFromBounds(node.getStart(sourceFile), node.getEnd(), 'code' /* OutliningSpanKind.Code */);
  }
  function spanForTemplateLiteral(node) {
    if (node.kind === 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */ && node.text.length === 0) {
      return undefined;
    }
    return createOutliningSpanFromBounds(node.getStart(sourceFile), node.getEnd(), 'code' /* OutliningSpanKind.Code */);
  }
  function spanForObjectOrArrayLiteral(node, open) {
    if (open === void 0) {
      open = 18 /* SyntaxKind.OpenBraceToken */;
    }
    // If the block has no leading keywords and is inside an array literal or call expression,
    // we only want to collapse the span of the block.
    // Otherwise, the collapsed section will include the end of the previous line.
    return spanForNode(
        node, /* autoCollapse*/ false,
        /* useFullStart*/ !ts.isArrayLiteralExpression(node.parent) && !ts.isCallExpression(node.parent), open);
  }
  function spanForNode(hintSpanNode, autoCollapse, useFullStart, open, close) {
    if (autoCollapse === void 0) {
      autoCollapse = false;
    }
    if (useFullStart === void 0) {
      useFullStart = true;
    }
    if (open === void 0) {
      open = 18 /* SyntaxKind.OpenBraceToken */;
    }
    if (close === void 0) {
      close = open === 18 /* SyntaxKind.OpenBraceToken */ ? 19 /* SyntaxKind.CloseBraceToken */ :
                                                            23 /* SyntaxKind.CloseBracketToken */;
    }
    const openToken = ts.findChildOfKind(n, open, sourceFile);
    const closeToken = ts.findChildOfKind(n, close, sourceFile);
    return openToken && closeToken &&
        spanBetweenTokens(openToken, closeToken, hintSpanNode, sourceFile, autoCollapse, useFullStart);
  }
  function spanForNodeArray(nodeArray) {
    return nodeArray.length ?
        createOutliningSpan(ts.createTextSpanFromRange(nodeArray), 'code' /* OutliningSpanKind.Code */) :
        undefined;
  }
  function spanForParenthesizedExpression(node) {
    if (ts.positionsAreOnSameLine(node.getStart(), node.getEnd(), sourceFile))
      {return undefined;}
    const textSpan = ts.createTextSpanFromBounds(node.getStart(), node.getEnd());
    return createOutliningSpan(textSpan, 'code' /* OutliningSpanKind.Code */, ts.createTextSpanFromNode(node));
  }
}
function functionSpan(node, body, sourceFile) {
  const openToken = tryGetFunctionOpenToken(node, body, sourceFile);
  const closeToken = ts.findChildOfKind(body, 19 /* SyntaxKind.CloseBraceToken */, sourceFile);
  return openToken && closeToken &&
      spanBetweenTokens(
             openToken, closeToken, node, sourceFile,
             /* autoCollapse*/ node.kind !== 216 /* SyntaxKind.ArrowFunction */);
}
function spanBetweenTokens(openToken, closeToken, hintSpanNode, sourceFile, autoCollapse, useFullStart) {
  if (autoCollapse === void 0) {
    autoCollapse = false;
  }
  if (useFullStart === void 0) {
    useFullStart = true;
  }
  const textSpan = ts.createTextSpanFromBounds(
      useFullStart ? openToken.getFullStart() : openToken.getStart(sourceFile), closeToken.getEnd());
  return createOutliningSpan(
      textSpan, 'code' /* OutliningSpanKind.Code */, ts.createTextSpanFromNode(hintSpanNode, sourceFile), autoCollapse);
}
function createOutliningSpan(textSpan, kind, hintSpan, autoCollapse, bannerText) {
  if (hintSpan === void 0) {
    hintSpan = textSpan;
  }
  if (autoCollapse === void 0) {
    autoCollapse = false;
  }
  if (bannerText === void 0) {
    bannerText = '...';
  }
  return {textSpan, kind, hintSpan, bannerText, autoCollapse};
}
function tryGetFunctionOpenToken(node, body, sourceFile) {
  if (ts.isNodeArrayMultiLine(node.parameters, sourceFile)) {
    const openParenToken = ts.findChildOfKind(node, 20 /* SyntaxKind.OpenParenToken */, sourceFile);
    if (openParenToken) {
      return openParenToken;
    }
  }
  return ts.findChildOfKind(body, 18 /* SyntaxKind.OpenBraceToken */, sourceFile);
}
})(OutliningElementsCollector = ts.OutliningElementsCollector || (ts.OutliningElementsCollector = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
// Note(cyrusn): this enum is ordered from strongest match type to weakest match type.
let PatternMatchKind;
(function(PatternMatchKind) {
PatternMatchKind[PatternMatchKind['exact'] = 0] = 'exact';
PatternMatchKind[PatternMatchKind['prefix'] = 1] = 'prefix';
PatternMatchKind[PatternMatchKind['substring'] = 2] = 'substring';
PatternMatchKind[PatternMatchKind['camelCase'] = 3] = 'camelCase';
})(PatternMatchKind = ts.PatternMatchKind || (ts.PatternMatchKind = {}));
function createPatternMatch(kind, isCaseSensitive) {
  return {kind, isCaseSensitive};
}
function createPatternMatcher(pattern) {
  // We'll often see the same candidate string many times when searching (For example, when
  // we see the name of a module that is used everywhere, or the name of an overload).  As
  // such, we cache the information we compute about the candidate for the life of this
  // pattern matcher so we don't have to compute it multiple times.
  const stringToWordSpans = new ts.Map();
  const dotSeparatedSegments = pattern.trim().split('.').map(function(p) {
    return createSegment(p.trim());
  });
  // A segment is considered invalid if we couldn't find any words in it.
  if (dotSeparatedSegments.some(function(segment) {
        return !segment.subWordTextChunks.length;
      }))
    {return undefined;}
  return {
    getFullMatch: function(containers, candidate) {
      return getFullMatch(containers, candidate, dotSeparatedSegments, stringToWordSpans);
    },
    getMatchForLastSegmentOfPattern: function(candidate) {
      return matchSegment(candidate, ts.last(dotSeparatedSegments), stringToWordSpans);
    },
    patternContainsDots: dotSeparatedSegments.length > 1
  };
}
ts.createPatternMatcher = createPatternMatcher;
function getFullMatch(candidateContainers, candidate, dotSeparatedSegments, stringToWordSpans) {
  // First, check that the last part of the dot separated pattern matches the name of the
  // candidate.  If not, then there's no point in proceeding and doing the more
  // expensive work.
  const candidateMatch = matchSegment(candidate, ts.last(dotSeparatedSegments), stringToWordSpans);
  if (!candidateMatch) {
    return undefined;
  }
  // -1 because the last part was checked against the name, and only the rest
  // of the parts are checked against the container.
  if (dotSeparatedSegments.length - 1 > candidateContainers.length) {
    // There weren't enough container parts to match against the pattern parts.
    // So this definitely doesn't match.
    return undefined;
  }
  let bestMatch;
  for (let i = dotSeparatedSegments.length - 2, j = candidateContainers.length - 1; i >= 0; i -= 1, j -= 1) {
    bestMatch =
        betterMatch(bestMatch, matchSegment(candidateContainers[j], dotSeparatedSegments[i], stringToWordSpans));
  }
  return bestMatch;
}
function getWordSpans(word, stringToWordSpans) {
  let spans = stringToWordSpans.get(word);
  if (!spans) {
    stringToWordSpans.set(word, spans = breakIntoWordSpans(word));
  }
  return spans;
}
function matchTextChunk(candidate, chunk, stringToWordSpans) {
  const index = indexOfIgnoringCase(candidate, chunk.textLowerCase);
  if (index === 0) {
    // a) Check if the word is a prefix of the candidate, in a case insensitive or
    //    sensitive manner. If it does, return that there was an exact match if the word and candidate are the same length, else a prefix match.
    return createPatternMatch(
        chunk.text.length === candidate.length ? PatternMatchKind.exact : PatternMatchKind.prefix,
        /* isCaseSensitive:*/ ts.startsWith(candidate, chunk.text));
  }
  if (chunk.isLowerCase) {
    if (index === -1)
      {return undefined;}
    // b) If the part is entirely lowercase, then check if it is contained anywhere in the
    //    candidate in a case insensitive manner.  If so, return that there was a substring
    //    match.
    //
    //    Note: We only have a substring match if the lowercase part is prefix match of some
    //    word part. That way we don't match something like 'Class' when the user types 'a'.
    //    But we would match 'FooAttribute' (since 'Attribute' starts with 'a').
    const wordSpans = getWordSpans(candidate, stringToWordSpans);
    for (let _i = 0, wordSpans_1 = wordSpans; _i < wordSpans_1.length; _i++) {
      const span = wordSpans_1[_i];
      if (partStartsWith(candidate, span, chunk.text, /* ignoreCase:*/ true)) {
        return createPatternMatch(
            PatternMatchKind.substring,
            /* isCaseSensitive:*/ partStartsWith(candidate, span, chunk.text, /* ignoreCase:*/ false));
      }
    }
    // c) Is the pattern a substring of the candidate starting on one of the candidate's word boundaries?
    // We could check every character boundary start of the candidate for the pattern. However, that's
    // an m * n operation in the wost case. Instead, find the first instance of the pattern
    // substring, and see if it starts on a capital letter. It seems unlikely that the user will try to
    // filter the list based on a substring that starts on a capital letter and also with a lowercase one.
    // (Pattern: fogbar, Candidate: quuxfogbarFogBar).
    if (chunk.text.length < candidate.length && isUpperCaseLetter(candidate.charCodeAt(index))) {
      return createPatternMatch(PatternMatchKind.substring, /* isCaseSensitive:*/ false);
    }
  } else {
    // d) If the part was not entirely lowercase, then check if it is contained in the
    //    candidate in a case *sensitive* manner. If so, return that there was a substring
    //    match.
    if (candidate.indexOf(chunk.text) > 0) {
      return createPatternMatch(PatternMatchKind.substring, /* isCaseSensitive:*/ true);
    }
    // e) If the part was not entirely lowercase, then attempt a camel cased match as well.
    if (chunk.characterSpans.length > 0) {
      const candidateParts = getWordSpans(candidate, stringToWordSpans);
      const isCaseSensitive = tryCamelCaseMatch(candidate, candidateParts, chunk, /* ignoreCase:*/ false) ? true :
          tryCamelCaseMatch(candidate, candidateParts, chunk, /* ignoreCase:*/ true)                    ? false :
                                                                                                         undefined;
      if (isCaseSensitive !== undefined) {
        return createPatternMatch(PatternMatchKind.camelCase, isCaseSensitive);
      }
    }
  }
}
function matchSegment(candidate, segment, stringToWordSpans) {
  // First check if the segment matches as is.  This is also useful if the segment contains
  // characters we would normally strip when splitting into parts that we also may want to
  // match in the candidate.  For example if the segment is "@int" and the candidate is
  // "@int", then that will show up as an exact match here.
  //
  // Note: if the segment contains a space or an asterisk then we must assume that it's a
  // multi-word segment.
  if (every(segment.totalTextChunk.text, function(ch) {
        return ch !== 32 /* CharacterCodes.space */ && ch !== 42 /* CharacterCodes.asterisk */;
      })) {
    const match = matchTextChunk(candidate, segment.totalTextChunk, stringToWordSpans);
    if (match)
      {return match;}
  }
  // The logic for pattern matching is now as follows:
  //
  // 1) Break the segment passed in into words.  Breaking is rather simple and a
  //    good way to think about it that if gives you all the individual alphanumeric words
  //    of the pattern.
  //
  // 2) For each word try to match the word against the candidate value.
  //
  // 3) Matching is as follows:
  //
  //   a) Check if the word is a prefix of the candidate, in a case insensitive or
  //      sensitive manner. If it does, return that there was an exact match if the word and candidate are the same length, else a prefix match.
  //
  //   If the word is entirely lowercase:
  //      b) Then check if it is contained anywhere in the
  //          candidate in a case insensitive manner.  If so, return that there was a substring
  //          match.
  //
  //          Note: We only have a substring match if the lowercase part is prefix match of
  //          some word part. That way we don't match something like 'Class' when the user
  //          types 'a'. But we would match 'FooAttribute' (since 'Attribute' starts with
  //          'a').
  //
  //       c) The word is all lower case. Is it a case insensitive substring of the candidate starting
  //          on a part boundary of the candidate?
  //
  //   Else:
  //       d) If the word was not entirely lowercase, then check if it is contained in the
  //          candidate in a case *sensitive* manner. If so, return that there was a substring
  //          match.
  //
  //       e) If the word was not entirely lowercase, then attempt a camel cased match as
  //          well.
  //
  // Only if all words have some sort of match is the pattern considered matched.
  const subWordTextChunks = segment.subWordTextChunks;
  let bestMatch;
  for (let _i = 0, subWordTextChunks_1 = subWordTextChunks; _i < subWordTextChunks_1.length; _i++) {
    const subWordTextChunk = subWordTextChunks_1[_i];
    bestMatch = betterMatch(bestMatch, matchTextChunk(candidate, subWordTextChunk, stringToWordSpans));
  }
  return bestMatch;
}
function betterMatch(a, b) {
  return ts.min([a, b], compareMatches);
}
function compareMatches(a, b) {
  return a === undefined ? 1 /* Comparison.GreaterThan */ :
      b === undefined    ? -1 /* Comparison.LessThan */
                        :
                        ts.compareValues(a.kind, b.kind) || ts.compareBooleans(!a.isCaseSensitive, !b.isCaseSensitive);
}
function partStartsWith(candidate, candidateSpan, pattern, ignoreCase, patternSpan) {
  if (patternSpan === void 0) {
    patternSpan = {start: 0, length: pattern.length};
  }
  return patternSpan.length <=
      candidateSpan.length  // If pattern part is longer than the candidate part there can never be a match.
      && everyInRange(0, patternSpan.length, function(i) {
           return equalChars(
               pattern.charCodeAt(patternSpan.start + i), candidate.charCodeAt(candidateSpan.start + i), ignoreCase);
         });
}
function equalChars(ch1, ch2, ignoreCase) {
  return ignoreCase ? toLowerCase(ch1) === toLowerCase(ch2) : ch1 === ch2;
}
function tryCamelCaseMatch(candidate, candidateParts, chunk, ignoreCase) {
  const chunkCharacterSpans = chunk.characterSpans;
  // Note: we may have more pattern parts than candidate parts.  This is because multiple
  // pattern parts may match a candidate part.  For example "SiUI" against "SimpleUI".
  // We'll have 3 pattern parts Si/U/I against two candidate parts Simple/UI.  However, U
  // and I will both match in UI.
  let currentCandidate = 0;
  let currentChunkSpan = 0;
  let firstMatch;
  let contiguous;
  while (true) {
    // Let's consider our termination cases
    if (currentChunkSpan === chunkCharacterSpans.length) {
      return true;
    } if (currentCandidate === candidateParts.length) {
      // No match, since we still have more of the pattern to hit
      return false;
    }
    let candidatePart = candidateParts[currentCandidate];
    let gotOneMatchThisCandidate = false;
    // Consider the case of matching SiUI against SimpleUIElement. The candidate parts
    // will be Simple/UI/Element, and the pattern parts will be Si/U/I.  We'll match 'Si'
    // against 'Simple' first.  Then we'll match 'U' against 'UI'. However, we want to
    // still keep matching pattern parts against that candidate part.
    for (; currentChunkSpan < chunkCharacterSpans.length; currentChunkSpan++) {
      const chunkCharacterSpan = chunkCharacterSpans[currentChunkSpan];
      if (gotOneMatchThisCandidate) {
        // We've already gotten one pattern part match in this candidate.  We will
        // only continue trying to consumer pattern parts if the last part and this
        // part are both upper case.
        if (!isUpperCaseLetter(chunk.text.charCodeAt(chunkCharacterSpans[currentChunkSpan - 1].start)) ||
            !isUpperCaseLetter(chunk.text.charCodeAt(chunkCharacterSpans[currentChunkSpan].start))) {
          break;
        }
      }
      if (!partStartsWith(candidate, candidatePart, chunk.text, ignoreCase, chunkCharacterSpan)) {
        break;
      }
      gotOneMatchThisCandidate = true;
      firstMatch = firstMatch === undefined ? currentCandidate : firstMatch;
      // If we were contiguous, then keep that value.  If we weren't, then keep that
      // value.  If we don't know, then set the value to 'true' as an initial match is
      // obviously contiguous.
      contiguous = contiguous === undefined ? true : contiguous;
      candidatePart = ts.createTextSpan(
          candidatePart.start + chunkCharacterSpan.length, candidatePart.length - chunkCharacterSpan.length);
    }
    // Check if we matched anything at all.  If we didn't, then we need to unset the
    // contiguous bit if we currently had it set.
    // If we haven't set the bit yet, then that means we haven't matched anything so
    // far, and we don't want to change that.
    if (!gotOneMatchThisCandidate && contiguous !== undefined) {
      contiguous = false;
    }
    // Move onto the next candidate.
    currentCandidate++;
  }
}
function createSegment(text) {
  return {totalTextChunk: createTextChunk(text), subWordTextChunks: breakPatternIntoTextChunks(text)};
}
function isUpperCaseLetter(ch) {
  // Fast check for the ascii range.
  if (ch >= 65 /* CharacterCodes.A */ && ch <= 90 /* CharacterCodes.Z */) {
    return true;
  }
  if (ch < 127 /* CharacterCodes.maxAsciiCharacter */ ||
      !ts.isUnicodeIdentifierStart(ch, 99 /* ScriptTarget.Latest */)) {
    return false;
  }
  // TODO: find a way to determine this for any unicode characters in a
  // non-allocating manner.
  const str = String.fromCharCode(ch);
  return str === str.toUpperCase();
}
function isLowerCaseLetter(ch) {
  // Fast check for the ascii range.
  if (ch >= 97 /* CharacterCodes.a */ && ch <= 122 /* CharacterCodes.z */) {
    return true;
  }
  if (ch < 127 /* CharacterCodes.maxAsciiCharacter */ ||
      !ts.isUnicodeIdentifierStart(ch, 99 /* ScriptTarget.Latest */)) {
    return false;
  }
  // TODO: find a way to determine this for any unicode characters in a
  // non-allocating manner.
  const str = String.fromCharCode(ch);
  return str === str.toLowerCase();
}
// Assumes 'value' is already lowercase.
function indexOfIgnoringCase(str, value) {
  const n = str.length - value.length;
  const _loop_6 = function(start) {
    if (every(value, function(valueChar, i) {
          return toLowerCase(str.charCodeAt(i + start)) === valueChar;
        })) {
      return {value: start};
    }
  };
  for (let start = 0; start <= n; start++) {
    const state_3 = _loop_6(start);
    if (typeof state_3 === 'object')
      {return state_3.value;}
  }
  return -1;
}
function toLowerCase(ch) {
  // Fast convert for the ascii range.
  if (ch >= 65 /* CharacterCodes.A */ && ch <= 90 /* CharacterCodes.Z */) {
    return 97 /* CharacterCodes.a */ + (ch - 65 /* CharacterCodes.A */);
  }
  if (ch < 127 /* CharacterCodes.maxAsciiCharacter */) {
    return ch;
  }
  // TODO: find a way to compute this for any unicode characters in a
  // non-allocating manner.
  return String.fromCharCode(ch).toLowerCase().charCodeAt(0);
}
function isDigit(ch) {
  // TODO(cyrusn): Find a way to support this for unicode digits.
  return ch >= 48 /* CharacterCodes._0 */ && ch <= 57 /* CharacterCodes._9 */;
}
function isWordChar(ch) {
  return isUpperCaseLetter(ch) || isLowerCaseLetter(ch) || isDigit(ch) || ch === 95 /* CharacterCodes._ */ ||
      ch === 36 /* CharacterCodes.$ */;
}
function breakPatternIntoTextChunks(pattern) {
  const result = [];
  let wordStart = 0;
  let wordLength = 0;
  for (let i = 0; i < pattern.length; i++) {
    const ch = pattern.charCodeAt(i);
    if (isWordChar(ch)) {
      if (wordLength === 0) {
        wordStart = i;
      }
      wordLength++;
    } else {
      if (wordLength > 0) {
        result.push(createTextChunk(pattern.substr(wordStart, wordLength)));
        wordLength = 0;
      }
    }
  }
  if (wordLength > 0) {
    result.push(createTextChunk(pattern.substr(wordStart, wordLength)));
  }
  return result;
}
function createTextChunk(text) {
  const textLowerCase = text.toLowerCase();
  return {
    text,
    textLowerCase,
    isLowerCase: text === textLowerCase,
    characterSpans: breakIntoCharacterSpans(text)
  };
}
function breakIntoCharacterSpans(identifier) {
  return breakIntoSpans(identifier, /* word:*/ false);
}
ts.breakIntoCharacterSpans = breakIntoCharacterSpans;
function breakIntoWordSpans(identifier) {
  return breakIntoSpans(identifier, /* word:*/ true);
}
ts.breakIntoWordSpans = breakIntoWordSpans;
function breakIntoSpans(identifier, word) {
  const result = [];
  let wordStart = 0;
  for (let i = 1; i < identifier.length; i++) {
    const lastIsDigit = isDigit(identifier.charCodeAt(i - 1));
    const currentIsDigit = isDigit(identifier.charCodeAt(i));
    const hasTransitionFromLowerToUpper = transitionFromLowerToUpper(identifier, word, i);
    const hasTransitionFromUpperToLower = word && transitionFromUpperToLower(identifier, i, wordStart);
    if (charIsPunctuation(identifier.charCodeAt(i - 1)) || charIsPunctuation(identifier.charCodeAt(i)) ||
        lastIsDigit !== currentIsDigit || hasTransitionFromLowerToUpper || hasTransitionFromUpperToLower) {
      if (!isAllPunctuation(identifier, wordStart, i)) {
        result.push(ts.createTextSpan(wordStart, i - wordStart));
      }
      wordStart = i;
    }
  }
  if (!isAllPunctuation(identifier, wordStart, identifier.length)) {
    result.push(ts.createTextSpan(wordStart, identifier.length - wordStart));
  }
  return result;
}
function charIsPunctuation(ch) {
  switch (ch) {
    case 33 /* CharacterCodes.exclamation */:
    case 34 /* CharacterCodes.doubleQuote */:
    case 35 /* CharacterCodes.hash */:
    case 37 /* CharacterCodes.percent */:
    case 38 /* CharacterCodes.ampersand */:
    case 39 /* CharacterCodes.singleQuote */:
    case 40 /* CharacterCodes.openParen */:
    case 41 /* CharacterCodes.closeParen */:
    case 42 /* CharacterCodes.asterisk */:
    case 44 /* CharacterCodes.comma */:
    case 45 /* CharacterCodes.minus */:
    case 46 /* CharacterCodes.dot */:
    case 47 /* CharacterCodes.slash */:
    case 58 /* CharacterCodes.colon */:
    case 59 /* CharacterCodes.semicolon */:
    case 63 /* CharacterCodes.question */:
    case 64 /* CharacterCodes.at */:
    case 91 /* CharacterCodes.openBracket */:
    case 92 /* CharacterCodes.backslash */:
    case 93 /* CharacterCodes.closeBracket */:
    case 95 /* CharacterCodes._ */:
    case 123 /* CharacterCodes.openBrace */:
    case 125 /* CharacterCodes.closeBrace */:
      return true;
  }
  return false;
}
function isAllPunctuation(identifier, start, end) {
  return every(identifier, function(ch) {
    return charIsPunctuation(ch) && ch !== 95 /* CharacterCodes._ */;
  }, start, end);
}
function transitionFromUpperToLower(identifier, index, wordStart) {
  // Cases this supports:
  // 1) IDisposable -> I, Disposable
  // 2) UIElement -> UI, Element
  // 3) HTMLDocument -> HTML, Document
  //
  // etc.
  // We have a transition from an upper to a lower letter here.  But we only
  // want to break if all the letters that preceded are uppercase.  i.e. if we
  // have "Foo" we don't want to break that into "F, oo".  But if we have
  // "IFoo" or "UIFoo", then we want to break that into "I, Foo" and "UI,
  // Foo".  i.e. the last uppercase letter belongs to the lowercase letters
  // that follows.  Note: this will make the following not split properly:
  // "HELLOthere".  However, these sorts of names do not show up in .Net
  // programs.
  return index !== wordStart && index + 1 < identifier.length && isUpperCaseLetter(identifier.charCodeAt(index)) &&
      isLowerCaseLetter(identifier.charCodeAt(index + 1)) && every(identifier, isUpperCaseLetter, wordStart, index);
}
function transitionFromLowerToUpper(identifier, word, index) {
  const lastIsUpper = isUpperCaseLetter(identifier.charCodeAt(index - 1));
  const currentIsUpper = isUpperCaseLetter(identifier.charCodeAt(index));
  // See if the casing indicates we're starting a new word. Note: if we're breaking on
  // words, then just seeing an upper case character isn't enough.  Instead, it has to
  // be uppercase and the previous character can't be uppercase.
  //
  // For example, breaking "AddMetadata" on words would make: Add Metadata
  //
  // on characters would be: A dd M etadata
  //
  // Break "AM" on words would be: AM
  //
  // on characters would be: A M
  //
  // We break the search string on characters.  But we break the symbol name on words.
  return currentIsUpper && (!word || !lastIsUpper);
}
function everyInRange(start, end, pred) {
  for (let i = start; i < end; i++) {
    if (!pred(i)) {
      return false;
    }
  }
  return true;
}
function every(s, pred, start, end) {
  if (start === void 0) {
    start = 0;
  }
  if (end === void 0) {
    end = s.length;
  }
  return everyInRange(start, end, function(i) {
    return pred(s.charCodeAt(i), i);
  });
}
})(ts || (ts = {}));
var ts;
(function(ts) {
function preProcessFile(sourceText, readImportFiles, detectJavaScriptImports) {
  if (readImportFiles === void 0) {
    readImportFiles = true;
  }
  if (detectJavaScriptImports === void 0) {
    detectJavaScriptImports = false;
  }
  const pragmaContext = {
    languageVersion: 1 /* ScriptTarget.ES5 */,
    pragmas: undefined,
    checkJsDirective: undefined,
    referencedFiles: [],
    typeReferenceDirectives: [],
    libReferenceDirectives: [],
    amdDependencies: [],
    hasNoDefaultLib: undefined,
    moduleName: undefined
  };
  const importedFiles = [];
  let ambientExternalModules;
  let lastToken;
  let currentToken;
  let braceNesting = 0;
  // assume that text represent an external module if it contains at least one top level import/export
  // ambient modules that are found inside external modules are interpreted as module augmentations
  let externalModule = false;
  function nextToken() {
    lastToken = currentToken;
    currentToken = ts.scanner.scan();
    if (currentToken === 18 /* SyntaxKind.OpenBraceToken */) {
      braceNesting++;
    } else if (currentToken === 19 /* SyntaxKind.CloseBraceToken */) {
      braceNesting--;
    }
    return currentToken;
  }
  function getFileReference() {
    const fileName = ts.scanner.getTokenValue();
    const pos = ts.scanner.getTokenPos();
    return {fileName, pos, end: pos + fileName.length};
  }
  function recordAmbientExternalModule() {
    if (!ambientExternalModules) {
      ambientExternalModules = [];
    }
    ambientExternalModules.push({ref: getFileReference(), depth: braceNesting});
  }
  function recordModuleName() {
    importedFiles.push(getFileReference());
    markAsExternalModuleIfTopLevel();
  }
  function markAsExternalModuleIfTopLevel() {
    if (braceNesting === 0) {
      externalModule = true;
    }
  }
  /**
   * Returns true if at least one token was consumed from the stream
   */
  function tryConsumeDeclare() {
    let token = ts.scanner.getToken();
    if (token === 136 /* SyntaxKind.DeclareKeyword */) {
      // declare module "mod"
      token = nextToken();
      if (token === 142 /* SyntaxKind.ModuleKeyword */) {
        token = nextToken();
        if (token === 10 /* SyntaxKind.StringLiteral */) {
          recordAmbientExternalModule();
        }
      }
      return true;
    }
    return false;
  }
  /**
   * Returns true if at least one token was consumed from the stream
   */
  function tryConsumeImport() {
    if (lastToken === 24 /* SyntaxKind.DotToken */) {
      return false;
    }
    let token = ts.scanner.getToken();
    if (token === 100 /* SyntaxKind.ImportKeyword */) {
      token = nextToken();
      if (token === 20 /* SyntaxKind.OpenParenToken */) {
        token = nextToken();
        if (token === 10 /* SyntaxKind.StringLiteral */ ||
            token === 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */) {
          // import("mod");
          recordModuleName();
          return true;
        }
      } else if (token === 10 /* SyntaxKind.StringLiteral */) {
        // import "mod";
        recordModuleName();
        return true;
      } else {
        if (token === 154 /* SyntaxKind.TypeKeyword */) {
          const skipTypeKeyword = ts.scanner.lookAhead(function() {
            const token = ts.scanner.scan();
            return token !== 158 /* SyntaxKind.FromKeyword */ &&
                (token === 41 /* SyntaxKind.AsteriskToken */ || token === 18 /* SyntaxKind.OpenBraceToken */ ||
                 token === 79 /* SyntaxKind.Identifier */ || ts.isKeyword(token));
          });
          if (skipTypeKeyword) {
            token = nextToken();
          }
        }
        if (token === 79 /* SyntaxKind.Identifier */ || ts.isKeyword(token)) {
          token = nextToken();
          if (token === 158 /* SyntaxKind.FromKeyword */) {
            token = nextToken();
            if (token === 10 /* SyntaxKind.StringLiteral */) {
              // import d from "mod";
              recordModuleName();
              return true;
            }
          } else if (token === 63 /* SyntaxKind.EqualsToken */) {
            if (tryConsumeRequireCall(/* skipCurrentToken*/ true)) {
              return true;
            }
          } else if (token === 27 /* SyntaxKind.CommaToken */) {
            // consume comma and keep going
            token = nextToken();
          } else {
            // unknown syntax
            return true;
          }
        }
        if (token === 18 /* SyntaxKind.OpenBraceToken */) {
          token = nextToken();
          // consume "{ a as B, c, d as D}" clauses
          // make sure that it stops on EOF
          while (token !== 19 /* SyntaxKind.CloseBraceToken */ && token !== 1 /* SyntaxKind.EndOfFileToken */) {
            token = nextToken();
          }
          if (token === 19 /* SyntaxKind.CloseBraceToken */) {
            token = nextToken();
            if (token === 158 /* SyntaxKind.FromKeyword */) {
              token = nextToken();
              if (token === 10 /* SyntaxKind.StringLiteral */) {
                // import {a as A} from "mod";
                // import d, {a, b as B} from "mod"
                recordModuleName();
              }
            }
          }
        } else if (token === 41 /* SyntaxKind.AsteriskToken */) {
          token = nextToken();
          if (token === 128 /* SyntaxKind.AsKeyword */) {
            token = nextToken();
            if (token === 79 /* SyntaxKind.Identifier */ || ts.isKeyword(token)) {
              token = nextToken();
              if (token === 158 /* SyntaxKind.FromKeyword */) {
                token = nextToken();
                if (token === 10 /* SyntaxKind.StringLiteral */) {
                  // import * as NS from "mod"
                  // import d, * as NS from "mod"
                  recordModuleName();
                }
              }
            }
          }
        }
      }
      return true;
    }
    return false;
  }
  function tryConsumeExport() {
    let token = ts.scanner.getToken();
    if (token === 93 /* SyntaxKind.ExportKeyword */) {
      markAsExternalModuleIfTopLevel();
      token = nextToken();
      if (token === 154 /* SyntaxKind.TypeKeyword */) {
        var skipTypeKeyword = ts.scanner.lookAhead(function() {
          const token = ts.scanner.scan();
          return token === 41 /* SyntaxKind.AsteriskToken */ || token === 18 /* SyntaxKind.OpenBraceToken */;
        });
        if (skipTypeKeyword) {
          token = nextToken();
        }
      }
      if (token === 18 /* SyntaxKind.OpenBraceToken */) {
        token = nextToken();
        // consume "{ a as B, c, d as D}" clauses
        // make sure it stops on EOF
        while (token !== 19 /* SyntaxKind.CloseBraceToken */ && token !== 1 /* SyntaxKind.EndOfFileToken */) {
          token = nextToken();
        }
        if (token === 19 /* SyntaxKind.CloseBraceToken */) {
          token = nextToken();
          if (token === 158 /* SyntaxKind.FromKeyword */) {
            token = nextToken();
            if (token === 10 /* SyntaxKind.StringLiteral */) {
              // export {a as A} from "mod";
              // export {a, b as B} from "mod"
              recordModuleName();
            }
          }
        }
      } else if (token === 41 /* SyntaxKind.AsteriskToken */) {
        token = nextToken();
        if (token === 158 /* SyntaxKind.FromKeyword */) {
          token = nextToken();
          if (token === 10 /* SyntaxKind.StringLiteral */) {
            // export * from "mod"
            recordModuleName();
          }
        }
      } else if (token === 100 /* SyntaxKind.ImportKeyword */) {
        token = nextToken();
        if (token === 154 /* SyntaxKind.TypeKeyword */) {
          var skipTypeKeyword = ts.scanner.lookAhead(function() {
            const token = ts.scanner.scan();
            return token === 79 /* SyntaxKind.Identifier */ || ts.isKeyword(token);
          });
          if (skipTypeKeyword) {
            token = nextToken();
          }
        }
        if (token === 79 /* SyntaxKind.Identifier */ || ts.isKeyword(token)) {
          token = nextToken();
          if (token === 63 /* SyntaxKind.EqualsToken */) {
            if (tryConsumeRequireCall(/* skipCurrentToken*/ true)) {
              return true;
            }
          }
        }
      }
      return true;
    }
    return false;
  }
  function tryConsumeRequireCall(skipCurrentToken, allowTemplateLiterals) {
    if (allowTemplateLiterals === void 0) {
      allowTemplateLiterals = false;
    }
    let token = skipCurrentToken ? nextToken() : ts.scanner.getToken();
    if (token === 147 /* SyntaxKind.RequireKeyword */) {
      token = nextToken();
      if (token === 20 /* SyntaxKind.OpenParenToken */) {
        token = nextToken();
        if (token === 10 /* SyntaxKind.StringLiteral */ ||
            allowTemplateLiterals && token === 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */) {
          //  require("mod");
          recordModuleName();
        }
      }
      return true;
    }
    return false;
  }
  function tryConsumeDefine() {
    let token = ts.scanner.getToken();
    if (token === 79 /* SyntaxKind.Identifier */ && ts.scanner.getTokenValue() === 'define') {
      token = nextToken();
      if (token !== 20 /* SyntaxKind.OpenParenToken */) {
        return true;
      }
      token = nextToken();
      if (token === 10 /* SyntaxKind.StringLiteral */ || token === 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */) {
        // looks like define ("modname", ... - skip string literal and comma
        token = nextToken();
        if (token === 27 /* SyntaxKind.CommaToken */) {
          token = nextToken();
        } else {
          // unexpected token
          return true;
        }
      }
      // should be start of dependency list
      if (token !== 22 /* SyntaxKind.OpenBracketToken */) {
        return true;
      }
      // skip open bracket
      token = nextToken();
      // scan until ']' or EOF
      while (token !== 23 /* SyntaxKind.CloseBracketToken */ && token !== 1 /* SyntaxKind.EndOfFileToken */) {
        // record string literals as module names
        if (token === 10 /* SyntaxKind.StringLiteral */ ||
            token === 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */) {
          recordModuleName();
        }
        token = nextToken();
      }
      return true;
    }
    return false;
  }
  function processImports() {
    ts.scanner.setText(sourceText);
    nextToken();
    // Look for:
    //    import "mod";
    //    import d from "mod"
    //    import {a as A } from "mod";
    //    import * as NS from "mod"
    //    import d, {a, b as B} from "mod"
    //    import i = require("mod");
    //    import("mod");
    //    export * from "mod"
    //    export {a as b} from "mod"
    //    export import i = require("mod")
    //    (for JavaScript files) require("mod")
    // Do not look for:
    //    AnySymbol.import("mod")
    //    AnySymbol.nested.import("mod")
    while (true) {
      if (ts.scanner.getToken() === 1 /* SyntaxKind.EndOfFileToken */) {
        break;
      }
      if (ts.scanner.getToken() === 15 /* SyntaxKind.TemplateHead */) {
        const stack = [ts.scanner.getToken()];
        loop: while (ts.length(stack)) {
          const token = ts.scanner.scan();
          switch (token) {
            case 1 /* SyntaxKind.EndOfFileToken */:
              break loop;
            case 100 /* SyntaxKind.ImportKeyword */:
              tryConsumeImport();
              break;
            case 15 /* SyntaxKind.TemplateHead */:
              stack.push(token);
              break;
            case 18 /* SyntaxKind.OpenBraceToken */:
              if (ts.length(stack)) {
                stack.push(token);
              }
              break;
            case 19 /* SyntaxKind.CloseBraceToken */:
              if (ts.length(stack)) {
                if (ts.lastOrUndefined(stack) === 15 /* SyntaxKind.TemplateHead */) {
                  if (ts.scanner.reScanTemplateToken(/* isTaggedTemplate */ false) ===
                      17 /* SyntaxKind.TemplateTail */) {
                    stack.pop();
                  }
                } else {
                  stack.pop();
                }
              }
              break;
          }
        }
        nextToken();
      }
      // check if at least one of alternative have moved scanner forward
      if (tryConsumeDeclare() || tryConsumeImport() || tryConsumeExport() ||
          (detectJavaScriptImports &&
           (tryConsumeRequireCall(/* skipCurrentToken*/ false, /* allowTemplateLiterals*/ true) || tryConsumeDefine()))) {
        continue;
      } else {
        nextToken();
      }
    }
    ts.scanner.setText(undefined);
  }
  if (readImportFiles) {
    processImports();
  }
  ts.processCommentPragmas(pragmaContext, sourceText);
  ts.processPragmasIntoFields(pragmaContext, ts.noop);
  if (externalModule) {
    // for external modules module all nested ambient modules are augmentations
    if (ambientExternalModules) {
      // move all detected ambient modules to imported files since they need to be resolved
      for (let _i = 0, ambientExternalModules_1 = ambientExternalModules; _i < ambientExternalModules_1.length; _i++) {
        var decl = ambientExternalModules_1[_i];
        importedFiles.push(decl.ref);
      }
    }
    return {
      referencedFiles: pragmaContext.referencedFiles,
      typeReferenceDirectives: pragmaContext.typeReferenceDirectives,
      libReferenceDirectives: pragmaContext.libReferenceDirectives,
      importedFiles,
      isLibFile: !!pragmaContext.hasNoDefaultLib,
      ambientExternalModules: undefined
    };
  }
    // for global scripts ambient modules still can have augmentations - look for ambient modules with depth > 0
    let ambientModuleNames = void 0;
    if (ambientExternalModules) {
      for (let _a = 0, ambientExternalModules_2 = ambientExternalModules; _a < ambientExternalModules_2.length; _a++) {
        var decl = ambientExternalModules_2[_a];
        if (decl.depth === 0) {
          if (!ambientModuleNames) {
            ambientModuleNames = [];
          }
          ambientModuleNames.push(decl.ref.fileName);
        } else {
          importedFiles.push(decl.ref);
        }
      }
    }
    return {
      referencedFiles: pragmaContext.referencedFiles,
      typeReferenceDirectives: pragmaContext.typeReferenceDirectives,
      libReferenceDirectives: pragmaContext.libReferenceDirectives,
      importedFiles,
      isLibFile: !!pragmaContext.hasNoDefaultLib,
      ambientExternalModules: ambientModuleNames
    };

}
ts.preProcessFile = preProcessFile;
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let Rename;
(function(Rename) {
function getRenameInfo(program, sourceFile, position, preferences) {
  const node = ts.getAdjustedRenameLocation(ts.getTouchingPropertyName(sourceFile, position));
  if (nodeIsEligibleForRename(node)) {
    const renameInfo = getRenameInfoForNode(node, program.getTypeChecker(), sourceFile, program, preferences);
    if (renameInfo) {
      return renameInfo;
    }
  }
  return getRenameInfoError(ts.Diagnostics.You_cannot_rename_this_element);
}
Rename.getRenameInfo = getRenameInfo;
function getRenameInfoForNode(node, typeChecker, sourceFile, program, preferences) {
  const symbol = typeChecker.getSymbolAtLocation(node);
  if (!symbol) {
    if (ts.isStringLiteralLike(node)) {
      const type = ts.getContextualTypeFromParentOrAncestorTypeNode(node, typeChecker);
      if (type &&
          ((type.flags & 128 /* TypeFlags.StringLiteral */) ||
           ((type.flags & 1048576 /* TypeFlags.Union */) && ts.every(type.types, function(type) {
             return !!(type.flags & 128 /* TypeFlags.StringLiteral */);
           })))) {
        return getRenameInfoSuccess(
            node.text, node.text, 'string' /* ScriptElementKind.string */, '', node, sourceFile);
      }
    } else if (ts.isLabelName(node)) {
      const name = ts.getTextOfNode(node);
      return getRenameInfoSuccess(
          name, name, 'label' /* ScriptElementKind.label */, '' /* ScriptElementKindModifier.none */, node, sourceFile);
    }
    return undefined;
  }
  // Only allow a symbol to be renamed if it actually has at least one declaration.
  const declarations = symbol.declarations;
  if (!declarations || declarations.length === 0)
    {return;}
  // Disallow rename for elements that are defined in the standard TypeScript library.
  if (declarations.some(function(declaration) {
        return isDefinedInLibraryFile(program, declaration);
      })) {
    return getRenameInfoError(
        ts.Diagnostics.You_cannot_rename_elements_that_are_defined_in_the_standard_TypeScript_library);
  }
  // Cannot rename `default` as in `import { default as foo } from "./someModule";
  if (ts.isIdentifier(node) && node.originalKeywordKind === 88 /* SyntaxKind.DefaultKeyword */ && symbol.parent &&
      symbol.parent.flags & 1536 /* SymbolFlags.Module */) {
    return undefined;
  }
  if (ts.isStringLiteralLike(node) && ts.tryGetImportFromModuleSpecifier(node)) {
    return preferences.allowRenameOfImportPath ? getRenameInfoForModule(node, sourceFile, symbol) : undefined;
  }
  // Disallow rename for elements that would rename across `*/node_modules/*` packages.
  const wouldRenameNodeModules = wouldRenameInOtherNodeModules(sourceFile, symbol, typeChecker, preferences);
  if (wouldRenameNodeModules) {
    return getRenameInfoError(wouldRenameNodeModules);
  }
  const kind = ts.SymbolDisplay.getSymbolKind(typeChecker, symbol, node);
  const specifierName =
      (ts.isImportOrExportSpecifierName(node) ||
       ts.isStringOrNumericLiteralLike(node) && node.parent.kind === 164 /* SyntaxKind.ComputedPropertyName */) ?
      ts.stripQuotes(ts.getTextOfIdentifierOrLiteral(node)) :
      undefined;
  const displayName = specifierName || typeChecker.symbolToString(symbol);
  const fullDisplayName = specifierName || typeChecker.getFullyQualifiedName(symbol);
  return getRenameInfoSuccess(
      displayName, fullDisplayName, kind, ts.SymbolDisplay.getSymbolModifiers(typeChecker, symbol), node, sourceFile);
}
function isDefinedInLibraryFile(program, declaration) {
  const sourceFile = declaration.getSourceFile();
  return program.isSourceFileDefaultLibrary(sourceFile) &&
      ts.fileExtensionIs(sourceFile.fileName, '.d.ts' /* Extension.Dts */);
}
function wouldRenameInOtherNodeModules(originalFile, symbol, checker, preferences) {
  if (!preferences.providePrefixAndSuffixTextForRename && symbol.flags & 2097152 /* SymbolFlags.Alias */) {
    const importSpecifier = symbol.declarations && ts.find(symbol.declarations, function(decl) {
      return ts.isImportSpecifier(decl);
    });
    if (importSpecifier && !importSpecifier.propertyName) {
      symbol = checker.getAliasedSymbol(symbol);
    }
  }
  const declarations = symbol.declarations;
  if (!declarations) {
    return undefined;
  }
  const originalPackage = getPackagePathComponents(originalFile.path);
  if (originalPackage === undefined) {  // original source file is not in node_modules
    if (ts.some(declarations, function(declaration) {
          return ts.isInsideNodeModules(declaration.getSourceFile().path);
        })) {
      return ts.Diagnostics.You_cannot_rename_elements_that_are_defined_in_a_node_modules_folder;
    }
      return undefined;

  }
  // original source file is in node_modules
  for (let _i = 0, declarations_4 = declarations; _i < declarations_4.length; _i++) {
    const declaration = declarations_4[_i];
    const declPackage = getPackagePathComponents(declaration.getSourceFile().path);
    if (declPackage) {
      const length_2 = Math.min(originalPackage.length, declPackage.length);
      for (let i = 0; i <= length_2; i++) {
        if (ts.compareStringsCaseSensitive(originalPackage[i], declPackage[i]) !== 0 /* Comparison.EqualTo */) {
          return ts.Diagnostics.You_cannot_rename_elements_that_are_defined_in_another_node_modules_folder;
        }
      }
    }
  }
  return undefined;
}
function getPackagePathComponents(filePath) {
  const components = ts.getPathComponents(filePath);
  const nodeModulesIdx = components.lastIndexOf('node_modules');
  if (nodeModulesIdx === -1) {
    return undefined;
  }
  return components.slice(0, nodeModulesIdx + 2);
}
function getRenameInfoForModule(node, sourceFile, moduleSymbol) {
  if (!ts.isExternalModuleNameRelative(node.text)) {
    return getRenameInfoError(ts.Diagnostics.You_cannot_rename_a_module_via_a_global_import);
  }
  const moduleSourceFile = moduleSymbol.declarations && ts.find(moduleSymbol.declarations, ts.isSourceFile);
  if (!moduleSourceFile)
    {return undefined;}
  const withoutIndex = ts.endsWith(node.text, '/index') || ts.endsWith(node.text, '/index.js') ?
      undefined :
      ts.tryRemoveSuffix(ts.removeFileExtension(moduleSourceFile.fileName), '/index');
  const name = withoutIndex === undefined ? moduleSourceFile.fileName : withoutIndex;
  const kind = withoutIndex === undefined ? 'module' /* ScriptElementKind.moduleElement */ :
                                          'directory' /* ScriptElementKind.directory */;
  const indexAfterLastSlash = node.text.lastIndexOf('/') + 1;
  // Span should only be the last component of the path. + 1 to account for the quote character.
  const triggerSpan =
      ts.createTextSpan(node.getStart(sourceFile) + 1 + indexAfterLastSlash, node.text.length - indexAfterLastSlash);
  return {
    canRename: true,
    fileToRename: name,
    kind,
    displayName: name,
    fullDisplayName: name,
    kindModifiers: '' /* ScriptElementKindModifier.none */,
    triggerSpan,
  };
}
function getRenameInfoSuccess(displayName, fullDisplayName, kind, kindModifiers, node, sourceFile) {
  return {
    canRename: true,
    fileToRename: undefined,
    kind,
    displayName,
    fullDisplayName,
    kindModifiers,
    triggerSpan: createTriggerSpanForNode(node, sourceFile)
  };
}
function getRenameInfoError(diagnostic) {
  return {canRename: false, localizedErrorMessage: ts.getLocaleSpecificMessage(diagnostic)};
}
function createTriggerSpanForNode(node, sourceFile) {
  let start = node.getStart(sourceFile);
  let width = node.getWidth(sourceFile);
  if (ts.isStringLiteralLike(node)) {
    // Exclude the quotes
    start += 1;
    width -= 2;
  }
  return ts.createTextSpan(start, width);
}
function nodeIsEligibleForRename(node) {
  switch (node.kind) {
    case 79 /* SyntaxKind.Identifier */:
    case 80 /* SyntaxKind.PrivateIdentifier */:
    case 10 /* SyntaxKind.StringLiteral */:
    case 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */:
    case 108 /* SyntaxKind.ThisKeyword */:
      return true;
    case 8 /* SyntaxKind.NumericLiteral */:
      return ts.isLiteralNameOfPropertyDeclarationOrIndexAccess(node);
    default:
      return false;
  }
}
Rename.nodeIsEligibleForRename = nodeIsEligibleForRename;
})(Rename = ts.Rename || (ts.Rename = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let SmartSelectionRange;
(function(SmartSelectionRange) {
function getSmartSelectionRange(pos, sourceFile) {
  let _a, _b;
  let selectionRange = {textSpan: ts.createTextSpanFromBounds(sourceFile.getFullStart(), sourceFile.getEnd())};
  let parentNode = sourceFile;
  outer: while (true) {
    const children = getSelectionChildren(parentNode);
    if (!children.length)
      {break;}
    for (let i = 0; i < children.length; i++) {
      const prevNode = children[i - 1];
      const node = children[i];
      const nextNode = children[i + 1];
      if (ts.getTokenPosOfNode(node, sourceFile, /* includeJsDoc*/ true) > pos) {
        break outer;
      }
      const comment = ts.singleOrUndefined(ts.getTrailingCommentRanges(sourceFile.text, node.end));
      if (comment && comment.kind === 2 /* SyntaxKind.SingleLineCommentTrivia */) {
        pushSelectionCommentRange(comment.pos, comment.end);
      }
      if (positionShouldSnapToNode(sourceFile, pos, node)) {
        if (ts.isFunctionBody(node) && ts.isFunctionLikeDeclaration(parentNode) &&
            !ts.positionsAreOnSameLine(node.getStart(sourceFile), node.getEnd(), sourceFile)) {
          pushSelectionRange(node.getStart(sourceFile), node.getEnd());
        }
        // 1. Blocks are effectively redundant with SyntaxLists.
        // 2. TemplateSpans, along with the SyntaxLists containing them, are a somewhat unintuitive grouping
        //    of things that should be considered independently.
        // 3. A VariableStatement’s children are just a VaraiableDeclarationList and a semicolon.
        // 4. A lone VariableDeclaration in a VaraibleDeclaration feels redundant with the VariableStatement.
        // Dive in without pushing a selection range.
        if (ts.isBlock(node) || ts.isTemplateSpan(node) || ts.isTemplateHead(node) || ts.isTemplateTail(node) ||
            prevNode && ts.isTemplateHead(prevNode) ||
            ts.isVariableDeclarationList(node) && ts.isVariableStatement(parentNode) ||
            ts.isSyntaxList(node) && ts.isVariableDeclarationList(parentNode) ||
            ts.isVariableDeclaration(node) && ts.isSyntaxList(parentNode) && children.length === 1 ||
            ts.isJSDocTypeExpression(node) || ts.isJSDocSignature(node) || ts.isJSDocTypeLiteral(node)) {
          parentNode = node;
          break;
        }
        // Synthesize a stop for '${ ... }' since '${' and '}' actually belong to siblings.
        if (ts.isTemplateSpan(parentNode) && nextNode && ts.isTemplateMiddleOrTemplateTail(nextNode)) {
          const start_1 = node.getFullStart() - '${'.length;
          const end_2 = nextNode.getStart() + '}'.length;
          pushSelectionRange(start_1, end_2);
        }
        // Blocks with braces, brackets, parens, or JSX tags on separate lines should be
        // selected from open to close, including whitespace but not including the braces/etc. themselves.
        const isBetweenMultiLineBookends = ts.isSyntaxList(node) && isListOpener(prevNode) && isListCloser(nextNode) &&
            !ts.positionsAreOnSameLine(prevNode.getStart(), nextNode.getStart(), sourceFile);
        let start = isBetweenMultiLineBookends ? prevNode.getEnd() : node.getStart();
        const end = isBetweenMultiLineBookends ? nextNode.getStart() : getEndPos(sourceFile, node);
        if (ts.hasJSDocNodes(node) && ((_a = node.jsDoc) === null || _a === void 0 ? void 0 : _a.length)) {
          pushSelectionRange(ts.first(node.jsDoc).getStart(), end);
        }
        // (#39618 & #49807)
        // When the node is a SyntaxList and its first child has a JSDoc comment, then the node's
        // `start` (which usually is the result of calling `node.getStart()`) points to the first
        // token after the JSDoc comment. So, we have to make sure we'd pushed the selection
        // covering the JSDoc comment before diving further.
        if (ts.isSyntaxList(node)) {
          const firstChild = node.getChildren()[0];
          if (firstChild && ts.hasJSDocNodes(firstChild) &&
              ((_b = firstChild.jsDoc) === null || _b === void 0 ? void 0 : _b.length) &&
              firstChild.getStart() !== node.pos) {
            start = Math.min(start, ts.first(firstChild.jsDoc).getStart());
          }
        }
        pushSelectionRange(start, end);
        // String literals should have a stop both inside and outside their quotes.
        if (ts.isStringLiteral(node) || ts.isTemplateLiteral(node)) {
          pushSelectionRange(start + 1, end - 1);
        }
        parentNode = node;
        break;
      }
      // If we made it to the end of the for loop, we’re done.
      // In practice, I’ve only seen this happen at the very end
      // of a SourceFile.
      if (i === children.length - 1) {
        break outer;
      }
    }
  }
  return selectionRange;
  function pushSelectionRange(start, end) {
    // Skip empty ranges
    if (start !== end) {
      const textSpan = ts.createTextSpanFromBounds(start, end);
      if (!selectionRange ||
          (
              // Skip ranges that are identical to the parent
              !ts.textSpansEqual(textSpan, selectionRange.textSpan) &&
              // Skip ranges that don’t contain the original position
              ts.textSpanIntersectsWithPosition(textSpan, pos))) {
        selectionRange = __assign({textSpan}, selectionRange && {parent: selectionRange});
      }
    }
  }
  function pushSelectionCommentRange(start, end) {
    pushSelectionRange(start, end);
    let pos = start;
    while (sourceFile.text.charCodeAt(pos) === 47 /* CharacterCodes.slash */) {
      pos++;
    }
    pushSelectionRange(pos, end);
  }
}
SmartSelectionRange.getSmartSelectionRange = getSmartSelectionRange;
/**
 * Like `ts.positionBelongsToNode`, except positions immediately after nodes
 * count too, unless that position belongs to the next node. In effect, makes
 * selections able to snap to preceding tokens when the cursor is on the tail
 * end of them with only whitespace ahead.
 * @param sourceFile The source file containing the nodes.
 * @param pos The position to check.
 * @param node The candidate node to snap to.
 */
function positionShouldSnapToNode(sourceFile, pos, node) {
  // Can’t use 'ts.positionBelongsToNode()' here because it cleverly accounts
  // for missing nodes, which can’t really be considered when deciding what
  // to select.
  ts.Debug.assert(node.pos <= pos);
  if (pos < node.end) {
    return true;
  }
  const nodeEnd = node.getEnd();
  if (nodeEnd === pos) {
    return ts.getTouchingPropertyName(sourceFile, pos).pos < node.end;
  }
  return false;
}
const isImport = ts.or(ts.isImportDeclaration, ts.isImportEqualsDeclaration);
/**
 * Gets the children of a node to be considered for selection ranging,
 * transforming them into an artificial tree according to their intuitive
 * grouping where no grouping actually exists in the parse tree. For example,
 * top-level imports are grouped into their own SyntaxList so they can be
 * selected all together, even though in the AST they’re just siblings of each
 * other as well as of other top-level statements and declarations.
 */
function getSelectionChildren(node) {
  let _a;
  // Group top-level imports
  if (ts.isSourceFile(node)) {
    return groupChildren(node.getChildAt(0).getChildren(), isImport);
  }
  // Mapped types _look_ like ObjectTypes with a single member,
  // but in fact don’t contain a SyntaxList or a node containing
  // the “key/value” pair like ObjectTypes do, but it seems intuitive
  // that the selection would snap to those points. The philosophy
  // of choosing a selection range is not so much about what the
  // syntax currently _is_ as what the syntax might easily become
  // if the user is making a selection; e.g., we synthesize a selection
  // around the “key/value” pair not because there’s a node there, but
  // because it allows the mapped type to become an object type with a
  // few keystrokes.
  if (ts.isMappedTypeNode(node)) {
    var _b = node.getChildren(), openBraceToken = _b[0], children = _b.slice(1);
    const closeBraceToken = ts.Debug.checkDefined(children.pop());
    ts.Debug.assertEqual(openBraceToken.kind, 18 /* SyntaxKind.OpenBraceToken */);
    ts.Debug.assertEqual(closeBraceToken.kind, 19 /* SyntaxKind.CloseBraceToken */);
    // Group `-/+readonly` and `-/+?`
    const groupedWithPlusMinusTokens = groupChildren(children, function(child) {
      return child === node.readonlyToken || child.kind === 146 /* SyntaxKind.ReadonlyKeyword */ ||
          child === node.questionToken || child.kind === 57 /* SyntaxKind.QuestionToken */;
    });
    // Group type parameter with surrounding brackets
    const groupedWithBrackets = groupChildren(groupedWithPlusMinusTokens, function(_a) {
      const kind = _a.kind;
      return kind === 22 /* SyntaxKind.OpenBracketToken */ || kind === 165 /* SyntaxKind.TypeParameter */ ||
          kind === 23 /* SyntaxKind.CloseBracketToken */;
    });
    return [
      openBraceToken,
      // Pivot on `:`
      createSyntaxList(splitChildren(
          groupedWithBrackets,
          function(_a) {
            const kind = _a.kind;
            return kind === 58 /* SyntaxKind.ColonToken */;
          })),
      closeBraceToken,
    ];
  }
  // Group modifiers and property name, then pivot on `:`.
  if (ts.isPropertySignature(node)) {
    var children = groupChildren(node.getChildren(), function(child) {
      return child === node.name || ts.contains(node.modifiers, child);
    });
    const firstJSDocChild =
        ((_a = children[0]) === null || _a === void 0 ? void 0 : _a.kind) === 323 /* SyntaxKind.JSDoc */ ? children[0] :
                                                                                                           undefined;
    const withJSDocSeparated = firstJSDocChild ? children.slice(1) : children;
    const splittedChildren = splitChildren(withJSDocSeparated, function(_a) {
      const kind = _a.kind;
      return kind === 58 /* SyntaxKind.ColonToken */;
    });
    return firstJSDocChild ? [firstJSDocChild, createSyntaxList(splittedChildren)] : splittedChildren;
  }
  // Group the parameter name with its `...`, then that group with its `?`, then pivot on `=`.
  if (ts.isParameter(node)) {
    const groupedDotDotDotAndName_1 = groupChildren(node.getChildren(), function(child) {
      return child === node.dotDotDotToken || child === node.name;
    });
    const groupedWithQuestionToken = groupChildren(groupedDotDotDotAndName_1, function(child) {
      return child === groupedDotDotDotAndName_1[0] || child === node.questionToken;
    });
    return splitChildren(groupedWithQuestionToken, function(_a) {
      const kind = _a.kind;
      return kind === 63 /* SyntaxKind.EqualsToken */;
    });
  }
  // Pivot on '='
  if (ts.isBindingElement(node)) {
    return splitChildren(node.getChildren(), function(_a) {
      const kind = _a.kind;
      return kind === 63 /* SyntaxKind.EqualsToken */;
    });
  }
  return node.getChildren();
}
/**
 * Groups sibling nodes together into their own SyntaxList if they
 * a) are adjacent, AND b) match a predicate function.
 */
function groupChildren(children, groupOn) {
  const result = [];
  let group;
  for (let _i = 0, children_1 = children; _i < children_1.length; _i++) {
    const child = children_1[_i];
    if (groupOn(child)) {
      group = group || [];
      group.push(child);
    } else {
      if (group) {
        result.push(createSyntaxList(group));
        group = undefined;
      }
      result.push(child);
    }
  }
  if (group) {
    result.push(createSyntaxList(group));
  }
  return result;
}
/**
 * Splits sibling nodes into up to four partitions:
 * 1) everything left of the first node matched by `pivotOn`,
 * 2) the first node matched by `pivotOn`,
 * 3) everything right of the first node matched by `pivotOn`,
 * 4) a trailing semicolon, if `separateTrailingSemicolon` is enabled.
 * The left and right groups, if not empty, will each be grouped into their own containing SyntaxList.
 * @param children The sibling nodes to split.
 * @param pivotOn The predicate function to match the node to be the pivot. The first node that matches
 * the predicate will be used; any others that may match will be included into the right-hand group.
 * @param separateTrailingSemicolon If the last token is a semicolon, it will be returned as a separate
 * child rather than be included in the right-hand group.
 */
function splitChildren(children, pivotOn, separateTrailingSemicolon) {
  if (separateTrailingSemicolon === void 0) {
    separateTrailingSemicolon = true;
  }
  if (children.length < 2) {
    return children;
  }
  const splitTokenIndex = ts.findIndex(children, pivotOn);
  if (splitTokenIndex === -1) {
    return children;
  }
  const leftChildren = children.slice(0, splitTokenIndex);
  const splitToken = children[splitTokenIndex];
  const lastToken = ts.last(children);
  const separateLastToken = separateTrailingSemicolon && lastToken.kind === 26 /* SyntaxKind.SemicolonToken */;
  const rightChildren = children.slice(splitTokenIndex + 1, separateLastToken ? children.length - 1 : undefined);
  const result = ts.compact([
    leftChildren.length ? createSyntaxList(leftChildren) : undefined,
    splitToken,
    rightChildren.length ? createSyntaxList(rightChildren) : undefined,
  ]);
  return separateLastToken ? result.concat(lastToken) : result;
}
function createSyntaxList(children) {
  ts.Debug.assertGreaterThanOrEqual(children.length, 1);
  return ts.setTextRangePosEnd(ts.parseNodeFactory.createSyntaxList(children), children[0].pos, ts.last(children).end);
}
function isListOpener(token) {
  const kind = token && token.kind;
  return kind === 18 /* SyntaxKind.OpenBraceToken */
      || kind === 22 /* SyntaxKind.OpenBracketToken */
      || kind === 20 /* SyntaxKind.OpenParenToken */
      || kind === 283 /* SyntaxKind.JsxOpeningElement */;
}
function isListCloser(token) {
  const kind = token && token.kind;
  return kind === 19 /* SyntaxKind.CloseBraceToken */
      || kind === 23 /* SyntaxKind.CloseBracketToken */
      || kind === 21 /* SyntaxKind.CloseParenToken */
      || kind === 284 /* SyntaxKind.JsxClosingElement */;
}
function getEndPos(sourceFile, node) {
  switch (node.kind) {
    case 343 /* SyntaxKind.JSDocParameterTag */:
    case 341 /* SyntaxKind.JSDocCallbackTag */:
    case 350 /* SyntaxKind.JSDocPropertyTag */:
    case 348 /* SyntaxKind.JSDocTypedefTag */:
    case 345 /* SyntaxKind.JSDocThisTag */:
      return sourceFile.getLineEndOfPosition(node.getStart());
    default:
      return node.getEnd();
  }
}
})(SmartSelectionRange = ts.SmartSelectionRange || (ts.SmartSelectionRange = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let SignatureHelp;
(function(SignatureHelp) {
let InvocationKind;
(function(InvocationKind) {
InvocationKind[InvocationKind['Call'] = 0] = 'Call';
InvocationKind[InvocationKind['TypeArgs'] = 1] = 'TypeArgs';
InvocationKind[InvocationKind['Contextual'] = 2] = 'Contextual';
})(InvocationKind || (InvocationKind = {}));
function getSignatureHelpItems(program, sourceFile, position, triggerReason, cancellationToken) {
  const typeChecker = program.getTypeChecker();
  // Decide whether to show signature help
  const startingToken = ts.findTokenOnLeftOfPosition(sourceFile, position);
  if (!startingToken) {
    // We are at the beginning of the file
    return undefined;
  }
  // Only need to be careful if the user typed a character and signature help wasn't showing.
  const onlyUseSyntacticOwners = !!triggerReason && triggerReason.kind === 'characterTyped';
  // Bail out quickly in the middle of a string or comment, don't provide signature help unless the user explicitly requested it.
  if (onlyUseSyntacticOwners &&
      (ts.isInString(sourceFile, position, startingToken) || ts.isInComment(sourceFile, position))) {
    return undefined;
  }
  const isManuallyInvoked = !!triggerReason && triggerReason.kind === 'invoked';
  const argumentInfo = getContainingArgumentInfo(startingToken, position, sourceFile, typeChecker, isManuallyInvoked);
  if (!argumentInfo)
    {return undefined;}
  cancellationToken.throwIfCancellationRequested();
  // Extra syntactic and semantic filtering of signature help
  const candidateInfo =
      getCandidateOrTypeInfo(argumentInfo, typeChecker, sourceFile, startingToken, onlyUseSyntacticOwners);
  cancellationToken.throwIfCancellationRequested();
  if (!candidateInfo) {
    // We didn't have any sig help items produced by the TS compiler.  If this is a JS
    // file, then see if we can figure out anything better.
    return ts.isSourceFileJS(sourceFile) ? createJSSignatureHelpItems(argumentInfo, program, cancellationToken) :
                                           undefined;
  }
  return typeChecker.runWithCancellationToken(cancellationToken, function(typeChecker) {
    return candidateInfo.kind === 0 /* CandidateOrTypeKind.Candidate */
        ?
        createSignatureHelpItems(
            candidateInfo.candidates, candidateInfo.resolvedSignature, argumentInfo, sourceFile, typeChecker) :
        createTypeHelpItems(candidateInfo.symbol, argumentInfo, sourceFile, typeChecker);
  });
}
SignatureHelp.getSignatureHelpItems = getSignatureHelpItems;
let CandidateOrTypeKind;
(function(CandidateOrTypeKind) {
CandidateOrTypeKind[CandidateOrTypeKind['Candidate'] = 0] = 'Candidate';
CandidateOrTypeKind[CandidateOrTypeKind['Type'] = 1] = 'Type';
})(CandidateOrTypeKind || (CandidateOrTypeKind = {}));
function getCandidateOrTypeInfo(_a, checker, sourceFile, startingToken, onlyUseSyntacticOwners) {
  const invocation = _a.invocation, argumentCount = _a.argumentCount;
  switch (invocation.kind) {
    case 0 /* InvocationKind.Call */: {
      if (onlyUseSyntacticOwners && !isSyntacticOwner(startingToken, invocation.node, sourceFile)) {
        return undefined;
      }
      var candidates = [];
      const resolvedSignature =
          checker.getResolvedSignatureForSignatureHelp(invocation.node, candidates, argumentCount);  // TODO: GH#18217
      return candidates.length === 0 ?
          undefined :
          {kind: 0 /* CandidateOrTypeKind.Candidate */, candidates, resolvedSignature};
    }
    case 1 /* InvocationKind.TypeArgs */: {
      const called = invocation.called;
      if (onlyUseSyntacticOwners &&
          !containsPrecedingToken(startingToken, sourceFile, ts.isIdentifier(called) ? called.parent : called)) {
        return undefined;
      }
      var candidates = ts.getPossibleGenericSignatures(called, argumentCount, checker);
      if (candidates.length !== 0)
        {return {
          kind: 0 /* CandidateOrTypeKind.Candidate */,
          candidates,
          resolvedSignature: ts.first(candidates)
        };}
      const symbol = checker.getSymbolAtLocation(called);
      return symbol && {kind: 1 /* CandidateOrTypeKind.Type */, symbol};
    }
    case 2 /* InvocationKind.Contextual */:
      return {
        kind: 0 /* CandidateOrTypeKind.Candidate */,
        candidates: [invocation.signature],
        resolvedSignature: invocation.signature
      };
    default:
      return ts.Debug.assertNever(invocation);
  }
}
function isSyntacticOwner(startingToken, node, sourceFile) {
  if (!ts.isCallOrNewExpression(node))
    {return false;}
  const invocationChildren = node.getChildren(sourceFile);
  switch (startingToken.kind) {
    case 20 /* SyntaxKind.OpenParenToken */:
      return ts.contains(invocationChildren, startingToken);
    case 27 /* SyntaxKind.CommaToken */: {
      const containingList = ts.findContainingList(startingToken);
      return !!containingList && ts.contains(invocationChildren, containingList);
    }
    case 29 /* SyntaxKind.LessThanToken */:
      return containsPrecedingToken(startingToken, sourceFile, node.expression);
    default:
      return false;
  }
}
function createJSSignatureHelpItems(argumentInfo, program, cancellationToken) {
  if (argumentInfo.invocation.kind === 2 /* InvocationKind.Contextual */)
    {return undefined;}
  // See if we can find some symbol with the call expression name that has call signatures.
  const expression = getExpressionFromInvocation(argumentInfo.invocation);
  const name = ts.isPropertyAccessExpression(expression) ? expression.name.text : undefined;
  const typeChecker = program.getTypeChecker();
  return name === undefined ? undefined : ts.firstDefined(program.getSourceFiles(), function(sourceFile) {
    return ts.firstDefined(sourceFile.getNamedDeclarations().get(name), function(declaration) {
      const type = declaration.symbol && typeChecker.getTypeOfSymbolAtLocation(declaration.symbol, declaration);
      const callSignatures = type && type.getCallSignatures();
      if (callSignatures && callSignatures.length) {
        return typeChecker.runWithCancellationToken(cancellationToken, function(typeChecker) {
          return createSignatureHelpItems(
              callSignatures, callSignatures[0], argumentInfo, sourceFile, typeChecker,
              /* useFullPrefix*/ true);
        });
      }
    });
  });
}
function containsPrecedingToken(startingToken, sourceFile, container) {
  const pos = startingToken.getFullStart();
  // There’s a possibility that `startingToken.parent` contains only `startingToken` and
  // missing nodes, none of which are valid to be returned by `findPrecedingToken`. In that
  // case, the preceding token we want is actually higher up the tree—almost definitely the
  // next parent, but theoretically the situation with missing nodes might be happening on
  // multiple nested levels.
  let currentParent = startingToken.parent;
  while (currentParent) {
    const precedingToken = ts.findPrecedingToken(pos, sourceFile, currentParent, /* excludeJsdoc*/ true);
    if (precedingToken) {
      return ts.rangeContainsRange(container, precedingToken);
    }
    currentParent = currentParent.parent;
  }
  return ts.Debug.fail('Could not find preceding token');
}
function getArgumentInfoForCompletions(node, position, sourceFile) {
  const info = getImmediatelyContainingArgumentInfo(node, position, sourceFile);
  return !info || info.isTypeParameterList || info.invocation.kind !== 0 /* InvocationKind.Call */ ?
      undefined :
      {invocation: info.invocation.node, argumentCount: info.argumentCount, argumentIndex: info.argumentIndex};
}
SignatureHelp.getArgumentInfoForCompletions = getArgumentInfoForCompletions;
function getArgumentOrParameterListInfo(node, position, sourceFile) {
  const info = getArgumentOrParameterListAndIndex(node, sourceFile);
  if (!info)
    {return undefined;}
  const list = info.list, argumentIndex = info.argumentIndex;
  const argumentCount = getArgumentCount(list, /* ignoreTrailingComma*/ ts.isInString(sourceFile, position, node));
  if (argumentIndex !== 0) {
    ts.Debug.assertLessThan(argumentIndex, argumentCount);
  }
  const argumentsSpan = getApplicableSpanForArguments(list, sourceFile);
  return {list, argumentIndex, argumentCount, argumentsSpan};
}
function getArgumentOrParameterListAndIndex(node, sourceFile) {
  if (node.kind === 29 /* SyntaxKind.LessThanToken */ || node.kind === 20 /* SyntaxKind.OpenParenToken */) {
    // Find the list that starts right *after* the < or ( token.
    // If the user has just opened a list, consider this item 0.
    return {list: getChildListThatStartsWithOpenerToken(node.parent, node, sourceFile), argumentIndex: 0};
  }
    // findListItemInfo can return undefined if we are not in parent's argument list
    // or type argument list. This includes cases where the cursor is:
    //   - To the right of the closing parenthesis, non-substitution template, or template tail.
    //   - Between the type arguments and the arguments (greater than token)
    //   - On the target of the call (parent.func)
    //   - On the 'new' keyword in a 'new' expression
    const list = ts.findContainingList(node);
    return list && {list, argumentIndex: getArgumentIndex(list, node)};

}
/**
 * Returns relevant information for the argument list and the current argument if we are
 * in the argument of an invocation; returns undefined otherwise.
 */
function getImmediatelyContainingArgumentInfo(node, position, sourceFile) {
  const parent = node.parent;
  if (ts.isCallOrNewExpression(parent)) {
    var invocation = parent;
    // There are 3 cases to handle:
    //   1. The token introduces a list, and should begin a signature help session
    //   2. The token is either not associated with a list, or ends a list, so the session should end
    //   3. The token is buried inside a list, and should give signature help
    //
    // The following are examples of each:
    //
    //    Case 1:
    //          foo<#T, U>(#a, b)    -> The token introduces a list, and should begin a signature help session
    //    Case 2:
    //          fo#o<T, U>#(a, b)#   -> The token is either not associated with a list, or ends a list, so the session should end
    //    Case 3:
    //          foo<T#, U#>(a#, #b#) -> The token is buried inside a list, and should give signature help
    // Find out if 'node' is an argument, a type argument, or neither
    const info = getArgumentOrParameterListInfo(node, position, sourceFile);
    if (!info)
      {return undefined;}
    var list = info.list, argumentIndex = info.argumentIndex, argumentCount = info.argumentCount,
        argumentsSpan = info.argumentsSpan;
    const isTypeParameterList = !!parent.typeArguments && parent.typeArguments.pos === list.pos;
    return {
      isTypeParameterList,
      invocation: {kind: 0 /* InvocationKind.Call */, node: invocation},
      argumentsSpan,
      argumentIndex,
      argumentCount
    };
  } if (ts.isNoSubstitutionTemplateLiteral(node) && ts.isTaggedTemplateExpression(parent)) {
    // Check if we're actually inside the template;
    // otherwise we'll fall out and return undefined.
    if (ts.isInsideTemplateLiteral(node, position, sourceFile)) {
      return getArgumentListInfoForTemplate(parent, /* argumentIndex*/ 0, sourceFile);
    }
    return undefined;
  } if (ts.isTemplateHead(node) && parent.parent.kind === 212 /* SyntaxKind.TaggedTemplateExpression */) {
    const templateExpression = parent;
    var tagExpression = templateExpression.parent;
    ts.Debug.assert(templateExpression.kind === 225 /* SyntaxKind.TemplateExpression */);
    var argumentIndex = ts.isInsideTemplateLiteral(node, position, sourceFile) ? 0 : 1;
    return getArgumentListInfoForTemplate(tagExpression, argumentIndex, sourceFile);
  } if (ts.isTemplateSpan(parent) && ts.isTaggedTemplateExpression(parent.parent.parent)) {
    const templateSpan = parent;
    var tagExpression = parent.parent.parent;
    // If we're just after a template tail, don't show signature help.
    if (ts.isTemplateTail(node) && !ts.isInsideTemplateLiteral(node, position, sourceFile)) {
      return undefined;
    }
    const spanIndex = templateSpan.parent.templateSpans.indexOf(templateSpan);
    var argumentIndex = getArgumentIndexForTemplatePiece(spanIndex, node, position, sourceFile);
    return getArgumentListInfoForTemplate(tagExpression, argumentIndex, sourceFile);
  } if (ts.isJsxOpeningLikeElement(parent)) {
    // Provide a signature help for JSX opening element or JSX self-closing element.
    // This is not guarantee that JSX tag-name is resolved into stateless function component. (that is done in "getSignatureHelpItems")
    // i.e
    //      export function MainButton(props: ButtonProps, context: any): JSX.Element { ... }
    //      <MainButton /*signatureHelp*/
    const attributeSpanStart = parent.attributes.pos;
    const attributeSpanEnd = ts.skipTrivia(sourceFile.text, parent.attributes.end, /* stopAfterLineBreak*/ false);
    return {
      isTypeParameterList: false,
      invocation: {kind: 0 /* InvocationKind.Call */, node: parent},
      argumentsSpan: ts.createTextSpan(attributeSpanStart, attributeSpanEnd - attributeSpanStart),
      argumentIndex: 0,
      argumentCount: 1
    };
  }
    const typeArgInfo = ts.getPossibleTypeArgumentsInfo(node, sourceFile);
    if (typeArgInfo) {
      const called = typeArgInfo.called, nTypeArguments = typeArgInfo.nTypeArguments;
      var invocation = {kind: 1 /* InvocationKind.TypeArgs */, called};
      var argumentsSpan = ts.createTextSpanFromBounds(called.getStart(sourceFile), node.end);
      return {
        isTypeParameterList: true,
        invocation,
        argumentsSpan,
        argumentIndex: nTypeArguments,
        argumentCount: nTypeArguments + 1
      };
    }
    return undefined;

}
function getImmediatelyContainingArgumentOrContextualParameterInfo(node, position, sourceFile, checker) {
  return tryGetParameterInfo(node, position, sourceFile, checker) ||
      getImmediatelyContainingArgumentInfo(node, position, sourceFile);
}
function getHighestBinary(b) {
  return ts.isBinaryExpression(b.parent) ? getHighestBinary(b.parent) : b;
}
function countBinaryExpressionParameters(b) {
  return ts.isBinaryExpression(b.left) ? countBinaryExpressionParameters(b.left) + 1 : 2;
}
function tryGetParameterInfo(startingToken, position, sourceFile, checker) {
  const info = getContextualSignatureLocationInfo(startingToken, sourceFile, position, checker);
  if (!info)
    {return undefined;}
  const contextualType = info.contextualType, argumentIndex = info.argumentIndex, argumentCount = info.argumentCount,
      argumentsSpan = info.argumentsSpan;
  // for optional function condition.
  const nonNullableContextualType = contextualType.getNonNullableType();
  const symbol = nonNullableContextualType.symbol;
  if (symbol === undefined)
    {return undefined;}
  const signature = ts.lastOrUndefined(nonNullableContextualType.getCallSignatures());
  if (signature === undefined)
    {return undefined;}
  const invocation = {
    kind: 2 /* InvocationKind.Contextual */,
    signature,
    node: startingToken,
    symbol: chooseBetterSymbol(symbol)
  };
  return {
    isTypeParameterList: false,
    invocation,
    argumentsSpan,
    argumentIndex,
    argumentCount
  };
}
function getContextualSignatureLocationInfo(startingToken, sourceFile, position, checker) {
  if (startingToken.kind !== 20 /* SyntaxKind.OpenParenToken */ &&
      startingToken.kind !== 27 /* SyntaxKind.CommaToken */)
    {return undefined;}
  const parent = startingToken.parent;
  switch (parent.kind) {
    case 214 /* SyntaxKind.ParenthesizedExpression */:
    case 171 /* SyntaxKind.MethodDeclaration */:
    case 215 /* SyntaxKind.FunctionExpression */:
    case 216 /* SyntaxKind.ArrowFunction */:
      var info = getArgumentOrParameterListInfo(startingToken, position, sourceFile);
      if (!info)
        {return undefined;}
      var argumentIndex = info.argumentIndex, argumentCount = info.argumentCount, argumentsSpan = info.argumentsSpan;
      var contextualType = ts.isMethodDeclaration(parent) ? checker.getContextualTypeForObjectLiteralElement(parent) :
                                                            checker.getContextualType(parent);
      return contextualType && {
        contextualType,
        argumentIndex,
        argumentCount,
        argumentsSpan
      };
    case 223 /* SyntaxKind.BinaryExpression */: {
      const highestBinary = getHighestBinary(parent);
      const contextualType_1 = checker.getContextualType(highestBinary);
      const argumentIndex_1 =
          startingToken.kind === 20 /* SyntaxKind.OpenParenToken */ ? 0 : countBinaryExpressionParameters(parent) - 1;
      const argumentCount_1 = countBinaryExpressionParameters(highestBinary);
      return contextualType_1 && {
        contextualType: contextualType_1,
        argumentIndex: argumentIndex_1,
        argumentCount: argumentCount_1,
        argumentsSpan: ts.createTextSpanFromNode(parent)
      };
    }
    default:
      return undefined;
  }
}
// The type of a function type node has a symbol at that node, but it's better to use the symbol for a parameter or type alias.
function chooseBetterSymbol(s) {
  return s.name === '__type' /* InternalSymbolName.Type */
      ?
      ts.firstDefined(
          s.declarations,
          function(d) {
            return ts.isFunctionTypeNode(d) ? d.parent.symbol : undefined;
          }) ||
          s :
      s;
}
function getArgumentIndex(argumentsList, node) {
  // The list we got back can include commas.  In the presence of errors it may
  // also just have nodes without commas.  For example "Foo(a b c)" will have 3
  // args without commas. We want to find what index we're at.  So we count
  // forward until we hit ourselves, only incrementing the index if it isn't a
  // comma.
  //
  // Note: the subtlety around trailing commas (in getArgumentCount) does not apply
  // here.  That's because we're only walking forward until we hit the node we're
  // on.  In that case, even if we're after the trailing comma, we'll still see
  // that trailing comma in the list, and we'll have generated the appropriate
  // arg index.
  let argumentIndex = 0;
  for (let _i = 0, _a = argumentsList.getChildren(); _i < _a.length; _i++) {
    const child = _a[_i];
    if (child === node) {
      break;
    }
    if (child.kind !== 27 /* SyntaxKind.CommaToken */) {
      argumentIndex++;
    }
  }
  return argumentIndex;
}
function getArgumentCount(argumentsList, ignoreTrailingComma) {
  // The argument count for a list is normally the number of non-comma children it has.
  // For example, if you have "Foo(a,b)" then there will be three children of the arg
  // list 'a' '<comma>' 'b'.  So, in this case the arg count will be 2.  However, there
  // is a small subtlety.  If you have "Foo(a,)", then the child list will just have
  // 'a' '<comma>'.  So, in the case where the last child is a comma, we increase the
  // arg count by one to compensate.
  //
  // Note: this subtlety only applies to the last comma.  If you had "Foo(a,," then
  // we'll have: 'a' '<comma>' '<missing>'
  // That will give us 2 non-commas.  We then add one for the last comma, giving us an
  // arg count of 3.
  const listChildren = argumentsList.getChildren();
  let argumentCount = ts.countWhere(listChildren, function(arg) {
    return arg.kind !== 27 /* SyntaxKind.CommaToken */;
  });
  if (!ignoreTrailingComma && listChildren.length > 0 &&
      ts.last(listChildren).kind === 27 /* SyntaxKind.CommaToken */) {
    argumentCount++;
  }
  return argumentCount;
}
// spanIndex is either the index for a given template span.
// This does not give appropriate results for a NoSubstitutionTemplateLiteral
function getArgumentIndexForTemplatePiece(spanIndex, node, position, sourceFile) {
  // Because the TemplateStringsArray is the first argument, we have to offset each substitution expression by 1.
  // There are three cases we can encounter:
  //      1. We are precisely in the template literal (argIndex = 0).
  //      2. We are in or to the right of the substitution expression (argIndex = spanIndex + 1).
  //      3. We are directly to the right of the template literal, but because we look for the token on the left,
  //          not enough to put us in the substitution expression; we should consider ourselves part of
  //          the *next* span's expression by offsetting the index (argIndex = (spanIndex + 1) + 1).
  //
  /* eslint-disable local/no-double-space */
  // Example: f  `# abcd $#{#  1 + 1#  }# efghi ${ #"#hello"#  }  #  `
  //              ^       ^ ^       ^   ^          ^ ^      ^     ^
  // Case:        1       1 3       2   1          3 2      2     1
  /* eslint-enable local/no-double-space */
  ts.Debug.assert(position >= node.getStart(), 'Assumed \'position\' could not occur before node.');
  if (ts.isTemplateLiteralToken(node)) {
    if (ts.isInsideTemplateLiteral(node, position, sourceFile)) {
      return 0;
    }
    return spanIndex + 2;
  }
  return spanIndex + 1;
}
function getArgumentListInfoForTemplate(tagExpression, argumentIndex, sourceFile) {
  // argumentCount is either 1 or (numSpans + 1) to account for the template strings array argument.
  const argumentCount =
      ts.isNoSubstitutionTemplateLiteral(tagExpression.template) ? 1 : tagExpression.template.templateSpans.length + 1;
  if (argumentIndex !== 0) {
    ts.Debug.assertLessThan(argumentIndex, argumentCount);
  }
  return {
    isTypeParameterList: false,
    invocation: {kind: 0 /* InvocationKind.Call */, node: tagExpression},
    argumentsSpan: getApplicableSpanForTaggedTemplate(tagExpression, sourceFile),
    argumentIndex,
    argumentCount
  };
}
function getApplicableSpanForArguments(argumentsList, sourceFile) {
  // We use full start and skip trivia on the end because we want to include trivia on
  // both sides. For example,
  //
  //    foo(   /*comment */     a, b, c      /*comment*/     )
  //        |                                               |
  //
  // The applicable span is from the first bar to the second bar (inclusive,
  // but not including parentheses)
  const applicableSpanStart = argumentsList.getFullStart();
  const applicableSpanEnd = ts.skipTrivia(sourceFile.text, argumentsList.getEnd(), /* stopAfterLineBreak*/ false);
  return ts.createTextSpan(applicableSpanStart, applicableSpanEnd - applicableSpanStart);
}
function getApplicableSpanForTaggedTemplate(taggedTemplate, sourceFile) {
  const template = taggedTemplate.template;
  const applicableSpanStart = template.getStart();
  let applicableSpanEnd = template.getEnd();
  // We need to adjust the end position for the case where the template does not have a tail.
  // Otherwise, we will not show signature help past the expression.
  // For example,
  //
  //      ` ${ 1 + 1 foo(10)
  //       |       |
  // This is because a Missing node has no width. However, what we actually want is to include trivia
  // leading up to the next token in case the user is about to type in a TemplateMiddle or TemplateTail.
  if (template.kind === 225 /* SyntaxKind.TemplateExpression */) {
    const lastSpan = ts.last(template.templateSpans);
    if (lastSpan.literal.getFullWidth() === 0) {
      applicableSpanEnd = ts.skipTrivia(sourceFile.text, applicableSpanEnd, /* stopAfterLineBreak*/ false);
    }
  }
  return ts.createTextSpan(applicableSpanStart, applicableSpanEnd - applicableSpanStart);
}
function getContainingArgumentInfo(node, position, sourceFile, checker, isManuallyInvoked) {
  const _loop_7 = function(n) {
    // If the node is not a subspan of its parent, this is a big problem.
    // There have been crashes that might be caused by this violation.
    ts.Debug.assert(ts.rangeContainsRange(n.parent, n), 'Not a subspan', function() {
      return 'Child: '.concat(ts.Debug.formatSyntaxKind(n.kind), ', parent: ')
          .concat(ts.Debug.formatSyntaxKind(n.parent.kind));
    });
    const argumentInfo = getImmediatelyContainingArgumentOrContextualParameterInfo(n, position, sourceFile, checker);
    if (argumentInfo) {
      return {value: argumentInfo};
    }
  };
  for (let n = node; !ts.isSourceFile(n) && (isManuallyInvoked || !ts.isBlock(n)); n = n.parent) {
    const state_4 = _loop_7(n);
    if (typeof state_4 === 'object')
      {return state_4.value;}
  }
  return undefined;
}
function getChildListThatStartsWithOpenerToken(parent, openerToken, sourceFile) {
  const children = parent.getChildren(sourceFile);
  const indexOfOpenerToken = children.indexOf(openerToken);
  ts.Debug.assert(indexOfOpenerToken >= 0 && children.length > indexOfOpenerToken + 1);
  return children[indexOfOpenerToken + 1];
}
function getExpressionFromInvocation(invocation) {
  return invocation.kind === 0 /* InvocationKind.Call */ ? ts.getInvokedExpression(invocation.node) : invocation.called;
}
function getEnclosingDeclarationFromInvocation(invocation) {
  return invocation.kind === 0 /* InvocationKind.Call */  ? invocation.node :
      invocation.kind === 1 /* InvocationKind.TypeArgs */ ? invocation.called :
                                                            invocation.node;
}
const signatureHelpNodeBuilderFlags = 8192 /* NodeBuilderFlags.OmitParameterModifiers */ |
    70221824 /* NodeBuilderFlags.IgnoreErrors */ | 16384 /* NodeBuilderFlags.UseAliasDefinedOutsideCurrentScope */;
function createSignatureHelpItems(candidates, resolvedSignature, _a, sourceFile, typeChecker, useFullPrefix) {
  let _b;
  const isTypeParameterList = _a.isTypeParameterList, argumentCount = _a.argumentCount, applicableSpan = _a.argumentsSpan,
      invocation = _a.invocation, argumentIndex = _a.argumentIndex;
  const enclosingDeclaration = getEnclosingDeclarationFromInvocation(invocation);
  const callTargetSymbol = invocation.kind === 2 /* InvocationKind.Contextual */ ?
      invocation.symbol :
      (typeChecker.getSymbolAtLocation(getExpressionFromInvocation(invocation)) ||
       useFullPrefix && ((_b = resolvedSignature.declaration) === null || _b === void 0 ? void 0 : _b.symbol));
  const callTargetDisplayParts = callTargetSymbol ?
      ts.symbolToDisplayParts(
          typeChecker, callTargetSymbol, useFullPrefix ? sourceFile : undefined, /* meaning*/ undefined) :
      ts.emptyArray;
  const items = ts.map(candidates, function(candidateSignature) {
    return getSignatureHelpItem(
        candidateSignature, callTargetDisplayParts, isTypeParameterList, typeChecker, enclosingDeclaration, sourceFile);
  });
  if (argumentIndex !== 0) {
    ts.Debug.assertLessThan(argumentIndex, argumentCount);
  }
  let selectedItemIndex = 0;
  let itemsSeen = 0;
  for (let i = 0; i < items.length; i++) {
    const item = items[i];
    if (candidates[i] === resolvedSignature) {
      selectedItemIndex = itemsSeen;
      if (item.length > 1) {
        // check to see if any items in the list better match than the first one, as the checker isn't filtering the nested lists
        // (those come from tuple parameter expansion)
        let count = 0;
        for (let _i = 0, item_1 = item; _i < item_1.length; _i++) {
          const i_1 = item_1[_i];
          if (i_1.isVariadic || i_1.parameters.length >= argumentCount) {
            selectedItemIndex = itemsSeen + count;
            break;
          }
          count++;
        }
      }
    }
    itemsSeen += item.length;
  }
  ts.Debug.assert(
      selectedItemIndex !==
      -1);  // If candidates is non-empty it should always include bestSignature. We check for an empty candidates before calling this function.
  const help = {
    items: ts.flatMapToMutable(items, ts.identity),
    applicableSpan,
    selectedItemIndex,
    argumentIndex,
    argumentCount
  };
  const selected = help.items[selectedItemIndex];
  if (selected.isVariadic) {
    const firstRest = ts.findIndex(selected.parameters, function(p) {
      return !!p.isRest;
    });
    if (-1 < firstRest && firstRest < selected.parameters.length - 1) {
      // We don't have any code to get this correct; instead, don't highlight a current parameter AT ALL
      help.argumentIndex = selected.parameters.length;
    } else {
      help.argumentIndex = Math.min(help.argumentIndex, selected.parameters.length - 1);
    }
  }
  return help;
}
function createTypeHelpItems(symbol, _a, sourceFile, checker) {
  const argumentCount = _a.argumentCount, applicableSpan = _a.argumentsSpan, invocation = _a.invocation,
      argumentIndex = _a.argumentIndex;
  const typeParameters = checker.getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol);
  if (!typeParameters)
    {return undefined;}
  const items =
      [getTypeHelpItem(symbol, typeParameters, checker, getEnclosingDeclarationFromInvocation(invocation), sourceFile)];
  return {
    items,
    applicableSpan,
    selectedItemIndex: 0,
    argumentIndex,
    argumentCount
  };
}
function getTypeHelpItem(symbol, typeParameters, checker, enclosingDeclaration, sourceFile) {
  const typeSymbolDisplay = ts.symbolToDisplayParts(checker, symbol);
  const printer = ts.createPrinter({removeComments: true});
  const parameters = typeParameters.map(function(t) {
    return createSignatureHelpParameterForTypeParameter(t, checker, enclosingDeclaration, sourceFile, printer);
  });
  const documentation = symbol.getDocumentationComment(checker);
  const tags = symbol.getJsDocTags(checker);
  const prefixDisplayParts = __spreadArray(
      __spreadArray([], typeSymbolDisplay, true), [ts.punctuationPart(29 /* SyntaxKind.LessThanToken */)], false);
  return {
    isVariadic: false,
    prefixDisplayParts,
    suffixDisplayParts: [ts.punctuationPart(31 /* SyntaxKind.GreaterThanToken */)],
    separatorDisplayParts,
    parameters,
    documentation,
    tags
  };
}
var separatorDisplayParts = [ts.punctuationPart(27 /* SyntaxKind.CommaToken */), ts.spacePart()];
function getSignatureHelpItem(
    candidateSignature, callTargetDisplayParts, isTypeParameterList, checker, enclosingDeclaration, sourceFile) {
  const infos = (isTypeParameterList ? itemInfoForTypeParameters : itemInfoForParameters)(
      candidateSignature, checker, enclosingDeclaration, sourceFile);
  return ts.map(infos, function(_a) {
    const isVariadic = _a.isVariadic, parameters = _a.parameters, prefix = _a.prefix, suffix = _a.suffix;
    const prefixDisplayParts = __spreadArray(__spreadArray([], callTargetDisplayParts, true), prefix, true);
    const suffixDisplayParts = __spreadArray(
        __spreadArray([], suffix, true), returnTypeToDisplayParts(candidateSignature, enclosingDeclaration, checker),
        true);
    const documentation = candidateSignature.getDocumentationComment(checker);
    const tags = candidateSignature.getJsDocTags();
    return {
      isVariadic,
      prefixDisplayParts,
      suffixDisplayParts,
      separatorDisplayParts,
      parameters,
      documentation,
      tags
    };
  });
}
function returnTypeToDisplayParts(candidateSignature, enclosingDeclaration, checker) {
  return ts.mapToDisplayParts(function(writer) {
    writer.writePunctuation(':');
    writer.writeSpace(' ');
    const predicate = checker.getTypePredicateOfSignature(candidateSignature);
    if (predicate) {
      checker.writeTypePredicate(predicate, enclosingDeclaration, /* flags*/ undefined, writer);
    } else {
      checker.writeType(
          checker.getReturnTypeOfSignature(candidateSignature), enclosingDeclaration, /* flags*/ undefined, writer);
    }
  });
}
function itemInfoForTypeParameters(candidateSignature, checker, enclosingDeclaration, sourceFile) {
  const typeParameters = (candidateSignature.target || candidateSignature).typeParameters;
  const printer = ts.createPrinter({removeComments: true});
  const parameters = (typeParameters || ts.emptyArray).map(function(t) {
    return createSignatureHelpParameterForTypeParameter(t, checker, enclosingDeclaration, sourceFile, printer);
  });
  const thisParameter = candidateSignature.thisParameter ?
      [checker.symbolToParameterDeclaration(
          candidateSignature.thisParameter, enclosingDeclaration, signatureHelpNodeBuilderFlags)] :
      [];
  return checker.getExpandedParameters(candidateSignature).map(function(paramList) {
    const params = ts.factory.createNodeArray(
        __spreadArray(__spreadArray([], thisParameter, true), ts.map(paramList, function(param) {
          return checker.symbolToParameterDeclaration(param, enclosingDeclaration, signatureHelpNodeBuilderFlags);
        }), true));
    const parameterParts = ts.mapToDisplayParts(function(writer) {
      printer.writeList(2576 /* ListFormat.CallExpressionArguments */, params, sourceFile, writer);
    });
    return {
      isVariadic: false,
      parameters,
      prefix: [ts.punctuationPart(29 /* SyntaxKind.LessThanToken */)],
      suffix: __spreadArray([ts.punctuationPart(31 /* SyntaxKind.GreaterThanToken */)], parameterParts, true)
    };
  });
}
function itemInfoForParameters(candidateSignature, checker, enclosingDeclaration, sourceFile) {
  const printer = ts.createPrinter({removeComments: true});
  const typeParameterParts = ts.mapToDisplayParts(function(writer) {
    if (candidateSignature.typeParameters && candidateSignature.typeParameters.length) {
      const args = ts.factory.createNodeArray(candidateSignature.typeParameters.map(function(p) {
        return checker.typeParameterToDeclaration(p, enclosingDeclaration, signatureHelpNodeBuilderFlags);
      }));
      printer.writeList(53776 /* ListFormat.TypeParameters */, args, sourceFile, writer);
    }
  });
  const lists = checker.getExpandedParameters(candidateSignature);
  const isVariadic = !checker.hasEffectiveRestParameter(candidateSignature) ?
      function(_) {
        return false;
      } :
      lists.length === 1 ?
      function(_) {
        return true;
      } :
      function(pList) {
        return !!(pList.length && pList[pList.length - 1].checkFlags & 32768 /* CheckFlags.RestParameter */);
      };
  return lists.map(function(parameterList) {
    return ({
      isVariadic: isVariadic(parameterList),
      parameters: parameterList.map(function(p) {
        return createSignatureHelpParameterForParameter(p, checker, enclosingDeclaration, sourceFile, printer);
      }),
      prefix: __spreadArray(
          __spreadArray([], typeParameterParts, true), [ts.punctuationPart(20 /* SyntaxKind.OpenParenToken */)], false),
      suffix: [ts.punctuationPart(21 /* SyntaxKind.CloseParenToken */)]
    });
  });
}
function createSignatureHelpParameterForParameter(parameter, checker, enclosingDeclaration, sourceFile, printer) {
  const displayParts = ts.mapToDisplayParts(function(writer) {
    const param = checker.symbolToParameterDeclaration(parameter, enclosingDeclaration, signatureHelpNodeBuilderFlags);
    printer.writeNode(4 /* EmitHint.Unspecified */, param, sourceFile, writer);
  });
  const isOptional = checker.isOptionalParameter(parameter.valueDeclaration);
  const isRest = !!(parameter.checkFlags & 32768 /* CheckFlags.RestParameter */);
  return {
    name: parameter.name,
    documentation: parameter.getDocumentationComment(checker),
    displayParts,
    isOptional,
    isRest
  };
}
function createSignatureHelpParameterForTypeParameter(
    typeParameter, checker, enclosingDeclaration, sourceFile, printer) {
  const displayParts = ts.mapToDisplayParts(function(writer) {
    const param = checker.typeParameterToDeclaration(typeParameter, enclosingDeclaration, signatureHelpNodeBuilderFlags);
    printer.writeNode(4 /* EmitHint.Unspecified */, param, sourceFile, writer);
  });
  return {
    name: typeParameter.symbol.name,
    documentation: typeParameter.symbol.getDocumentationComment(checker),
    displayParts,
    isOptional: false,
    isRest: false
  };
}
})(SignatureHelp = ts.SignatureHelp || (ts.SignatureHelp = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let InlayHints;
(function(InlayHints) {
const maxHintsLength = 30;
const leadingParameterNameCommentRegexFactory = function(name) {
  return new RegExp('^\\s?/\\*\\*?\\s?'.concat(name, '\\s?\\*\\/\\s?$'));
};
function shouldShowParameterNameHints(preferences) {
  return preferences.includeInlayParameterNameHints === 'literals' ||
      preferences.includeInlayParameterNameHints === 'all';
}
function shouldShowLiteralParameterNameHintsOnly(preferences) {
  return preferences.includeInlayParameterNameHints === 'literals';
}
function provideInlayHints(context) {
  const file = context.file, program = context.program, span = context.span,
      cancellationToken = context.cancellationToken, preferences = context.preferences;
  const sourceFileText = file.text;
  const compilerOptions = program.getCompilerOptions();
  const checker = program.getTypeChecker();
  const result = [];
  visitor(file);
  return result;
  function visitor(node) {
    if (!node || node.getFullWidth() === 0) {
      return;
    }
    switch (node.kind) {
      case 264 /* SyntaxKind.ModuleDeclaration */:
      case 260 /* SyntaxKind.ClassDeclaration */:
      case 261 /* SyntaxKind.InterfaceDeclaration */:
      case 259 /* SyntaxKind.FunctionDeclaration */:
      case 228 /* SyntaxKind.ClassExpression */:
      case 215 /* SyntaxKind.FunctionExpression */:
      case 171 /* SyntaxKind.MethodDeclaration */:
      case 216 /* SyntaxKind.ArrowFunction */:
        cancellationToken.throwIfCancellationRequested();
    }
    if (!ts.textSpanIntersectsWith(span, node.pos, node.getFullWidth())) {
      return;
    }
    if (ts.isTypeNode(node) && !ts.isExpressionWithTypeArguments(node)) {
      return;
    }
    if (preferences.includeInlayVariableTypeHints && ts.isVariableDeclaration(node)) {
      visitVariableLikeDeclaration(node);
    } else if (preferences.includeInlayPropertyDeclarationTypeHints && ts.isPropertyDeclaration(node)) {
      visitVariableLikeDeclaration(node);
    } else if (preferences.includeInlayEnumMemberValueHints && ts.isEnumMember(node)) {
      visitEnumMember(node);
    } else if (shouldShowParameterNameHints(preferences) && (ts.isCallExpression(node) || ts.isNewExpression(node))) {
      visitCallOrNewExpression(node);
    } else {
      if (preferences.includeInlayFunctionParameterTypeHints && ts.isFunctionLikeDeclaration(node) &&
          ts.hasContextSensitiveParameters(node)) {
        visitFunctionLikeForParameterType(node);
      }
      if (preferences.includeInlayFunctionLikeReturnTypeHints && isSignatureSupportingReturnAnnotation(node)) {
        visitFunctionDeclarationLikeForReturnType(node);
      }
    }
    return ts.forEachChild(node, visitor);
  }
  function isSignatureSupportingReturnAnnotation(node) {
    return ts.isArrowFunction(node) || ts.isFunctionExpression(node) || ts.isFunctionDeclaration(node) ||
        ts.isMethodDeclaration(node) || ts.isGetAccessorDeclaration(node);
  }
  function addParameterHints(text, position, isFirstVariadicArgument) {
    result.push({
      text: ''.concat(isFirstVariadicArgument ? '...' : '').concat(truncation(text, maxHintsLength), ':'),
      position,
      kind: 'Parameter' /* InlayHintKind.Parameter */,
      whitespaceAfter: true,
    });
  }
  function addTypeHints(text, position) {
    result.push({
      text: ': '.concat(truncation(text, maxHintsLength)),
      position,
      kind: 'Type' /* InlayHintKind.Type */,
      whitespaceBefore: true,
    });
  }
  function addEnumMemberValueHints(text, position) {
    result.push({
      text: '= '.concat(truncation(text, maxHintsLength)),
      position,
      kind: 'Enum' /* InlayHintKind.Enum */,
      whitespaceBefore: true,
    });
  }
  function visitEnumMember(member) {
    if (member.initializer) {
      return;
    }
    const enumValue = checker.getConstantValue(member);
    if (enumValue !== undefined) {
      addEnumMemberValueHints(enumValue.toString(), member.end);
    }
  }
  function isModuleReferenceType(type) {
    return type.symbol && (type.symbol.flags & 1536 /* SymbolFlags.Module */);
  }
  function visitVariableLikeDeclaration(decl) {
    if (!decl.initializer || ts.isBindingPattern(decl.name) ||
        ts.isVariableDeclaration(decl) && !isHintableDeclaration(decl)) {
      return;
    }
    const effectiveTypeAnnotation = ts.getEffectiveTypeAnnotationNode(decl);
    if (effectiveTypeAnnotation) {
      return;
    }
    const declarationType = checker.getTypeAtLocation(decl);
    if (isModuleReferenceType(declarationType)) {
      return;
    }
    const typeDisplayString = printTypeInSingleLine(declarationType);
    if (typeDisplayString) {
      const isVariableNameMatchesType = preferences.includeInlayVariableTypeHintsWhenTypeMatchesName === false &&
          ts.equateStringsCaseInsensitive(decl.name.getText(), typeDisplayString);
      if (isVariableNameMatchesType) {
        return;
      }
      addTypeHints(typeDisplayString, decl.name.end);
    }
  }
  function visitCallOrNewExpression(expr) {
    const args = expr.arguments;
    if (!args || !args.length) {
      return;
    }
    const candidates = [];
    const signature = checker.getResolvedSignatureForSignatureHelp(expr, candidates);
    if (!signature || !candidates.length) {
      return;
    }
    for (let i = 0; i < args.length; ++i) {
      const originalArg = args[i];
      const arg = ts.skipParentheses(originalArg);
      if (shouldShowLiteralParameterNameHintsOnly(preferences) && !isHintableLiteral(arg)) {
        continue;
      }
      const identifierNameInfo = checker.getParameterIdentifierNameAtPosition(signature, i);
      if (identifierNameInfo) {
        const parameterName = identifierNameInfo[0], isFirstVariadicArgument = identifierNameInfo[1];
        const isParameterNameNotSameAsArgument = preferences.includeInlayParameterNameHintsWhenArgumentMatchesName ||
            !identifierOrAccessExpressionPostfixMatchesParameterName(arg, parameterName);
        if (!isParameterNameNotSameAsArgument && !isFirstVariadicArgument) {
          continue;
        }
        const name = ts.unescapeLeadingUnderscores(parameterName);
        if (leadingCommentsContainsParameterName(arg, name)) {
          continue;
        }
        addParameterHints(name, originalArg.getStart(), isFirstVariadicArgument);
      }
    }
  }
  function identifierOrAccessExpressionPostfixMatchesParameterName(expr, parameterName) {
    if (ts.isIdentifier(expr)) {
      return expr.text === parameterName;
    }
    if (ts.isPropertyAccessExpression(expr)) {
      return expr.name.text === parameterName;
    }
    return false;
  }
  function leadingCommentsContainsParameterName(node, name) {
    if (!ts.isIdentifierText(name, compilerOptions.target, ts.getLanguageVariant(file.scriptKind))) {
      return false;
    }
    const ranges = ts.getLeadingCommentRanges(sourceFileText, node.pos);
    if (!(ranges === null || ranges === void 0 ? void 0 : ranges.length)) {
      return false;
    }
    const regex = leadingParameterNameCommentRegexFactory(name);
    return ts.some(ranges, function(range) {
      return regex.test(sourceFileText.substring(range.pos, range.end));
    });
  }
  function isHintableLiteral(node) {
    switch (node.kind) {
      case 221 /* SyntaxKind.PrefixUnaryExpression */: {
        const operand = node.operand;
        return ts.isLiteralExpression(operand) ||
            ts.isIdentifier(operand) && ts.isInfinityOrNaNString(operand.escapedText);
      }
      case 110 /* SyntaxKind.TrueKeyword */:
      case 95 /* SyntaxKind.FalseKeyword */:
      case 104 /* SyntaxKind.NullKeyword */:
      case 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */:
      case 225 /* SyntaxKind.TemplateExpression */:
        return true;
      case 79 /* SyntaxKind.Identifier */: {
        const name = node.escapedText;
        return isUndefined(name) || ts.isInfinityOrNaNString(name);
      }
    }
    return ts.isLiteralExpression(node);
  }
  function visitFunctionDeclarationLikeForReturnType(decl) {
    if (ts.isArrowFunction(decl)) {
      if (!ts.findChildOfKind(decl, 20 /* SyntaxKind.OpenParenToken */, file)) {
        return;
      }
    }
    const effectiveTypeAnnotation = ts.getEffectiveReturnTypeNode(decl);
    if (effectiveTypeAnnotation || !decl.body) {
      return;
    }
    const signature = checker.getSignatureFromDeclaration(decl);
    if (!signature) {
      return;
    }
    const returnType = checker.getReturnTypeOfSignature(signature);
    if (isModuleReferenceType(returnType)) {
      return;
    }
    const typeDisplayString = printTypeInSingleLine(returnType);
    if (!typeDisplayString) {
      return;
    }
    addTypeHints(typeDisplayString, getTypeAnnotationPosition(decl));
  }
  function getTypeAnnotationPosition(decl) {
    const closeParenToken = ts.findChildOfKind(decl, 21 /* SyntaxKind.CloseParenToken */, file);
    if (closeParenToken) {
      return closeParenToken.end;
    }
    return decl.parameters.end;
  }
  function visitFunctionLikeForParameterType(node) {
    const signature = checker.getSignatureFromDeclaration(node);
    if (!signature) {
      return;
    }
    for (let i = 0; i < node.parameters.length && i < signature.parameters.length; ++i) {
      const param = node.parameters[i];
      if (!isHintableDeclaration(param)) {
        continue;
      }
      const effectiveTypeAnnotation = ts.getEffectiveTypeAnnotationNode(param);
      if (effectiveTypeAnnotation) {
        continue;
      }
      const typeDisplayString = getParameterDeclarationTypeDisplayString(signature.parameters[i]);
      if (!typeDisplayString) {
        continue;
      }
      addTypeHints(typeDisplayString, param.questionToken ? param.questionToken.end : param.name.end);
    }
  }
  function getParameterDeclarationTypeDisplayString(symbol) {
    const valueDeclaration = symbol.valueDeclaration;
    if (!valueDeclaration || !ts.isParameter(valueDeclaration)) {
      return undefined;
    }
    const signatureParamType = checker.getTypeOfSymbolAtLocation(symbol, valueDeclaration);
    if (isModuleReferenceType(signatureParamType)) {
      return undefined;
    }
    return printTypeInSingleLine(signatureParamType);
  }
  function truncation(text, maxLength) {
    if (text.length > maxLength) {
      return text.substr(0, maxLength - '...'.length) + '...';
    }
    return text;
  }
  function printTypeInSingleLine(type) {
    const flags = 70221824 /* NodeBuilderFlags.IgnoreErrors */ | 1048576 /* TypeFormatFlags.AllowUniqueESSymbolType */ |
        16384 /* TypeFormatFlags.UseAliasDefinedOutsideCurrentScope */;
    const options = {removeComments: true};
    const printer = ts.createPrinter(options);
    return ts.usingSingleLineStringWriter(function(writer) {
      const typeNode = checker.typeToTypeNode(type, /* enclosingDeclaration*/ undefined, flags, writer);
      ts.Debug.assertIsDefined(typeNode, 'should always get typenode');
      printer.writeNode(4 /* EmitHint.Unspecified */, typeNode, /* sourceFile*/ file, writer);
    });
  }
  function isUndefined(name) {
    return name === 'undefined';
  }
  function isHintableDeclaration(node) {
    if ((ts.isParameterDeclaration(node) || ts.isVariableDeclaration(node) && ts.isVarConst(node)) &&
        node.initializer) {
      const initializer = ts.skipParentheses(node.initializer);
      return !(
          isHintableLiteral(initializer) || ts.isNewExpression(initializer) ||
          ts.isObjectLiteralExpression(initializer) || ts.isAssertionExpression(initializer));
    }
    return true;
  }
}
InlayHints.provideInlayHints = provideInlayHints;
})(InlayHints = ts.InlayHints || (ts.InlayHints = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
const base64UrlRegExp = /^data:(?:application\/json(?:;charset=[uU][tT][fF]-8);base64,([A-Za-z0-9+\/=]+)$)?/;
function getSourceMapper(host) {
  const getCanonicalFileName = ts.createGetCanonicalFileName(host.useCaseSensitiveFileNames());
  const currentDirectory = host.getCurrentDirectory();
  const sourceFileLike = new ts.Map();
  const documentPositionMappers = new ts.Map();
  return {
    tryGetSourcePosition,
    tryGetGeneratedPosition,
    toLineColumnOffset,
    clearCache
  };
  function toPath(fileName) {
    return ts.toPath(fileName, currentDirectory, getCanonicalFileName);
  }
  function getDocumentPositionMapper(generatedFileName, sourceFileName) {
    const path = toPath(generatedFileName);
    const value = documentPositionMappers.get(path);
    if (value)
      {return value;}
    let mapper;
    if (host.getDocumentPositionMapper) {
      mapper = host.getDocumentPositionMapper(generatedFileName, sourceFileName);
    } else if (host.readFile) {
      const file = getSourceFileLike(generatedFileName);
      mapper = file &&
          ts.getDocumentPositionMapper(
              {
                getSourceFileLike,
                getCanonicalFileName,
                log: function(s) {
                  return host.log(s);
                }
              },
              generatedFileName, ts.getLineInfo(file.text, ts.getLineStarts(file)), function(f) {
                return !host.fileExists || host.fileExists(f) ? host.readFile(f) : undefined;
              });
    }
    documentPositionMappers.set(path, mapper || ts.identitySourceMapConsumer);
    return mapper || ts.identitySourceMapConsumer;
  }
  function tryGetSourcePosition(info) {
    if (!ts.isDeclarationFileName(info.fileName))
      {return undefined;}
    const file = getSourceFile(info.fileName);
    if (!file)
      {return undefined;}
    const newLoc = getDocumentPositionMapper(info.fileName).getSourcePosition(info);
    return !newLoc || newLoc === info ? undefined : tryGetSourcePosition(newLoc) || newLoc;
  }
  function tryGetGeneratedPosition(info) {
    if (ts.isDeclarationFileName(info.fileName))
      {return undefined;}
    const sourceFile = getSourceFile(info.fileName);
    if (!sourceFile)
      {return undefined;}
    const program = host.getProgram();
    // If this is source file of project reference source (instead of redirect) there is no generated position
    if (program.isSourceOfProjectReferenceRedirect(sourceFile.fileName)) {
      return undefined;
    }
    const options = program.getCompilerOptions();
    const outPath = ts.outFile(options);
    const declarationPath = outPath ? ts.removeFileExtension(outPath) + '.d.ts' /* Extension.Dts */ :
                                    ts.getDeclarationEmitOutputFilePathWorker(
                                        info.fileName, program.getCompilerOptions(), currentDirectory,
                                        program.getCommonSourceDirectory(), getCanonicalFileName);
    if (declarationPath === undefined)
      {return undefined;}
    const newLoc = getDocumentPositionMapper(declarationPath, info.fileName).getGeneratedPosition(info);
    return newLoc === info ? undefined : newLoc;
  }
  function getSourceFile(fileName) {
    const program = host.getProgram();
    if (!program)
      {return undefined;}
    const path = toPath(fileName);
    // file returned here could be .d.ts when asked for .ts file if projectReferences and module resolution created this source file
    const file = program.getSourceFileByPath(path);
    return file && file.resolvedPath === path ? file : undefined;
  }
  function getOrCreateSourceFileLike(fileName) {
    const path = toPath(fileName);
    const fileFromCache = sourceFileLike.get(path);
    if (fileFromCache !== undefined)
      {return fileFromCache ? fileFromCache : undefined;}
    if (!host.readFile || host.fileExists && !host.fileExists(path)) {
      sourceFileLike.set(path, false);
      return undefined;
    }
    // And failing that, check the disk
    const text = host.readFile(path);
    const file = text ? createSourceFileLike(text) : false;
    sourceFileLike.set(path, file);
    return file ? file : undefined;
  }
  // This can be called from source mapper in either source program or program that includes generated file
  function getSourceFileLike(fileName) {
    return !host.getSourceFileLike ? getSourceFile(fileName) || getOrCreateSourceFileLike(fileName) :
                                     host.getSourceFileLike(fileName);
  }
  function toLineColumnOffset(fileName, position) {
    const file = getSourceFileLike(fileName);  // TODO: GH#18217
    return file.getLineAndCharacterOfPosition(position);
  }
  function clearCache() {
    sourceFileLike.clear();
    documentPositionMappers.clear();
  }
}
ts.getSourceMapper = getSourceMapper;
function getDocumentPositionMapper(host, generatedFileName, generatedFileLineInfo, readMapFile) {
  let mapFileName = ts.tryGetSourceMappingURL(generatedFileLineInfo);
  if (mapFileName) {
    const match = base64UrlRegExp.exec(mapFileName);
    if (match) {
      if (match[1]) {
        const base64Object = match[1];
        return convertDocumentToSourceMapper(host, ts.base64decode(ts.sys, base64Object), generatedFileName);
      }
      // Not a data URL we can parse, skip it
      mapFileName = undefined;
    }
  }
  const possibleMapLocations = [];
  if (mapFileName) {
    possibleMapLocations.push(mapFileName);
  }
  possibleMapLocations.push(generatedFileName + '.map');
  const originalMapFileName =
      mapFileName && ts.getNormalizedAbsolutePath(mapFileName, ts.getDirectoryPath(generatedFileName));
  for (let _i = 0, possibleMapLocations_1 = possibleMapLocations; _i < possibleMapLocations_1.length; _i++) {
    const location = possibleMapLocations_1[_i];
    const mapFileName_1 = ts.getNormalizedAbsolutePath(location, ts.getDirectoryPath(generatedFileName));
    const mapFileContents = readMapFile(mapFileName_1, originalMapFileName);
    if (ts.isString(mapFileContents)) {
      return convertDocumentToSourceMapper(host, mapFileContents, mapFileName_1);
    }
    if (mapFileContents !== undefined) {
      return mapFileContents || undefined;
    }
  }
  return undefined;
}
ts.getDocumentPositionMapper = getDocumentPositionMapper;
function convertDocumentToSourceMapper(host, contents, mapFileName) {
  const map = ts.tryParseRawSourceMap(contents);
  if (!map || !map.sources || !map.file || !map.mappings) {
    // obviously invalid map
    return undefined;
  }
  // Dont support sourcemaps that contain inlined sources
  if (map.sourcesContent && map.sourcesContent.some(ts.isString))
    {return undefined;}
  return ts.createDocumentPositionMapper(host, map, mapFileName);
}
function createSourceFileLike(text, lineMap) {
  return {
    text,
    lineMap,
    getLineAndCharacterOfPosition: function(pos) {
      return ts.computeLineAndCharacterOfPosition(ts.getLineStarts(this), pos);
    }
  };
}
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
const visitedNestedConvertibleFunctions = new ts.Map();
function computeSuggestionDiagnostics(sourceFile, program, cancellationToken) {
  program.getSemanticDiagnostics(sourceFile, cancellationToken);
  const diags = [];
  const checker = program.getTypeChecker();
  const isCommonJSFile = sourceFile.impliedNodeFormat === ts.ModuleKind.CommonJS ||
      ts.fileExtensionIsOneOf(sourceFile.fileName, ['.cts' /* Extension.Cts */, '.cjs' /* Extension.Cjs */]);
  if (!isCommonJSFile && sourceFile.commonJsModuleIndicator &&
      (ts.programContainsEsModules(program) || ts.compilerOptionsIndicateEsModules(program.getCompilerOptions())) &&
      containsTopLevelCommonjs(sourceFile)) {
    diags.push(ts.createDiagnosticForNode(
        getErrorNodeFromCommonJsIndicator(sourceFile.commonJsModuleIndicator),
        ts.Diagnostics.File_is_a_CommonJS_module_it_may_be_converted_to_an_ES_module));
  }
  const isJsFile = ts.isSourceFileJS(sourceFile);
  visitedNestedConvertibleFunctions.clear();
  check(sourceFile);
  if (ts.getAllowSyntheticDefaultImports(program.getCompilerOptions())) {
    for (let _i = 0, _a = sourceFile.imports; _i < _a.length; _i++) {
      const moduleSpecifier = _a[_i];
      const importNode = ts.importFromModuleSpecifier(moduleSpecifier);
      const name = importNameForConvertToDefaultImport(importNode);
      if (!name)
        {continue;}
      const module_1 = ts.getResolvedModule(
          sourceFile, moduleSpecifier.text, ts.getModeForUsageLocation(sourceFile, moduleSpecifier));
      const resolvedFile = module_1 && program.getSourceFile(module_1.resolvedFileName);
      if (resolvedFile && resolvedFile.externalModuleIndicator && resolvedFile.externalModuleIndicator !== true &&
          ts.isExportAssignment(resolvedFile.externalModuleIndicator) &&
          resolvedFile.externalModuleIndicator.isExportEquals) {
        diags.push(ts.createDiagnosticForNode(name, ts.Diagnostics.Import_may_be_converted_to_a_default_import));
      }
    }
  }
  ts.addRange(diags, sourceFile.bindSuggestionDiagnostics);
  ts.addRange(diags, program.getSuggestionDiagnostics(sourceFile, cancellationToken));
  return diags.sort(function(d1, d2) {
    return d1.start - d2.start;
  });
  function check(node) {
    if (isJsFile) {
      if (canBeConvertedToClass(node, checker)) {
        diags.push(ts.createDiagnosticForNode(
            ts.isVariableDeclaration(node.parent) ? node.parent.name : node,
            ts.Diagnostics.This_constructor_function_may_be_converted_to_a_class_declaration));
      }
    } else {
      if (ts.isVariableStatement(node) && node.parent === sourceFile &&
          node.declarationList.flags & 2 /* NodeFlags.Const */ && node.declarationList.declarations.length === 1) {
        const init = node.declarationList.declarations[0].initializer;
        if (init && ts.isRequireCall(init, /* checkArgumentIsStringLiteralLike*/ true)) {
          diags.push(ts.createDiagnosticForNode(init, ts.Diagnostics.require_call_may_be_converted_to_an_import));
        }
      }
      if (ts.codefix.parameterShouldGetTypeFromJSDoc(node)) {
        diags.push(
            ts.createDiagnosticForNode(node.name || node, ts.Diagnostics.JSDoc_types_may_be_moved_to_TypeScript_types));
      }
    }
    if (canBeConvertedToAsync(node)) {
      addConvertToAsyncFunctionDiagnostics(node, checker, diags);
    }
    node.forEachChild(check);
  }
}
ts.computeSuggestionDiagnostics = computeSuggestionDiagnostics;
// convertToEsModule only works on top-level, so don't trigger it if commonjs code only appears in nested scopes.
function containsTopLevelCommonjs(sourceFile) {
  return sourceFile.statements.some(function(statement) {
    switch (statement.kind) {
      case 240 /* SyntaxKind.VariableStatement */:
        return statement.declarationList.declarations.some(function(decl) {
          return !!decl.initializer &&
              ts.isRequireCall(propertyAccessLeftHandSide(decl.initializer), /* checkArgumentIsStringLiteralLike*/ true);
        });
      case 241 /* SyntaxKind.ExpressionStatement */: {
        const expression = statement.expression;
        if (!ts.isBinaryExpression(expression))
          {return ts.isRequireCall(expression, /* checkArgumentIsStringLiteralLike*/ true);}
        const kind = ts.getAssignmentDeclarationKind(expression);
        return kind === 1 /* AssignmentDeclarationKind.ExportsProperty */ ||
            kind === 2 /* AssignmentDeclarationKind.ModuleExports */;
      }
      default:
        return false;
    }
  });
}
function propertyAccessLeftHandSide(node) {
  return ts.isPropertyAccessExpression(node) ? propertyAccessLeftHandSide(node.expression) : node;
}
function importNameForConvertToDefaultImport(node) {
  switch (node.kind) {
    case 269 /* SyntaxKind.ImportDeclaration */:
      var importClause = node.importClause, moduleSpecifier = node.moduleSpecifier;
      return importClause && !importClause.name && importClause.namedBindings &&
              importClause.namedBindings.kind === 271 /* SyntaxKind.NamespaceImport */ &&
              ts.isStringLiteral(moduleSpecifier) ?
          importClause.namedBindings.name :
          undefined;
    case 268 /* SyntaxKind.ImportEqualsDeclaration */:
      return node.name;
    default:
      return undefined;
  }
}
function addConvertToAsyncFunctionDiagnostics(node, checker, diags) {
  // need to check function before checking map so that deeper levels of nested callbacks are checked
  if (isConvertibleFunction(node, checker) && !visitedNestedConvertibleFunctions.has(getKeyFromNode(node))) {
    diags.push(ts.createDiagnosticForNode(
        !node.name && ts.isVariableDeclaration(node.parent) && ts.isIdentifier(node.parent.name) ? node.parent.name :
                                                                                                   node,
        ts.Diagnostics.This_may_be_converted_to_an_async_function));
  }
}
function isConvertibleFunction(node, checker) {
  return !ts.isAsyncFunction(node) && node.body && ts.isBlock(node.body) &&
      hasReturnStatementWithPromiseHandler(node.body, checker) && returnsPromise(node, checker);
}
function returnsPromise(node, checker) {
  const signature = checker.getSignatureFromDeclaration(node);
  const returnType = signature ? checker.getReturnTypeOfSignature(signature) : undefined;
  return !!returnType && !!checker.getPromisedTypeOfPromise(returnType);
}
ts.returnsPromise = returnsPromise;
function getErrorNodeFromCommonJsIndicator(commonJsModuleIndicator) {
  return ts.isBinaryExpression(commonJsModuleIndicator) ? commonJsModuleIndicator.left : commonJsModuleIndicator;
}
function hasReturnStatementWithPromiseHandler(body, checker) {
  return !!ts.forEachReturnStatement(body, function(statement) {
    return isReturnStatementWithFixablePromiseHandler(statement, checker);
  });
}
function isReturnStatementWithFixablePromiseHandler(node, checker) {
  return ts.isReturnStatement(node) && !!node.expression && isFixablePromiseHandler(node.expression, checker);
}
ts.isReturnStatementWithFixablePromiseHandler = isReturnStatementWithFixablePromiseHandler;
// Should be kept up to date with transformExpression in convertToAsyncFunction.ts
function isFixablePromiseHandler(node, checker) {
  // ensure outermost call exists and is a promise handler
  if (!isPromiseHandler(node) || !hasSupportedNumberOfArguments(node) || !node.arguments.every(function(arg) {
        return isFixablePromiseArgument(arg, checker);
      })) {
    return false;
  }
  // ensure all chained calls are valid
  let currentNode = node.expression.expression;
  while (isPromiseHandler(currentNode) || ts.isPropertyAccessExpression(currentNode)) {
    if (ts.isCallExpression(currentNode)) {
      if (!hasSupportedNumberOfArguments(currentNode) || !currentNode.arguments.every(function(arg) {
            return isFixablePromiseArgument(arg, checker);
          })) {
        return false;
      }
      currentNode = currentNode.expression.expression;
    } else {
      currentNode = currentNode.expression;
    }
  }
  return true;
}
ts.isFixablePromiseHandler = isFixablePromiseHandler;
function isPromiseHandler(node) {
  return ts.isCallExpression(node) &&
      (ts.hasPropertyAccessExpressionWithName(node, 'then') || ts.hasPropertyAccessExpressionWithName(node, 'catch') ||
       ts.hasPropertyAccessExpressionWithName(node, 'finally'));
}
function hasSupportedNumberOfArguments(node) {
  const name = node.expression.name.text;
  const maxArguments = name === 'then' ? 2 : name === 'catch' ? 1 : name === 'finally' ? 1 : 0;
  if (node.arguments.length > maxArguments)
    {return false;}
  if (node.arguments.length < maxArguments)
    {return true;}
  return maxArguments === 1 || ts.some(node.arguments, function(arg) {
    return arg.kind === 104 /* SyntaxKind.NullKeyword */ || ts.isIdentifier(arg) && arg.text === 'undefined';
  });
}
// should be kept up to date with getTransformationBody in convertToAsyncFunction.ts
function isFixablePromiseArgument(arg, checker) {
  switch (arg.kind) {
    case 259 /* SyntaxKind.FunctionDeclaration */:
    case 215 /* SyntaxKind.FunctionExpression */:
      var functionFlags = ts.getFunctionFlags(arg);
      if (functionFlags & 1 /* FunctionFlags.Generator */) {
        return false;
      }
    // falls through
    case 216 /* SyntaxKind.ArrowFunction */:
      visitedNestedConvertibleFunctions.set(getKeyFromNode(arg), true);
    // falls through
    case 104 /* SyntaxKind.NullKeyword */:
      return true;
    case 79 /* SyntaxKind.Identifier */:
    case 208 /* SyntaxKind.PropertyAccessExpression */: {
      const symbol = checker.getSymbolAtLocation(arg);
      if (!symbol) {
        return false;
      }
      return checker.isUndefinedSymbol(symbol) || ts.some(ts.skipAlias(symbol, checker).declarations, function(d) {
        return ts.isFunctionLike(d) || ts.hasInitializer(d) && !!d.initializer && ts.isFunctionLike(d.initializer);
      });
    }
    default:
      return false;
  }
}
function getKeyFromNode(exp) {
  return ''.concat(exp.pos.toString(), ':').concat(exp.end.toString());
}
function canBeConvertedToClass(node, checker) {
  let _a, _b, _c, _d;
  if (node.kind === 215 /* SyntaxKind.FunctionExpression */) {
    if (ts.isVariableDeclaration(node.parent) &&
        ((_a = node.symbol.members) === null || _a === void 0 ? void 0 : _a.size)) {
      return true;
    }
    const symbol = checker.getSymbolOfExpando(node, /* allowDeclaration*/ false);
    return !!(
        symbol &&
        (((_b = symbol.exports) === null || _b === void 0 ? void 0 : _b.size) ||
         ((_c = symbol.members) === null || _c === void 0 ? void 0 : _c.size)));
  }
  if (node.kind === 259 /* SyntaxKind.FunctionDeclaration */) {
    return !!((_d = node.symbol.members) === null || _d === void 0 ? void 0 : _d.size);
  }
  return false;
}
function canBeConvertedToAsync(node) {
  switch (node.kind) {
    case 259 /* SyntaxKind.FunctionDeclaration */:
    case 171 /* SyntaxKind.MethodDeclaration */:
    case 215 /* SyntaxKind.FunctionExpression */:
    case 216 /* SyntaxKind.ArrowFunction */:
      return true;
    default:
      return false;
  }
}
ts.canBeConvertedToAsync = canBeConvertedToAsync;
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let SymbolDisplay;
(function(SymbolDisplay) {
const symbolDisplayNodeBuilderFlags = 8192 /* NodeBuilderFlags.OmitParameterModifiers */ |
    70221824 /* NodeBuilderFlags.IgnoreErrors */ | 16384 /* NodeBuilderFlags.UseAliasDefinedOutsideCurrentScope */;
// TODO(drosen): use contextual SemanticMeaning.
function getSymbolKind(typeChecker, symbol, location) {
  const result = getSymbolKindOfConstructorPropertyMethodAccessorFunctionOrVar(typeChecker, symbol, location);
  if (result !== '' /* ScriptElementKind.unknown */) {
    return result;
  }
  const flags = ts.getCombinedLocalAndExportSymbolFlags(symbol);
  if (flags & 32 /* SymbolFlags.Class */) {
    return ts.getDeclarationOfKind(symbol, 228 /* SyntaxKind.ClassExpression */) ?
        'local class' /* ScriptElementKind.localClassElement */ :
        'class' /* ScriptElementKind.classElement */;
  }
  if (flags & 384 /* SymbolFlags.Enum */)
    {return 'enum' /* ScriptElementKind.enumElement */;}
  if (flags & 524288 /* SymbolFlags.TypeAlias */)
    {return 'type' /* ScriptElementKind.typeElement */;}
  if (flags & 64 /* SymbolFlags.Interface */)
    {return 'interface' /* ScriptElementKind.interfaceElement */;}
  if (flags & 262144 /* SymbolFlags.TypeParameter */)
    {return 'type parameter' /* ScriptElementKind.typeParameterElement */;}
  if (flags & 8 /* SymbolFlags.EnumMember */)
    {return 'enum member' /* ScriptElementKind.enumMemberElement */;}
  if (flags & 2097152 /* SymbolFlags.Alias */)
    {return 'alias' /* ScriptElementKind.alias */;}
  if (flags & 1536 /* SymbolFlags.Module */)
    {return 'module' /* ScriptElementKind.moduleElement */;}
  return result;
}
SymbolDisplay.getSymbolKind = getSymbolKind;
function getSymbolKindOfConstructorPropertyMethodAccessorFunctionOrVar(typeChecker, symbol, location) {
  const roots = typeChecker.getRootSymbols(symbol);
  // If this is a method from a mapped type, leave as a method so long as it still has a call signature.
  if (roots.length === 1 &&
      ts.first(roots).flags & 8192 /* SymbolFlags.Method */
      // Ensure the mapped version is still a method, as opposed to `{ [K in keyof I]: number }`.
      &&
      typeChecker.getTypeOfSymbolAtLocation(symbol, location).getNonNullableType().getCallSignatures().length !== 0) {
    return 'method' /* ScriptElementKind.memberFunctionElement */;
  }
  if (typeChecker.isUndefinedSymbol(symbol)) {
    return 'var' /* ScriptElementKind.variableElement */;
  }
  if (typeChecker.isArgumentsSymbol(symbol)) {
    return 'local var' /* ScriptElementKind.localVariableElement */;
  }
  if (location.kind === 108 /* SyntaxKind.ThisKeyword */ && ts.isExpression(location) ||
      ts.isThisInTypeQuery(location)) {
    return 'parameter' /* ScriptElementKind.parameterElement */;
  }
  const flags = ts.getCombinedLocalAndExportSymbolFlags(symbol);
  if (flags & 3 /* SymbolFlags.Variable */) {
    if (ts.isFirstDeclarationOfSymbolParameter(symbol)) {
      return 'parameter' /* ScriptElementKind.parameterElement */;
    } if (symbol.valueDeclaration && ts.isVarConst(symbol.valueDeclaration)) {
      return 'const' /* ScriptElementKind.constElement */;
    } if (ts.forEach(symbol.declarations, ts.isLet)) {
      return 'let' /* ScriptElementKind.letElement */;
    }
    return isLocalVariableOrFunction(symbol) ? 'local var' /* ScriptElementKind.localVariableElement */ :
                                               'var' /* ScriptElementKind.variableElement */;
  }
  if (flags & 16 /* SymbolFlags.Function */)
    {return isLocalVariableOrFunction(symbol) ? 'local function' /* ScriptElementKind.localFunctionElement */ :
                                               'function' /* ScriptElementKind.functionElement */;}
  // FIXME: getter and setter use the same symbol. And it is rare to use only setter without getter, so in most cases the symbol always has getter flag.
  // So, even when the location is just on the declaration of setter, this function returns getter.
  if (flags & 32768 /* SymbolFlags.GetAccessor */)
    {return 'getter' /* ScriptElementKind.memberGetAccessorElement */;}
  if (flags & 65536 /* SymbolFlags.SetAccessor */)
    {return 'setter' /* ScriptElementKind.memberSetAccessorElement */;}
  if (flags & 8192 /* SymbolFlags.Method */)
    {return 'method' /* ScriptElementKind.memberFunctionElement */;}
  if (flags & 16384 /* SymbolFlags.Constructor */)
    {return 'constructor' /* ScriptElementKind.constructorImplementationElement */;}
  if (flags & 131072 /* SymbolFlags.Signature */)
    {return 'index' /* ScriptElementKind.indexSignatureElement */;}
  if (flags & 4 /* SymbolFlags.Property */) {
    if (flags & 33554432 /* SymbolFlags.Transient */ && symbol.checkFlags & 6 /* CheckFlags.Synthetic */) {
      // If union property is result of union of non method (property/accessors/variables), it is labeled as property
      const unionPropertyKind = ts.forEach(typeChecker.getRootSymbols(symbol), function(rootSymbol) {
        const rootSymbolFlags = rootSymbol.getFlags();
        if (rootSymbolFlags & (98308 /* SymbolFlags.PropertyOrAccessor */ | 3 /* SymbolFlags.Variable */)) {
          return 'property' /* ScriptElementKind.memberVariableElement */;
        }
      });
      if (!unionPropertyKind) {
        // If this was union of all methods,
        // make sure it has call signatures before we can label it as method
        const typeOfUnionProperty = typeChecker.getTypeOfSymbolAtLocation(symbol, location);
        if (typeOfUnionProperty.getCallSignatures().length) {
          return 'method' /* ScriptElementKind.memberFunctionElement */;
        }
        return 'property' /* ScriptElementKind.memberVariableElement */;
      }
      return unionPropertyKind;
    }
    return 'property' /* ScriptElementKind.memberVariableElement */;
  }
  return '' /* ScriptElementKind.unknown */;
}
function getNormalizedSymbolModifiers(symbol) {
  if (symbol.declarations && symbol.declarations.length) {
    const _a = symbol.declarations, declaration = _a[0], declarations = _a.slice(1);
    // omit deprecated flag if some declarations are not deprecated
    const excludeFlags = ts.length(declarations) && ts.isDeprecatedDeclaration(declaration) &&
            ts.some(
                declarations,
                function(d) {
                  return !ts.isDeprecatedDeclaration(d);
                }) ?
        8192 /* ModifierFlags.Deprecated */
        :
        0 /* ModifierFlags.None */;
    const modifiers = ts.getNodeModifiers(declaration, excludeFlags);
    if (modifiers) {
      return modifiers.split(',');
    }
  }
  return [];
}
function getSymbolModifiers(typeChecker, symbol) {
  if (!symbol) {
    return '' /* ScriptElementKindModifier.none */;
  }
  const modifiers = new ts.Set(getNormalizedSymbolModifiers(symbol));
  if (symbol.flags & 2097152 /* SymbolFlags.Alias */) {
    const resolvedSymbol = typeChecker.getAliasedSymbol(symbol);
    if (resolvedSymbol !== symbol) {
      ts.forEach(getNormalizedSymbolModifiers(resolvedSymbol), function(modifier) {
        modifiers.add(modifier);
      });
    }
  }
  if (symbol.flags & 16777216 /* SymbolFlags.Optional */) {
    modifiers.add('optional' /* ScriptElementKindModifier.optionalModifier */);
  }
  return modifiers.size > 0 ? ts.arrayFrom(modifiers.values()).join(',') : '' /* ScriptElementKindModifier.none */;
}
SymbolDisplay.getSymbolModifiers = getSymbolModifiers;
// TODO(drosen): Currently completion entry details passes the SemanticMeaning.All instead of using semanticMeaning of location
function getSymbolDisplayPartsDocumentationAndSymbolKind(
    typeChecker, symbol, sourceFile, enclosingDeclaration, location, semanticMeaning, alias) {
  let _a;
  if (semanticMeaning === void 0) {
    semanticMeaning = ts.getMeaningFromLocation(location);
  }
  const displayParts = [];
  let documentation = [];
  let tags = [];
  const symbolFlags = ts.getCombinedLocalAndExportSymbolFlags(symbol);
  let symbolKind = semanticMeaning & 1 /* SemanticMeaning.Value */ ?
      getSymbolKindOfConstructorPropertyMethodAccessorFunctionOrVar(typeChecker, symbol, location) :
      '' /* ScriptElementKind.unknown */;
  let hasAddedSymbolInfo = false;
  const isThisExpression = location.kind === 108 /* SyntaxKind.ThisKeyword */ && ts.isInExpressionContext(location) ||
      ts.isThisInTypeQuery(location);
  let type;
  let printer;
  let documentationFromAlias;
  let tagsFromAlias;
  let hasMultipleSignatures = false;
  if (location.kind === 108 /* SyntaxKind.ThisKeyword */ && !isThisExpression) {
    return {
      displayParts: [ts.keywordPart(108 /* SyntaxKind.ThisKeyword */)],
      documentation: [],
      symbolKind: 'primitive type' /* ScriptElementKind.primitiveType */,
      tags: undefined
    };
  }
  // Class at constructor site need to be shown as constructor apart from property,method, vars
  if (symbolKind !== '' /* ScriptElementKind.unknown */ || symbolFlags & 32 /* SymbolFlags.Class */ ||
      symbolFlags & 2097152 /* SymbolFlags.Alias */) {
    // If symbol is accessor, they are allowed only if location is at declaration identifier of the accessor
    if (symbolKind === 'getter' /* ScriptElementKind.memberGetAccessorElement */ ||
        symbolKind === 'setter' /* ScriptElementKind.memberSetAccessorElement */) {
      var declaration = ts.find(symbol.declarations, function(declaration) {
        return declaration.name === location;
      });
      if (declaration) {
        switch (declaration.kind) {
          case 174 /* SyntaxKind.GetAccessor */:
            symbolKind = 'getter' /* ScriptElementKind.memberGetAccessorElement */;
            break;
          case 175 /* SyntaxKind.SetAccessor */:
            symbolKind = 'setter' /* ScriptElementKind.memberSetAccessorElement */;
            break;
          case 169 /* SyntaxKind.PropertyDeclaration */:
            symbolKind = 'accessor' /* ScriptElementKind.memberAccessorVariableElement */;
            break;
          default:
            ts.Debug.assertNever(declaration);
        }
      } else {
        symbolKind = 'property' /* ScriptElementKind.memberVariableElement */;
      }
    }
    var signature = void 0;
    type = isThisExpression ? typeChecker.getTypeAtLocation(location) :
                              typeChecker.getTypeOfSymbolAtLocation(symbol, location);
    if (location.parent && location.parent.kind === 208 /* SyntaxKind.PropertyAccessExpression */) {
      const right = location.parent.name;
      // Either the location is on the right of a property access, or on the left and the right is missing
      if (right === location || (right && right.getFullWidth() === 0)) {
        location = location.parent;
      }
    }
    // try get the call/construct signature from the type if it matches
    let callExpressionLike = void 0;
    if (ts.isCallOrNewExpression(location)) {
      callExpressionLike = location;
    } else if (ts.isCallExpressionTarget(location) || ts.isNewExpressionTarget(location)) {
      callExpressionLike = location.parent;
    } else if (
        location.parent &&
        (ts.isJsxOpeningLikeElement(location.parent) || ts.isTaggedTemplateExpression(location.parent)) &&
        ts.isFunctionLike(symbol.valueDeclaration)) {
      callExpressionLike = location.parent;
    }
    if (callExpressionLike) {
      signature = typeChecker.getResolvedSignature(callExpressionLike);  // TODO: GH#18217
      const useConstructSignatures = callExpressionLike.kind === 211 /* SyntaxKind.NewExpression */ ||
          (ts.isCallExpression(callExpressionLike) &&
           callExpressionLike.expression.kind === 106 /* SyntaxKind.SuperKeyword */);
      var allSignatures = useConstructSignatures ? type.getConstructSignatures() : type.getCallSignatures();
      if (signature && !ts.contains(allSignatures, signature.target) && !ts.contains(allSignatures, signature)) {
        // Get the first signature if there is one -- allSignatures may contain
        // either the original signature or its target, so check for either
        signature = allSignatures.length ? allSignatures[0] : undefined;
      }
      if (signature) {
        if (useConstructSignatures && (symbolFlags & 32 /* SymbolFlags.Class */)) {
          // Constructor
          symbolKind = 'constructor' /* ScriptElementKind.constructorImplementationElement */;
          addPrefixForAnyFunctionOrVar(type.symbol, symbolKind);
        } else if (symbolFlags & 2097152 /* SymbolFlags.Alias */) {
          symbolKind = 'alias' /* ScriptElementKind.alias */;
          pushSymbolKind(symbolKind);
          displayParts.push(ts.spacePart());
          if (useConstructSignatures) {
            if (signature.flags & 4 /* SignatureFlags.Abstract */) {
              displayParts.push(ts.keywordPart(126 /* SyntaxKind.AbstractKeyword */));
              displayParts.push(ts.spacePart());
            }
            displayParts.push(ts.keywordPart(103 /* SyntaxKind.NewKeyword */));
            displayParts.push(ts.spacePart());
          }
          addFullSymbolName(symbol);
        } else {
          addPrefixForAnyFunctionOrVar(symbol, symbolKind);
        }
        switch (symbolKind) {
          case 'JSX attribute' /* ScriptElementKind.jsxAttribute */:
          case 'property' /* ScriptElementKind.memberVariableElement */:
          case 'var' /* ScriptElementKind.variableElement */:
          case 'const' /* ScriptElementKind.constElement */:
          case 'let' /* ScriptElementKind.letElement */:
          case 'parameter' /* ScriptElementKind.parameterElement */:
          case 'local var' /* ScriptElementKind.localVariableElement */:
            // If it is call or construct signature of lambda's write type name
            displayParts.push(ts.punctuationPart(58 /* SyntaxKind.ColonToken */));
            displayParts.push(ts.spacePart());
            if (!(ts.getObjectFlags(type) & 16 /* ObjectFlags.Anonymous */) && type.symbol) {
              ts.addRange(
                  displayParts,
                  ts.symbolToDisplayParts(
                      typeChecker, type.symbol, enclosingDeclaration, /* meaning*/ undefined,
                      4 /* SymbolFormatFlags.AllowAnyNodeKind */ |
                          1 /* SymbolFormatFlags.WriteTypeParametersOrArguments */));
              displayParts.push(ts.lineBreakPart());
            }
            if (useConstructSignatures) {
              if (signature.flags & 4 /* SignatureFlags.Abstract */) {
                displayParts.push(ts.keywordPart(126 /* SyntaxKind.AbstractKeyword */));
                displayParts.push(ts.spacePart());
              }
              displayParts.push(ts.keywordPart(103 /* SyntaxKind.NewKeyword */));
              displayParts.push(ts.spacePart());
            }
            addSignatureDisplayParts(signature, allSignatures, 262144 /* TypeFormatFlags.WriteArrowStyleSignature */);
            break;
          default:
            // Just signature
            addSignatureDisplayParts(signature, allSignatures);
        }
        hasAddedSymbolInfo = true;
        hasMultipleSignatures = allSignatures.length > 1;
      }
    } else if (
        (ts.isNameOfFunctionDeclaration(location) &&
         !(symbolFlags & 98304 /* SymbolFlags.Accessor */)) ||  // name of function declaration
        (location.kind === 135 /* SyntaxKind.ConstructorKeyword */ &&
         location.parent.kind ===
             173 /* SyntaxKind.Constructor */)) {  // At constructor keyword of constructor declaration
      // get the signature from the declaration and write it
      const functionDeclaration_1 = location.parent;
      // Use function declaration to write the signatures only if the symbol corresponding to this declaration
      const locationIsSymbolDeclaration = symbol.declarations && ts.find(symbol.declarations, function(declaration) {
        return declaration ===
            (location.kind === 135 /* SyntaxKind.ConstructorKeyword */ ? functionDeclaration_1.parent :
                                                                         functionDeclaration_1);
      });
      if (locationIsSymbolDeclaration) {
        var allSignatures = functionDeclaration_1.kind === 173 /* SyntaxKind.Constructor */ ?
            type.getNonNullableType().getConstructSignatures() :
            type.getNonNullableType().getCallSignatures();
        if (!typeChecker.isImplementationOfOverload(functionDeclaration_1)) {
          signature = typeChecker.getSignatureFromDeclaration(functionDeclaration_1);  // TODO: GH#18217
        } else {
          signature = allSignatures[0];
        }
        if (functionDeclaration_1.kind === 173 /* SyntaxKind.Constructor */) {
          // show (constructor) Type(...) signature
          symbolKind = 'constructor' /* ScriptElementKind.constructorImplementationElement */;
          addPrefixForAnyFunctionOrVar(type.symbol, symbolKind);
        } else {
          // (function/method) symbol(..signature)
          addPrefixForAnyFunctionOrVar(
              functionDeclaration_1.kind === 176 /* SyntaxKind.CallSignature */ &&
                      !(type.symbol.flags & 2048 /* SymbolFlags.TypeLiteral */ ||
                        type.symbol.flags & 4096 /* SymbolFlags.ObjectLiteral */) ?
                  type.symbol :
                  symbol,
              symbolKind);
        }
        if (signature) {
          addSignatureDisplayParts(signature, allSignatures);
        }
        hasAddedSymbolInfo = true;
        hasMultipleSignatures = allSignatures.length > 1;
      }
    }
  }
  if (symbolFlags & 32 /* SymbolFlags.Class */ && !hasAddedSymbolInfo && !isThisExpression) {
    addAliasPrefixIfNecessary();
    if (ts.getDeclarationOfKind(symbol, 228 /* SyntaxKind.ClassExpression */)) {
      // Special case for class expressions because we would like to indicate that
      // the class name is local to the class body (similar to function expression)
      //      (local class) class <className>
      pushSymbolKind('local class' /* ScriptElementKind.localClassElement */);
    } else {
      // Class declaration has name which is not local.
      displayParts.push(ts.keywordPart(84 /* SyntaxKind.ClassKeyword */));
    }
    displayParts.push(ts.spacePart());
    addFullSymbolName(symbol);
    writeTypeParametersOfSymbol(symbol, sourceFile);
  }
  if ((symbolFlags & 64 /* SymbolFlags.Interface */) && (semanticMeaning & 2 /* SemanticMeaning.Type */)) {
    prefixNextMeaning();
    displayParts.push(ts.keywordPart(118 /* SyntaxKind.InterfaceKeyword */));
    displayParts.push(ts.spacePart());
    addFullSymbolName(symbol);
    writeTypeParametersOfSymbol(symbol, sourceFile);
  }
  if ((symbolFlags & 524288 /* SymbolFlags.TypeAlias */) && (semanticMeaning & 2 /* SemanticMeaning.Type */)) {
    prefixNextMeaning();
    displayParts.push(ts.keywordPart(154 /* SyntaxKind.TypeKeyword */));
    displayParts.push(ts.spacePart());
    addFullSymbolName(symbol);
    writeTypeParametersOfSymbol(symbol, sourceFile);
    displayParts.push(ts.spacePart());
    displayParts.push(ts.operatorPart(63 /* SyntaxKind.EqualsToken */));
    displayParts.push(ts.spacePart());
    ts.addRange(
        displayParts,
        ts.typeToDisplayParts(
            typeChecker,
            ts.isConstTypeReference(location.parent) ? typeChecker.getTypeAtLocation(location.parent) :
                                                       typeChecker.getDeclaredTypeOfSymbol(symbol),
            enclosingDeclaration, 8388608 /* TypeFormatFlags.InTypeAlias */));
  }
  if (symbolFlags & 384 /* SymbolFlags.Enum */) {
    prefixNextMeaning();
    if (ts.some(symbol.declarations, function(d) {
          return ts.isEnumDeclaration(d) && ts.isEnumConst(d);
        })) {
      displayParts.push(ts.keywordPart(85 /* SyntaxKind.ConstKeyword */));
      displayParts.push(ts.spacePart());
    }
    displayParts.push(ts.keywordPart(92 /* SyntaxKind.EnumKeyword */));
    displayParts.push(ts.spacePart());
    addFullSymbolName(symbol);
  }
  if (symbolFlags & 1536 /* SymbolFlags.Module */ && !isThisExpression) {
    prefixNextMeaning();
    var declaration = ts.getDeclarationOfKind(symbol, 264 /* SyntaxKind.ModuleDeclaration */);
    const isNamespace = declaration && declaration.name && declaration.name.kind === 79 /* SyntaxKind.Identifier */;
    displayParts.push(
        ts.keywordPart(isNamespace ? 143 /* SyntaxKind.NamespaceKeyword */ : 142 /* SyntaxKind.ModuleKeyword */));
    displayParts.push(ts.spacePart());
    addFullSymbolName(symbol);
  }
  if ((symbolFlags & 262144 /* SymbolFlags.TypeParameter */) && (semanticMeaning & 2 /* SemanticMeaning.Type */)) {
    prefixNextMeaning();
    displayParts.push(ts.punctuationPart(20 /* SyntaxKind.OpenParenToken */));
    displayParts.push(ts.textPart('type parameter'));
    displayParts.push(ts.punctuationPart(21 /* SyntaxKind.CloseParenToken */));
    displayParts.push(ts.spacePart());
    addFullSymbolName(symbol);
    if (symbol.parent) {
      // Class/Interface type parameter
      addInPrefix();
      addFullSymbolName(symbol.parent, enclosingDeclaration);
      writeTypeParametersOfSymbol(symbol.parent, enclosingDeclaration);
    } else {
      // Method/function type parameter
      const decl = ts.getDeclarationOfKind(symbol, 165 /* SyntaxKind.TypeParameter */);
      if (decl === undefined)
        {return ts.Debug.fail();}
      var declaration = decl.parent;
      if (declaration) {
        if (ts.isFunctionLikeKind(declaration.kind)) {
          addInPrefix();
          var signature = typeChecker.getSignatureFromDeclaration(declaration);  // TODO: GH#18217
          if (declaration.kind === 177 /* SyntaxKind.ConstructSignature */) {
            displayParts.push(ts.keywordPart(103 /* SyntaxKind.NewKeyword */));
            displayParts.push(ts.spacePart());
          } else if (declaration.kind !== 176 /* SyntaxKind.CallSignature */ && declaration.name) {
            addFullSymbolName(declaration.symbol);
          }
          ts.addRange(
              displayParts,
              ts.signatureToDisplayParts(
                  typeChecker, signature, sourceFile, 32 /* TypeFormatFlags.WriteTypeArgumentsOfSignature */));
        } else if (declaration.kind === 262 /* SyntaxKind.TypeAliasDeclaration */) {
          // Type alias type parameter
          // For example
          //      type list<T> = T[]; // Both T will go through same code path
          addInPrefix();
          displayParts.push(ts.keywordPart(154 /* SyntaxKind.TypeKeyword */));
          displayParts.push(ts.spacePart());
          addFullSymbolName(declaration.symbol);
          writeTypeParametersOfSymbol(declaration.symbol, sourceFile);
        }
      }
    }
  }
  if (symbolFlags & 8 /* SymbolFlags.EnumMember */) {
    symbolKind = 'enum member' /* ScriptElementKind.enumMemberElement */;
    addPrefixForAnyFunctionOrVar(symbol, 'enum member');
    var declaration = (_a = symbol.declarations) === null || _a === void 0 ? void 0 : _a[0];
    if ((declaration === null || declaration === void 0 ? void 0 : declaration.kind) ===
        302 /* SyntaxKind.EnumMember */) {
      const constantValue = typeChecker.getConstantValue(declaration);
      if (constantValue !== undefined) {
        displayParts.push(ts.spacePart());
        displayParts.push(ts.operatorPart(63 /* SyntaxKind.EqualsToken */));
        displayParts.push(ts.spacePart());
        displayParts.push(ts.displayPart(
            ts.getTextOfConstantValue(constantValue),
            typeof constantValue === 'number' ? ts.SymbolDisplayPartKind.numericLiteral :
                                                ts.SymbolDisplayPartKind.stringLiteral));
      }
    }
  }
  // don't use symbolFlags since getAliasedSymbol requires the flag on the symbol itself
  if (symbol.flags & 2097152 /* SymbolFlags.Alias */) {
    prefixNextMeaning();
    if (!hasAddedSymbolInfo) {
      const resolvedSymbol = typeChecker.getAliasedSymbol(symbol);
      if (resolvedSymbol !== symbol && resolvedSymbol.declarations && resolvedSymbol.declarations.length > 0) {
        const resolvedNode = resolvedSymbol.declarations[0];
        const declarationName = ts.getNameOfDeclaration(resolvedNode);
        if (declarationName) {
          const isExternalModuleDeclaration = ts.isModuleWithStringLiteralName(resolvedNode) &&
              ts.hasSyntacticModifier(resolvedNode, 2 /* ModifierFlags.Ambient */);
          const shouldUseAliasName = symbol.name !== 'default' && !isExternalModuleDeclaration;
          const resolvedInfo = getSymbolDisplayPartsDocumentationAndSymbolKind(
              typeChecker, resolvedSymbol, ts.getSourceFileOfNode(resolvedNode), resolvedNode, declarationName,
              semanticMeaning, shouldUseAliasName ? symbol : resolvedSymbol);
          displayParts.push.apply(displayParts, resolvedInfo.displayParts);
          displayParts.push(ts.lineBreakPart());
          documentationFromAlias = resolvedInfo.documentation;
          tagsFromAlias = resolvedInfo.tags;
        } else {
          documentationFromAlias = resolvedSymbol.getContextualDocumentationComment(resolvedNode, typeChecker);
          tagsFromAlias = resolvedSymbol.getJsDocTags(typeChecker);
        }
      }
    }
    if (symbol.declarations) {
      switch (symbol.declarations[0].kind) {
        case 267 /* SyntaxKind.NamespaceExportDeclaration */:
          displayParts.push(ts.keywordPart(93 /* SyntaxKind.ExportKeyword */));
          displayParts.push(ts.spacePart());
          displayParts.push(ts.keywordPart(143 /* SyntaxKind.NamespaceKeyword */));
          break;
        case 274 /* SyntaxKind.ExportAssignment */:
          displayParts.push(ts.keywordPart(93 /* SyntaxKind.ExportKeyword */));
          displayParts.push(ts.spacePart());
          displayParts.push(ts.keywordPart(
              symbol.declarations[0].isExportEquals ? 63 /* SyntaxKind.EqualsToken */ :
                                                      88 /* SyntaxKind.DefaultKeyword */));
          break;
        case 278 /* SyntaxKind.ExportSpecifier */:
          displayParts.push(ts.keywordPart(93 /* SyntaxKind.ExportKeyword */));
          break;
        default:
          displayParts.push(ts.keywordPart(100 /* SyntaxKind.ImportKeyword */));
      }
    }
    displayParts.push(ts.spacePart());
    addFullSymbolName(symbol);
    ts.forEach(symbol.declarations, function(declaration) {
      if (declaration.kind === 268 /* SyntaxKind.ImportEqualsDeclaration */) {
        const importEqualsDeclaration = declaration;
        if (ts.isExternalModuleImportEqualsDeclaration(importEqualsDeclaration)) {
          displayParts.push(ts.spacePart());
          displayParts.push(ts.operatorPart(63 /* SyntaxKind.EqualsToken */));
          displayParts.push(ts.spacePart());
          displayParts.push(ts.keywordPart(147 /* SyntaxKind.RequireKeyword */));
          displayParts.push(ts.punctuationPart(20 /* SyntaxKind.OpenParenToken */));
          displayParts.push(ts.displayPart(
              ts.getTextOfNode(ts.getExternalModuleImportEqualsDeclarationExpression(importEqualsDeclaration)),
              ts.SymbolDisplayPartKind.stringLiteral));
          displayParts.push(ts.punctuationPart(21 /* SyntaxKind.CloseParenToken */));
        } else {
          const internalAliasSymbol = typeChecker.getSymbolAtLocation(importEqualsDeclaration.moduleReference);
          if (internalAliasSymbol) {
            displayParts.push(ts.spacePart());
            displayParts.push(ts.operatorPart(63 /* SyntaxKind.EqualsToken */));
            displayParts.push(ts.spacePart());
            addFullSymbolName(internalAliasSymbol, enclosingDeclaration);
          }
        }
        return true;
      }
    });
  }
  if (!hasAddedSymbolInfo) {
    if (symbolKind !== '' /* ScriptElementKind.unknown */) {
      if (type) {
        if (isThisExpression) {
          prefixNextMeaning();
          displayParts.push(ts.keywordPart(108 /* SyntaxKind.ThisKeyword */));
        } else {
          addPrefixForAnyFunctionOrVar(symbol, symbolKind);
        }
        // For properties, variables and local vars: show the type
        if (symbolKind === 'property' /* ScriptElementKind.memberVariableElement */ ||
            symbolKind === 'accessor' /* ScriptElementKind.memberAccessorVariableElement */ ||
            symbolKind === 'getter' /* ScriptElementKind.memberGetAccessorElement */ ||
            symbolKind === 'setter' /* ScriptElementKind.memberSetAccessorElement */ ||
            symbolKind === 'JSX attribute' /* ScriptElementKind.jsxAttribute */ ||
            symbolFlags & 3 /* SymbolFlags.Variable */ ||
            symbolKind === 'local var' /* ScriptElementKind.localVariableElement */ ||
            symbolKind === 'index' /* ScriptElementKind.indexSignatureElement */ || isThisExpression) {
          displayParts.push(ts.punctuationPart(58 /* SyntaxKind.ColonToken */));
          displayParts.push(ts.spacePart());
          // If the type is type parameter, format it specially
          if (type.symbol && type.symbol.flags & 262144 /* SymbolFlags.TypeParameter */ &&
              symbolKind !== 'index' /* ScriptElementKind.indexSignatureElement */) {
            const typeParameterParts = ts.mapToDisplayParts(function(writer) {
              const param =
                  typeChecker.typeParameterToDeclaration(type, enclosingDeclaration, symbolDisplayNodeBuilderFlags);
              getPrinter().writeNode(
                  4 /* EmitHint.Unspecified */, param,
                  ts.getSourceFileOfNode(ts.getParseTreeNode(enclosingDeclaration)), writer);
            });
            ts.addRange(displayParts, typeParameterParts);
          } else {
            ts.addRange(displayParts, ts.typeToDisplayParts(typeChecker, type, enclosingDeclaration));
          }
          if (symbol.target && symbol.target.tupleLabelDeclaration) {
            const labelDecl = symbol.target.tupleLabelDeclaration;
            ts.Debug.assertNode(labelDecl.name, ts.isIdentifier);
            displayParts.push(ts.spacePart());
            displayParts.push(ts.punctuationPart(20 /* SyntaxKind.OpenParenToken */));
            displayParts.push(ts.textPart(ts.idText(labelDecl.name)));
            displayParts.push(ts.punctuationPart(21 /* SyntaxKind.CloseParenToken */));
          }
        } else if (
            symbolFlags & 16 /* SymbolFlags.Function */ || symbolFlags & 8192 /* SymbolFlags.Method */ ||
            symbolFlags & 16384 /* SymbolFlags.Constructor */ || symbolFlags & 131072 /* SymbolFlags.Signature */ ||
            symbolFlags & 98304 /* SymbolFlags.Accessor */ ||
            symbolKind === 'method' /* ScriptElementKind.memberFunctionElement */) {
          var allSignatures = type.getNonNullableType().getCallSignatures();
          if (allSignatures.length) {
            addSignatureDisplayParts(allSignatures[0], allSignatures);
            hasMultipleSignatures = allSignatures.length > 1;
          }
        }
      }
    } else {
      symbolKind = getSymbolKind(typeChecker, symbol, location);
    }
  }
  if (documentation.length === 0 && !hasMultipleSignatures) {
    documentation = symbol.getContextualDocumentationComment(enclosingDeclaration, typeChecker);
  }
  if (documentation.length === 0 && symbolFlags & 4 /* SymbolFlags.Property */) {
    // For some special property access expressions like `exports.foo = foo` or `module.exports.foo = foo`
    // there documentation comments might be attached to the right hand side symbol of their declarations.
    // The pattern of such special property access is that the parent symbol is the symbol of the file.
    if (symbol.parent && symbol.declarations && ts.forEach(symbol.parent.declarations, function(declaration) {
          return declaration.kind === 308 /* SyntaxKind.SourceFile */;
        })) {
      for (let _i = 0, _b = symbol.declarations; _i < _b.length; _i++) {
        var declaration = _b[_i];
        if (!declaration.parent || declaration.parent.kind !== 223 /* SyntaxKind.BinaryExpression */) {
          continue;
        }
        const rhsSymbol = typeChecker.getSymbolAtLocation(declaration.parent.right);
        if (!rhsSymbol) {
          continue;
        }
        documentation = rhsSymbol.getDocumentationComment(typeChecker);
        tags = rhsSymbol.getJsDocTags(typeChecker);
        if (documentation.length > 0) {
          break;
        }
      }
    }
  }
  if (documentation.length === 0 && ts.isIdentifier(location) && symbol.valueDeclaration &&
      ts.isBindingElement(symbol.valueDeclaration)) {
    var declaration = symbol.valueDeclaration;
    const parent = declaration.parent;
    if (ts.isIdentifier(declaration.name) && ts.isObjectBindingPattern(parent)) {
      const name_4 = ts.getTextOfIdentifierOrLiteral(declaration.name);
      const objectType = typeChecker.getTypeAtLocation(parent);
      documentation = ts.firstDefined(objectType.isUnion() ? objectType.types : [objectType], function(t) {
        const prop = t.getProperty(name_4);
        return prop ? prop.getDocumentationComment(typeChecker) : undefined;
      }) || ts.emptyArray;
    }
  }
  if (tags.length === 0 && !hasMultipleSignatures) {
    tags = symbol.getContextualJsDocTags(enclosingDeclaration, typeChecker);
  }
  if (documentation.length === 0 && documentationFromAlias) {
    documentation = documentationFromAlias;
  }
  if (tags.length === 0 && tagsFromAlias) {
    tags = tagsFromAlias;
  }
  return {
    displayParts,
    documentation,
    symbolKind,
    tags: tags.length === 0 ? undefined : tags
  };
  function getPrinter() {
    if (!printer) {
      printer = ts.createPrinter({removeComments: true});
    }
    return printer;
  }
  function prefixNextMeaning() {
    if (displayParts.length) {
      displayParts.push(ts.lineBreakPart());
    }
    addAliasPrefixIfNecessary();
  }
  function addAliasPrefixIfNecessary() {
    if (alias) {
      pushSymbolKind('alias' /* ScriptElementKind.alias */);
      displayParts.push(ts.spacePart());
    }
  }
  function addInPrefix() {
    displayParts.push(ts.spacePart());
    displayParts.push(ts.keywordPart(101 /* SyntaxKind.InKeyword */));
    displayParts.push(ts.spacePart());
  }
  function addFullSymbolName(symbolToDisplay, enclosingDeclaration) {
    let indexInfos;
    if (alias && symbolToDisplay === symbol) {
      symbolToDisplay = alias;
    }
    if (symbolKind === 'index' /* ScriptElementKind.indexSignatureElement */) {
      indexInfos = typeChecker.getIndexInfosOfIndexSymbol(symbolToDisplay);
    }
    let fullSymbolDisplayParts = [];
    if (symbolToDisplay.flags & 131072 /* SymbolFlags.Signature */ && indexInfos) {
      if (symbolToDisplay.parent) {
        fullSymbolDisplayParts = ts.symbolToDisplayParts(typeChecker, symbolToDisplay.parent);
      }
      fullSymbolDisplayParts.push(ts.punctuationPart(22 /* SyntaxKind.OpenBracketToken */));
      // Needed to handle more than one type of index
      indexInfos.forEach(function(info, i) {
        // Needed to handle template literals
        fullSymbolDisplayParts.push.apply(fullSymbolDisplayParts, ts.typeToDisplayParts(typeChecker, info.keyType));
        if (i !== indexInfos.length - 1) {
          fullSymbolDisplayParts.push(ts.spacePart());
          fullSymbolDisplayParts.push(ts.punctuationPart(51 /* SyntaxKind.BarToken */));
          fullSymbolDisplayParts.push(ts.spacePart());
        }
      });
      fullSymbolDisplayParts.push(ts.punctuationPart(23 /* SyntaxKind.CloseBracketToken */));
    } else {
      fullSymbolDisplayParts = ts.symbolToDisplayParts(
          typeChecker, symbolToDisplay, enclosingDeclaration || sourceFile, /* meaning*/ undefined,
          1 /* SymbolFormatFlags.WriteTypeParametersOrArguments */ | 2 /* SymbolFormatFlags.UseOnlyExternalAliasing */ |
              4 /* SymbolFormatFlags.AllowAnyNodeKind */);
    }
    ts.addRange(displayParts, fullSymbolDisplayParts);
    if (symbol.flags & 16777216 /* SymbolFlags.Optional */) {
      displayParts.push(ts.punctuationPart(57 /* SyntaxKind.QuestionToken */));
    }
  }
  function addPrefixForAnyFunctionOrVar(symbol, symbolKind) {
    prefixNextMeaning();
    if (symbolKind) {
      pushSymbolKind(symbolKind);
      if (symbol && !ts.some(symbol.declarations, function(d) {
            return ts.isArrowFunction(d) || (ts.isFunctionExpression(d) || ts.isClassExpression(d)) && !d.name;
          })) {
        displayParts.push(ts.spacePart());
        addFullSymbolName(symbol);
      }
    }
  }
  function pushSymbolKind(symbolKind) {
    switch (symbolKind) {
      case 'var' /* ScriptElementKind.variableElement */:
      case 'function' /* ScriptElementKind.functionElement */:
      case 'let' /* ScriptElementKind.letElement */:
      case 'const' /* ScriptElementKind.constElement */:
      case 'constructor' /* ScriptElementKind.constructorImplementationElement */:
        displayParts.push(ts.textOrKeywordPart(symbolKind));
        return;
      default:
        displayParts.push(ts.punctuationPart(20 /* SyntaxKind.OpenParenToken */));
        displayParts.push(ts.textOrKeywordPart(symbolKind));
        displayParts.push(ts.punctuationPart(21 /* SyntaxKind.CloseParenToken */));
        return;
    }
  }
  function addSignatureDisplayParts(signature, allSignatures, flags) {
    if (flags === void 0) {
      flags = 0 /* TypeFormatFlags.None */;
    }
    ts.addRange(
        displayParts,
        ts.signatureToDisplayParts(
            typeChecker, signature, enclosingDeclaration,
            flags | 32 /* TypeFormatFlags.WriteTypeArgumentsOfSignature */));
    if (allSignatures.length > 1) {
      displayParts.push(ts.spacePart());
      displayParts.push(ts.punctuationPart(20 /* SyntaxKind.OpenParenToken */));
      displayParts.push(ts.operatorPart(39 /* SyntaxKind.PlusToken */));
      displayParts.push(ts.displayPart((allSignatures.length - 1).toString(), ts.SymbolDisplayPartKind.numericLiteral));
      displayParts.push(ts.spacePart());
      displayParts.push(ts.textPart(allSignatures.length === 2 ? 'overload' : 'overloads'));
      displayParts.push(ts.punctuationPart(21 /* SyntaxKind.CloseParenToken */));
    }
    documentation = signature.getDocumentationComment(typeChecker);
    tags = signature.getJsDocTags();
    if (allSignatures.length > 1 && documentation.length === 0 && tags.length === 0) {
      documentation = allSignatures[0].getDocumentationComment(typeChecker);
      tags = allSignatures[0].getJsDocTags().filter(function(tag) {
        return tag.name !== 'deprecated';
      });  // should only include @deprecated JSDoc tag on the first overload (#49368)
    }
  }
  function writeTypeParametersOfSymbol(symbol, enclosingDeclaration) {
    const typeParameterParts = ts.mapToDisplayParts(function(writer) {
      const params =
          typeChecker.symbolToTypeParameterDeclarations(symbol, enclosingDeclaration, symbolDisplayNodeBuilderFlags);
      getPrinter().writeList(
          53776 /* ListFormat.TypeParameters */, params,
          ts.getSourceFileOfNode(ts.getParseTreeNode(enclosingDeclaration)), writer);
    });
    ts.addRange(displayParts, typeParameterParts);
  }
}
SymbolDisplay.getSymbolDisplayPartsDocumentationAndSymbolKind = getSymbolDisplayPartsDocumentationAndSymbolKind;
function isLocalVariableOrFunction(symbol) {
  if (symbol.parent) {
    return false;  // This is exported symbol
  }
  return ts.forEach(symbol.declarations, function(declaration) {
    // Function expressions are local
    if (declaration.kind === 215 /* SyntaxKind.FunctionExpression */) {
      return true;
    }
    if (declaration.kind !== 257 /* SyntaxKind.VariableDeclaration */ &&
        declaration.kind !== 259 /* SyntaxKind.FunctionDeclaration */) {
      return false;
    }
    // If the parent is not sourceFile or module block it is local variable
    for (let parent = declaration.parent; !ts.isFunctionBlock(parent); parent = parent.parent) {
      // Reached source file or module block
      if (parent.kind === 308 /* SyntaxKind.SourceFile */ || parent.kind === 265 /* SyntaxKind.ModuleBlock */) {
        return false;
      }
    }
    // parent is in function block
    return true;
  });
}
})(SymbolDisplay = ts.SymbolDisplay || (ts.SymbolDisplay = {}));
})(ts || (ts = {}));
var ts;
(function(ts) {
/*
     * This function will compile source text from 'input' argument using specified compiler options.
     * If not options are provided - it will use a set of default compiler options.
     * Extra compiler options that will unconditionally be used by this function are:
     * - isolatedModules = true
     * - allowNonTsExtensions = true
     * - noLib = true
     * - noResolve = true
     */
function transpileModule(input, transpileOptions) {
  const diagnostics = [];
  const options =
      transpileOptions.compilerOptions ? fixupCompilerOptions(transpileOptions.compilerOptions, diagnostics) : {};
  // mix in default options
  const defaultOptions = ts.getDefaultCompilerOptions();
  for (const key in defaultOptions) {
    if (ts.hasProperty(defaultOptions, key) && options[key] === undefined) {
      options[key] = defaultOptions[key];
    }
  }
  for (let _i = 0, transpileOptionValueCompilerOptions_1 = ts.transpileOptionValueCompilerOptions;
       _i < transpileOptionValueCompilerOptions_1.length; _i++) {
    const option = transpileOptionValueCompilerOptions_1[_i];
    options[option.name] = option.transpileOptionValue;
  }
  // transpileModule does not write anything to disk so there is no need to verify that there are no conflicts between input and output paths.
  options.suppressOutputPathCheck = true;
  // Filename can be non-ts file.
  options.allowNonTsExtensions = true;
  const newLine = ts.getNewLineCharacter(options);
  // Create a compilerHost object to allow the compiler to read and write files
  const compilerHost = {
    getSourceFile: function(fileName) {
      return fileName === ts.normalizePath(inputFileName) ? sourceFile : undefined;
    },
    writeFile: function(name, text) {
      if (ts.fileExtensionIs(name, '.map')) {
        ts.Debug.assertEqual(sourceMapText, undefined, 'Unexpected multiple source map outputs, file:', name);
        sourceMapText = text;
      } else {
        ts.Debug.assertEqual(outputText, undefined, 'Unexpected multiple outputs, file:', name);
        outputText = text;
      }
    },
    getDefaultLibFileName: function() {
      return 'lib.d.ts';
    },
    useCaseSensitiveFileNames: function() {
      return false;
    },
    getCanonicalFileName: function(fileName) {
      return fileName;
    },
    getCurrentDirectory: function() {
      return '';
    },
    getNewLine: function() {
      return newLine;
    },
    fileExists: function(fileName) {
      return fileName === inputFileName;
    },
    readFile: function() {
      return '';
    },
    directoryExists: function() {
      return true;
    },
    getDirectories: function() {
      return [];
    }
  };
  // if jsx is specified then treat file as .tsx
  var inputFileName = transpileOptions.fileName ||
      (transpileOptions.compilerOptions && transpileOptions.compilerOptions.jsx ? 'module.tsx' : 'module.ts');
  var sourceFile = ts.createSourceFile(inputFileName, input, {
    languageVersion: ts.getEmitScriptTarget(options),
    impliedNodeFormat: ts.getImpliedNodeFormatForFile(
        ts.toPath(inputFileName, '', compilerHost.getCanonicalFileName), /* cache*/ undefined, compilerHost, options),
    setExternalModuleIndicator: ts.getSetExternalModuleIndicator(options)
  });
  if (transpileOptions.moduleName) {
    sourceFile.moduleName = transpileOptions.moduleName;
  }
  if (transpileOptions.renamedDependencies) {
    sourceFile.renamedDependencies = new ts.Map(ts.getEntries(transpileOptions.renamedDependencies));
  }
  // Output
  let outputText;
  let sourceMapText;
  const program = ts.createProgram([inputFileName], options, compilerHost);
  if (transpileOptions.reportDiagnostics) {
    ts.addRange(/* to*/ diagnostics, /* from*/ program.getSyntacticDiagnostics(sourceFile));
    ts.addRange(/* to*/ diagnostics, /* from*/ program.getOptionsDiagnostics());
  }
  // Emit
  program.emit(/* targetSourceFile*/ undefined, /* writeFile*/ undefined, /* cancellationToken*/ undefined,
               /* emitOnlyDtsFiles*/ undefined, transpileOptions.transformers);
  if (outputText === undefined)
    {return ts.Debug.fail('Output generation failed');}
  return {outputText, diagnostics, sourceMapText};
}
ts.transpileModule = transpileModule;
/*
     * This is a shortcut function for transpileModule - it accepts transpileOptions as parameters and returns only outputText part of the result.
     */
function transpile(input, compilerOptions, fileName, diagnostics, moduleName) {
  const output = transpileModule(
      input,
      {compilerOptions, fileName, reportDiagnostics: !!diagnostics, moduleName});
  // addRange correctly handles cases when wither 'from' or 'to' argument is missing
  ts.addRange(diagnostics, output.diagnostics);
  return output.outputText;
}
ts.transpile = transpile;
let commandLineOptionsStringToEnum;
/** JS users may pass in string values for enum compiler options (such as ModuleKind), so convert. */
/* @internal*/
function fixupCompilerOptions(options, diagnostics) {
  // Lazily create this value to fix module loading errors.
  commandLineOptionsStringToEnum = commandLineOptionsStringToEnum || ts.filter(ts.optionDeclarations, function(o) {
    return typeof o.type === 'object' && !ts.forEachEntry(o.type, function(v) {
      return typeof v !== 'number';
    });
  });
  options = ts.cloneCompilerOptions(options);
  const _loop_8 = function(opt) {
    if (!ts.hasProperty(options, opt.name)) {
      return 'continue';
    }
    const value = options[opt.name];
    // Value should be a key of opt.type
    if (ts.isString(value)) {
      // If value is not a string, this will fail
      options[opt.name] = ts.parseCustomTypeOption(opt, value, diagnostics);
    } else {
      if (!ts.forEachEntry(opt.type, function(v) {
            return v === value;
          })) {
        // Supplied value isn't a valid enum value.
        diagnostics.push(ts.createCompilerDiagnosticForInvalidCustomType(opt));
      }
    }
  };
  for (let _i = 0, commandLineOptionsStringToEnum_1 = commandLineOptionsStringToEnum;
       _i < commandLineOptionsStringToEnum_1.length; _i++) {
    const opt = commandLineOptionsStringToEnum_1[_i];
    _loop_8(opt);
  }
  return options;
}
ts.fixupCompilerOptions = fixupCompilerOptions;
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let formatting;
(function(formatting) {
let FormattingRequestKind;
(function(FormattingRequestKind) {
FormattingRequestKind[FormattingRequestKind['FormatDocument'] = 0] = 'FormatDocument';
FormattingRequestKind[FormattingRequestKind['FormatSelection'] = 1] = 'FormatSelection';
FormattingRequestKind[FormattingRequestKind['FormatOnEnter'] = 2] = 'FormatOnEnter';
FormattingRequestKind[FormattingRequestKind['FormatOnSemicolon'] = 3] = 'FormatOnSemicolon';
FormattingRequestKind[FormattingRequestKind['FormatOnOpeningCurlyBrace'] = 4] = 'FormatOnOpeningCurlyBrace';
FormattingRequestKind[FormattingRequestKind['FormatOnClosingCurlyBrace'] = 5] = 'FormatOnClosingCurlyBrace';
})(FormattingRequestKind = formatting.FormattingRequestKind || (formatting.FormattingRequestKind = {}));
const FormattingContext = /** @class */ (function() {
  function FormattingContext(sourceFile, formattingRequestKind, options) {
    this.sourceFile = sourceFile;
    this.formattingRequestKind = formattingRequestKind;
    this.options = options;
  }
  FormattingContext.prototype.updateContext = function(
      currentRange, currentTokenParent, nextRange, nextTokenParent, commonParent) {
    this.currentTokenSpan = ts.Debug.checkDefined(currentRange);
    this.currentTokenParent = ts.Debug.checkDefined(currentTokenParent);
    this.nextTokenSpan = ts.Debug.checkDefined(nextRange);
    this.nextTokenParent = ts.Debug.checkDefined(nextTokenParent);
    this.contextNode = ts.Debug.checkDefined(commonParent);
    // drop cached results
    this.contextNodeAllOnSameLine = undefined;
    this.nextNodeAllOnSameLine = undefined;
    this.tokensAreOnSameLine = undefined;
    this.contextNodeBlockIsOnOneLine = undefined;
    this.nextNodeBlockIsOnOneLine = undefined;
  };
  FormattingContext.prototype.ContextNodeAllOnSameLine = function() {
    if (this.contextNodeAllOnSameLine === undefined) {
      this.contextNodeAllOnSameLine = this.NodeIsOnOneLine(this.contextNode);
    }
    return this.contextNodeAllOnSameLine;
  };
  FormattingContext.prototype.NextNodeAllOnSameLine = function() {
    if (this.nextNodeAllOnSameLine === undefined) {
      this.nextNodeAllOnSameLine = this.NodeIsOnOneLine(this.nextTokenParent);
    }
    return this.nextNodeAllOnSameLine;
  };
  FormattingContext.prototype.TokensAreOnSameLine = function() {
    if (this.tokensAreOnSameLine === undefined) {
      const startLine = this.sourceFile.getLineAndCharacterOfPosition(this.currentTokenSpan.pos).line;
      const endLine = this.sourceFile.getLineAndCharacterOfPosition(this.nextTokenSpan.pos).line;
      this.tokensAreOnSameLine = (startLine === endLine);
    }
    return this.tokensAreOnSameLine;
  };
  FormattingContext.prototype.ContextNodeBlockIsOnOneLine = function() {
    if (this.contextNodeBlockIsOnOneLine === undefined) {
      this.contextNodeBlockIsOnOneLine = this.BlockIsOnOneLine(this.contextNode);
    }
    return this.contextNodeBlockIsOnOneLine;
  };
  FormattingContext.prototype.NextNodeBlockIsOnOneLine = function() {
    if (this.nextNodeBlockIsOnOneLine === undefined) {
      this.nextNodeBlockIsOnOneLine = this.BlockIsOnOneLine(this.nextTokenParent);
    }
    return this.nextNodeBlockIsOnOneLine;
  };
  FormattingContext.prototype.NodeIsOnOneLine = function(node) {
    const startLine = this.sourceFile.getLineAndCharacterOfPosition(node.getStart(this.sourceFile)).line;
    const endLine = this.sourceFile.getLineAndCharacterOfPosition(node.getEnd()).line;
    return startLine === endLine;
  };
  FormattingContext.prototype.BlockIsOnOneLine = function(node) {
    const openBrace = ts.findChildOfKind(node, 18 /* SyntaxKind.OpenBraceToken */, this.sourceFile);
    const closeBrace = ts.findChildOfKind(node, 19 /* SyntaxKind.CloseBraceToken */, this.sourceFile);
    if (openBrace && closeBrace) {
      const startLine = this.sourceFile.getLineAndCharacterOfPosition(openBrace.getEnd()).line;
      const endLine = this.sourceFile.getLineAndCharacterOfPosition(closeBrace.getStart(this.sourceFile)).line;
      return startLine === endLine;
    }
    return false;
  };
  return FormattingContext;
})();
formatting.FormattingContext = FormattingContext;
})(formatting = ts.formatting || (ts.formatting = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let formatting;
(function(formatting) {
const standardScanner =
    ts.createScanner(99 /* ScriptTarget.Latest */, /* skipTrivia*/ false, 0 /* LanguageVariant.Standard */);
const jsxScanner = ts.createScanner(99 /* ScriptTarget.Latest */, /* skipTrivia*/ false, 1 /* LanguageVariant.JSX */);
let ScanAction;
(function(ScanAction) {
ScanAction[ScanAction['Scan'] = 0] = 'Scan';
ScanAction[ScanAction['RescanGreaterThanToken'] = 1] = 'RescanGreaterThanToken';
ScanAction[ScanAction['RescanSlashToken'] = 2] = 'RescanSlashToken';
ScanAction[ScanAction['RescanTemplateToken'] = 3] = 'RescanTemplateToken';
ScanAction[ScanAction['RescanJsxIdentifier'] = 4] = 'RescanJsxIdentifier';
ScanAction[ScanAction['RescanJsxText'] = 5] = 'RescanJsxText';
ScanAction[ScanAction['RescanJsxAttributeValue'] = 6] = 'RescanJsxAttributeValue';
})(ScanAction || (ScanAction = {}));
function getFormattingScanner(text, languageVariant, startPos, endPos, cb) {
  const scanner = languageVariant === 1 /* LanguageVariant.JSX */ ? jsxScanner : standardScanner;
  scanner.setText(text);
  scanner.setTextPos(startPos);
  let wasNewLine = true;
  let leadingTrivia;
  let trailingTrivia;
  let savedPos;
  let lastScanAction;
  let lastTokenInfo;
  const res = cb({
    advance,
    readTokenInfo,
    readEOFTokenRange,
    isOnToken,
    isOnEOF,
    getCurrentLeadingTrivia: function() {
      return leadingTrivia;
    },
    lastTrailingTriviaWasNewLine: function() {
      return wasNewLine;
    },
    skipToEndOf,
    skipToStartOf,
    getStartPos: function() {
      let _a;
      return (_a = lastTokenInfo === null || lastTokenInfo === void 0 ? void 0 : lastTokenInfo.token.pos) !== null &&
              _a !== void 0 ?
          _a :
          scanner.getTokenPos();
    },
  });
  lastTokenInfo = undefined;
  scanner.setText(undefined);
  return res;
  function advance() {
    lastTokenInfo = undefined;
    const isStarted = scanner.getStartPos() !== startPos;
    if (isStarted) {
      wasNewLine = !!trailingTrivia && ts.last(trailingTrivia).kind === 4 /* SyntaxKind.NewLineTrivia */;
    } else {
      scanner.scan();
    }
    leadingTrivia = undefined;
    trailingTrivia = undefined;
    let pos = scanner.getStartPos();
    // Read leading trivia and token
    while (pos < endPos) {
      const t = scanner.getToken();
      if (!ts.isTrivia(t)) {
        break;
      }
      // consume leading trivia
      scanner.scan();
      const item = {pos, end: scanner.getStartPos(), kind: t};
      pos = scanner.getStartPos();
      leadingTrivia = ts.append(leadingTrivia, item);
    }
    savedPos = scanner.getStartPos();
  }
  function shouldRescanGreaterThanToken(node) {
    switch (node.kind) {
      case 33 /* SyntaxKind.GreaterThanEqualsToken */:
      case 71 /* SyntaxKind.GreaterThanGreaterThanEqualsToken */:
      case 72 /* SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken */:
      case 49 /* SyntaxKind.GreaterThanGreaterThanGreaterThanToken */:
      case 48 /* SyntaxKind.GreaterThanGreaterThanToken */:
        return true;
    }
    return false;
  }
  function shouldRescanJsxIdentifier(node) {
    if (node.parent) {
      switch (node.parent.kind) {
        case 288 /* SyntaxKind.JsxAttribute */:
        case 283 /* SyntaxKind.JsxOpeningElement */:
        case 284 /* SyntaxKind.JsxClosingElement */:
        case 282 /* SyntaxKind.JsxSelfClosingElement */:
          // May parse an identifier like `module-layout`; that will be scanned as a keyword at first, but we should parse the whole thing to get an identifier.
          return ts.isKeyword(node.kind) || node.kind === 79 /* SyntaxKind.Identifier */;
      }
    }
    return false;
  }
  function shouldRescanJsxText(node) {
    return ts.isJsxText(node) ||
        ts.isJsxElement(node) &&
        (lastTokenInfo === null || lastTokenInfo === void 0 ? void 0 : lastTokenInfo.token.kind) ===
            11 /* SyntaxKind.JsxText */;
  }
  function shouldRescanSlashToken(container) {
    return container.kind === 13 /* SyntaxKind.RegularExpressionLiteral */;
  }
  function shouldRescanTemplateToken(container) {
    return container.kind === 16 /* SyntaxKind.TemplateMiddle */ || container.kind === 17 /* SyntaxKind.TemplateTail */;
  }
  function shouldRescanJsxAttributeValue(node) {
    return node.parent && ts.isJsxAttribute(node.parent) && node.parent.initializer === node;
  }
  function startsWithSlashToken(t) {
    return t === 43 /* SyntaxKind.SlashToken */ || t === 68 /* SyntaxKind.SlashEqualsToken */;
  }
  function readTokenInfo(n) {
    ts.Debug.assert(isOnToken());
    // normally scanner returns the smallest available token
    // check the kind of context node to determine if scanner should have more greedy behavior and consume more text.
    const expectedScanAction = shouldRescanGreaterThanToken(n) ? 1 /* ScanAction.RescanGreaterThanToken */ :
        shouldRescanSlashToken(n)                            ? 2 /* ScanAction.RescanSlashToken */ :
        shouldRescanTemplateToken(n)                         ? 3 /* ScanAction.RescanTemplateToken */ :
        shouldRescanJsxIdentifier(n)                         ? 4 /* ScanAction.RescanJsxIdentifier */ :
        shouldRescanJsxText(n)                               ? 5 /* ScanAction.RescanJsxText */ :
        shouldRescanJsxAttributeValue(n)                     ? 6 /* ScanAction.RescanJsxAttributeValue */ :
                                                               0 /* ScanAction.Scan */;
    if (lastTokenInfo && expectedScanAction === lastScanAction) {
      // readTokenInfo was called before with the same expected scan action.
      // No need to re-scan text, return existing 'lastTokenInfo'
      // it is ok to call fixTokenKind here since it does not affect
      // what portion of text is consumed. In contrast rescanning can change it,
      // i.e. for '>=' when originally scanner eats just one character
      // and rescanning forces it to consume more.
      return fixTokenKind(lastTokenInfo, n);
    }
    if (scanner.getStartPos() !== savedPos) {
      ts.Debug.assert(lastTokenInfo !== undefined);
      // readTokenInfo was called before but scan action differs - rescan text
      scanner.setTextPos(savedPos);
      scanner.scan();
    }
    let currentToken = getNextToken(n, expectedScanAction);
    const token = formatting.createTextRangeWithKind(scanner.getStartPos(), scanner.getTextPos(), currentToken);
    // consume trailing trivia
    if (trailingTrivia) {
      trailingTrivia = undefined;
    }
    while (scanner.getStartPos() < endPos) {
      currentToken = scanner.scan();
      if (!ts.isTrivia(currentToken)) {
        break;
      }
      const trivia = formatting.createTextRangeWithKind(scanner.getStartPos(), scanner.getTextPos(), currentToken);
      if (!trailingTrivia) {
        trailingTrivia = [];
      }
      trailingTrivia.push(trivia);
      if (currentToken === 4 /* SyntaxKind.NewLineTrivia */) {
        // move past new line
        scanner.scan();
        break;
      }
    }
    lastTokenInfo = {leadingTrivia, trailingTrivia, token};
    return fixTokenKind(lastTokenInfo, n);
  }
  function getNextToken(n, expectedScanAction) {
    const token = scanner.getToken();
    lastScanAction = 0 /* ScanAction.Scan */;
    switch (expectedScanAction) {
      case 1 /* ScanAction.RescanGreaterThanToken */:
        if (token === 31 /* SyntaxKind.GreaterThanToken */) {
          lastScanAction = 1 /* ScanAction.RescanGreaterThanToken */;
          var newToken = scanner.reScanGreaterToken();
          ts.Debug.assert(n.kind === newToken);
          return newToken;
        }
        break;
      case 2 /* ScanAction.RescanSlashToken */:
        if (startsWithSlashToken(token)) {
          lastScanAction = 2 /* ScanAction.RescanSlashToken */;
          var newToken = scanner.reScanSlashToken();
          ts.Debug.assert(n.kind === newToken);
          return newToken;
        }
        break;
      case 3 /* ScanAction.RescanTemplateToken */:
        if (token === 19 /* SyntaxKind.CloseBraceToken */) {
          lastScanAction = 3 /* ScanAction.RescanTemplateToken */;
          return scanner.reScanTemplateToken(/* isTaggedTemplate */ false);
        }
        break;
      case 4 /* ScanAction.RescanJsxIdentifier */:
        lastScanAction = 4 /* ScanAction.RescanJsxIdentifier */;
        return scanner.scanJsxIdentifier();
      case 5 /* ScanAction.RescanJsxText */:
        lastScanAction = 5 /* ScanAction.RescanJsxText */;
        return scanner.reScanJsxToken(/* allowMultilineJsxText */ false);
      case 6 /* ScanAction.RescanJsxAttributeValue */:
        lastScanAction = 6 /* ScanAction.RescanJsxAttributeValue */;
        return scanner.reScanJsxAttributeValue();
      case 0 /* ScanAction.Scan */:
        break;
      default:
        ts.Debug.assertNever(expectedScanAction);
    }
    return token;
  }
  function readEOFTokenRange() {
    ts.Debug.assert(isOnEOF());
    return formatting.createTextRangeWithKind(
        scanner.getStartPos(), scanner.getTextPos(), 1 /* SyntaxKind.EndOfFileToken */);
  }
  function isOnToken() {
    const current = lastTokenInfo ? lastTokenInfo.token.kind : scanner.getToken();
    return current !== 1 /* SyntaxKind.EndOfFileToken */ && !ts.isTrivia(current);
  }
  function isOnEOF() {
    const current = lastTokenInfo ? lastTokenInfo.token.kind : scanner.getToken();
    return current === 1 /* SyntaxKind.EndOfFileToken */;
  }
  // when containing node in the tree is token
  // but its kind differs from the kind that was returned by the scanner,
  // then kind needs to be fixed. This might happen in cases
  // when parser interprets token differently, i.e keyword treated as identifier
  function fixTokenKind(tokenInfo, container) {
    if (ts.isToken(container) && tokenInfo.token.kind !== container.kind) {
      tokenInfo.token.kind = container.kind;
    }
    return tokenInfo;
  }
  function skipToEndOf(node) {
    scanner.setTextPos(node.end);
    savedPos = scanner.getStartPos();
    lastScanAction = undefined;
    lastTokenInfo = undefined;
    wasNewLine = false;
    leadingTrivia = undefined;
    trailingTrivia = undefined;
  }
  function skipToStartOf(node) {
    scanner.setTextPos(node.pos);
    savedPos = scanner.getStartPos();
    lastScanAction = undefined;
    lastTokenInfo = undefined;
    wasNewLine = false;
    leadingTrivia = undefined;
    trailingTrivia = undefined;
  }
}
formatting.getFormattingScanner = getFormattingScanner;
})(formatting = ts.formatting || (ts.formatting = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let formatting;
(function(formatting) {
formatting.anyContext = ts.emptyArray;
let RuleAction;
(function(RuleAction) {
RuleAction[RuleAction['StopProcessingSpaceActions'] = 1] = 'StopProcessingSpaceActions';
RuleAction[RuleAction['StopProcessingTokenActions'] = 2] = 'StopProcessingTokenActions';
RuleAction[RuleAction['InsertSpace'] = 4] = 'InsertSpace';
RuleAction[RuleAction['InsertNewLine'] = 8] = 'InsertNewLine';
RuleAction[RuleAction['DeleteSpace'] = 16] = 'DeleteSpace';
RuleAction[RuleAction['DeleteToken'] = 32] = 'DeleteToken';
RuleAction[RuleAction['InsertTrailingSemicolon'] = 64] = 'InsertTrailingSemicolon';
RuleAction[RuleAction['StopAction'] = 3] = 'StopAction';
RuleAction[RuleAction['ModifySpaceAction'] = 28] = 'ModifySpaceAction';
RuleAction[RuleAction['ModifyTokenAction'] = 96] = 'ModifyTokenAction';
})(RuleAction = formatting.RuleAction || (formatting.RuleAction = {}));
let RuleFlags;
(function(RuleFlags) {
RuleFlags[RuleFlags['None'] = 0] = 'None';
RuleFlags[RuleFlags['CanDeleteNewLines'] = 1] = 'CanDeleteNewLines';
})(RuleFlags = formatting.RuleFlags || (formatting.RuleFlags = {}));
})(formatting = ts.formatting || (ts.formatting = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let formatting;
(function(formatting) {
function getAllRules() {
  const allTokens = [];
  for (let token = 0 /* SyntaxKind.FirstToken */; token <= 162 /* SyntaxKind.LastToken */; token++) {
    if (token !== 1 /* SyntaxKind.EndOfFileToken */) {
      allTokens.push(token);
    }
  }
  function anyTokenExcept() {
    const tokens = [];
    for (let _i = 0; _i < arguments.length; _i++) {
      tokens[_i] = arguments[_i];
    }
    return {
      tokens: allTokens.filter(function(t) {
        return !tokens.some(function(t2) {
          return t2 === t;
        });
      }),
      isSpecific: false
    };
  }
  const anyToken = {tokens: allTokens, isSpecific: false};
  const anyTokenIncludingMultilineComments = tokenRangeFrom(
      __spreadArray(__spreadArray([], allTokens, true), [3 /* SyntaxKind.MultiLineCommentTrivia */], false));
  const anyTokenIncludingEOF =
      tokenRangeFrom(__spreadArray(__spreadArray([], allTokens, true), [1 /* SyntaxKind.EndOfFileToken */], false));
  const keywords = tokenRangeFromRange(81 /* SyntaxKind.FirstKeyword */, 162 /* SyntaxKind.LastKeyword */);
  const binaryOperators =
      tokenRangeFromRange(29 /* SyntaxKind.FirstBinaryOperator */, 78 /* SyntaxKind.LastBinaryOperator */);
  const binaryKeywordOperators = [
    101 /* SyntaxKind.InKeyword */, 102 /* SyntaxKind.InstanceOfKeyword */, 162 /* SyntaxKind.OfKeyword */,
    128 /* SyntaxKind.AsKeyword */, 140 /* SyntaxKind.IsKeyword */
  ];
  const unaryPrefixOperators = [
    45 /* SyntaxKind.PlusPlusToken */, 46 /* SyntaxKind.MinusMinusToken */, 54 /* SyntaxKind.TildeToken */,
    53 /* SyntaxKind.ExclamationToken */
  ];
  const unaryPrefixExpressions = [
    8 /* SyntaxKind.NumericLiteral */, 9 /* SyntaxKind.BigIntLiteral */, 79 /* SyntaxKind.Identifier */,
    20 /* SyntaxKind.OpenParenToken */, 22 /* SyntaxKind.OpenBracketToken */, 18 /* SyntaxKind.OpenBraceToken */,
    108 /* SyntaxKind.ThisKeyword */, 103 /* SyntaxKind.NewKeyword */
  ];
  const unaryPreincrementExpressions = [
    79 /* SyntaxKind.Identifier */, 20 /* SyntaxKind.OpenParenToken */, 108 /* SyntaxKind.ThisKeyword */,
    103 /* SyntaxKind.NewKeyword */
  ];
  const unaryPostincrementExpressions = [
    79 /* SyntaxKind.Identifier */, 21 /* SyntaxKind.CloseParenToken */, 23 /* SyntaxKind.CloseBracketToken */,
    103 /* SyntaxKind.NewKeyword */
  ];
  const unaryPredecrementExpressions = [
    79 /* SyntaxKind.Identifier */, 20 /* Syn