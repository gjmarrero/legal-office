putedWithoutCacheCount = _a.computedWithoutCacheCount;
    const result = getBestFix(fixes, importingFile, program, packageJsonImportFilter, host);
    return result && __assign(__assign({}, result), {computedWithoutCacheCount});
  }
}
codefix.createImportSpecifierResolver = createImportSpecifierResolver;
// Sorted with the preferred fix coming first.
let ImportFixKind;
(function(ImportFixKind) {
ImportFixKind[ImportFixKind['UseNamespace'] = 0] = 'UseNamespace';
ImportFixKind[ImportFixKind['JsdocTypeImport'] = 1] = 'JsdocTypeImport';
ImportFixKind[ImportFixKind['AddToExisting'] = 2] = 'AddToExisting';
ImportFixKind[ImportFixKind['AddNew'] = 3] = 'AddNew';
ImportFixKind[ImportFixKind['PromoteTypeOnly'] = 4] = 'PromoteTypeOnly';
})(ImportFixKind || (ImportFixKind = {}));
// These should not be combined as bitflags, but are given powers of 2 values to
// easily detect conflicts between `NotAllowed` and `Required` by giving them a unique sum.
// They're also ordered in terms of increasing priority for a fix-all scenario (see
// `reduceAddAsTypeOnlyValues`).
let AddAsTypeOnly;
(function(AddAsTypeOnly) {
AddAsTypeOnly[AddAsTypeOnly['Allowed'] = 1] = 'Allowed';
AddAsTypeOnly[AddAsTypeOnly['Required'] = 2] = 'Required';
AddAsTypeOnly[AddAsTypeOnly['NotAllowed'] = 4] = 'NotAllowed';
})(AddAsTypeOnly || (AddAsTypeOnly = {}));
function getImportCompletionAction(
    targetSymbol, moduleSymbol, sourceFile, symbolName, isJsxTagName, host, program, formatContext, position,
    preferences, cancellationToken) {
  const compilerOptions = program.getCompilerOptions();
  const exportInfos = ts.pathIsBareSpecifier(ts.stripQuotes(moduleSymbol.name)) ?
      [getSingleExportInfoForSymbol(targetSymbol, moduleSymbol, program, host)] :
      getAllExportInfoForSymbol(
          sourceFile, targetSymbol, symbolName, isJsxTagName, program, host, preferences, cancellationToken);
  ts.Debug.assertIsDefined(exportInfos);
  const useRequire = shouldUseRequire(sourceFile, program);
  const isValidTypeOnlyUseSite = ts.isValidTypeOnlyAliasUseSite(ts.getTokenAtPosition(sourceFile, position));
  const fix = ts.Debug.checkDefined(getImportFixForSymbol(
      sourceFile, exportInfos, moduleSymbol, program, {symbolName, position},
      isValidTypeOnlyUseSite, useRequire, host, preferences));
  return {
    moduleSpecifier: fix.moduleSpecifier,
    codeAction: codeFixActionToCodeAction(codeActionForFix(
        {host, formatContext, preferences}, sourceFile, symbolName, fix,
        /* includeSymbolNameInDescription*/ false, ts.getQuotePreference(sourceFile, preferences), compilerOptions))
  };
}
codefix.getImportCompletionAction = getImportCompletionAction;
function getPromoteTypeOnlyCompletionAction(sourceFile, symbolToken, program, host, formatContext, preferences) {
  const compilerOptions = program.getCompilerOptions();
  const symbolName =
      ts.single(getSymbolNamesToImport(sourceFile, program.getTypeChecker(), symbolToken, compilerOptions));
  const fix = getTypeOnlyPromotionFix(sourceFile, symbolToken, symbolName, program);
  const includeSymbolNameInDescription = symbolName !== symbolToken.text;
  return fix &&
      codeFixActionToCodeAction(codeActionForFix(
          {host, formatContext, preferences}, sourceFile, symbolName, fix,
          includeSymbolNameInDescription, 1 /* QuotePreference.Double */, compilerOptions));
}
codefix.getPromoteTypeOnlyCompletionAction = getPromoteTypeOnlyCompletionAction;
function getImportFixForSymbol(
    sourceFile, exportInfos, moduleSymbol, program, useNamespaceInfo, isValidTypeOnlyUseSite, useRequire, host,
    preferences) {
  ts.Debug.assert(
      exportInfos.some(function(info) {
        return info.moduleSymbol === moduleSymbol || info.symbol.parent === moduleSymbol;
      }),
      'Some exportInfo should match the specified moduleSymbol');
  const packageJsonImportFilter = ts.createPackageJsonImportFilter(sourceFile, preferences, host);
  return getBestFix(
      getImportFixes(
          exportInfos, useNamespaceInfo, isValidTypeOnlyUseSite, useRequire, program, sourceFile, host, preferences)
          .fixes,
      sourceFile, program, packageJsonImportFilter, host);
}
function codeFixActionToCodeAction(_a) {
  const description = _a.description, changes = _a.changes, commands = _a.commands;
  return {description, changes, commands};
}
function getAllExportInfoForSymbol(
    importingFile, symbol, symbolName, preferCapitalized, program, host, preferences, cancellationToken) {
  const getChecker = createGetChecker(program, host);
  return ts.getExportInfoMap(importingFile, host, program, preferences, cancellationToken)
      .search(
          importingFile.path, preferCapitalized,
          function(name) {
            return name === symbolName;
          },
          function(info) {
            if (ts.skipAlias(info[0].symbol, getChecker(info[0].isFromPackageJson)) === symbol) {
              return info;
            }
          });
}
function getSingleExportInfoForSymbol(symbol, moduleSymbol, program, host) {
  let _a, _b;
  const compilerOptions = program.getCompilerOptions();
  const mainProgramInfo = getInfoWithChecker(program.getTypeChecker(), /* isFromPackageJson*/ false);
  if (mainProgramInfo) {
    return mainProgramInfo;
  }
  const autoImportProvider =
      (_b = (_a = host.getPackageJsonAutoImportProvider) === null || _a === void 0 ? void 0 : _a.call(host)) === null ||
          _b === void 0 ?
      void 0 :
      _b.getTypeChecker();
  return ts.Debug.checkDefined(
      autoImportProvider && getInfoWithChecker(autoImportProvider, /* isFromPackageJson*/ true),
      'Could not find symbol in specified module for code actions');
  function getInfoWithChecker(checker, isFromPackageJson) {
    const defaultInfo = ts.getDefaultLikeExportInfo(moduleSymbol, checker, compilerOptions);
    if (defaultInfo && ts.skipAlias(defaultInfo.symbol, checker) === symbol) {
      return {
        symbol: defaultInfo.symbol,
        moduleSymbol,
        moduleFileName: undefined,
        exportKind: defaultInfo.exportKind,
        targetFlags: ts.skipAlias(symbol, checker).flags,
        isFromPackageJson
      };
    }
    const named = checker.tryGetMemberInModuleExportsAndProperties(symbol.name, moduleSymbol);
    if (named && ts.skipAlias(named, checker) === symbol) {
      return {
        symbol: named,
        moduleSymbol,
        moduleFileName: undefined,
        exportKind: 0 /* ExportKind.Named */,
        targetFlags: ts.skipAlias(symbol, checker).flags,
        isFromPackageJson
      };
    }
  }
}
function getImportFixes(
    exportInfos, useNamespaceInfo,
    /** undefined only for missing JSX namespace */
    isValidTypeOnlyUseSite, useRequire, program, sourceFile, host, preferences, importMap, fromCacheOnly) {
  if (importMap === void 0) {
    importMap = createExistingImportMap(program.getTypeChecker(), sourceFile, program.getCompilerOptions());
  }
  const checker = program.getTypeChecker();
  const existingImports = ts.flatMap(exportInfos, importMap.getImportsForExportInfo);
  const useNamespace = useNamespaceInfo &&
      tryUseExistingNamespaceImport(existingImports, useNamespaceInfo.symbolName, useNamespaceInfo.position, checker);
  const addToExisting =
      tryAddToExistingImport(existingImports, isValidTypeOnlyUseSite, checker, program.getCompilerOptions());
  if (addToExisting) {
    // Don't bother providing an action to add a new import if we can add to an existing one.
    return {
      computedWithoutCacheCount: 0,
      fixes: __spreadArray(
          __spreadArray([], (useNamespace ? [useNamespace] : ts.emptyArray), true), [addToExisting], false),
    };
  }
  const _a = getFixesForAddImport(
          exportInfos, existingImports, program, sourceFile,
          useNamespaceInfo === null || useNamespaceInfo === void 0 ? void 0 : useNamespaceInfo.position,
          isValidTypeOnlyUseSite, useRequire, host, preferences, fromCacheOnly),
      fixes = _a.fixes, _b = _a.computedWithoutCacheCount, computedWithoutCacheCount = _b === void 0 ? 0 : _b;
  return {
    computedWithoutCacheCount,
    fixes: __spreadArray(__spreadArray([], (useNamespace ? [useNamespace] : ts.emptyArray), true), fixes, true),
  };
}
function tryUseExistingNamespaceImport(existingImports, symbolName, position, checker) {
  // It is possible that multiple import statements with the same specifier exist in the file.
  // e.g.
  //
  //     import * as ns from "foo";
  //     import { member1, member2 } from "foo";
  //
  //     member3/**/ <-- cusor here
  //
  // in this case we should provie 2 actions:
  //     1. change "member3" to "ns.member3"
  //     2. add "member3" to the second import statement's import list
  // and it is up to the user to decide which one fits best.
  return ts.firstDefined(existingImports, function(_a) {
    let _b;
    const declaration = _a.declaration;
    const namespacePrefix = getNamespaceLikeImportText(declaration);
    const moduleSpecifier =
        (_b = ts.tryGetModuleSpecifierFromDeclaration(declaration)) === null || _b === void 0 ? void 0 : _b.text;
    if (namespacePrefix && moduleSpecifier) {
      const moduleSymbol = getTargetModuleFromNamespaceLikeImport(declaration, checker);
      if (moduleSymbol && moduleSymbol.exports.has(ts.escapeLeadingUnderscores(symbolName))) {
        return {
          kind: 0 /* ImportFixKind.UseNamespace */,
          namespacePrefix,
          position,
          moduleSpecifier
        };
      }
    }
  });
}
function getTargetModuleFromNamespaceLikeImport(declaration, checker) {
  let _a;
  switch (declaration.kind) {
    case 257 /* SyntaxKind.VariableDeclaration */:
      return checker.resolveExternalModuleName(declaration.initializer.arguments[0]);
    case 268 /* SyntaxKind.ImportEqualsDeclaration */:
      return checker.getAliasedSymbol(declaration.symbol);
    case 269 /* SyntaxKind.ImportDeclaration */:
      var namespaceImport = ts.tryCast(
          (_a = declaration.importClause) === null || _a === void 0 ? void 0 : _a.namedBindings, ts.isNamespaceImport);
      return namespaceImport && checker.getAliasedSymbol(namespaceImport.symbol);
    default:
      return ts.Debug.assertNever(declaration);
  }
}
function getNamespaceLikeImportText(declaration) {
  let _a, _b, _c;
  switch (declaration.kind) {
    case 257 /* SyntaxKind.VariableDeclaration */:
      return (_a = ts.tryCast(declaration.name, ts.isIdentifier)) === null || _a === void 0 ? void 0 : _a.text;
    case 268 /* SyntaxKind.ImportEqualsDeclaration */:
      return declaration.name.text;
    case 269 /* SyntaxKind.ImportDeclaration */:
      return (_c = ts.tryCast(
                  (_b = declaration.importClause) === null || _b === void 0 ? void 0 : _b.namedBindings,
                  ts.isNamespaceImport)) === null ||
              _c === void 0 ?
          void 0 :
          _c.name.text;
    default:
      return ts.Debug.assertNever(declaration);
  }
}
function getAddAsTypeOnly(
    isValidTypeOnlyUseSite, isForNewImportDeclaration, symbol, targetFlags, checker, compilerOptions) {
  if (!isValidTypeOnlyUseSite) {
    // Can't use a type-only import if the usage is an emitting position
    return 4 /* AddAsTypeOnly.NotAllowed */;
  }
  if (isForNewImportDeclaration && compilerOptions.importsNotUsedAsValues === 2 /* ImportsNotUsedAsValues.Error */) {
    // Not writing a (top-level) type-only import here would create an error because the runtime dependency is unnecessary
    return 2 /* AddAsTypeOnly.Required */;
  }
  if (compilerOptions.isolatedModules && compilerOptions.preserveValueImports &&
      (!(targetFlags & 111551 /* SymbolFlags.Value */) || !!checker.getTypeOnlyAliasDeclaration(symbol))) {
    // A type-only import is required for this symbol if under these settings if the symbol will
    // be erased, which will happen if the target symbol is purely a type or if it was exported/imported
    // as type-only already somewhere between this import and the target.
    return 2 /* AddAsTypeOnly.Required */;
  }
  return 1 /* AddAsTypeOnly.Allowed */;
}
function tryAddToExistingImport(existingImports, isValidTypeOnlyUseSite, checker, compilerOptions) {
  return ts.firstDefined(existingImports, function(_a) {
    const declaration = _a.declaration, importKind = _a.importKind, symbol = _a.symbol, targetFlags = _a.targetFlags;
    if (importKind === 3 /* ImportKind.CommonJS */ || importKind === 2 /* ImportKind.Namespace */ ||
        declaration.kind === 268 /* SyntaxKind.ImportEqualsDeclaration */) {
      // These kinds of imports are not combinable with anything
      return undefined;
    }
    if (declaration.kind === 257 /* SyntaxKind.VariableDeclaration */) {
      return (importKind === 0 /* ImportKind.Named */ || importKind === 1 /* ImportKind.Default */) &&
              declaration.name.kind === 203 /* SyntaxKind.ObjectBindingPattern */
          ?
          {
            kind: 2 /* ImportFixKind.AddToExisting */,
            importClauseOrBindingPattern: declaration.name,
            importKind,
            moduleSpecifier: declaration.initializer.arguments[0].text,
            addAsTypeOnly: 4 /* AddAsTypeOnly.NotAllowed */
          } :
          undefined;
    }
    const importClause = declaration.importClause;
    if (!importClause || !ts.isStringLiteralLike(declaration.moduleSpecifier))
      {return undefined;}
    const name = importClause.name, namedBindings = importClause.namedBindings;
    // A type-only import may not have both a default and named imports, so the only way a name can
    // be added to an existing type-only import is adding a named import to existing named bindings.
    if (importClause.isTypeOnly && !(importKind === 0 /* ImportKind.Named */ && namedBindings))
      {return undefined;}
    // N.B. we don't have to figure out whether to use the main program checker
    // or the AutoImportProvider checker because we're adding to an existing import; the existence of
    // the import guarantees the symbol came from the main program.
    const addAsTypeOnly = getAddAsTypeOnly(
        isValidTypeOnlyUseSite, /* isForNewImportDeclaration*/ false, symbol, targetFlags, checker, compilerOptions);
    if (importKind === 1 /* ImportKind.Default */ &&
        (
            name ||  // Cannot add a default import to a declaration that already has one
            addAsTypeOnly === 2 /* AddAsTypeOnly.Required */ &&
                namedBindings  // Cannot add a default import as type-only if the import already has named bindings
            ))
      {return undefined;}
    if (
        importKind === 0 /* ImportKind.Named */ &&
        (namedBindings === null || namedBindings === void 0 ? void 0 : namedBindings.kind) ===
            271 /* SyntaxKind.NamespaceImport */  // Cannot add a named import to a declaration that has a namespace import
    )
      {return undefined;}
    return {
      kind: 2 /* ImportFixKind.AddToExisting */,
      importClauseOrBindingPattern: importClause,
      importKind,
      moduleSpecifier: declaration.moduleSpecifier.text,
      addAsTypeOnly,
    };
  });
}
function createExistingImportMap(checker, importingFile, compilerOptions) {
  let importMap;
  for (let _i = 0, _a = importingFile.imports; _i < _a.length; _i++) {
    const moduleSpecifier = _a[_i];
    const i = ts.importFromModuleSpecifier(moduleSpecifier);
    if (ts.isVariableDeclarationInitializedToRequire(i.parent)) {
      var moduleSymbol = checker.resolveExternalModuleName(moduleSpecifier);
      if (moduleSymbol) {
        (importMap || (importMap = ts.createMultiMap())).add(ts.getSymbolId(moduleSymbol), i.parent);
      }
    } else if (
        i.kind === 269 /* SyntaxKind.ImportDeclaration */ || i.kind === 268 /* SyntaxKind.ImportEqualsDeclaration */) {
      var moduleSymbol = checker.getSymbolAtLocation(moduleSpecifier);
      if (moduleSymbol) {
        (importMap || (importMap = ts.createMultiMap())).add(ts.getSymbolId(moduleSymbol), i);
      }
    }
  }
  return {
    getImportsForExportInfo: function(_a) {
      const moduleSymbol = _a.moduleSymbol, exportKind = _a.exportKind, targetFlags = _a.targetFlags, symbol = _a.symbol;
      // Can't use an es6 import for a type in JS.
      if (!(targetFlags & 111551 /* SymbolFlags.Value */) && ts.isSourceFileJS(importingFile))
        {return ts.emptyArray;}
      const matchingDeclarations =
          importMap === null || importMap === void 0 ? void 0 : importMap.get(ts.getSymbolId(moduleSymbol));
      if (!matchingDeclarations)
        {return ts.emptyArray;}
      const importKind = getImportKind(importingFile, exportKind, compilerOptions);
      return matchingDeclarations.map(function(declaration) {
        return ({declaration, importKind, symbol, targetFlags});
      });
    }
  };
}
function shouldUseRequire(sourceFile, program) {
  // 1. TypeScript files don't use require variable declarations
  if (!ts.isSourceFileJS(sourceFile)) {
    return false;
  }
  // 2. If the current source file is unambiguously CJS or ESM, go with that
  if (sourceFile.commonJsModuleIndicator && !sourceFile.externalModuleIndicator)
    {return true;}
  if (sourceFile.externalModuleIndicator && !sourceFile.commonJsModuleIndicator)
    {return false;}
  // 3. If there's a tsconfig/jsconfig, use its module setting
  const compilerOptions = program.getCompilerOptions();
  if (compilerOptions.configFile) {
    return ts.getEmitModuleKind(compilerOptions) < ts.ModuleKind.ES2015;
  }
  // 4. Match the first other JS file in the program that's unambiguously CJS or ESM
  for (let _i = 0, _a = program.getSourceFiles(); _i < _a.length; _i++) {
    const otherFile = _a[_i];
    if (otherFile === sourceFile || !ts.isSourceFileJS(otherFile) || program.isSourceFileFromExternalLibrary(otherFile))
      {continue;}
    if (otherFile.commonJsModuleIndicator && !otherFile.externalModuleIndicator)
      {return true;}
    if (otherFile.externalModuleIndicator && !otherFile.commonJsModuleIndicator)
      {return false;}
  }
  // 5. Literally nothing to go on
  return true;
}
function createGetChecker(program, host) {
  return ts.memoizeOne(function(isFromPackageJson) {
    return isFromPackageJson ? host.getPackageJsonAutoImportProvider().getTypeChecker() : program.getTypeChecker();
  });
}
function getNewImportFixes(
    program, sourceFile, position, isValidTypeOnlyUseSite, useRequire, exportInfo, host, preferences, fromCacheOnly) {
  const isJs = ts.isSourceFileJS(sourceFile);
  const compilerOptions = program.getCompilerOptions();
  const moduleSpecifierResolutionHost = ts.createModuleSpecifierResolutionHost(program, host);
  const getChecker = createGetChecker(program, host);
  const rejectNodeModulesRelativePaths =
      ts.moduleResolutionUsesNodeModules(ts.getEmitModuleResolutionKind(compilerOptions));
  const getModuleSpecifiers = fromCacheOnly ? function(moduleSymbol) {
    return ({
      moduleSpecifiers: ts.moduleSpecifiers.tryGetModuleSpecifiersFromCache(
          moduleSymbol, sourceFile, moduleSpecifierResolutionHost, preferences),
      computedWithoutCache: false
    });
  } : function(moduleSymbol, checker) {
    return ts.moduleSpecifiers.getModuleSpecifiersWithCacheInfo(
        moduleSymbol, checker, compilerOptions, sourceFile, moduleSpecifierResolutionHost, preferences);
  };
  let computedWithoutCacheCount = 0;
  const fixes = ts.flatMap(exportInfo, function(exportInfo, i) {
    const checker = getChecker(exportInfo.isFromPackageJson);
    const _a = getModuleSpecifiers(exportInfo.moduleSymbol, checker), computedWithoutCache = _a.computedWithoutCache,
        moduleSpecifiers = _a.moduleSpecifiers;
    const importedSymbolHasValueMeaning = !!(exportInfo.targetFlags & 111551 /* SymbolFlags.Value */);
    const addAsTypeOnly = getAddAsTypeOnly(
        isValidTypeOnlyUseSite, /* isForNewImportDeclaration*/ true, exportInfo.symbol, exportInfo.targetFlags, checker,
        compilerOptions);
    computedWithoutCacheCount += computedWithoutCache ? 1 : 0;
    return ts.mapDefined(moduleSpecifiers, function(moduleSpecifier) {
      return rejectNodeModulesRelativePaths && ts.pathContainsNodeModules(moduleSpecifier) ?
          undefined :
          // `position` should only be undefined at a missing jsx namespace, in which case we shouldn't be looking for pure types.
          !importedSymbolHasValueMeaning && isJs && position !== undefined ?
          {
            kind: 1 /* ImportFixKind.JsdocTypeImport */,
            moduleSpecifier,
            position,
            exportInfo,
            isReExport: i > 0
          } :
          {
            kind: 3 /* ImportFixKind.AddNew */,
            moduleSpecifier,
            importKind: getImportKind(sourceFile, exportInfo.exportKind, compilerOptions),
            useRequire,
            addAsTypeOnly,
            exportInfo,
            isReExport: i > 0,
          };
    });
  });
  return {computedWithoutCacheCount, fixes};
}
function getFixesForAddImport(
    exportInfos, existingImports, program, sourceFile, position, isValidTypeOnlyUseSite, useRequire, host, preferences,
    fromCacheOnly) {
  const existingDeclaration = ts.firstDefined(existingImports, function(info) {
    return newImportInfoFromExistingSpecifier(
        info, isValidTypeOnlyUseSite, useRequire, program.getTypeChecker(), program.getCompilerOptions());
  });
  return existingDeclaration ? {fixes: [existingDeclaration]} :
                               getNewImportFixes(
                                   program, sourceFile, position, isValidTypeOnlyUseSite, useRequire, exportInfos, host,
                                   preferences, fromCacheOnly);
}
function newImportInfoFromExistingSpecifier(_a, isValidTypeOnlyUseSite, useRequire, checker, compilerOptions) {
  let _b;
  const declaration = _a.declaration, importKind = _a.importKind, symbol = _a.symbol, targetFlags = _a.targetFlags;
  const moduleSpecifier =
      (_b = ts.tryGetModuleSpecifierFromDeclaration(declaration)) === null || _b === void 0 ? void 0 : _b.text;
  if (moduleSpecifier) {
    const addAsTypeOnly = useRequire ?
        4 /* AddAsTypeOnly.NotAllowed */
        :
        getAddAsTypeOnly(
            isValidTypeOnlyUseSite, /* isForNewImportDeclaration*/ true, symbol, targetFlags, checker, compilerOptions);
    return {
      kind: 3 /* ImportFixKind.AddNew */,
      moduleSpecifier,
      importKind,
      addAsTypeOnly,
      useRequire
    };
  }
}
function getFixInfos(context, errorCode, pos, useAutoImportProvider) {
  const symbolToken = ts.getTokenAtPosition(context.sourceFile, pos);
  let info;
  if (errorCode ===
      ts.Diagnostics._0_refers_to_a_UMD_global_but_the_current_file_is_a_module_Consider_adding_an_import_instead
          .code) {
    info = getFixesInfoForUMDImport(context, symbolToken);
  } else if (!ts.isIdentifier(symbolToken)) {
    return undefined;
  } else if (errorCode === ts.Diagnostics._0_cannot_be_used_as_a_value_because_it_was_imported_using_import_type.code) {
    const symbolName_1 = ts.single(getSymbolNamesToImport(
        context.sourceFile, context.program.getTypeChecker(), symbolToken, context.program.getCompilerOptions()));
    const fix = getTypeOnlyPromotionFix(context.sourceFile, symbolToken, symbolName_1, context.program);
    return fix && [{fix, symbolName: symbolName_1, errorIdentifierText: symbolToken.text}];
  } else {
    info = getFixesInfoForNonUMDImport(context, symbolToken, useAutoImportProvider);
  }
  const packageJsonImportFilter = ts.createPackageJsonImportFilter(context.sourceFile, context.preferences, context.host);
  return info && sortFixInfo(info, context.sourceFile, context.program, packageJsonImportFilter, context.host);
}
function sortFixInfo(fixes, sourceFile, program, packageJsonImportFilter, host) {
  const _toPath = function(fileName) {
    return ts.toPath(fileName, host.getCurrentDirectory(), ts.hostGetCanonicalFileName(host));
  };
  return ts.sort(fixes, function(a, b) {
    return ts.compareBooleans(!!a.isJsxNamespaceFix, !!b.isJsxNamespaceFix) ||
        ts.compareValues(a.fix.kind, b.fix.kind) ||
        compareModuleSpecifiers(
               a.fix, b.fix, sourceFile, program, packageJsonImportFilter.allowsImportingSpecifier, _toPath);
  });
}
function getBestFix(fixes, sourceFile, program, packageJsonImportFilter, host) {
  if (!ts.some(fixes))
    {return;}
  // These will always be placed first if available, and are better than other kinds
  if (fixes[0].kind === 0 /* ImportFixKind.UseNamespace */ || fixes[0].kind === 2 /* ImportFixKind.AddToExisting */) {
    return fixes[0];
  }
  return fixes.reduce(function(best, fix) {
    // Takes true branch of conditional if `fix` is better than `best`
    return compareModuleSpecifiers(
               fix, best, sourceFile, program, packageJsonImportFilter.allowsImportingSpecifier,
               function(fileName) {
                 return ts.toPath(fileName, host.getCurrentDirectory(), ts.hostGetCanonicalFileName(host));
               }) === -1 /* Comparison.LessThan */ ?
        fix :
        best;
  });
}
/** @returns `Comparison.LessThan` if `a` is better than `b`. */
function compareModuleSpecifiers(a, b, importingFile, program, allowsImportingSpecifier, toPath) {
  if (a.kind !== 0 /* ImportFixKind.UseNamespace */ && b.kind !== 0 /* ImportFixKind.UseNamespace */) {
    return ts.compareBooleans(
               allowsImportingSpecifier(b.moduleSpecifier), allowsImportingSpecifier(a.moduleSpecifier)) ||
        compareNodeCoreModuleSpecifiers(a.moduleSpecifier, b.moduleSpecifier, importingFile, program) ||
        ts.compareBooleans(
            isFixPossiblyReExportingImportingFile(a, importingFile, program.getCompilerOptions(), toPath),
            isFixPossiblyReExportingImportingFile(b, importingFile, program.getCompilerOptions(), toPath)) ||
        ts.compareNumberOfDirectorySeparators(a.moduleSpecifier, b.moduleSpecifier);
  }
  return 0 /* Comparison.EqualTo */;
}
// This is a simple heuristic to try to avoid creating an import cycle with a barrel re-export.
// E.g., do not `import { Foo } from ".."` when you could `import { Foo } from "../Foo"`.
// This can produce false positives or negatives if re-exports cross into sibling directories
// (e.g. `export * from "../whatever"`) or are not named "index" (we don't even try to consider
// this if we're in a resolution mode where you can't drop trailing "/index" from paths).
function isFixPossiblyReExportingImportingFile(fix, importingFile, compilerOptions, toPath) {
  let _a;
  if (fix.isReExport && ((_a = fix.exportInfo) === null || _a === void 0 ? void 0 : _a.moduleFileName) &&
      ts.getEmitModuleResolutionKind(compilerOptions) === ts.ModuleResolutionKind.NodeJs &&
      isIndexFileName(fix.exportInfo.moduleFileName)) {
    const reExportDir = toPath(ts.getDirectoryPath(fix.exportInfo.moduleFileName));
    return ts.startsWith((importingFile.path), reExportDir);
  }
  return false;
}
function isIndexFileName(fileName) {
  return ts.getBaseFileName(fileName, ['.js', '.jsx', '.d.ts', '.ts', '.tsx'], /* ignoreCase*/ true) === 'index';
}
function compareNodeCoreModuleSpecifiers(a, b, importingFile, program) {
  if (ts.startsWith(a, 'node:') && !ts.startsWith(b, 'node:'))
    {return ts.shouldUseUriStyleNodeCoreModules(importingFile, program) ? -1 /* Comparison.LessThan */ :
                                                                         1 /* Comparison.GreaterThan */;}
  if (ts.startsWith(b, 'node:') && !ts.startsWith(a, 'node:'))
    {return ts.shouldUseUriStyleNodeCoreModules(importingFile, program) ? 1 /* Comparison.GreaterThan */ :
                                                                         -1 /* Comparison.LessThan */;}
  return 0 /* Comparison.EqualTo */;
}
function getFixesInfoForUMDImport(_a, token) {
  const sourceFile = _a.sourceFile, program = _a.program, host = _a.host, preferences = _a.preferences;
  const checker = program.getTypeChecker();
  const umdSymbol = getUmdSymbol(token, checker);
  if (!umdSymbol)
    {return undefined;}
  const symbol = checker.getAliasedSymbol(umdSymbol);
  const symbolName = umdSymbol.name;
  const exportInfo = [{
    symbol: umdSymbol,
    moduleSymbol: symbol,
    moduleFileName: undefined,
    exportKind: 3 /* ExportKind.UMD */,
    targetFlags: symbol.flags,
    isFromPackageJson: false
  }];
  const useRequire = shouldUseRequire(sourceFile, program);
  const position = ts.isIdentifier(token) ? token.getStart(sourceFile) : undefined;
  const fixes = getImportFixes(
                  exportInfo, position ? {position, symbolName} : undefined,
                  /* isValidTypeOnlyUseSite*/ false, useRequire, program, sourceFile, host, preferences)
                  .fixes;
  return fixes.map(function(fix) {
    let _a;
    return ({
      fix,
      symbolName,
      errorIdentifierText: (_a = ts.tryCast(token, ts.isIdentifier)) === null || _a === void 0 ? void 0 : _a.text
    });
  });
}
function getUmdSymbol(token, checker) {
  // try the identifier to see if it is the umd symbol
  const umdSymbol = ts.isIdentifier(token) ? checker.getSymbolAtLocation(token) : undefined;
  if (ts.isUMDExportSymbol(umdSymbol))
    {return umdSymbol;}
  // The error wasn't for the symbolAtLocation, it was for the JSX tag itself, which needs access to e.g. `React`.
  const parent = token.parent;
  return (ts.isJsxOpeningLikeElement(parent) && parent.tagName === token) || ts.isJsxOpeningFragment(parent) ?
      ts.tryCast(
          checker.resolveName(
              checker.getJsxNamespace(parent), ts.isJsxOpeningLikeElement(parent) ? token : parent,
              111551 /* SymbolFlags.Value */, /* excludeGlobals*/ false),
          ts.isUMDExportSymbol) :
      undefined;
}
/**
 * @param forceImportKeyword Indicates that the user has already typed `import`, so the result must start with `import`.
 * (In other words, do not allow `const x = require("...")` for JS files.)
 */
function getImportKind(importingFile, exportKind, compilerOptions, forceImportKeyword) {
  switch (exportKind) {
    case 0 /* ExportKind.Named */:
      return 0 /* ImportKind.Named */;
    case 1 /* ExportKind.Default */:
      return 1 /* ImportKind.Default */;
    case 2 /* ExportKind.ExportEquals */:
      return getExportEqualsImportKind(importingFile, compilerOptions, !!forceImportKeyword);
    case 3 /* ExportKind.UMD */:
      return getUmdImportKind(importingFile, compilerOptions, !!forceImportKeyword);
    default:
      return ts.Debug.assertNever(exportKind);
  }
}
codefix.getImportKind = getImportKind;
function getUmdImportKind(importingFile, compilerOptions, forceImportKeyword) {
  // Import a synthetic `default` if enabled.
  if (ts.getAllowSyntheticDefaultImports(compilerOptions)) {
    return 1 /* ImportKind.Default */;
  }
  // When a synthetic `default` is unavailable, use `import..require` if the module kind supports it.
  const moduleKind = ts.getEmitModuleKind(compilerOptions);
  switch (moduleKind) {
    case ts.ModuleKind.AMD:
    case ts.ModuleKind.CommonJS:
    case ts.ModuleKind.UMD:
      if (ts.isInJSFile(importingFile)) {
        return ts.isExternalModule(importingFile) || forceImportKeyword ? 2 /* ImportKind.Namespace */ :
                                                                          3 /* ImportKind.CommonJS */;
      }
      return 3 /* ImportKind.CommonJS */;
    case ts.ModuleKind.System:
    case ts.ModuleKind.ES2015:
    case ts.ModuleKind.ES2020:
    case ts.ModuleKind.ES2022:
    case ts.ModuleKind.ESNext:
    case ts.ModuleKind.None:
      // Fall back to the `import * as ns` style import.
      return 2 /* ImportKind.Namespace */;
    case ts.ModuleKind.Node16:
    case ts.ModuleKind.NodeNext:
      return importingFile.impliedNodeFormat === ts.ModuleKind.ESNext ? 2 /* ImportKind.Namespace */ :
                                                                        3 /* ImportKind.CommonJS */;
    default:
      return ts.Debug.assertNever(moduleKind, 'Unexpected moduleKind '.concat(moduleKind));
  }
}
function getFixesInfoForNonUMDImport(_a, symbolToken, useAutoImportProvider) {
  const sourceFile = _a.sourceFile, program = _a.program, cancellationToken = _a.cancellationToken, host = _a.host,
      preferences = _a.preferences;
  const checker = program.getTypeChecker();
  const compilerOptions = program.getCompilerOptions();
  return ts.flatMap(getSymbolNamesToImport(sourceFile, checker, symbolToken, compilerOptions), function(symbolName) {
    // "default" is a keyword and not a legal identifier for the import, but appears as an identifier.
    if (symbolName === 'default' /* InternalSymbolName.Default */) {
      return undefined;
    }
    const isValidTypeOnlyUseSite = ts.isValidTypeOnlyAliasUseSite(symbolToken);
    const useRequire = shouldUseRequire(sourceFile, program);
    const exportInfo = getExportInfos(
        symbolName, ts.isJSXTagName(symbolToken), ts.getMeaningFromLocation(symbolToken), cancellationToken, sourceFile,
        program, useAutoImportProvider, host, preferences);
    const fixes = ts.arrayFrom(ts.flatMapIterator(exportInfo.entries(), function(_a) {
      const _ = _a[0], exportInfos = _a[1];
      return getImportFixes(
                 exportInfos, {symbolName, position: symbolToken.getStart(sourceFile)},
                 isValidTypeOnlyUseSite, useRequire, program, sourceFile, host, preferences)
          .fixes;
    }));
    return fixes.map(function(fix) {
      return ({
        fix,
        symbolName,
        errorIdentifierText: symbolToken.text,
        isJsxNamespaceFix: symbolName !== symbolToken.text
      });
    });
  });
}
function getTypeOnlyPromotionFix(sourceFile, symbolToken, symbolName, program) {
  const checker = program.getTypeChecker();
  const symbol = checker.resolveName(symbolName, symbolToken, 111551 /* SymbolFlags.Value */, /* excludeGlobals*/ true);
  if (!symbol)
    {return undefined;}
  const typeOnlyAliasDeclaration = checker.getTypeOnlyAliasDeclaration(symbol);
  if (!typeOnlyAliasDeclaration || ts.getSourceFileOfNode(typeOnlyAliasDeclaration) !== sourceFile)
    {return undefined;}
  return {kind: 4 /* ImportFixKind.PromoteTypeOnly */, typeOnlyAliasDeclaration};
}
function getSymbolNamesToImport(sourceFile, checker, symbolToken, compilerOptions) {
  const parent = symbolToken.parent;
  if ((ts.isJsxOpeningLikeElement(parent) || ts.isJsxClosingElement(parent)) && parent.tagName === symbolToken &&
      ts.jsxModeNeedsExplicitImport(compilerOptions.jsx)) {
    const jsxNamespace = checker.getJsxNamespace(sourceFile);
    if (needsJsxNamespaceFix(jsxNamespace, symbolToken, checker)) {
      const needsComponentNameFix = !ts.isIntrinsicJsxName(symbolToken.text) &&
          !checker.resolveName(symbolToken.text, symbolToken, 111551 /* SymbolFlags.Value */, /* excludeGlobals*/ false);
      return needsComponentNameFix ? [symbolToken.text, jsxNamespace] : [jsxNamespace];
    }
  }
  return [symbolToken.text];
}
function needsJsxNamespaceFix(jsxNamespace, symbolToken, checker) {
  if (ts.isIntrinsicJsxName(symbolToken.text))
    {return true;}  // If we were triggered by a matching error code on an intrinsic, the error must have been about missing the JSX factory
  const namespaceSymbol =
      checker.resolveName(jsxNamespace, symbolToken, 111551 /* SymbolFlags.Value */, /* excludeGlobals*/ true);
  return !namespaceSymbol ||
      ts.some(namespaceSymbol.declarations, ts.isTypeOnlyImportOrExportDeclaration) &&
      !(namespaceSymbol.flags & 111551 /* SymbolFlags.Value */);
}
// Returns a map from an exported symbol's ID to a list of every way it's (re-)exported.
function getExportInfos(
    symbolName, isJsxTagName, currentTokenMeaning, cancellationToken, fromFile, program, useAutoImportProvider, host,
    preferences) {
  let _a;
  // For each original symbol, keep all re-exports of that symbol together so we can call `getCodeActionsForImport` on the whole group at once.
  // Maps symbol id to info for modules providing that symbol (original export + re-exports).
  const originalSymbolToExportInfos = ts.createMultiMap();
  const packageJsonFilter = ts.createPackageJsonImportFilter(fromFile, preferences, host);
  const moduleSpecifierCache = (_a = host.getModuleSpecifierCache) === null || _a === void 0 ? void 0 : _a.call(host);
  const getModuleSpecifierResolutionHost = ts.memoizeOne(function(isFromPackageJson) {
    return ts.createModuleSpecifierResolutionHost(
        isFromPackageJson ? host.getPackageJsonAutoImportProvider() : program, host);
  });
  function addSymbol(moduleSymbol, toFile, exportedSymbol, exportKind, program, isFromPackageJson) {
    const moduleSpecifierResolutionHost = getModuleSpecifierResolutionHost(isFromPackageJson);
    if (toFile &&
            ts.isImportableFile(
                program, fromFile, toFile, preferences, packageJsonFilter, moduleSpecifierResolutionHost,
                moduleSpecifierCache) ||
        !toFile && packageJsonFilter.allowsImportingAmbientModule(moduleSymbol, moduleSpecifierResolutionHost)) {
      const checker = program.getTypeChecker();
      originalSymbolToExportInfos.add(ts.getUniqueSymbolId(exportedSymbol, checker).toString(), {
        symbol: exportedSymbol,
        moduleSymbol,
        moduleFileName: toFile === null || toFile === void 0 ? void 0 : toFile.fileName,
        exportKind,
        targetFlags: ts.skipAlias(exportedSymbol, checker).flags,
        isFromPackageJson
      });
    }
  }
  ts.forEachExternalModuleToImportFrom(
      program, host, preferences, useAutoImportProvider,
      function(moduleSymbol, sourceFile, program, isFromPackageJson) {
        const checker = program.getTypeChecker();
        cancellationToken.throwIfCancellationRequested();
        const compilerOptions = program.getCompilerOptions();
        const defaultInfo = ts.getDefaultLikeExportInfo(moduleSymbol, checker, compilerOptions);
        if (defaultInfo &&
            (defaultInfo.name === symbolName ||
             moduleSymbolToValidIdentifier(moduleSymbol, ts.getEmitScriptTarget(compilerOptions), isJsxTagName) ===
                 symbolName) &&
            symbolHasMeaning(defaultInfo.symbolForMeaning, currentTokenMeaning)) {
          addSymbol(moduleSymbol, sourceFile, defaultInfo.symbol, defaultInfo.exportKind, program, isFromPackageJson);
        }
        // check exports with the same name
        const exportSymbolWithIdenticalName = checker.tryGetMemberInModuleExportsAndProperties(symbolName, moduleSymbol);
        if (exportSymbolWithIdenticalName && symbolHasMeaning(exportSymbolWithIdenticalName, currentTokenMeaning)) {
          addSymbol(
              moduleSymbol, sourceFile, exportSymbolWithIdenticalName, 0 /* ExportKind.Named */, program,
              isFromPackageJson);
        }
      });
  return originalSymbolToExportInfos;
}
function getExportEqualsImportKind(importingFile, compilerOptions, forceImportKeyword) {
  const allowSyntheticDefaults = ts.getAllowSyntheticDefaultImports(compilerOptions);
  const isJS = ts.isInJSFile(importingFile);
  // 1. 'import =' will not work in es2015+ TS files, so the decision is between a default
  //    and a namespace import, based on allowSyntheticDefaultImports/esModuleInterop.
  if (!isJS && ts.getEmitModuleKind(compilerOptions) >= ts.ModuleKind.ES2015) {
    return allowSyntheticDefaults ? 1 /* ImportKind.Default */ : 2 /* ImportKind.Namespace */;
  }
  // 2. 'import =' will not work in JavaScript, so the decision is between a default import,
  //    a namespace import, and const/require.
  if (isJS) {
    return ts.isExternalModule(importingFile) || forceImportKeyword ?
        allowSyntheticDefaults ? 1 /* ImportKind.Default */ : 2 /* ImportKind.Namespace */
        :
        3 /* ImportKind.CommonJS */;
  }
  // 3. At this point the most correct choice is probably 'import =', but people
  //    really hate that, so look to see if the importing file has any precedent
  //    on how to handle it.
  for (let _i = 0, _a = importingFile.statements; _i < _a.length; _i++) {
    const statement = _a[_i];
    // `import foo` parses as an ImportEqualsDeclaration even though it could be an ImportDeclaration
    if (ts.isImportEqualsDeclaration(statement) && !ts.nodeIsMissing(statement.moduleReference)) {
      return 3 /* ImportKind.CommonJS */;
    }
  }
  // 4. We have no precedent to go on, so just use a default import if
  //    allowSyntheticDefaultImports/esModuleInterop is enabled.
  return allowSyntheticDefaults ? 1 /* ImportKind.Default */ : 3 /* ImportKind.CommonJS */;
}
function codeActionForFix(
    context, sourceFile, symbolName, fix, includeSymbolNameInDescription, quotePreference, compilerOptions) {
  let diag;
  const changes = ts.textChanges.ChangeTracker.with(context, function(tracker) {
    diag = codeActionForFixWorker(
        tracker, sourceFile, symbolName, fix, includeSymbolNameInDescription, quotePreference, compilerOptions);
  });
  return codefix.createCodeFixAction(
      codefix.importFixName, changes, diag, importFixId, ts.Diagnostics.Add_all_missing_imports);
}
function codeActionForFixWorker(
    changes, sourceFile, symbolName, fix, includeSymbolNameInDescription, quotePreference, compilerOptions) {
  switch (fix.kind) {
    case 0 /* ImportFixKind.UseNamespace */:
      addNamespaceQualifier(changes, sourceFile, fix);
      return [ts.Diagnostics.Change_0_to_1, symbolName, ''.concat(fix.namespacePrefix, '.').concat(symbolName)];
    case 1 /* ImportFixKind.JsdocTypeImport */:
      addImportType(changes, sourceFile, fix, quotePreference);
      return [
        ts.Diagnostics.Change_0_to_1, symbolName, getImportTypePrefix(fix.moduleSpecifier, quotePreference) + symbolName
      ];
    case 2 /* ImportFixKind.AddToExisting */: {
      var importClauseOrBindingPattern = fix.importClauseOrBindingPattern, importKind = fix.importKind,
          addAsTypeOnly = fix.addAsTypeOnly, moduleSpecifier = fix.moduleSpecifier;
      doAddExistingFix(
          changes, sourceFile, importClauseOrBindingPattern,
          importKind === 1 /* ImportKind.Default */ ? {name: symbolName, addAsTypeOnly} : undefined,
          importKind === 0 /* ImportKind.Named */ ? [{name: symbolName, addAsTypeOnly}] : ts.emptyArray,
          compilerOptions);
      const moduleSpecifierWithoutQuotes = ts.stripQuotes(moduleSpecifier);
      return includeSymbolNameInDescription ?
          [ts.Diagnostics.Import_0_from_1, symbolName, moduleSpecifierWithoutQuotes] :
          [ts.Diagnostics.Update_import_from_0, moduleSpecifierWithoutQuotes];
    }
    case 3 /* ImportFixKind.AddNew */: {
      var importKind = fix.importKind, moduleSpecifier = fix.moduleSpecifier, addAsTypeOnly = fix.addAsTypeOnly,
          useRequire = fix.useRequire;
      const getDeclarations = useRequire ? getNewRequires : getNewImports;
      const defaultImport =
          importKind === 1 /* ImportKind.Default */ ? {name: symbolName, addAsTypeOnly} : undefined;
      const namedImports =
          importKind === 0 /* ImportKind.Named */ ? [{name: symbolName, addAsTypeOnly}] : undefined;
      const namespaceLikeImport =
          importKind === 2 /* ImportKind.Namespace */ || importKind === 3 /* ImportKind.CommonJS */ ?
          {importKind, name: symbolName, addAsTypeOnly} :
          undefined;
      ts.insertImports(
          changes, sourceFile,
          getDeclarations(moduleSpecifier, quotePreference, defaultImport, namedImports, namespaceLikeImport),
          /* blankLineBetween*/ true);
      return includeSymbolNameInDescription ? [ts.Diagnostics.Import_0_from_1, symbolName, moduleSpecifier] :
                                              [ts.Diagnostics.Add_import_from_0, moduleSpecifier];
    }
    case 4 /* ImportFixKind.PromoteTypeOnly */: {
      const typeOnlyAliasDeclaration = fix.typeOnlyAliasDeclaration;
      const promotedDeclaration = promoteFromTypeOnly(changes, typeOnlyAliasDeclaration, compilerOptions, sourceFile);
      return promotedDeclaration.kind === 273 /* SyntaxKind.ImportSpecifier */
          ?
          [
            ts.Diagnostics.Remove_type_from_import_of_0_from_1, symbolName,
            getModuleSpecifierText(promotedDeclaration.parent.parent)
          ] :
          [ts.Diagnostics.Remove_type_from_import_declaration_from_0, getModuleSpecifierText(promotedDeclaration)];
    }
    default:
      return ts.Debug.assertNever(fix, 'Unexpected fix kind '.concat(fix.kind));
  }
}
function getModuleSpecifierText(promotedDeclaration) {
  let _a, _b;
  return promotedDeclaration.kind === 268 /* SyntaxKind.ImportEqualsDeclaration */
      ?
      ((_b = ts.tryCast(
            (_a = ts.tryCast(promotedDeclaration.moduleReference, ts.isExternalModuleReference)) === null ||
                    _a === void 0 ?
                void 0 :
                _a.expression,
            ts.isStringLiteralLike)) === null ||
               _b === void 0 ?
           void 0 :
           _b.text) ||
          promotedDeclaration.moduleReference.getText() :
      ts.cast(promotedDeclaration.parent.moduleSpecifier, ts.isStringLiteral).text;
}
function promoteFromTypeOnly(changes, aliasDeclaration, compilerOptions, sourceFile) {
  // See comment in `doAddExistingFix` on constant with the same name.
  const convertExistingToTypeOnly = compilerOptions.preserveValueImports && compilerOptions.isolatedModules;
  switch (aliasDeclaration.kind) {
    case 273 /* SyntaxKind.ImportSpecifier */:
      if (aliasDeclaration.isTypeOnly) {
        if (aliasDeclaration.parent.elements.length > 1 &&
            ts.OrganizeImports.importSpecifiersAreSorted(aliasDeclaration.parent.elements)) {
          changes.delete(sourceFile, aliasDeclaration);
          const newSpecifier = ts.factory.updateImportSpecifier(
              aliasDeclaration, /* isTypeOnly*/ false, aliasDeclaration.propertyName, aliasDeclaration.name);
          const insertionIndex =
              ts.OrganizeImports.getImportSpecifierInsertionIndex(aliasDeclaration.parent.elements, newSpecifier);
          changes.insertImportSpecifierAtIndex(sourceFile, newSpecifier, aliasDeclaration.parent, insertionIndex);
        } else {
          changes.deleteRange(sourceFile, aliasDeclaration.getFirstToken());
        }
        return aliasDeclaration;
      }
        ts.Debug.assert(aliasDeclaration.parent.parent.isTypeOnly);
        promoteImportClause(aliasDeclaration.parent.parent);
        return aliasDeclaration.parent.parent;

    case 270 /* SyntaxKind.ImportClause */:
      promoteImportClause(aliasDeclaration);
      return aliasDeclaration;
    case 271 /* SyntaxKind.NamespaceImport */:
      promoteImportClause(aliasDeclaration.parent);
      return aliasDeclaration.parent;
    case 268 /* SyntaxKind.ImportEqualsDeclaration */:
      changes.deleteRange(sourceFile, aliasDeclaration.getChildAt(1));
      return aliasDeclaration;
    default:
      ts.Debug.failBadSyntaxKind(aliasDeclaration);
  }
  function promoteImportClause(importClause) {
    changes.delete(sourceFile, ts.getTypeKeywordOfTypeOnlyImport(importClause, sourceFile));
    if (convertExistingToTypeOnly) {
      const namedImports = ts.tryCast(importClause.namedBindings, ts.isNamedImports);
      if (namedImports && namedImports.elements.length > 1) {
        if (ts.OrganizeImports.importSpecifiersAreSorted(namedImports.elements) &&
            aliasDeclaration.kind === 273 /* SyntaxKind.ImportSpecifier */ &&
            namedImports.elements.indexOf(aliasDeclaration) !== 0) {
          // The import specifier being promoted will be the only non-type-only,
          //  import in the NamedImports, so it should be moved to the front.
          changes.delete(sourceFile, aliasDeclaration);
          changes.insertImportSpecifierAtIndex(sourceFile, aliasDeclaration, namedImports, 0);
        }
        for (let _i = 0, _a = namedImports.elements; _i < _a.length; _i++) {
          const element = _a[_i];
          if (element !== aliasDeclaration && !element.isTypeOnly) {
            changes.insertModifierBefore(sourceFile, 154 /* SyntaxKind.TypeKeyword */, element);
          }
        }
      }
    }
  }
}
function doAddExistingFix(changes, sourceFile, clause, defaultImport, namedImports, compilerOptions) {
  let _a;
  if (clause.kind === 203 /* SyntaxKind.ObjectBindingPattern */) {
    if (defaultImport) {
      addElementToBindingPattern(clause, defaultImport.name, 'default');
    }
    for (let _i = 0, namedImports_1 = namedImports; _i < namedImports_1.length; _i++) {
      var specifier = namedImports_1[_i];
      addElementToBindingPattern(clause, specifier.name, /* propertyName*/ undefined);
    }
    return;
  }
  const promoteFromTypeOnly =
      clause.isTypeOnly && ts.some(__spreadArray([defaultImport], namedImports, true), function(i) {
        return (i === null || i === void 0 ? void 0 : i.addAsTypeOnly) === 4 /* AddAsTypeOnly.NotAllowed */;
      });
  const existingSpecifiers = clause.namedBindings &&
      ((_a = ts.tryCast(clause.namedBindings, ts.isNamedImports)) === null || _a === void 0 ? void 0 : _a.elements);
  // If we are promoting from a type-only import and `--isolatedModules` and `--preserveValueImports`
  // are enabled, we need to make every existing import specifier type-only. It may be possible that
  // some of them don't strictly need to be marked type-only (if they have a value meaning and are
  // never used in an emitting position). These are allowed to be imported without being type-only,
  // but the user has clearly already signified that they don't need them to be present at runtime
  // by placing them in a type-only import. So, just mark each specifier as type-only.
  const convertExistingToTypeOnly =
      promoteFromTypeOnly && compilerOptions.preserveValueImports && compilerOptions.isolatedModules;
  if (defaultImport) {
    ts.Debug.assert(!clause.name, 'Cannot add a default import to an import clause that already has one');
    changes.insertNodeAt(
        sourceFile, clause.getStart(sourceFile), ts.factory.createIdentifier(defaultImport.name), {suffix: ', '});
  }
  if (namedImports.length) {
    const newSpecifiers = ts.stableSort(
        namedImports.map(function(namedImport) {
          return ts.factory.createImportSpecifier(
              (!clause.isTypeOnly || promoteFromTypeOnly) && needsTypeOnly(namedImport),
              /* propertyName*/ undefined, ts.factory.createIdentifier(namedImport.name));
        }),
        ts.OrganizeImports.compareImportOrExportSpecifiers);
    if ((existingSpecifiers === null || existingSpecifiers === void 0 ? void 0 : existingSpecifiers.length) &&
        ts.OrganizeImports.importSpecifiersAreSorted(existingSpecifiers)) {
      for (let _b = 0, newSpecifiers_1 = newSpecifiers; _b < newSpecifiers_1.length; _b++) {
        var spec = newSpecifiers_1[_b];
        // Organize imports puts type-only import specifiers last, so if we're
        // adding a non-type-only specifier and converting all the other ones to
        // type-only, there's no need to ask for the insertion index - it's 0.
        const insertionIndex = convertExistingToTypeOnly && !spec.isTypeOnly ?
            0 :
            ts.OrganizeImports.getImportSpecifierInsertionIndex(existingSpecifiers, spec);
        changes.insertImportSpecifierAtIndex(sourceFile, spec, clause.namedBindings, insertionIndex);
      }
    } else if (existingSpecifiers === null || existingSpecifiers === void 0 ? void 0 : existingSpecifiers.length) {
      for (let _c = 0, newSpecifiers_2 = newSpecifiers; _c < newSpecifiers_2.length; _c++) {
        var spec = newSpecifiers_2[_c];
        changes.insertNodeInListAfter(sourceFile, ts.last(existingSpecifiers), spec, existingSpecifiers);
      }
    } else {
      if (newSpecifiers.length) {
        const namedImports_2 = ts.factory.createNamedImports(newSpecifiers);
        if (clause.namedBindings) {
          changes.replaceNode(sourceFile, clause.namedBindings, namedImports_2);
        } else {
          changes.insertNodeAfter(
              sourceFile,
              ts.Debug.checkDefined(clause.name, 'Import clause must have either named imports or a default import'),
              namedImports_2);
        }
      }
    }
  }
  if (promoteFromTypeOnly) {
    changes.delete(sourceFile, ts.getTypeKeywordOfTypeOnlyImport(clause, sourceFile));
    if (convertExistingToTypeOnly && existingSpecifiers) {
      for (let _d = 0, existingSpecifiers_1 = existingSpecifiers; _d < existingSpecifiers_1.length; _d++) {
        var specifier = existingSpecifiers_1[_d];
        changes.insertModifierBefore(sourceFile, 154 /* SyntaxKind.TypeKeyword */, specifier);
      }
    }
  }
  function addElementToBindingPattern(bindingPattern, name, propertyName) {
    const element = ts.factory.createBindingElement(/* dotDotDotToken*/ undefined, propertyName, name);
    if (bindingPattern.elements.length) {
      changes.insertNodeInListAfter(sourceFile, ts.last(bindingPattern.elements), element);
    } else {
      changes.replaceNode(sourceFile, bindingPattern, ts.factory.createObjectBindingPattern([element]));
    }
  }
}
function addNamespaceQualifier(changes, sourceFile, _a) {
  const namespacePrefix = _a.namespacePrefix, position = _a.position;
  changes.insertText(sourceFile, position, namespacePrefix + '.');
}
function addImportType(changes, sourceFile, _a, quotePreference) {
  const moduleSpecifier = _a.moduleSpecifier, position = _a.position;
  changes.insertText(sourceFile, position, getImportTypePrefix(moduleSpecifier, quotePreference));
}
function getImportTypePrefix(moduleSpecifier, quotePreference) {
  const quote = ts.getQuoteFromPreference(quotePreference);
  return 'import('.concat(quote).concat(moduleSpecifier).concat(quote, ').');
}
function needsTypeOnly(_a) {
  const addAsTypeOnly = _a.addAsTypeOnly;
  return addAsTypeOnly === 2 /* AddAsTypeOnly.Required */;
}
function getNewImports(moduleSpecifier, quotePreference, defaultImport, namedImports, namespaceLikeImport) {
  const quotedModuleSpecifier = ts.makeStringLiteral(moduleSpecifier, quotePreference);
  let statements;
  if (defaultImport !== undefined ||
      (namedImports === null || namedImports === void 0 ? void 0 : namedImports.length)) {
    const topLevelTypeOnly_1 = (!defaultImport || needsTypeOnly(defaultImport)) && ts.every(namedImports, needsTypeOnly);
    statements = ts.combine(
        statements,
        ts.makeImport(
            defaultImport && ts.factory.createIdentifier(defaultImport.name),
            namedImports === null || namedImports === void 0 ? void 0 : namedImports.map(function(_a) {
              const addAsTypeOnly = _a.addAsTypeOnly, name = _a.name;
              return ts.factory.createImportSpecifier(
                  !topLevelTypeOnly_1 && addAsTypeOnly === 2 /* AddAsTypeOnly.Required */,
                  /* propertyName*/ undefined, ts.factory.createIdentifier(name));
            }),
            moduleSpecifier, quotePreference, topLevelTypeOnly_1));
  }
  if (namespaceLikeImport) {
    const declaration = namespaceLikeImport.importKind === 3 /* ImportKind.CommonJS */
        ?
        ts.factory.createImportEqualsDeclaration(
            /* modifiers*/ undefined, needsTypeOnly(namespaceLikeImport),
            ts.factory.createIdentifier(namespaceLikeImport.name),
            ts.factory.createExternalModuleReference(quotedModuleSpecifier)) :
        ts.factory.createImportDeclaration(
            /* modifiers*/ undefined,
            ts.factory.createImportClause(
                needsTypeOnly(namespaceLikeImport),
                /* name*/ undefined,
                ts.factory.createNamespaceImport(ts.factory.createIdentifier(namespaceLikeImport.name))),
            quotedModuleSpecifier,
            /* assertClause*/ undefined);
    statements = ts.combine(statements, declaration);
  }
  return ts.Debug.checkDefined(statements);
}
function getNewRequires(moduleSpecifier, quotePreference, defaultImport, namedImports, namespaceLikeImport) {
  const quotedModuleSpecifier = ts.makeStringLiteral(moduleSpecifier, quotePreference);
  let statements;
  // const { default: foo, bar, etc } = require('./mod');
  if (defaultImport || (namedImports === null || namedImports === void 0 ? void 0 : namedImports.length)) {
    const bindingElements =
        (namedImports === null || namedImports === void 0 ? void 0 : namedImports.map(function(_a) {
          const name = _a.name;
          return ts.factory.createBindingElement(/* dotDotDotToken*/ undefined, /* propertyName*/ undefined, name);
        })) ||
        [];
    if (defaultImport) {
      bindingElements.unshift(
          ts.factory.createBindingElement(/* dotDotDotToken*/ undefined, 'default', defaultImport.name));
    }
    var declaration = createConstEqualsRequireDeclaration(
        ts.factory.createObjectBindingPattern(bindingElements), quotedModuleSpecifier);
    statements = ts.combine(statements, declaration);
  }
  // const foo = require('./mod');
  if (namespaceLikeImport) {
    var declaration = createConstEqualsRequireDeclaration(namespaceLikeImport.name, quotedModuleSpecifier);
    statements = ts.combine(statements, declaration);
  }
  return ts.Debug.checkDefined(statements);
}
function createConstEqualsRequireDeclaration(name, quotedModuleSpecifier) {
  return ts.factory.createVariableStatement(
      /* modifiers*/ undefined,
      ts.factory.createVariableDeclarationList(
          [ts.factory.createVariableDeclaration(
              typeof name === 'string' ? ts.factory.createIdentifier(name) : name,
              /* exclamationToken*/ undefined,
              /* type*/ undefined,
              ts.factory.createCallExpression(
                  ts.factory.createIdentifier('require'), /* typeArguments*/ undefined, [quotedModuleSpecifier]))],
          2 /* NodeFlags.Const */));
}
function symbolHasMeaning(_a, meaning) {
  const declarations = _a.declarations;
  return ts.some(declarations, function(decl) {
    return !!(ts.getMeaningFromDeclaration(decl) & meaning);
  });
}
function moduleSymbolToValidIdentifier(moduleSymbol, target, forceCapitalize) {
  return moduleSpecifierToValidIdentifier(
      ts.removeFileExtension(ts.stripQuotes(moduleSymbol.name)), target, forceCapitalize);
}
codefix.moduleSymbolToValidIdentifier = moduleSymbolToValidIdentifier;
function moduleSpecifierToValidIdentifier(moduleSpecifier, target, forceCapitalize) {
  const baseName = ts.getBaseFileName(ts.removeSuffix(moduleSpecifier, '/index'));
  let res = '';
  let lastCharWasValid = true;
  const firstCharCode = baseName.charCodeAt(0);
  if (ts.isIdentifierStart(firstCharCode, target)) {
    res += String.fromCharCode(firstCharCode);
    if (forceCapitalize) {
      res = res.toUpperCase();
    }
  } else {
    lastCharWasValid = false;
  }
  for (let i = 1; i < baseName.length; i++) {
    const ch = baseName.charCodeAt(i);
    const isValid = ts.isIdentifierPart(ch, target);
    if (isValid) {
      let char = String.fromCharCode(ch);
      if (!lastCharWasValid) {
        char = char.toUpperCase();
      }
      res += char;
    }
    lastCharWasValid = isValid;
  }
  // Need `|| "_"` to ensure result isn't empty.
  return !ts.isStringANonContextualKeyword(res) ? res || '_' : '_'.concat(res);
}
codefix.moduleSpecifierToValidIdentifier = moduleSpecifierToValidIdentifier;
})(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let codefix;
(function(codefix) {
const fixId = 'addMissingConstraint';
const errorCodes = [
  // We want errors this could be attached to:
  // Diagnostics.This_type_parameter_probably_needs_an_extends_0_constraint
  ts.Diagnostics.Type_0_is_not_comparable_to_type_1.code,
  ts.Diagnostics.Type_0_is_not_assignable_to_type_1_Two_different_types_with_this_name_exist_but_they_are_unrelated
      .code,
  ts.Diagnostics
      .Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_types_of_the_target_s_properties
      .code,
  ts.Diagnostics.Type_0_is_not_assignable_to_type_1.code,
  ts.Diagnostics
      .Argument_of_type_0_is_not_assignable_to_parameter_of_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_types_of_the_target_s_properties
      .code,
  ts.Diagnostics.Property_0_is_incompatible_with_index_signature.code,
  ts.Diagnostics.Property_0_in_type_1_is_not_assignable_to_type_2.code,
  ts.Diagnostics.Type_0_does_not_satisfy_the_constraint_1.code,
];
codefix.registerCodeFix({
  errorCodes,
  getCodeActions: function(context) {
    const sourceFile = context.sourceFile, span = context.span, program = context.program,
        preferences = context.preferences, host = context.host;
    const info = getInfo(program, sourceFile, span);
    if (info === undefined)
      {return;}
    const changes = ts.textChanges.ChangeTracker.with(context, function(t) {
      return addMissingConstraint(t, program, preferences, host, sourceFile, info);
    });
    return [codefix.createCodeFixAction(
        fixId, changes, ts.Diagnostics.Add_extends_constraint, fixId,
        ts.Diagnostics.Add_extends_constraint_to_all_type_parameters)];
  },
  fixIds: [fixId],
  getAllCodeActions: function(context) {
    const program = context.program, preferences = context.preferences, host = context.host;
    const seen = new ts.Map();
    return codefix.createCombinedCodeActions(ts.textChanges.ChangeTracker.with(context, function(changes) {
      codefix.eachDiagnostic(context, errorCodes, function(diag) {
        const info = getInfo(program, diag.file, ts.createTextSpan(diag.start, diag.length));
        if (info) {
          if (ts.addToSeen(seen, ts.getNodeId(info.declaration))) {
            return addMissingConstraint(changes, program, preferences, host, diag.file, info);
          }
        }
        return undefined;
      });
    }));
  }
});
function getInfo(program, sourceFile, span) {
  const diag = ts.find(program.getSemanticDiagnostics(sourceFile), function(diag) {
    return diag.start === span.start && diag.length === span.length;
  });
  if (diag === undefined || diag.relatedInformation === undefined)
    {return;}
  const related = ts.find(diag.relatedInformation, function(related) {
    return related.code === ts.Diagnostics.This_type_parameter_might_need_an_extends_0_constraint.code;
  });
  if (related === undefined || related.file === undefined || related.start === undefined ||
      related.length === undefined)
    {return;}
  let declaration = codefix.findAncestorMatchingSpan(related.file, ts.createTextSpan(related.start, related.length));
  if (declaration === undefined)
    {return;}
  if (ts.isIdentifier(declaration) && ts.isTypeParameterDeclaration(declaration.parent)) {
    declaration = declaration.parent;
  }
  if (ts.isTypeParameterDeclaration(declaration)) {
    // should only issue fix on type parameters written using `extends`
    if (ts.isMappedTypeNode(declaration.parent))
      {return;}
    const token = ts.getTokenAtPosition(sourceFile, span.start);
    const checker = program.getTypeChecker();
    const constraint = tryGetConstraintType(checker, token) || tryGetConstraintFromDiagnosticMessage(related.messageText);
    return {constraint, declaration, token};
  }
  return undefined;
}
function addMissingConstraint(changes, program, preferences, host, sourceFile, info) {
  const declaration = info.declaration, constraint = info.constraint;
  const checker = program.getTypeChecker();
  if (ts.isString(constraint)) {
    changes.insertText(sourceFile, declaration.name.end, ' extends '.concat(constraint));
  } else {
    const scriptTarget = ts.getEmitScriptTarget(program.getCompilerOptions());
    const tracker = codefix.getNoopSymbolTrackerWithResolver({program, host});
    const importAdder = codefix.createImportAdder(sourceFile, program, preferences, host);
    const typeNode = codefix.typeToAutoImportableTypeNode(
        checker, importAdder, constraint, /* contextNode*/ undefined, scriptTarget, /* flags*/ undefined, tracker);
    if (typeNode) {
      changes.replaceNode(
          sourceFile, declaration,
          ts.factory.updateTypeParameterDeclaration(
              declaration, /* modifiers*/ undefined, declaration.name, typeNode, declaration.default));
      importAdder.writeFixes(changes);
    }
  }
}
function tryGetConstraintFromDiagnosticMessage(messageText) {
  const _a = ts.flattenDiagnosticMessageText(messageText, '\n', 0).match(/`extends (.*)`/) || [], _ = _a[0],
      constraint = _a[1];
  return constraint;
}
function tryGetConstraintType(checker, node) {
  if (ts.isTypeNode(node.parent)) {
    return checker.getTypeArgumentConstraint(node.parent);
  }
  const contextualType = ts.isExpression(node) ? checker.getContextualType(node) : undefined;
  return contextualType || checker.getTypeAtLocation(node);
}
})(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let codefix;
(function(codefix) {
let _a;
const fixName = 'fixOverrideModifier';
const fixAddOverrideId = 'fixAddOverrideModifier';
const fixRemoveOverrideId = 'fixRemoveOverrideModifier';
const errorCodes = [
  ts.Diagnostics.This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0.code,
  ts.Diagnostics
      .This_member_cannot_have_an_override_modifier_because_its_containing_class_0_does_not_extend_another_class.code,
  ts.Diagnostics
      .This_member_must_have_an_override_modifier_because_it_overrides_an_abstract_method_that_is_declared_in_the_base_class_0
      .code,
  ts.Diagnostics.This_member_must_have_an_override_modifier_because_it_overrides_a_member_in_the_base_class_0.code,
  ts.Diagnostics.This_parameter_property_must_have_an_override_modifier_because_it_overrides_a_member_in_base_class_0
      .code,
  ts.Diagnostics
      .This_member_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_in_the_base_class_0
      .code,
  ts.Diagnostics
      .This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_its_containing_class_0_does_not_extend_another_class
      .code,
  ts.Diagnostics
      .This_parameter_property_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_in_the_base_class_0
      .code,
  ts.Diagnostics
      .This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base_class_0.code,
];
const errorCodeFixIdMap =
    (_a = {},
     // case #1:
     _a[ts.Diagnostics.This_member_must_have_an_override_modifier_because_it_overrides_a_member_in_the_base_class_0
            .code] = {
       descriptions: ts.Diagnostics.Add_override_modifier,
       fixId: fixAddOverrideId,
       fixAllDescriptions: ts.Diagnostics.Add_all_missing_override_modifiers,
     },
     _a[ts.Diagnostics
            .This_member_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_in_the_base_class_0
            .code] = {
       descriptions: ts.Diagnostics.Add_override_modifier,
       fixId: fixAddOverrideId,
       fixAllDescriptions: ts.Diagnostics.Add_all_missing_override_modifiers
     },
     // case #2:
     _a[ts.Diagnostics
            .This_member_cannot_have_an_override_modifier_because_its_containing_class_0_does_not_extend_another_class
            .code] = {
       descriptions: ts.Diagnostics.Remove_override_modifier,
       fixId: fixRemoveOverrideId,
       fixAllDescriptions: ts.Diagnostics.Remove_all_unnecessary_override_modifiers,
     },
     _a[ts.Diagnostics
            .This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_its_containing_class_0_does_not_extend_another_class
            .code] = {
       descriptions: ts.Diagnostics.Remove_override_modifier,
       fixId: fixRemoveOverrideId,
       fixAllDescriptions: ts.Diagnostics.Remove_override_modifier
     },
     // case #3:
     _a[ts.Diagnostics
            .This_parameter_property_must_have_an_override_modifier_because_it_overrides_a_member_in_base_class_0
            .code] = {
       descriptions: ts.Diagnostics.Add_override_modifier,
       fixId: fixAddOverrideId,
       fixAllDescriptions: ts.Diagnostics.Add_all_missing_override_modifiers,
     },
     _a[ts.Diagnostics
            .This_parameter_property_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_in_the_base_class_0
            .code] = {
       descriptions: ts.Diagnostics.Add_override_modifier,
       fixId: fixAddOverrideId,
       fixAllDescriptions: ts.Diagnostics.Add_all_missing_override_modifiers,
     },
     // case #4:
     _a[ts.Diagnostics
            .This_member_must_have_an_override_modifier_because_it_overrides_an_abstract_method_that_is_declared_in_the_base_class_0
            .code] = {
       descriptions: ts.Diagnostics.Add_override_modifier,
       fixId: fixAddOverrideId,
       fixAllDescriptions: ts.Diagnostics.Remove_all_unnecessary_override_modifiers,
     },
     // case #5:
     _a[ts.Diagnostics.This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0
            .code] = {
       descriptions: ts.Diagnostics.Remove_override_modifier,
       fixId: fixRemoveOverrideId,
       fixAllDescriptions: ts.Diagnostics.Remove_all_unnecessary_override_modifiers,
     },
     _a[ts.Diagnostics
            .This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base_class_0
            .code] = {
       descriptions: ts.Diagnostics.Remove_override_modifier,
       fixId: fixRemoveOverrideId,
       fixAllDescriptions: ts.Diagnostics.Remove_all_unnecessary_override_modifiers,
     },
     _a);
codefix.registerCodeFix({
  errorCodes,
  getCodeActions: function getCodeActionsToFixOverrideModifierIssues(context) {
    const errorCode = context.errorCode, span = context.span;
    const info = errorCodeFixIdMap[errorCode];
    if (!info)
      {return ts.emptyArray;}
    const descriptions = info.descriptions, fixId = info.fixId, fixAllDescriptions = info.fixAllDescriptions;
    const changes = ts.textChanges.ChangeTracker.with(context, function(changes) {
      return dispatchChanges(changes, context, errorCode, span.start);
    });
    return [codefix.createCodeFixActionMaybeFixAll(fixName, changes, descriptions, fixId, fixAllDescriptions)];
  },
  fixIds: [fixName, fixAddOverrideId, fixRemoveOverrideId],
  getAllCodeActions: function(context) {
    return codefix.codeFixAll(context, errorCodes, function(changes, diag) {
      const code = diag.code, start = diag.start;
      const info = errorCodeFixIdMap[code];
      if (!info || info.fixId !== context.fixId) {
        return;
      }
      dispatchChanges(changes, context, code, start);
    });
  }
});
function dispatchChanges(changeTracker, context, errorCode, pos) {
  switch (errorCode) {
    case ts.Diagnostics.This_member_must_have_an_override_modifier_because_it_overrides_a_member_in_the_base_class_0
        .code:
    case ts.Diagnostics
        .This_member_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_in_the_base_class_0
        .code:
    case ts.Diagnostics
        .This_member_must_have_an_override_modifier_because_it_overrides_an_abstract_method_that_is_declared_in_the_base_class_0
        .code:
    case ts.Diagnostics
        .This_parameter_property_must_have_an_override_modifier_because_it_overrides_a_member_in_base_class_0.code:
    case ts.Diagnostics
        .This_parameter_property_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_in_the_base_class_0
        .code:
      return doAddOverrideModifierChange(changeTracker, context.sourceFile, pos);
    case ts.Diagnostics.This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0
        .code:
    case ts.Diagnostics
        .This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base_class_0
        .code:
    case ts.Diagnostics
        .This_member_cannot_have_an_override_modifier_because_its_containing_class_0_does_not_extend_another_class.code:
    case ts.Diagnostics
        .This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_its_containing_class_0_does_not_extend_another_class
        .code:
      return doRemoveOverrideModifierChange(changeTracker, context.sourceFile, pos);
    default:
      ts.Debug.fail('Unexpected error code: ' + errorCode);
  }
}
function doAddOverrideModifierChange(changeTracker, sourceFile, pos) {
  const classElement = findContainerClassElementLike(sourceFile, pos);
  if (ts.isSourceFileJS(sourceFile)) {
    changeTracker.addJSDocTags(
        sourceFile, classElement, [ts.factory.createJSDocOverrideTag(ts.factory.createIdentifier('override'))]);
    return;
  }
  const modifiers = classElement.modifiers || ts.emptyArray;
  const staticModifier = ts.find(modifiers, ts.isStaticModifier);
  const abstractModifier = ts.find(modifiers, ts.isAbstractModifier);
  const accessibilityModifier = ts.find(modifiers, function(m) {
    return ts.isAccessibilityModifier(m.kind);
  });
  const lastDecorator = ts.findLast(modifiers, ts.isDecorator);
  const modifierPos = abstractModifier ? abstractModifier.end :
      staticModifier                 ? staticModifier.end :
      accessibilityModifier          ? accessibilityModifier.end :
      lastDecorator                  ? ts.skipTrivia(sourceFile.text, lastDecorator.end) :
                                       classElement.getStart(sourceFile);
  const options = accessibilityModifier || staticModifier || abstractModifier ? {prefix: ' '} : {suffix: ' '};
  changeTracker.insertModifierAt(sourceFile, modifierPos, 161 /* SyntaxKind.OverrideKeyword */, options);
}
function doRemoveOverrideModifierChange(changeTracker, sourceFile, pos) {
  const classElement = findContainerClassElementLike(sourceFile, pos);
  if (ts.isSourceFileJS(sourceFile)) {
    changeTracker.filterJSDocTags(sourceFile, classElement, ts.not(ts.isJSDocOverrideTag));
    return;
  }
  const overrideModifier = ts.find(classElement.modifiers, ts.isOverrideModifier);
  ts.Debug.assertIsDefined(overrideModifier);
  changeTracker.deleteModifier(sourceFile, overrideModifier);
}
function isClassElementLikeHasJSDoc(node) {
  switch (node.kind) {
    case 173 /* SyntaxKind.Constructor */:
    case 169 /* SyntaxKind.PropertyDeclaration */:
    case 171 /* SyntaxKind.MethodDeclaration */:
    case 174 /* SyntaxKind.GetAccessor */:
    case 175 /* SyntaxKind.SetAccessor */:
      return true;
    case 166 /* SyntaxKind.Parameter */:
      return ts.isParameterPropertyDeclaration(node, node.parent);
    default:
      return false;
  }
}
function findContainerClassElementLike(sourceFile, pos) {
  const token = ts.getTokenAtPosition(sourceFile, pos);
  const classElement = ts.findAncestor(token, function(node) {
    if (ts.isClassLike(node))
      {return 'quit';}
    return isClassElementLikeHasJSDoc(node);
  });
  ts.Debug.assert(classElement && isClassElementLikeHasJSDoc(classElement));
  return classElement;
}
})(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let codefix;
(function(codefix) {
const fixId = 'fixNoPropertyAccessFromIndexSignature';
const errorCodes = [ts.Diagnostics.Property_0_comes_from_an_index_signature_so_it_must_be_accessed_with_0.code];
codefix.registerCodeFix({
  errorCodes,
  fixIds: [fixId],
  getCodeActions: function(context) {
    const sourceFile = context.sourceFile, span = context.span, preferences = context.preferences;
    const property = getPropertyAccessExpression(sourceFile, span.start);
    const changes = ts.textChanges.ChangeTracker.with(context, function(t) {
      return doChange(t, context.sourceFile, property, preferences);
    });
    return [codefix.createCodeFixAction(
        fixId, changes, [ts.Diagnostics.Use_element_access_for_0, property.name.text], fixId,
        ts.Diagnostics.Use_element_access_for_all_undeclared_properties)];
  },
  getAllCodeActions: function(context) {
    return codefix.codeFixAll(context, errorCodes, function(changes, diag) {
      return doChange(changes, diag.file, getPropertyAccessExpression(diag.file, diag.start), context.preferences);
    });
  }
});
function doChange(changes, sourceFile, node, preferences) {
  const quotePreference = ts.getQuotePreference(sourceFile, preferences);
  const argumentsExpression =
      ts.factory.createStringLiteral(node.name.text, quotePreference === 0 /* QuotePreference.Single */);
  changes.replaceNode(
      sourceFile, node,
      ts.isPropertyAccessChain(node) ?
          ts.factory.createElementAccessChain(node.expression, node.questionDotToken, argumentsExpression) :
          ts.factory.createElementAccessExpression(node.expression, argumentsExpression));
}
function getPropertyAccessExpression(sourceFile, pos) {
  return ts.cast(ts.getTokenAtPosition(sourceFile, pos).parent, ts.isPropertyAccessExpression);
}
})(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let codefix;
(function(codefix) {
const fixId = 'fixImplicitThis';
const errorCodes = [ts.Diagnostics.this_implicitly_has_type_any_because_it_does_not_have_a_type_annotation.code];
codefix.registerCodeFix({
  errorCodes,
  getCodeActions: function getCodeActionsToFixImplicitThis(context) {
    const sourceFile = context.sourceFile, program = context.program, span = context.span;
    let diagnostic;
    const changes = ts.textChanges.ChangeTracker.with(context, function(t) {
      diagnostic = doChange(t, sourceFile, span.start, program.getTypeChecker());
    });
    return diagnostic ?
        [codefix.createCodeFixAction(fixId, changes, diagnostic, fixId, ts.Diagnostics.Fix_all_implicit_this_errors)] :
        ts.emptyArray;
  },
  fixIds: [fixId],
  getAllCodeActions: function(context) {
    return codefix.codeFixAll(context, errorCodes, function(changes, diag) {
      doChange(changes, diag.file, diag.start, context.program.getTypeChecker());
    });
  },
});
function doChange(changes, sourceFile, pos, checker) {
  const token = ts.getTokenAtPosition(sourceFile, pos);
  if (!ts.isThis(token))
    {return undefined;}
  const fn = ts.getThisContainer(token, /* includeArrowFunctions*/ false);
  if (!ts.isFunctionDeclaration(fn) && !ts.isFunctionExpression(fn))
    {return undefined;}
  if (!ts.isSourceFile(ts.getThisContainer(
          fn, /* includeArrowFunctions*/ false))) {  // 'this' is defined outside, convert to arrow function
    const fnKeyword = ts.Debug.checkDefined(ts.findChildOfKind(fn, 98 /* SyntaxKind.FunctionKeyword */, sourceFile));
    const name = fn.name;
    const body = ts.Debug.checkDefined(fn.body);  // Should be defined because the function contained a 'this' expression
    if (ts.isFunctionExpression(fn)) {
      if (name && ts.FindAllReferences.Core.isSymbolReferencedInFile(name, checker, sourceFile, body)) {
        // Function expression references itself. To fix we would have to extract it to a const.
        return undefined;
      }
      // `function() {}` --> `() => {}`
      changes.delete(sourceFile, fnKeyword);
      if (name) {
        changes.delete(sourceFile, name);
      }
      changes.insertText(sourceFile, body.pos, ' =>');
      return [ts.Diagnostics.Convert_function_expression_0_to_arrow_function, name ? name.text : ts.ANONYMOUS];
    }
      // `function f() {}` => `const f = () => {}`
      // `name` should be defined because we only do this in inner contexts, and name is only undefined for `export default function() {}`.
      changes.replaceNode(sourceFile, fnKeyword, ts.factory.createToken(85 /* SyntaxKind.ConstKeyword */));
      changes.insertText(sourceFile, name.end, ' = ');
      changes.insertText(sourceFile, body.pos, ' =>');
      return [ts.Diagnostics.Convert_function_declaration_0_to_arrow_function, name.text];

  }
}
})(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let codefix;
(function(codefix) {
const fixId = 'fixImportNonExportedMember';
const errorCodes = [
  ts.Diagnostics.Module_0_declares_1_locally_but_it_is_not_exported.code,
];
codefix.registerCodeFix({
  errorCodes,
  fixIds: [fixId],
  getCodeActions: function(context) {
    const sourceFile = context.sourceFile, span = context.span, program = context.program;
    const info = getInfo(sourceFile, span.start, program);
    if (info === undefined)
      {return undefined;}
    const changes = ts.textChanges.ChangeTracker.with(context, function(t) {
      return doChange(t, program, info);
    });
    return [codefix.createCodeFixAction(
        fixId, changes, [ts.Diagnostics.Export_0_from_module_1, info.exportName.node.text, info.moduleSpecifier], fixId,
        ts.Diagnostics.Export_all_referenced_locals)];
  },
  getAllCodeActions: function(context) {
    const program = context.program;
    return codefix.createCombinedCodeActions(ts.textChanges.ChangeTracker.with(context, function(changes) {
      const exports = new ts.Map();
      codefix.eachDiagnostic(context, errorCodes, function(diag) {
        const info = getInfo(diag.file, diag.start, program);
        if (info === undefined)
          {return undefined;}
        const exportName = info.exportName, node = info.node, moduleSourceFile = info.moduleSourceFile;
        if (tryGetExportDeclaration(moduleSourceFile, exportName.isTypeOnly) === undefined &&
            ts.canHaveExportModifier(node)) {
          changes.insertExportModifier(moduleSourceFile, node);
        } else {
          const moduleExports = exports.get(moduleSourceFile) || {typeOnlyExports: [], exports: []};
          if (exportName.isTypeOnly) {
            moduleExports.typeOnlyExports.push(exportName);
          } else {
            moduleExports.exports.push(exportName);
          }
          exports.set(moduleSourceFile, moduleExports);
        }
      });
      exports.forEach(function(moduleExports, moduleSourceFile) {
        const exportDeclaration = tryGetExportDeclaration(moduleSourceFile, /* isTypeOnly*/ true);
        if (exportDeclaration && exportDeclaration.isTypeOnly) {
          doChanges(changes, program, moduleSourceFile, moduleExports.typeOnlyExports, exportDeclaration);
          doChanges(
              changes, program, moduleSourceFile, moduleExports.exports,
              tryGetExportDeclaration(moduleSourceFile, /* isTypeOnly*/ false));
        } else {
          doChanges(
              changes, program, moduleSourceFile,
              __spreadArray(__spreadArray([], moduleExports.exports, true), moduleExports.typeOnlyExports, true),
              exportDeclaration);
        }
      });
    }));
  }
});
function getInfo(sourceFile, pos, program) {
  let _a;
  const token = ts.getTokenAtPosition(sourceFile, pos);
  if (ts.isIdentifier(token)) {
    const importDeclaration = ts.findAncestor(token, ts.isImportDeclaration);
    if (importDeclaration === undefined)
      {return undefined;}
    const moduleSpecifier =
        ts.isStringLiteral(importDeclaration.moduleSpecifier) ? importDeclaration.moduleSpecifier.text : undefined;
    if (moduleSpecifier === undefined)
      {return undefined;}
    const resolvedModule = ts.getResolvedModule(sourceFile, moduleSpecifier, /* mode*/ undefined);
    if (resolvedModule === undefined)
      {return undefined;}
    const moduleSourceFile = program.getSourceFile(resolvedModule.resolvedFileName);
    if (moduleSourceFile === undefined || ts.isSourceFileFromLibrary(program, moduleSourceFile))
      {return undefined;}
    const moduleSymbol = moduleSourceFile.symbol;
    const locals = (_a = moduleSymbol.valueDeclaration) === null || _a === void 0 ? void 0 : _a.locals;
    if (locals === undefined)
      {return undefined;}
    const localSymbol = locals.get(token.escapedText);
    if (localSymbol === undefined)
      {return undefined;}
    const node = getNodeOfSymbol(localSymbol);
    if (node === undefined)
      {return undefined;}
    const exportName = {node: token, isTypeOnly: ts.isTypeDeclaration(node)};
    return {exportName, node, moduleSourceFile, moduleSpecifier};
  }
  return undefined;
}
function doChange(changes, program, _a) {
  const exportName = _a.exportName, node = _a.node, moduleSourceFile = _a.moduleSourceFile;
  const exportDeclaration = tryGetExportDeclaration(moduleSourceFile, exportName.isTypeOnly);
  if (exportDeclaration) {
    updateExport(changes, program, moduleSourceFile, exportDeclaration, [exportName]);
  } else if (ts.canHaveExportModifier(node)) {
    changes.insertExportModifier(moduleSourceFile, node);
  } else {
    createExport(changes, program, moduleSourceFile, [exportName]);
  }
}
function doChanges(changes, program, sourceFile, moduleExports, node) {
  if (ts.length(moduleExports)) {
    if (node) {
      updateExport(changes, program, sourceFile, node, moduleExports);
    } else {
      createExport(changes, program, sourceFile, moduleExports);
    }
  }
}
function tryGetExportDeclaration(sourceFile, isTypeOnly) {
  const predicate = function(node) {
    return ts.isExportDeclaration(node) && (isTypeOnly && node.isTypeOnly || !node.isTypeOnly);
  };
  return ts.findLast(sourceFile.statements, predicate);
}
function updateExport(changes, program, sourceFile, node, names) {
  const namedExports = node.exportClause && ts.isNamedExports(node.exportClause) ? node.exportClause.elements :
                                                                                 ts.factory.createNodeArray([]);
  const allowTypeModifier =
      !node.isTypeOnly && !!(program.getCompilerOptions().isolatedModules || ts.find(namedExports, function(e) {
        return e.isTypeOnly;
      }));
  changes.replaceNode(
      sourceFile, node,
      ts.factory.updateExportDeclaration(
          node, node.modifiers, node.isTypeOnly,
          ts.factory.createNamedExports(ts.factory.createNodeArray(
              __spreadArray(
                  __spreadArray([], namedExports, true), createExportSpecifiers(names, allowTypeModifier), true),
              /* hasTrailingComma*/ namedExports.hasTrailingComma)),
          node.moduleSpecifier, node.assertClause));
}
function createExport(changes, program, sourceFile, names) {
  changes.insertNodeAtEndOfScope(
      sourceFile, sourceFile,
      ts.factory.createExportDeclaration(
          /* modifiers*/ undefined, /* isTypeOnly*/ false,
          ts.factory.createNamedExports(
              createExportSpecifiers(names, /* allowTypeModifier*/ !!program.getCompilerOptions().isolatedModules)),
          /* moduleSpecifier*/ undefined, /* assertClause*/ undefined));
}
function createExportSpecifiers(names, allowTypeModifier) {
  return ts.factory.createNodeArray(ts.map(names, function(n) {
    return ts.factory.createExportSpecifier(allowTypeModifier && n.isTypeOnly, /* propertyName*/ undefined, n.node);
  }));
}
function getNodeOfSymbol(symbol) {
  if (symbol.valueDeclaration === undefined) {
    return ts.firstOrUndefined(symbol.declarations);
  }
  const declaration = symbol.valueDeclaration;
  const variableStatement =
      ts.isVariableDeclaration(declaration) ? ts.tryCast(declaration.parent.parent, ts.isVariableStatement) : undefined;
  return variableStatement && ts.length(variableStatement.declarationList.declarations) === 1 ? variableStatement :
                                                                                                declaration;
}
})(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let codefix;
(function(codefix) {
const fixId = 'fixIncorrectNamedTupleSyntax';
const errorCodes = [
  ts.Diagnostics
      .A_labeled_tuple_element_is_declared_as_optional_with_a_question_mark_after_the_name_and_before_the_colon_rather_than_after_the_type
      .code,
  ts.Diagnostics.A_labeled_tuple_element_is_declared_as_rest_with_a_before_the_name_rather_than_before_the_type.code
];
codefix.registerCodeFix({
  errorCodes,
  getCodeActions: function getCodeActionsToFixIncorrectNamedTupleSyntax(context) {
    const sourceFile = context.sourceFile, span = context.span;
    const namedTupleMember = getNamedTupleMember(sourceFile, span.start);
    const changes = ts.textChanges.ChangeTracker.with(context, function(t) {
      return doChange(t, sourceFile, namedTupleMember);
    });
    return [codefix.createCodeFixAction(
        fixId, changes, ts.Diagnostics.Move_labeled_tuple_element_modifiers_to_labels, fixId,
        ts.Diagnostics.Move_labeled_tuple_element_modifiers_to_labels)];
  },
  fixIds: [fixId]
});
function getNamedTupleMember(sourceFile, pos) {
  const token = ts.getTokenAtPosition(sourceFile, pos);
  return ts.findAncestor(token, function(t) {
    return t.kind === 199 /* SyntaxKind.NamedTupleMember */;
  });
}
function doChange(changes, sourceFile, namedTupleMember) {
  if (!namedTupleMember) {
    return;
  }
  let unwrappedType = namedTupleMember.type;
  let sawOptional = false;
  let sawRest = false;
  while (unwrappedType.kind === 187 /* SyntaxKind.OptionalType */ ||
         unwrappedType.kind === 188 /* SyntaxKind.RestType */ ||
         unwrappedType.kind === 193 /* SyntaxKind.ParenthesizedType */) {
    if (unwrappedType.kind === 187 /* SyntaxKind.OptionalType */) {
      sawOptional = true;
    } else if (unwrappedType.kind === 188 /* SyntaxKind.RestType */) {
      sawRest = true;
    }
    unwrappedType = unwrappedType.type;
  }
  const updated = ts.factory.updateNamedTupleMember(
      namedTupleMember,
      namedTupleMember.dotDotDotToken ||
          (sawRest ? ts.factory.createToken(25 /* SyntaxKind.DotDotDotToken */) : undefined),
      namedTupleMember.name,
      namedTupleMember.questionToken ||
          (sawOptional ? ts.factory.createToken(57 /* SyntaxKind.QuestionToken */) : undefined),
      unwrappedType);
  if (updated === namedTupleMember) {
    return;
  }
  changes.replaceNode(sourceFile, namedTupleMember, updated);
}
})(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let codefix;
(function(codefix) {
const fixId = 'fixSpelling';
const errorCodes = [
  ts.Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_2.code,
  ts.Diagnostics.Property_0_may_not_exist_on_type_1_Did_you_mean_2.code,
  ts.Diagnostics.Cannot_find_name_0_Did_you_mean_1.code,
  ts.Diagnostics.Could_not_find_name_0_Did_you_mean_1.code,
  ts.Diagnostics.Cannot_find_namespace_0_Did_you_mean_1.code,
  ts.Diagnostics.Cannot_find_name_0_Did_you_mean_the_instance_member_this_0.code,
  ts.Diagnostics.Cannot_find_name_0_Did_you_mean_the_static_member_1_0.code,
  ts.Diagnostics._0_has_no_exported_member_named_1_Did_you_mean_2.code,
  ts.Diagnostics
      .This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0_Did_you_mean_1.code,
  ts.Diagnostics
      .This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base_class_0_Did_you_mean_1
      .code,
  // for JSX class components
  ts.Diagnostics.No_overload_matches_this_call.code,
  // for JSX FC
  ts.Diagnostics.Type_0_is_not_assignable_to_type_1.code,
];
codefix.registerCodeFix({
  errorCodes,
  getCodeActions: function(context) {
    const sourceFile = context.sourceFile, errorCode = context.errorCode;
    const info = getInfo(sourceFile, context.span.start, context, errorCode);
    if (!info)
      {return undefined;}
    const node = info.node, suggestedSymbol = info.suggestedSymbol;
    const target = ts.getEmitScriptTarget(context.host.getCompilationSettings());
    const changes = ts.textChanges.ChangeTracker.with(context, function(t) {
      return doChange(t, sourceFile, node, suggestedSymbol, target);
    });
    return [codefix.createCodeFixAction(
        'spelling', changes, [ts.Diagnostics.Change_spelling_to_0, ts.symbolName(suggestedSymbol)], fixId,
        ts.Diagnostics.Fix_all_detected_spelling_errors)];
  },
  fixIds: [fixId],
  getAllCodeActions: function(context) {
    return codefix.codeFixAll(context, errorCodes, function(changes, diag) {
      const info = getInfo(diag.file, diag.start, context, diag.code);
      const target = ts.getEmitScriptTarget(context.host.getCompilationSettings());
      if (info)
        {doChange(changes, context.sourceFile, info.node, info.suggestedSymbol, target);}
    });
  },
});
function getInfo(sourceFile, pos, context, errorCode) {
  // This is the identifier of the misspelled word. eg:
  // this.speling = 1;
  //      ^^^^^^^
  const node = ts.getTokenAtPosition(sourceFile, pos);
  const parent = node.parent;
  // Only fix spelling for No_overload_matches_this_call emitted on the React class component
  if ((errorCode === ts.Diagnostics.No_overload_matches_this_call.code ||
       errorCode === ts.Diagnostics.Type_0_is_not_assignable_to_type_1.code) &&
      !ts.isJsxAttribute(parent))
    {return undefined;}
  const checker = context.program.getTypeChecker();
  let suggestedSymbol;
  if (ts.isPropertyAccessExpression(parent) && parent.name === node) {
    ts.Debug.assert(ts.isMemberName(node), 'Expected an identifier for spelling (property access)');
    let containingType = checker.getTypeAtLocation(parent.expression);
    if (parent.flags & 32 /* NodeFlags.OptionalChain */) {
      containingType = checker.getNonNullableType(containingType);
    }
    suggestedSymbol = checker.getSuggestedSymbolForNonexistentProperty(node, containingType);
  } else if (
      ts.isBinaryExpression(parent) && parent.operatorToken.kind === 101 /* SyntaxKind.InKeyword */ &&
      parent.left === node && ts.isPrivateIdentifier(node)) {
    const receiverType = checker.getTypeAtLocation(parent.right);
    suggestedSymbol = checker.getSuggestedSymbolForNonexistentProperty(node, receiverType);
  } else if (ts.isQualifiedName(parent) && parent.right === node) {
    const symbol = checker.getSymbolAtLocation(parent.left);
    if (symbol && symbol.flags & 1536 /* SymbolFlags.Module */) {
      suggestedSymbol = checker.getSuggestedSymbolForNonexistentModule(parent.right, symbol);
    }
  } else if (ts.isImportSpecifier(parent) && parent.name === node) {
    ts.Debug.assertNode(node, ts.isIdentifier, 'Expected an identifier for spelling (import)');
    const importDeclaration = ts.findAncestor(node, ts.isImportDeclaration);
    const resolvedSourceFile = getResolvedSourceFileFromImportDeclaration(sourceFile, context, importDeclaration);
    if (resolvedSourceFile && resolvedSourceFile.symbol) {
      suggestedSymbol = checker.getSuggestedSymbolForNonexistentModule(node, resolvedSourceFile.symbol);
    }
  } else if (ts.isJsxAttribute(parent) && parent.name === node) {
    ts.Debug.assertNode(node, ts.isIdentifier, 'Expected an identifier for JSX attribute');
    const tag = ts.findAncestor(node, ts.isJsxOpeningLikeElement);
    const props = checker.getContextualTypeForArgumentAtIndex(tag, 0);
    suggestedSymbol = checker.getSuggestedSymbolForNonexistentJSXAttribute(node, props);
  } else if (
      ts.hasSyntacticModifier(parent, 16384 /* ModifierFlags.Override */) && ts.isClassElement(parent) &&
      parent.name === node) {
    const baseDeclaration = ts.findAncestor(node, ts.isClassLike);
    const baseTypeNode = baseDeclaration ? ts.getEffectiveBaseTypeNode(baseDeclaration) : undefined;
    const baseType = baseTypeNode ? checker.getTypeAtLocation(baseTypeNode) : undefined;
    if (baseType) {
      suggestedSymbol = checker.getSuggestedSymbolForNonexistentClassMember(ts.getTextOfNode(node), baseType);
    }
  } else {
    const meaning = ts.getMeaningFromLocation(node);
    const name = ts.getTextOfNode(node);
    ts.Debug.assert(name !== undefined, 'name should be defined');
    suggestedSymbol =
        checker.getSuggestedSymbolForNonexistentSymbol(node, name, convertSemanticMeaningToSymbolFlags(meaning));
  }
  return suggestedSymbol === undefined ? undefined : {node, suggestedSymbol};
}
function doChange(changes, sourceFile, node, suggestedSymbol, target) {
  const suggestion = ts.symbolName(suggestedSymbol);
  if (!ts.isIdentifierText(suggestion, target) && ts.isPropertyAccessExpression(node.parent)) {
    const valDecl = suggestedSymbol.valueDeclaration;
    if (valDecl && ts.isNamedDeclaration(valDecl) && ts.isPrivateIdentifier(valDecl.name)) {
      changes.replaceNode(sourceFile, node, ts.factory.createIdentifier(suggestion));
    } else {
      changes.replaceNode(
          sourceFile, node.parent,
          ts.factory.createElementAccessExpression(node.parent.expression, ts.factory.createStringLiteral(suggestion)));
    }
  } else {
    changes.replaceNode(sourceFile, node, ts.factory.createIdentifier(suggestion));
  }
}
function convertSemanticMeaningToSymbolFlags(meaning) {
  let flags = 0;
  if (meaning & 4 /* SemanticMeaning.Namespace */) {
    flags |= 1920 /* SymbolFlags.Namespace */;
  }
  if (meaning & 2 /* SemanticMeaning.Type */) {
    flags |= 788968 /* SymbolFlags.Type */;
  }
  if (meaning & 1 /* SemanticMeaning.Value */) {
    flags |= 111551 /* SymbolFlags.Value */;
  }
  return flags;
}
function getResolvedSourceFileFromImportDeclaration(sourceFile, context, importDeclaration) {
  if (!importDeclaration || !ts.isStringLiteralLike(importDeclaration.moduleSpecifier))
    {return undefined;}
  const resolvedModule = ts.getResolvedModule(
      sourceFile, importDeclaration.moduleSpecifier.text,
      ts.getModeForUsageLocation(sourceFile, importDeclaration.moduleSpecifier));
  if (!resolvedModule)
    {return undefined;}
  return context.program.getSourceFile(resolvedModule.resolvedFileName);
}
})(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let codefix;
(function(codefix) {
const fixId = 'returnValueCorrect';
const fixIdAddReturnStatement = 'fixAddReturnStatement';
const fixRemoveBracesFromArrowFunctionBody = 'fixRemoveBracesFromArrowFunctionBody';
const fixIdWrapTheBlockWithParen = 'fixWrapTheBlockWithParen';
const errorCodes = [
  ts.Diagnostics.A_function_whose_declared_type_is_neither_void_nor_any_must_return_a_value.code,
  ts.Diagnostics.Type_0_is_not_assignable_to_type_1.code,
  ts.Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1.code
];
let ProblemKind;
(function(ProblemKind) {
ProblemKind[ProblemKind['MissingReturnStatement'] = 0] = 'MissingReturnStatement';
ProblemKind[ProblemKind['MissingParentheses'] = 1] = 'MissingParentheses';
})(ProblemKind || (ProblemKind = {}));
codefix.registerCodeFix({
  errorCodes,
  fixIds: [fixIdAddReturnStatement, fixRemoveBracesFromArrowFunctionBody, fixIdWrapTheBlockWithParen],
  getCodeActions: function getCodeActionsToCorrectReturnValue(context) {
    const program = context.program, sourceFile = context.sourceFile, start = context.span.start,
        errorCode = context.errorCode;
    const info = getInfo(program.getTypeChecker(), sourceFile, start, errorCode);
    if (!info)
      {return undefined;}
    if (info.kind === ProblemKind.MissingReturnStatement) {
      return ts.append(
          [getActionForfixAddReturnStatement(context, info.expression, info.statement)],
          ts.isArrowFunction(info.declaration) ? getActionForFixRemoveBracesFromArrowFunctionBody(
                                                     context, info.declaration, info.expression, info.commentSource) :
                                                 undefined);
    }
      return [getActionForfixWrapTheBlockWithParen(context, info.declaration, info.expression)];

  },
  getAllCodeActions: function(context) {
    return codefix.codeFixAll(context, errorCodes, function(changes, diag) {
      const info = getInfo(context.program.getTypeChecker(), diag.file, diag.start, diag.code);
      if (!info)
        {return undefined;}
      switch (context.fixId) {
        case fixIdAddReturnStatement:
          addReturnStatement(changes, diag.file, info.expression, info.statement);
          break;
        case fixRemoveBracesFromArrowFunctionBody:
          if (!ts.isArrowFunction(info.declaration))
            {return undefined;}
          removeBlockBodyBrace(
              changes, diag.file, info.declaration, info.expression, info.commentSource, /* withParen */ false);
          break;
        case fixIdWrapTheBlockWithParen:
          if (!ts.isArrowFunction(info.declaration))
            {return undefined;}
          wrapBlockWithParen(changes, diag.file, info.declaration, info.expression);
          break;
        default:
          ts.Debug.fail(JSON.stringify(context.fixId));
      }
    });
  },
});
function createObjectTypeFromLabeledExpression(checker, label, expression) {
  const member = checker.createSymbol(4 /* SymbolFlags.Property */, label.escapedText);
  member.type = checker.getTypeAtLocation(expression);
  const members = ts.createSymbolTable([member]);
  return checker.createAnonymousType(/* symbol*/ undefined, members, [], [], []);
}
function getFixInfo(checker, declaration, expectType, isFunctionType) {
  if (!declaration.body || !ts.isBlock(declaration.body) || ts.length(declaration.body.statements) !== 1)
    {return undefined;}
  const firstStatement = ts.first(declaration.body.statements);
  if (ts.isExpressionStatement(firstStatement) &&
      checkFixedAssignableTo(
          checker, declaration, checker.getTypeAtLocation(firstStatement.expression), expectType, isFunctionType)) {
    return {
      declaration,
      kind: ProblemKind.MissingReturnStatement,
      expression: firstStatement.expression,
      statement: firstStatement,
      commentSource: firstStatement.expression
    };
  } if (ts.isLabeledStatement(firstStatement) && ts.isExpressionStatement(firstStatement.statement)) {
    var node = ts.factory.createObjectLiteralExpression(
        [ts.factory.createPropertyAssignment(firstStatement.label, firstStatement.statement.expression)]);
    var nodeType =
        createObjectTypeFromLabeledExpression(checker, firstStatement.label, firstStatement.statement.expression);
    if (checkFixedAssignableTo(checker, declaration, nodeType, expectType, isFunctionType)) {
      return ts.isArrowFunction(declaration) ? {
        declaration,
        kind: ProblemKind.MissingParentheses,
        expression: node,
        statement: firstStatement,
        commentSource: firstStatement.statement.expression
      } :
                                               {
                                                 declaration,
                                                 kind: ProblemKind.MissingReturnStatement,
                                                 expression: node,
                                                 statement: firstStatement,
                                                 commentSource: firstStatement.statement.expression
                                               };
    }
  } else if (ts.isBlock(firstStatement) && ts.length(firstStatement.statements) === 1) {
    const firstBlockStatement = ts.first(firstStatement.statements);
    if (ts.isLabeledStatement(firstBlockStatement) && ts.isExpressionStatement(firstBlockStatement.statement)) {
      var node = ts.factory.createObjectLiteralExpression(
          [ts.factory.createPropertyAssignment(firstBlockStatement.label, firstBlockStatement.statement.expression)]);
      var nodeType = createObjectTypeFromLabeledExpression(
          checker, firstBlockStatement.label, firstBlockStatement.statement.expression);
      if (checkFixedAssignableTo(checker, declaration, nodeType, expectType, isFunctionType)) {
        return {
          declaration,
          kind: ProblemKind.MissingReturnStatement,
          expression: node,
          statement: firstStatement,
          commentSource: firstBlockStatement
        };
      }
    }
  }
  return undefined;
}
function checkFixedAssignableTo(checker, declaration, exprType, type, isFunctionType) {
  if (isFunctionType) {
    const sig = checker.getSignatureFromDeclaration(declaration);
    if (sig) {
      if (ts.hasSyntacticModifier(declaration, 512 /* ModifierFlags.Async */)) {
        exprType = checker.createPromiseType(exprType);
      }
      const newSig = checker.createSignature(
          declaration, sig.typeParameters, sig.thisParameter, sig.parameters, exprType,
          /* typePredicate*/ undefined, sig.minArgumentCount, sig.flags);
      exprType = checker.createAnonymousType(
          /* symbol*/ undefined, ts.createSymbolTable(), [newSig], [], []);
    } else {
      exprType = checker.getAnyType();
    }
  }
  return checker.isTypeAssignableTo(exprType, type);
}
function getInfo(checker, sourceFile, position, errorCode) {
  const node = ts.getTokenAtPosition(sourceFile, position);
  if (!node.parent)
    {return undefined;}
  const declaration = ts.findAncestor(node.parent, ts.isFunctionLikeDeclaration);
  switch (errorCode) {
    case ts.Diagnostics.A_function_whose_declared_type_is_neither_void_nor_any_must_return_a_value.code:
      if (!declaration || !declaration.body || !declaration.type || !ts.rangeContainsRange(declaration.type, node))
        {return undefined;}
      return getFixInfo(
          checker, declaration, checker.getTypeFromTypeNode(declaration.type), /* isFunctionType */ false);
    case ts.Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1.code:
      if (!declaration || !ts.isCallExpression(declaration.parent) || !declaration.body)
        {return undefined;}
      var pos = declaration.parent.arguments.indexOf(declaration);
      var type = checker.getContextualTypeForArgumentAtIndex(declaration.parent, pos);
      if (!type)
        {return undefined;}
      return getFixInfo(checker, declaration, type, /* isFunctionType */ true);
    case ts.Diagnostics.Type_0_is_not_assignable_to_type_1.code:
      if (!ts.isDeclarationName(node) || !ts.isVariableLike(node.parent) && !ts.isJsxAttribute(node.parent))
        {return undefined;}
      var initializer = getVariableLikeInitializer(node.parent);
      if (!initializer || !ts.isFunctionLikeDeclaration(initializer) || !initializer.body)
        {return undefined;}
      return getFixInfo(checker, initializer, checker.getTypeAtLocation(node.parent), /* isFunctionType */ true);
  }
  return undefined;
}
function getVariableLikeInitializer(declaration) {
  switch (declaration.kind) {
    case 257 /* SyntaxKind.VariableDeclaration */:
    case 166 /* SyntaxKind.Parameter */:
    case 205 /* SyntaxKind.BindingElement */:
    case 169 /* SyntaxKind.PropertyDeclaration */:
    case 299 /* SyntaxKind.PropertyAssignment */:
      return declaration.initializer;
    case 288 /* SyntaxKind.JsxAttribute */:
      return declaration.initializer &&
          (ts.isJsxExpression(declaration.initializer) ? declaration.initializer.expression : undefined);
    case 300 /* SyntaxKind.ShorthandPropertyAssignment */:
    case 168 /* SyntaxKind.PropertySignature */:
    case 302 /* SyntaxKind.EnumMember */:
    case 350 /* SyntaxKind.JSDocPropertyTag */:
    case 343 /* SyntaxKind.JSDocParameterTag */:
      return undefined;
  }
}
function addReturnStatement(changes, sourceFile, expression, statement) {
  ts.suppressLeadingAndTrailingTrivia(expression);
  const probablyNeedSemi = ts.probablyUsesSemicolons(sourceFile);
  changes.replaceNode(sourceFile, statement, ts.factory.createReturnStatement(expression), {
    leadingTriviaOption: ts.textChanges.LeadingTriviaOption.Exclude,
    trailingTriviaOption: ts.textChanges.TrailingTriviaOption.Exclude,
    suffix: probablyNeedSemi ? ';' : undefined
  });
}
function removeBlockBodyBrace(changes, sourceFile, declaration, expression, commentSource, withParen) {
  const newBody = (withParen || ts.needsParentheses(expression)) ? ts.factory.createParenthesizedExpression(expression) :
                                                                 expression;
  ts.suppressLeadingAndTrailingTrivia(commentSource);
  ts.copyComments(commentSource, newBody);
  changes.replaceNode(sourceFile, declaration.body, newBody);
}
function wrapBlockWithParen(changes, sourceFile, declaration, expression) {
  changes.replaceNode(sourceFile, declaration.body, ts.factory.createParenthesizedExpression(expression));
}
function getActionForfixAddReturnStatement(context, expression, statement) {
  const changes = ts.textChanges.ChangeTracker.with(context, function(t) {
    return addReturnStatement(t, context.sourceFile, expression, statement);
  });
  return codefix.createCodeFixAction(
      fixId, changes, ts.Diagnostics.Add_a_return_statement, fixIdAddReturnStatement,
      ts.Diagnostics.Add_all_missing_return_statement);
}
function getActionForFixRemoveBracesFromArrowFunctionBody(context, declaration, expression, commentSource) {
  const changes = ts.textChanges.ChangeTracker.with(context, function(t) {
    return removeBlockBodyBrace(t, context.sourceFile, declaration, expression, commentSource, /* withParen */ false);
  });
  return codefix.createCodeFixAction(
      fixId, changes, ts.Diagnostics.Remove_braces_from_arrow_function_body, fixRemoveBracesFromArrowFunctionBody,
      ts.Diagnostics.Remove_braces_from_all_arrow_function_bodies_with_relevant_issues);
}
function getActionForfixWrapTheBlockWithParen(context, declaration, expression) {
  const changes = ts.textChanges.ChangeTracker.with(context, function(t) {
    return wrapBlockWithParen(t, context.sourceFile, declaration, expression);
  });
  return codefix.createCodeFixAction(
      fixId, changes, ts.Diagnostics.Wrap_the_following_body_with_parentheses_which_should_be_an_object_literal,
      fixIdWrapTheBlockWithParen, ts.Diagnostics.Wrap_all_object_literal_with_parentheses);
}
})(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let codefix;
(function(codefix) {
const fixMissingMember = 'fixMissingMember';
const fixMissingProperties = 'fixMissingProperties';
const fixMissingAttributes = 'fixMissingAttributes';
const fixMissingFunctionDeclaration = 'fixMissingFunctionDeclaration';
const errorCodes = [
  ts.Diagnostics.Property_0_does_not_exist_on_type_1.code,
  ts.Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_2.code,
  ts.Diagnostics.Property_0_is_missing_in_type_1_but_required_in_type_2.code,
  ts.Diagnostics.Type_0_is_missing_the_following_properties_from_type_1_Colon_2.code,
  ts.Diagnostics.Type_0_is_missing_the_following_properties_from_type_1_Colon_2_and_3_more.code,
  ts.Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1.code,
  ts.Diagnostics.Cannot_find_name_0.code
];
let InfoKind;
(function(InfoKind) {
InfoKind[InfoKind['TypeLikeDeclaration'] = 0] = 'TypeLikeDeclaration';
InfoKind[InfoKind['Enum'] = 1] = 'Enum';
InfoKind[InfoKind['Function'] = 2] = 'Function';
InfoKind[InfoKind['ObjectLiteral'] = 3] = 'ObjectLiteral';
InfoKind[InfoKind['JsxAttributes'] = 4] = 'JsxAttributes';
InfoKind[InfoKind['Signature'] = 5] = 'Signature';
})(InfoKind || (InfoKind = {}));
codefix.registerCodeFix({
  errorCodes,
  getCodeActions: function(context) {
    const typeChecker = context.program.getTypeChecker();
    const info = getInfo(context.sourceFile, context.span.start, context.errorCode, typeChecker, context.program);
    if (!info) {
      return undefined;
    }
    if (info.kind === InfoKind.ObjectLiteral) {
      var changes = ts.textChanges.ChangeTracker.with(context, function(t) {
        return addObjectLiteralProperties(t, context, info);
      });
      return [codefix.createCodeFixAction(
          fixMissingProperties, changes, ts.Diagnostics.Add_missing_properties, fixMissingProperties,
          ts.Diagnostics.Add_all_missing_properties)];
    }
    if (info.kind === InfoKind.JsxAttributes) {
      var changes = ts.textChanges.ChangeTracker.with(context, function(t) {
        return addJsxAttributes(t, context, info);
      });
      return [codefix.createCodeFixAction(
          fixMissingAttributes, changes, ts.Diagnostics.Add_missing_attributes, fixMissingAttributes,
          ts.Diagnostics.Add_all_missing_attributes)];
    }
    if (info.kind === InfoKind.Function || info.kind === InfoKind.Signature) {
      var changes = ts.textChanges.ChangeTracker.with(context, function(t) {
        return addFunctionDeclaration(t, context, info);
      });
      return [codefix.createCodeFixAction(
          fixMissingFunctionDeclaration, changes, [ts.Diagnostics.Add_missing_function_declaration_0, info.token.text],
          fixMissingFunctionDeclaration, ts.Diagnostics.Add_all_missing_function_declarations)];
    }
    if (info.kind === InfoKind.Enum) {
      var changes = ts.textChanges.ChangeTracker.with(context, function(t) {
        return addEnumMemberDeclaration(t, context.program.getTypeChecker(), info);
      });
      return [codefix.createCodeFixAction(
          fixMissingMember, changes, [ts.Diagnostics.Add_missing_enum_member_0, info.token.text], fixMissingMember,
          ts.Diagnostics.Add_all_missing_members)];
    }
    return ts.concatenate(
        getActionsForMissingMethodDeclaration(context, info), getActionsForMissingMemberDeclaration(context, info));
  },
  fixIds: [fixMissingMember, fixMissingFunctionDeclaration, fixMissingProperties, fixMissingAttributes],
  getAllCodeActions: function(context) {
    const program = context.program, fixId = context.fixId;
    const checker = program.getTypeChecker();
    const seen = new ts.Map();
    const typeDeclToMembers = new ts.Map();
    return codefix.createCombinedCodeActions(ts.textChanges.ChangeTracker.with(context, function(changes) {
      codefix.eachDiagnostic(context, errorCodes, function(diag) {
        const info = getInfo(diag.file, diag.start, diag.code, checker, context.program);
        if (!info || !ts.addToSeen(seen, ts.getNodeId(info.parentDeclaration) + '#' + info.token.text)) {
          return;
        }
        if (fixId === fixMissingFunctionDeclaration &&
            (info.kind === InfoKind.Function || info.kind === InfoKind.Signature)) {
          addFunctionDeclaration(changes, context, info);
        } else if (fixId === fixMissingProperties && info.kind === InfoKind.ObjectLiteral) {
          addObjectLiteralProperties(changes, context, info);
        } else if (fixId === fixMissingAttributes && info.kind === InfoKind.JsxAttributes) {
          addJsxAttributes(changes, context, info);
        } else {
          if (info.kind === InfoKind.Enum) {
            addEnumMemberDeclaration(changes, checker, info);
          }
          if (info.kind === InfoKind.TypeLikeDeclaration) {
            const parentDeclaration = info.parentDeclaration, token_1 = info.token;
            const infos = ts.getOrUpdate(typeDeclToMembers, parentDeclaration, function() {
              return [];
            });
            if (!infos.some(function(i) {
                  return i.token.text === token_1.text;
                })) {
              infos.push(info);
            }
          }
        }
      });
      typeDeclToMembers.forEach(function(infos, declaration) {
        const supers = ts.isTypeLiteralNode(declaration) ? undefined : codefix.getAllSupers(declaration, checker);
        const _loop_13 = function(info) {
          // If some superclass added this property, don't add it again.
          if (supers === null || supers === void 0 ? void 0 : supers.some(function(superClassOrInterface) {
                const superInfos = typeDeclToMembers.get(superClassOrInterface);
                return !!superInfos && superInfos.some(function(_a) {
                  const token = _a.token;
                  return token.text === info.token.text;
                });
              }))
            {return 'continue';}
          const parentDeclaration = info.parentDeclaration, declSourceFile = info.declSourceFile,
              modifierFlags = info.modifierFlags, token = info.token, call = info.call, isJSFile = info.isJSFile;
          // Always prefer to add a method declaration if possible.
          if (call && !ts.isPrivateIdentifier(token)) {
            addMethodDeclaration(
                context, changes, call, token, modifierFlags & 32 /* ModifierFlags.Static */, parentDeclaration,
                declSourceFile);
          } else {
            if (isJSFile && !ts.isInterfaceDeclaration(parentDeclaration) && !ts.isTypeLiteralNode(parentDeclaration)) {
              addMissingMemberInJs(
                  changes, declSourceFile, parentDeclaration, token, !!(modifierFlags & 32 /* ModifierFlags.Static */));
            } else {
              const typeNode = getTypeNode(checker, parentDeclaration, token);
              addPropertyDeclaration(
                  changes, declSourceFile, parentDeclaration, token.text, typeNode,
                  modifierFlags & 32 /* ModifierFlags.Static */);
            }
          }
        };
        for (let _i = 0, infos_1 = infos; _i < infos_1.length; _i++) {
          const info = infos_1[_i];
          _loop_13(info);
        }
      });
    }));
  },
});
function getInfo(sourceFile, tokenPos, errorCode, checker, program) {
  // The identifier of the missing property. eg:
  // this.missing = 1;
  //      ^^^^^^^
  const token = ts.getTokenAtPosition(sourceFile, tokenPos);
  const parent = token.parent;
  if (errorCode === ts.Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1.code) {
    if (!(token.kind === 18 /* SyntaxKind.OpenBraceToken */ && ts.isObjectLiteralExpression(parent) &&
          ts.isCallExpression(parent.parent)))
      {return undefined;}
    const argIndex = ts.findIndex(parent.parent.arguments, function(arg) {
      return arg === parent;
    });
    if (argIndex < 0)
      {return undefined;}
    var signature = checker.getResolvedSignature(parent.parent);
    if (!(signature && signature.declaration && signature.parameters[argIndex]))
      {return undefined;}
    const param = signature.parameters[argIndex].valueDeclaration;
    if (!(param && ts.isParameter(param) && ts.isIdentifier(param.name)))
      {return undefined;}
    var properties = ts.arrayFrom(checker.getUnmatchedProperties(
        checker.getTypeAtLocation(parent), checker.getParameterType(signature, argIndex),
        /* requireOptionalProperties */ false, /* matchDiscriminantProperties */ false));
    if (!ts.length(properties))
      {return undefined;}
    return {kind: InfoKind.ObjectLiteral, token: param.name, properties, parentDeclaration: parent};
  }
  if (!ts.isMemberName(token))
    {return undefined;}
  if (ts.isIdentifier(token) && ts.hasInitializer(parent) && parent.initializer &&
      ts.isObjectLiteralExpression(parent.initializer)) {
    var properties = ts.arrayFrom(checker.getUnmatchedProperties(
        checker.getTypeAtLocation(parent.initializer), checker.getTypeAtLocation(token),
        /* requireOptionalProperties */ false, /* matchDiscriminantProperties */ false));
    if (!ts.length(properties))
      {return undefined;}
    return {kind: InfoKind.ObjectLiteral, token, properties, parentDeclaration: parent.initializer};
  }
  if (ts.isIdentifier(token) && ts.isJsxOpeningLikeElement(token.parent)) {
    const target = ts.getEmitScriptTarget(program.getCompilerOptions());
    const attributes = getUnmatchedAttributes(checker, target, token.parent);
    if (!ts.length(attributes))
      {return undefined;}
    return {kind: InfoKind.JsxAttributes, token, attributes, parentDeclaration: token.parent};
  }
  if (ts.isIdentifier(token)) {
    const type = checker.getContextualType(token);
    if (type && ts.getObjectFlags(type) & 16 /* ObjectFlags.Anonymous */) {
      var signature = ts.firstOrUndefined(checker.getSignaturesOfType(type, 0 /* SignatureKind.Call */));
      if (signature === undefined)
        {return undefined;}
      return {
        kind: InfoKind.Signature,
        token,
        signature,
        sourceFile,
        parentDeclaration: findScope(token)
      };
    }
    if (ts.isCallExpression(parent) && parent.expression === token) {
      return {
        kind: InfoKind.Function,
        token,
        call: parent,
        sourceFile,
        modifierFlags: 0 /* ModifierFlags.None */,
        parentDeclaration: findScope(token)
      };
    }
  }
  if (!ts.isPropertyAccessExpression(parent))
    {return undefined;}
  const leftExpressionType = ts.skipConstraint(checker.getTypeAtLocation(parent.expression));
  const symbol = leftExpressionType.symbol;
  if (!symbol || !symbol.declarations)
    {return undefined;}
  if (ts.isIdentifier(token) && ts.isCallExpression(parent.parent)) {
    const moduleDeclaration = ts.find(symbol.declarations, ts.isModuleDeclaration);
    const moduleDeclarationSourceFile =
        moduleDeclaration === null || moduleDeclaration === void 0 ? void 0 : moduleDeclaration.getSourceFile();
    if (moduleDeclaration && moduleDeclarationSourceFile &&
        !ts.isSourceFileFromLibrary(program, moduleDeclarationSourceFile)) {
      return {
        kind: InfoKind.Function,
        token,
        call: parent.parent,
        sourceFile,
        modifierFlags: 1 /* ModifierFlags.Export */,
        parentDeclaration: moduleDeclaration
      };
    }
    const moduleSourceFile = ts.find(symbol.declarations, ts.isSourceFile);
    if (sourceFile.commonJsModuleIndicator)
      {return undefined;}
    if (moduleSourceFile && !ts.isSourceFileFromLibrary(program, moduleSourceFile)) {
      return {
        kind: InfoKind.Function,
        token,
        call: parent.parent,
        sourceFile: moduleSourceFile,
        modifierFlags: 1 /* ModifierFlags.Export */,
        parentDeclaration: moduleSourceFile
      };
    }
  }
  const classDeclaration = ts.find(symbol.declarations, ts.isClassLike);
  // Don't suggest adding private identifiers to anything other than a class.
  if (!classDeclaration && ts.isPrivateIdentifier(token))
    {return undefined;}
  // Prefer to change the class instead of the interface if they are merged
  const declaration = classDeclaration || ts.find(symbol.declarations, function(d) {
    return ts.isInterfaceDeclaration(d) || ts.isTypeLiteralNode(d);
  });
  if (declaration && !ts.isSourceFileFromLibrary(program, declaration.getSourceFile())) {
    const makeStatic = !ts.isTypeLiteralNode(declaration) &&
        (leftExpressionType.target || leftExpressionType) !== checker.getDeclaredTypeOfSymbol(symbol);
    if (makeStatic && (ts.isPrivateIdentifier(token) || ts.isInterfaceDeclaration(declaration)))
      {return undefined;}
    const declSourceFile = declaration.getSourceFile();
    const modifierFlags = ts.isTypeLiteralNode(declaration) ?
        0 /* ModifierFlags.None */ :
        (makeStatic ? 32 /* ModifierFlags.Static */ : 0 /* ModifierFlags.None */) |
            (ts.startsWithUnderscore(token.text) ? 8 /* ModifierFlags.Private */ : 0 /* ModifierFlags.None */);
    const isJSFile = ts.isSourceFileJS(declSourceFile);
    const call = ts.tryCast(parent.parent, ts.isCallExpression);
    return {
      kind: InfoKind.TypeLikeDeclaration,
      token,
      call,
      modifierFlags,
      parentDeclaration: declaration,
      declSourceFile,
      isJSFile
    };
  }
  const enumDeclaration = ts.find(symbol.declarations, ts.isEnumDeclaration);
  if (enumDeclaration && !(leftExpressionType.flags & 1056 /* TypeFlags.EnumLike */) &&
      !ts.isPrivateIdentifier(token) && !ts.isSourceFileFromLibrary(program, enumDeclaration.getSourceFile())) {
    return {kind: InfoKind.Enum, token, parentDeclaration: enumDeclaration};
  }
  return undefined;
}
function getActionsForMissingMemberDeclaration(context, info) {
  return info.isJSFile ? ts.singleElementArray(createActionForAddMissingMemberInJavascriptFile(context, info)) :
                         createActionsForAddMissingMemberInTypeScriptFile(context, info);
}
function createActionForAddMissingMemberInJavascriptFile(context, _a) {
  const parentDeclaration = _a.parentDeclaration, declSourceFile = _a.declSourceFile, modifierFlags = _a.modifierFlags,
      token = _a.token;
  if (ts.isInterfaceDeclaration(parentDeclaration) || ts.isTypeLiteralNode(parentDeclaration)) {
    return undefined;
  }
  const changes = ts.textChanges.ChangeTracker.with(context, function(t) {
    return addMissingMemberInJs(
        t, declSourceFile, parentDeclaration, token, !!(modifierFlags & 32 /* ModifierFlags.Static */));
  });
  if (changes.length === 0) {
    return undefined;
  }
  const diagnostic = modifierFlags & 32 /* ModifierFlags.Static */ ? ts.Diagnostics.Initialize_static_property_0 :
      ts.isPrivateIdentifier(token)                              ? ts.Diagnostics.Declare_a_private_field_named_0 :
                                      ts.Diagnostics.Initialize_property_0_in_the_constructor;
  return codefix.createCodeFixAction(
      fixMissingMember, changes, [diagnostic, token.text], fixMissingMember, ts.Diagnostics.Add_all_missing_members);
}
function addMissingMemberInJs(changeTracker, sourceFile, classDeclaration, token, makeStatic) {
  const tokenName = token.text;
  if (makeStatic) {
    if (classDeclaration.kind === 228 /* SyntaxKind.ClassExpression */) {
      return;
    }
    const className = classDeclaration.name.getText();
    const staticInitialization = initializePropertyToUndefined(ts.factory.createIdentifier(className), tokenName);
    changeTracker.insertNodeAfter(sourceFile, classDeclaration, staticInitialization);
  } else if (ts.isPrivateIdentifier(token)) {
    const property = ts.factory.createPropertyDeclaration(
        /* modifiers*/ undefined, tokenName,
        /* questionToken*/ undefined,
        /* type*/ undefined,
        /* initializer*/ undefined);
    const lastProp = getNodeToInsertPropertyAfter(classDeclaration);
    if (lastProp) {
      changeTracker.insertNodeAfter(sourceFile, lastProp, property);
    } else {
      changeTracker.insertMemberAtStart(sourceFile, classDeclaration, property);
    }
  } else {
    const classConstructor = ts.getFirstConstructorWithBody(classDeclaration);
    if (!classConstructor) {
      return;
    }
    const propertyInitialization = initializePropertyToUndefined(ts.factory.createThis(), tokenName);
    changeTracker.insertNodeAtConstructorEnd(sourceFile, classConstructor, propertyInitialization);
  }
}
function initializePropertyToUndefined(obj, propertyName) {
  return ts.factory.createExpressionStatement(
      ts.factory.createAssignment(ts.factory.createPropertyAccessExpression(obj, propertyName), createUndefined()));
}
function createActionsForAddMissingMemberInTypeScriptFile(context, _a) {
  const parentDeclaration = _a.parentDeclaration, declSourceFile = _a.declSourceFile, modifierFlags = _a.modifierFlags,
      token = _a.token;
  const memberName = token.text;
  const isStatic = modifierFlags & 32 /* ModifierFlags.Static */;
  const typeNode = getTypeNode(context.program.getTypeChecker(), parentDeclaration, token);
  const addPropertyDeclarationChanges = function(modifierFlags) {
    return ts.textChanges.ChangeTracker.with(context, function(t) {
      return addPropertyDeclaration(t, declSourceFile, parentDeclaration, memberName, typeNode, modifierFlags);
    });
  };
  const actions = [codefix.createCodeFixAction(
      fixMissingMember, addPropertyDeclarationChanges(modifierFlags & 32 /* ModifierFlags.Static */),
      [isStatic ? ts.Diagnostics.Declare_static_property_0 : ts.Diagnostics.Declare_property_0, memberName],
      fixMissingMember, ts.Diagnostics.Add_all_missing_members)];
  if (isStatic || ts.isPrivateIdentifier(token)) {
    return actions;
  }
  if (modifierFlags & 8 /* ModifierFlags.Private */) {
    actions.unshift(codefix.createCodeFixActionWithoutFixAll(
        fixMissingMember, addPropertyDeclarationChanges(8 /* ModifierFlags.Private */),
        [ts.Diagnostics.Declare_private_property_0, memberName]));
  }
  actions.push(createAddIndexSignatureAction(context, declSourceFile, parentDeclaration, token.text, typeNode));
  return actions;
}
function getTypeNode(checker, node, token) {
  let typeNode;
  if (token.parent.parent.kind === 223 /* SyntaxKind.BinaryExpression */) {
    const binaryExpression = token.parent.parent;
    const otherExpression = token.parent === binaryExpression.left ? binaryExpression.right : binaryExpression.left;
    const widenedType =
        checker.getWidenedType(checker.getBaseTypeOfLiteralType(checker.getTypeAtLocation(otherExpression)));
    typeNode = checker.typeToTypeNode(widenedType, node, 1 /* NodeBuilderFlags.NoTruncation */);
  } else {
    const contextualType = checker.getContextualType(token.parent);
    typeNode = contextualType ?
        checker.typeToTypeNode(
            contextualType, /* enclosingDeclaration*/ undefined, 1 /* NodeBuilderFlags.NoTruncation */) :
        undefined;
  }
  return typeNode || ts.factory.createKeywordTypeNode(131 /* SyntaxKind.AnyKeyword */);
}
function addPropertyDeclaration(changeTracker, sourceFile, node, tokenName, typeNode, modifierFlags) {
  const modifiers = modifierFlags ?
      ts.factory.createNodeArray(ts.factory.createModifiersFromModifierFlags(modifierFlags)) :
      undefined;
  const property = ts.isClassLike(node) ?
      ts.factory.createPropertyDeclaration(
          modifiers, tokenName, /* questionToken*/ undefined, typeNode, /* initializer*/ undefined) :
      ts.factory.createPropertySignature(/* modifiers*/ undefined, tokenName, /* questionToken*/ undefined, typeNode);
  const lastProp = getNodeToInsertPropertyAfter(node);
  if (lastProp) {
    changeTracker.insertNodeAfter(sourceFile, lastProp, property);
  } else {
    changeTracker.insertMemberAtStart(sourceFile, node, property);
  }
}
// Gets the last of the first run of PropertyDeclarations, or undefined if the class does not start with a PropertyDeclaration.
function getNodeToInsertPropertyAfter(node) {
  let res;
  for (let _i = 0, _a = node.members; _i < _a.length; _i++) {
    const member = _a[_i];
    if (!ts.isPropertyDeclaration(member))
      {break;}
    res = member;
  }
  return res;
}
function createAddIndexSignatureAction(context, sourceFile, node, tokenName, typeNode) {
  // Index signatures cannot have the static modifier.
  const stringTypeNode = ts.factory.createKeywordTypeNode(152 /* SyntaxKind.StringKeyword */);
  const indexingParameter = ts.factory.createParameterDeclaration(
      /* modifiers*/ undefined,
      /* dotDotDotToken*/ undefined, 'x',
      /* questionToken*/ undefined, stringTypeNode,
      /* initializer*/ undefined);
  const indexSignature = ts.factory.createIndexSignature(
      /* modifiers*/ undefined, [indexingParameter], typeNode);
  const changes = ts.textChanges.ChangeTracker.with(context, function(t) {
    return t.insertMemberAtStart(sourceFile, node, indexSignature);
  });
  // No fixId here because code-fix-all currently only works on adding individual named properties.
  return codefix.createCodeFixActionWithoutFixAll(
      fixMissingMember, changes, [ts.Diagnostics.Add_index_signature_for_property_0, tokenName]);
}
function getActionsForMissingMethodDeclaration(context, info) {
  const parentDeclaration = info.parentDeclaration, declSourceFile = info.declSourceFile,
      modifierFlags = info.modifierFlags, token = info.token, call = info.call;
  if (call === undefined) {
    return undefined;
  }
  // Private methods are not implemented yet.
  if (ts.isPrivateIdentifier(token)) {
    return undefined;
  }
  const methodName = token.text;
  const addMethodDeclarationChanges = function(modifierFlags) {
    return ts.textChanges.ChangeTracker.with(context, function(t) {
      return addMethodDeclaration(context, t, call, token, modifierFlags, parentDeclaration, declSourceFile);
    });
  };
  const actions = [codefix.createCodeFixAction(
      fixMissingMember, addMethodDeclarationChanges(modifierFlags & 32 /* ModifierFlags.Static */),
      [
        modifierFlags & 32 /* ModifierFlags.Static */ ? ts.Diagnostics.Declare_static_method_0 :
                                                        ts.Diagnostics.Declare_method_0,
        methodName
      ],
      fixMissingMember, ts.Diagnostics.Add_all_missing_members)];
  if (modifierFlags & 8 /* ModifierFlags.Private */) {
    actions.unshift(codefix.createCodeFixActionWithoutFixAll(
        fixMissingMember, addMethodDeclarationChanges(8 /* ModifierFlags.Private */),
        [ts.Diagnostics.Declare_private_method_0, methodName]));
  }
  return actions;
}
function addMethodDeclaration(context, changes, callExpression, name, modifierFlags, parentDeclaration, sourceFile) {
  const importAdder = codefix.createImportAdder(sourceFile, context.program, context.preferences, context.host);
  const kind =
      ts.isClassLike(parentDeclaration) ? 171 /* SyntaxKind.MethodDeclaration */ : 170 /* SyntaxKind.MethodSignature */;
  const signatureDeclaration = codefix.createSignatureDeclarationFromCallExpression(
      kind, context, importAdder, callExpression, name, modifierFlags, parentDeclaration);
  const containingMethodDeclaration = tryGetContainingMethodDeclaration(parentDeclaration, callExpression);
  if (containingMethodDeclaration) {
    changes.insertNodeAfter(sourceFile, containingMethodDeclaration, signatureDeclaration);
  } else {
    changes.insertMemberAtStart(sourceFile, parentDeclaration, signatureDeclaration);
  }
  importAdder.writeFixes(changes);
}
function addEnumMemberDeclaration(changes, checker, _a) {
  const token = _a.token, parentDeclaration = _a.parentDeclaration;
  /**
   * create initializer only literal enum that has string initializer.
   * value of initializer is a string literal that equal to name of enum member.
   * numeric enum or empty enum will not create initializer.
   */
  const hasStringInitializer = ts.some(parentDeclaration.members, function(member) {
    const type = checker.getTypeAtLocation(member);
    return !!(type && type.flags & 402653316 /* TypeFlags.StringLike */);
  });
  const enumMember =
      ts.factory.createEnumMember(token, hasStringInitializer ? ts.factory.createStringLiteral(token.text) : undefined);
  changes.replaceNode(
      parentDeclaration.getSourceFile(), parentDeclaration,
      ts.factory.updateEnumDeclaration(
          parentDeclaration, parentDeclaration.modifiers, parentDeclaration.name,
          ts.concatenate(parentDeclaration.members, ts.singleElementArray(enumMember))),
      {
        leadingTriviaOption: ts.textChanges.LeadingTriviaOption.IncludeAll,
        trailingTriviaOption: ts.textChanges.TrailingTriviaOption.Exclude
      });
}
function addFunctionDeclaration(changes, context, info) {
  const quotePreference = ts.getQuotePreference(context.sourceFile, context.preferences);
  const importAdder = codefix.createImportAdder(context.sourceFile, context.program, context.preferences, context.host);
  const functionDeclaration = info.kind === InfoKind.Function ?
      codefix.createSignatureDeclarationFromCallExpression(
          259 /* SyntaxKind.FunctionDeclaration */, context, importAdder, info.call, ts.idText(info.token),
          info.modifierFlags, info.parentDeclaration) :
      codefix.createSignatureDeclarationFromSignature(
          259 /* SyntaxKind.FunctionDeclaration */, context, quotePreference, info.signature,
          codefix.createStubbedBody(ts.Diagnostics.Function_not_implemented.message, quotePreference), info.token,
          /* modifiers*/ undefined, /* optional*/ undefined, /* enclosingDeclaration*/ undefined, importAdder);
  if (functionDeclaration === undefined) {
    ts.Debug.fail('fixMissingFunctionDeclaration codefix got unexpected error.');
  }
  ts.isReturnStatement(info.parentDeclaration) ?
      changes.insertNodeBefore(
          info.sourceFile, info.parentDeclaration, functionDeclaration, /* blankLineBetween*/ true) :
      changes.insertNodeAtEndOfScope(info.sourceFile, info.parentDeclaration, functionDeclaration);
  importAdder.writeFixes(changes);
}
function addJsxAttributes(changes, context, info) {
  const importAdder = codefix.createImportAdder(context.sourceFile, context.program, context.preferences, context.host);
  const quotePreference = ts.getQuotePreference(context.sourceFile, context.preferences);
  const checker = context.program.getTypeChecker();
  const jsxAttributesNode = info.parentDeclaration.attributes;
  const hasSpreadAttribute = ts.some(jsxAttributesNode.properties, ts.isJsxSpreadAttribute);
  const attrs = ts.map(info.attributes, function(attr) {
    const value = tryGetValueFromType(
        context, checker, importAdder, quotePreference, checker.getTypeOfSymbol(attr), info.parentDeclaration);
    const name = ts.factory.createIdentifier(attr.name);
    const jsxAttribute =
        ts.factory.createJsxAttribute(name, ts.factory.createJsxExpression(/* dotDotDotToken*/ undefined, value));
    // formattingScanner requires the Identifier to have a context for scanning attributes with "-" (data-foo).
    ts.setParent(name, jsxAttribute);
    return jsxAttribute;
  });
  const jsxAttributes = ts.factory.createJsxAttributes(
      hasSpreadAttribute ? __spreadArray(__spreadArray([], attrs, true), jsxAttributesNode.properties, true) :
                           __spreadArray(__spreadArray([], jsxAttributesNode.properties, true), attrs, true));
  const options = {prefix: jsxAttributesNode.pos === jsxAttributesNode.end ? ' ' : undefined};
  changes.replaceNode(context.sourceFile, jsxAttributesNode, jsxAttributes, options);
  importAdder.writeFixes(changes);
}
function addObjectLiteralProperties(changes, context, info) {
  const importAdder = codefix.createImportAdder(context.sourceFile, context.program, context.preferences, context.host);
  const quotePreference = ts.getQuotePreference(context.sourceFile, context.preferences);
  const target = ts.getEmitScriptTarget(context.program.getCompilerOptions());
  const checker = context.program.getTypeChecker();
  const props = ts.map(info.properties, function(prop) {
    const initializer = tryGetValueFromType(
        context, checker, importAdder, quotePreference, checker.getTypeOfSymbol(prop), info.parentDeclaration);
    return ts.factory.createPropertyAssignment(
        createPropertyNameFromSymbol(prop, target, quotePreference, checker), initializer);
  });
  const options = {
    leadingTriviaOption: ts.textChanges.LeadingTriviaOption.Exclude,
    trailingTriviaOption: ts.textChanges.TrailingTriviaOption.Exclude,
    indentation: info.indentation
  };
  changes.replaceNode(
      context.sourceFile, info.parentDeclaration,
      ts.factory.createObjectLiteralExpression(
          __spreadArray(__spreadArray([], info.parentDeclaration.properties, true), props, true), /* multiLine*/ true),
      options);
  importAdder.writeFixes(changes);
}
function tryGetValueFromType(context, checker, importAdder, quotePreference, type, enclosingDeclaration) {
  if (type.flags & 3 /* TypeFlags.AnyOrUnknown */) {
    return createUndefined();
  }
  if (type.flags & (4 /* TypeFlags.String */ | 134217728 /* TypeFlags.TemplateLiteral */)) {
    return ts.factory.createStringLiteral('', /* isSingleQuote */ quotePreference === 0 /* QuotePreference.Single */);
  }
  if (type.flags & 8 /* TypeFlags.Number */) {
    return ts.factory.createNumericLiteral(0);
  }
  if (type.flags & 64 /* TypeFlags.BigInt */) {
    return ts.factory.createBigIntLiteral('0n');
  }
  if (type.flags & 16 /* TypeFlags.Boolean */) {
    return ts.factory.createFalse();
  }
  if (type.flags & 1056 /* TypeFlags.EnumLike */) {
    const enumMember =
        type.symbol.exports ? ts.firstOrUndefined(ts.arrayFrom(type.symbol.exports.values())) : type.symbol;
    const name = checker.symbolToExpression(
        type.symbol.parent ? type.symbol.parent : type.symbol, 111551 /* SymbolFlags.Value */,
        /* enclosingDeclaration*/ undefined, /* flags*/ undefined);
    return enumMember === undefined || name === undefined ?
        ts.factory.createNumericLiteral(0) :
        ts.factory.createPropertyAccessExpression(name, checker.symbolToString(enumMember));
  }
  if (type.flags & 256 /* TypeFlags.NumberLiteral */) {
    return ts.factory.createNumericLiteral(type.value);
  }
  if (type.flags & 2048 /* TypeFlags.BigIntLiteral */) {
    return ts.factory.createBigIntLiteral(type.value);
  }
  if (type.flags & 128 /* TypeFlags.StringLiteral */) {
    return ts.factory.createStringLiteral(
        type.value, /* isSingleQuote */ quotePreference === 0 /* QuotePreference.Single */);
  }
  if (type.flags & 512 /* TypeFlags.BooleanLiteral */) {
    return (type === checker.getFalseType() || type === checker.getFalseType(/* fresh*/ true)) ?
        ts.factory.createFalse() :
        ts.factory.createTrue();
  }
  if (type.flags & 65536 /* TypeFlags.Null */) {
    return ts.factory.createNull();
  }
  if (type.flags & 1048576 /* TypeFlags.Union */) {
    const expression = ts.firstDefined(type.types, function(t) {
      return tryGetValueFromType(context, checker, importAdder, quotePreference, t, enclosingDeclaration);
    });
    return expression !== null && expression !== void 0 ? expression : createUndefined();
  }
  if (checker.isArrayLikeType(type)) {
    return ts.factory.createArrayLiteralExpression();
  }
  if (isObjectLiteralType(type)) {
    const props = ts.map(checker.getPropertiesOfType(type), function(prop) {
      const initializer = prop.valueDeclaration ?
          tryGetValueFromType(
              context, checker, importAdder, quotePreference, checker.getTypeAtLocation(prop.valueDeclaration),
              enclosingDeclaration) :
          createUndefined();
      return ts.factory.createPropertyAssignment(prop.name, initializer);
    });
    return ts.factory.createObjectLiteralExpression(props, /* multiLine*/ true);
  }
  if (ts.getObjectFlags(type) & 16 /* ObjectFlags.Anonymous */) {
    const decl = ts.find(
        type.symbol.declarations || ts.emptyArray,
        ts.or(ts.isFunctionTypeNode, ts.isMethodSignature, ts.isMethodDeclaration));
    if (decl === undefined)
      {return createUndefined();}
    const signature = checker.getSignaturesOfType(type, 0 /* SignatureKind.Call */);
    if (signature === undefined)
      {return createUndefined();}
    const func = codefix.createSignatureDeclarationFromSignature(
        215 /* SyntaxKind.FunctionExpression */, context, quotePreference, signature[0],
        codefix.createStubbedBody(ts.Diagnostics.Function_not_implemented.message, quotePreference), /* name*/ undefined,
        /* modifiers*/ undefined, /* optional*/ undefined, /* enclosingDeclaration*/ enclosingDeclaration, importAdder);
    return func !== null && func !== void 0 ? func : createUndefined();
  }
  if (ts.getObjectFlags(type) & 1 /* ObjectFlags.Class */) {
    const classDeclaration = ts.getClassLikeDeclarationOfSymbol(type.symbol);
    if (classDeclaration === undefined || ts.hasAbstractModifier(classDeclaration))
      {return createUndefined();}
    const constructorDeclaration = ts.getFirstConstructorWithBody(classDeclaration);
    if (constructorDeclaration && ts.length(constructorDeclaration.parameters))
      {return createUndefined();}
    return ts.factory.createNewExpression(
        ts.factory.createIdentifier(type.symbol.name), /* typeArguments*/ undefined, /* argumentsArray*/ undefined);
  }
  return createUndefined();
}
function createUndefined() {
  return ts.factory.createIdentifier('undefined');
}
function isObjectLiteralType(type) {
  return (type.flags & 524288 /* TypeFlags.Object */) &&
      ((ts.getObjectFlags(type) & 128 /* ObjectFlags.ObjectLiteral */) ||
       (type.symbol && ts.tryCast(ts.singleOrUndefined(type.symbol.declarations), ts.isTypeLiteralNode)));
}
function getUnmatchedAttributes(checker, target, source) {
  const attrsType = checker.getContextualType(source.attributes);
  if (attrsType === undefined)
    {return ts.emptyArray;}
  const targetProps = attrsType.getProperties();
  if (!ts.length(targetProps))
    {return ts.emptyArray;}
  const seenNames = new ts.Set();
  for (let _i = 0, _a = source.attributes.properties; _i < _a.length; _i++) {
    const sourceProp = _a[_i];
    if (ts.isJsxAttribute(sourceProp)) {
      seenNames.add(sourceProp.name.escapedText);
    }
    if (ts.isJsxSpreadAttribute(sourceProp)) {
      const type = checker.getTypeAtLocation(sourceProp.expression);
      for (let _b = 0, _c = type.getProperties(); _b < _c.length; _b++) {
        const prop = _c[_b];
        seenNames.add(prop.escapedName);
      }
    }
  }
  return ts.filter(targetProps, function(targetProp) {
    return ts.isIdentifierText(targetProp.name, target, 1 /* LanguageVariant.JSX */) &&
        !((targetProp.flags & 16777216 /* SymbolFlags.Optional */ ||
           ts.getCheckFlags(targetProp) & 48 /* CheckFlags.Partial */) ||
          seenNames.has(targetProp.escapedName));
  });
}
function tryGetContainingMethodDeclaration(node, callExpression) {
  if (ts.isTypeLiteralNode(node)) {
    return undefined;
  }
  const declaration = ts.findAncestor(callExpression, function(n) {
    return ts.isMethodDeclaration(n) || ts.isConstructorDeclaration(n);
  });
  return declaration && declaration.parent === node ? declaration : undefined;
}
function createPropertyNameFromSymbol(symbol, target, quotePreference, checker) {
  if (ts.isTransientSymbol(symbol)) {
    const prop = checker.symbolToNode(
        symbol, 111551 /* SymbolFlags.Value */, /* enclosingDeclaration*/ undefined,
        1073741824 /* NodeBuilderFlags.WriteComputedProps */);
    if (prop && ts.isComputedPropertyName(prop))
      {return prop;}
  }
  return ts.createPropertyNameNodeForIdentifierOrLiteral(
      symbol.name, target, quotePreference === 0 /* QuotePreference.Single */);
}
function findScope(node) {
  if (ts.findAncestor(node, ts.isJsxExpression)) {
    const returnStatement = ts.findAncestor(node.parent, ts.isReturnStatement);
    if (returnStatement)
      {return returnStatement;}
  }
  return ts.getSourceFileOfNode(node);
}
})(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let codefix;
(function(codefix) {
const fixId = 'addMissingNewOperator';
const errorCodes = [ts.Diagnostics.Value_of_type_0_is_not_callable_Did_you_mean_to_include_new.code];
codefix.registerCodeFix({
  errorCodes,
  getCodeActions: function(context) {
    const sourceFile = context.sourceFile, span = context.span;
    const changes = ts.textChanges.ChangeTracker.with(context, function(t) {
      return addMissingNewOperator(t, sourceFile, span);
    });
    return [codefix.createCodeFixAction(
        fixId, changes, ts.Diagnostics.Add_missing_new_operator_to_call, fixId,
        ts.Diagnostics.Add_missing_new_operator_to_all_calls)];
  },
  fixIds: [fixId],
  getAllCodeActions: function(context) {
    return codefix.codeFixAll(context, errorCodes, function(changes, diag) {
      return addMissingNewOperator(changes, context.sourceFile, diag);
    });
  },
});
function addMissingNewOperator(changes, sourceFile, span) {
  const call = ts.cast(findAncestorMatchingSpan(sourceFile, span), ts.isCallExpression);
  const newExpression = ts.factory.createNewExpression(call.expression, call.typeArguments, call.arguments);
  changes.replaceNode(sourceFile, call, newExpression);
}
function findAncestorMatchingSpan(sourceFile, span) {
  let token = ts.getTokenAtPosition(sourceFile, span.start);
  const end = ts.textSpanEnd(span);
  while (token.end < end) {
    token = token.parent;
  }
  return token;
}
})(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let codefix;
(function(codefix) {
const fixName = 'fixCannotFindModule';
const fixIdInstallTypesPackage = 'installTypesPackage';
const errorCodeCannotFindModule = ts.Diagnostics.Cannot_find_module_0_or_its_corresponding_type_declarations.code;
const errorCodes = [
  errorCodeCannotFindModule,
  ts.Diagnostics.Could_not_find_a_declaration_file_for_module_0_1_implicitly_has_an_any_type.code,
];
codefix.registerCodeFix({
  errorCodes,
  getCodeActions: function getCodeActionsToFixNotFoundModule(context) {
    const host = context.host, sourceFile = context.sourceFile, start = context.span.start;
    const packageName = tryGetImportedPackageName(sourceFile, start);
    if (packageName === undefined)
      {return undefined;}
    const typesPackageName = getTypesPackageNameToInstall(packageName, host, context.errorCode);
    return typesPackageName === undefined ? [] : [
      codefix.createCodeFixAction(
          fixName, /* changes*/[], [ts.Diagnostics.Install_0, typesPackageName], fixIdInstallTypesPackage,
          ts.Diagnostics.Install_all_missing_types_packages, getInstallCommand(sourceFile.fileName, typesPackageName))
    ];
  },
  fixIds: [fixIdInstallTypesPackage],
  getAllCodeActions: function(context) {
    return codefix.codeFixAll(context, errorCodes, function(_changes, diag, commands) {
      const packageName = tryGetImportedPackageName(diag.file, diag.start);
      if (packageName === undefined)
        {return undefined;}
      switch (context.fixId) {
        case fixIdInstallTypesPackage: {
          const pkg = getTypesPackageNameToInstall(packageName, context.host, diag.code);
          if (pkg) {
            commands.push(getInstallCommand(diag.file.fileName, pkg));
          }
          break;
        }
        default:
          ts.Debug.fail('Bad fixId: '.concat(context.fixId));
      }
    });
  },
});
function getInstallCommand(fileName, packageName) {
  return {type: 'install package', file: fileName, packageName};
}
function tryGetImportedPackageName(sourceFile, pos) {
  const moduleSpecifierText = ts.tryCast(ts.getTokenAtPosition(sourceFile, pos), ts.isStringLiteral);
  if (!moduleSpecifierText)
    {return undefined;}
  const moduleName = moduleSpecifierText.text;
  const packageName = ts.parsePackageName(moduleName).packageName;
  return ts.isExternalModuleNameRelative(packageName) ? undefined : packageName;
}
function getTypesPackageNameToInstall(packageName, host, diagCode) {
  let _a;
  return diagCode === errorCodeCannotFindModule ?
      (ts.JsTyping.nodeCoreModules.has(packageName) ? '@types/node' : undefined) :
      (((_a = host.isKnownTypesPackageName) === null || _a === void 0 ? void 0 : _a.call(host, packageName)) ?
           ts.getTypesPackageName(packageName) :
           undefined);
}
})(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let codefix;
(function(codefix) {
const errorCodes = [
  ts.Diagnostics.Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_class_2.code,
  ts.Diagnostics.Non_abstract_class_expression_does_not_implement_inherited_abstract_member_0_from_class_1.code,
];
const fixId = 'fixClassDoesntImplementInheritedAbstractMember';
codefix.registerCodeFix({
  errorCodes,
  getCodeActions: function getCodeActionsToFixClassNotImplementingInheritedMembers(context) {
    const sourceFile = context.sourceFile, span = context.span;
    const changes = ts.textChanges.ChangeTracker.with(context, function(t) {
      return addMissingMembers(getClass(sourceFile, span.start), sourceFile, context, t, context.preferences);
    });
    return changes.length === 0 ? undefined : [codefix.createCodeFixAction(
                                                  fixId, changes, ts.Diagnostics.Implement_inherited_abstract_class,
                                                  fixId, ts.Diagnostics.Implement_all_inherited_abstract_classes)];
  },
  fixIds: [fixId],
  getAllCodeActions: function getAllCodeActionsToFixClassDoesntImplementInheritedAbstractMember(context) {
    const seenClassDeclarations = new ts.Map();
    return codefix.codeFixAll(context, errorCodes, function(changes, diag) {
      const classDeclaration = getClass(diag.file, diag.start);
      if (ts.addToSeen(seenClassDeclarations, ts.getNodeId(classDeclaration))) {
        addMissingMembers(classDeclaration, context.sourceFile, context, changes, context.preferences);
      }
    });
  },
});
function getClass(sourceFile, pos) {
  // Token is the identifier in the case of a class declaration
  // or the class keyword token in the case of a class expression.
  const token = ts.getTokenAtPosition(sourceFile, pos);
  return ts.cast(token.parent, ts.isClassLike);
}
function addMissingMembers(classDeclaration, sourceFile, context, changeTracker, preferences) {
  const extendsNode = ts.getEffectiveBaseTypeNode(classDeclaration);
  const checker = context.program.getTypeChecker();
  const instantiatedExtendsType = checker.getTypeAtLocation(extendsNode);
  // Note that this is ultimately derived from a map indexed by symbol names,
  // so duplicates cannot occur.
  const abstractAndNonPrivateExtendsSymbols =
      checker.getPropertiesOfType(instantiatedExtendsType).filter(symbolPointsToNonPrivateAndAbstractMember);
  const importAdder = codefix.createImportAdder(sourceFile, context.program, preferences, context.host);
  codefix.createMissingMemberNodes(
      classDeclaration, abstractAndNonPrivateExtendsSymbols, sourceFile, context, preferences, importAdder,
      function(member) {
        return changeTracker.insertMemberAtStart(sourceFile, classDeclaration, member);
      });
  importAdder.writeFixes(changeTracker);
}
function symbolPointsToNonPrivateAndAbstractMember(symbol) {
  // See `codeFixClassExtendAbstractProtectedProperty.ts` in https://github.com/Microsoft/TypeScript/pull/11547/files
  // (now named `codeFixClassExtendAbstractPrivateProperty.ts`)
  const flags = ts.getSyntacticModifierFlags(ts.first(symbol.getDeclarations()));
  return !(flags & 8 /* ModifierFlags.Private */) && !!(flags & 256 /* ModifierFlags.Abstract */);
}
})(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let codefix;
(function(codefix) {
const fixId = 'classSuperMustPrecedeThisAccess';
const errorCodes = [ts.Diagnostics.super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class.code];
codefix.registerCodeFix({
  errorCodes,
  getCodeActions: function(context) {
    const sourceFile = context.sourceFile, span = context.span;
    const nodes = getNodes(sourceFile, span.start);
    if (!nodes)
      {return undefined;}
    const constructor = nodes.constructor, superCall = nodes.superCall;
    const changes = ts.textChanges.ChangeTracker.with(context, function(t) {
      return doChange(t, sourceFile, constructor, superCall);
    });
    return [codefix.createCodeFixAction(
        fixId, changes, ts.Diagnostics.Make_super_call_the_first_statement_in_the_constructor, fixId,
        ts.Diagnostics.Make_all_super_calls_the_first_statement_in_their_constructor)];
  },
  fixIds: [fixId],
  getAllCodeActions: function(context) {
    const sourceFile = context.sourceFile;
    const seenClasses = new ts.Map();  // Ensure we only do this once per class.
    return codefix.codeFixAll(context, errorCodes, function(changes, diag) {
      const nodes = getNodes(diag.file, diag.start);
      if (!nodes)
        {return;}
      const constructor = nodes.constructor, superCall = nodes.superCall;
      if (ts.addToSeen(seenClasses, ts.getNodeId(constructor.parent))) {
        doChange(changes, sourceFile, constructor, superCall);
      }
    });
  },
});
function doChange(changes, sourceFile, constructor, superCall) {
  changes.insertNodeAtConstructorStart(sourceFile, constructor, superCall);
  changes.delete(sourceFile, superCall);
}
function getNodes(sourceFile, pos) {
  const token = ts.getTokenAtPosition(sourceFile, pos);
  if (token.kind !== 108 /* SyntaxKind.ThisKeyword */)
    {return undefined;}
  const constructor = ts.getContainingFunction(token);
  const superCall = findSuperCall(constructor.body);
  // figure out if the `this` access is actually inside the supercall
  // i.e. super(this.a), since in that case we won't suggest a fix
  return superCall && !superCall.expression.arguments.some(function(arg) {
    return ts.isPropertyAccessExpression(arg) && arg.expression === token;
  }) ?
      {constructor, superCall} :
      undefined;
}
function findSuperCall(n) {
  return ts.isExpressionStatement(n) && ts.isSuperCall(n.expression) ? n :
      ts.isFunctionLike(n)                                           ? undefined :
                                                                       ts.forEachChild(n, findSuperCall);
}
})(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let codefix;
(function(codefix) {
const fixId = 'constructorForDerivedNeedSuperCall';
const errorCodes = [ts.Diagnostics.Constructors_for_derived_classes_must_contain_a_super_call.code];
codefix.registerCodeFix({
  errorCodes,
  getCodeActions: function(context) {
    const sourceFile = context.sourceFile, span = context.span;
    const ctr = getNode(sourceFile, span.start);
    const changes = ts.textChanges.ChangeTracker.with(context, function(t) {
      return doChange(t, sourceFile, ctr);
    });
    return [codefix.createCodeFixAction(
        fixId, changes, ts.Diagnostics.Add_missing_super_call, fixId, ts.Diagnostics.Add_all_missing_super_calls)];
  },
  fixIds: [fixId],
  getAllCodeActions: function(context) {
    return codefix.codeFixAll(context, errorCodes, function(changes, diag) {
      return doChange(changes, context.sourceFile, getNode(diag.file, diag.start));
    });
  },
});
function getNode(sourceFile, pos) {
  const token = ts.getTokenAtPosition(sourceFile, pos);
  ts.Debug.assert(ts.isConstructorDeclaration(token.parent), 'token should be at the constructor declaration');
  return token.parent;
}
function doChange(changes, sourceFile, ctr) {
  const superCall = ts.factory.createExpressionStatement(ts.factory.createCallExpression(
      ts.factory.createSuper(), /* typeArguments*/ undefined, /* argumentsArray*/ ts.emptyArray));
  changes.insertNodeAtConstructorStart(sourceFile, ctr, superCall);
}
})(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let codefix;
(function(codefix) {
const fixId = 'enableExperimentalDecorators';
const errorCodes = [
  ts.Diagnostics
      .Experimental_support_for_decorators_is_a_feature_that_is_subject_to_change_in_a_future_release_Set_the_experimentalDecorators_option_in_your_tsconfig_or_jsconfig_to_remove_this_warning
      .code
];
codefix.registerCodeFix({
  errorCodes,
  getCodeActions: function getCodeActionsToEnableExperimentalDecorators(context) {
    const configFile = context.program.getCompilerOptions().configFile;
    if (configFile === undefined) {
      return undefined;
    }
    const changes = ts.textChanges.ChangeTracker.with(context, function(changeTracker) {
      return doChange(changeTracker, configFile);
    });
    return [codefix.createCodeFixActionWithoutFixAll(
        fixId, changes, ts.Diagnostics.Enable_the_experimentalDecorators_option_in_your_configuration_file)];
  },
  fixIds: [fixId],
  getAllCodeActions: function(context) {
    return codefix.codeFixAll(context, errorCodes, function(changes) {
      const configFile = context.program.getCompilerOptions().configFile;
      if (configFile === undefined) {
        return undefined;
      }
      doChange(changes, configFile);
    });
  },
});
function doChange(changeTracker, configFile) {
  codefix.setJsonCompilerOptionValue(changeTracker, configFile, 'experimentalDecorators', ts.factory.createTrue());
}
})(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let codefix;
(function(codefix) {
const fixID = 'fixEnableJsxFlag';
const errorCodes = [ts.Diagnostics.Cannot_use_JSX_unless_the_jsx_flag_is_provided.code];
codefix.registerCodeFix({
  errorCodes,
  getCodeActions: function getCodeActionsToFixEnableJsxFlag(context) {
    const configFile = context.program.getCompilerOptions().configFile;
    if (configFile === undefined) {
      return undefined;
    }
    const changes = ts.textChanges.ChangeTracker.with(context, function(changeTracker) {
      return doChange(changeTracker, configFile);
    });
    return [codefix.createCodeFixActionWithoutFixAll(
        fixID, changes, ts.Diagnostics.Enable_the_jsx_flag_in_your_configuration_file)];
  },
  fixIds: [fixID],
  getAllCodeActions: function(context) {
    return codefix.codeFixAll(context, errorCodes, function(changes) {
      const configFile = context.program.getCompilerOptions().configFile;
      if (configFile === undefined) {
        return undefined;
      }
      doChange(changes, configFile);
    });
  }
});
function doChange(changeTracker, configFile) {
  codefix.setJsonCompilerOptionValue(changeTracker, configFile, 'jsx', ts.factory.createStringLiteral('react'));
}
})(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let codefix;
(function(codefix) {
const fixId = 'fixNaNEquality';
const errorCodes = [
  ts.Diagnostics.This_condition_will_always_return_0.code,
];
codefix.registerCodeFix({
  errorCodes,
  getCodeActions: function(context) {
    const sourceFile = context.sourceFile, span = context.span, program = context.program;
    const info = getInfo(program, sourceFile, span);
    if (info === undefined)
      {return;}
    const suggestion = info.suggestion, expression = info.expression, arg = info.arg;
    const changes = ts.textChanges.ChangeTracker.with(context, function(t) {
      return doChange(t, sourceFile, arg, expression);
    });
    return [codefix.createCodeFixAction(
        fixId, changes, [ts.Diagnostics.Use_0, suggestion], fixId, ts.Diagnostics.Use_Number_isNaN_in_all_conditions)];
  },
  fixIds: [fixId],
  getAllCodeActions: function(context) {
    return codefix.codeFixAll(context, errorCodes, function(changes, diag) {
      const info = getInfo(context.program, diag.file, ts.createTextSpan(diag.start, diag.length));
      if (info) {
        doChange(changes, diag.file, info.arg, info.expression);
      }
    });
  }
});
function getInfo(program, sourceFile, span) {
  const diag = ts.find(program.getSemanticDiagnostics(sourceFile), function(diag) {
    return diag.start === span.start && diag.length === span.length;
  });
  if (diag === undefined || diag.relatedInformation === undefined)
    {return;}
  const related = ts.find(diag.relatedInformation, function(related) {
    return related.code === ts.Diagnostics.Did_you_mean_0.code;
  });
  if (related === undefined || related.file === undefined || related.start === undefined ||
      related.length === undefined)
    {return;}
  const token = codefix.findAncestorMatchingSpan(related.file, ts.createTextSpan(related.start, related.length));
  if (token === undefined)
    {return;}
  if (ts.isExpression(token) && ts.isBinaryExpression(token.parent)) {
    return {suggestion: getSuggestion(related.messageText), expression: token.parent, arg: token};
  }
  return undefined;
}
function doChange(changes, sourceFile, arg, expression) {
  const callExpression = ts.factory.createCallExpression(
      ts.factory.createPropertyAccessExpression(
          ts.factory.createIdentifier('Number'), ts.factory.createIdentifier('isNaN')),
      /* typeArguments*/ undefined, [arg]);
  const operator = expression.operatorToken.kind;
  changes.replaceNode(
      sourceFile, expression,
      operator === 37 /* SyntaxKind.ExclamationEqualsEqualsToken */ ||
              operator === 35 /* SyntaxKind.ExclamationEqualsToken */
          ?
          ts.factory.createPrefixUnaryExpression(53 /* SyntaxKind.ExclamationToken */, callExpression) :
          callExpression);
}
function getSuggestion(messageText) {
  const _a = ts.flattenDiagnosticMessageText(messageText, '\n', 0).match(/\'(.*)\'/) || [], _ = _a[0], suggestion = _a[1];
  return suggestion;
}
})(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let codefix;
(function(codefix) {
codefix.registerCodeFix({
  errorCodes: [
    ts.Diagnostics
        .Top_level_await_expressions_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_node16_or_nodenext_and_the_target_option_is_set_to_es2017_or_higher
        .code,
    ts.Diagnostics
        .Top_level_for_await_loops_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_node16_or_nodenext_and_the_target_option_is_set_to_es2017_or_higher
        .code,
  ],
  getCodeActions: function getCodeActionsToFixModuleAndTarget(context) {
    const compilerOptions = context.program.getCompilerOptions();
    const configFile = compilerOptions.configFile;
    if (configFile === undefined) {
      return undefined;
    }
    const codeFixes = [];
    const moduleKind = ts.getEmitModuleKind(compilerOptions);
    const moduleOutOfRange = moduleKind >= ts.ModuleKind.ES2015 && moduleKind < ts.ModuleKind.ESNext;
    if (moduleOutOfRange) {
      var changes = ts.textChanges.ChangeTracker.with(context, function(changes) {
        codefix.setJsonCompilerOptionValue(changes, configFile, 'module', ts.factory.createStringLiteral('esnext'));
      });
      codeFixes.push(codefix.createCodeFixActionWithoutFixAll(
          'fixModuleOption', changes,
          [ts.Diagnostics.Set_the_module_option_in_your_configuration_file_to_0, 'esnext']));
    }
    const target = ts.getEmitScriptTarget(compilerOptions);
    const targetOutOfRange = target < 4 /* ScriptTarget.ES2017 */ || target > 99 /* ScriptTarget.ESNext */;
    if (targetOutOfRange) {
      var changes = ts.textChanges.ChangeTracker.with(context, function(tracker) {
        const configObject = ts.getTsConfigObjectLiteralExpression(configFile);
        if (!configObject)
          {return;}
        const options = [['target', ts.factory.createStringLiteral('es2017')]];
        if (moduleKind === ts.ModuleKind.CommonJS) {
          // Ensure we preserve the default module kind (commonjs), as targets >= ES2015 have a default module kind of es2015.
          options.push(['module', ts.factory.createStringLiteral('commonjs')]);
        }
        codefix.setJsonCompilerOptionValues(tracker, configFile, options);
      });
      codeFixes.push(codefix.createCodeFixActionWithoutFixAll(
          'fixTargetOption', changes,
          [ts.Diagnostics.Set_the_target_option_in_your_configuration_file_to_0, 'es2017']));
    }
    return codeFixes.length ? codeFixes : undefined;
  }
});
})(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let codefix;
(function(codefix) {
const fixId = 'fixPropertyAssignment';
const errorCodes = [
  ts.Diagnostics
      .Did_you_mean_to_use_a_Colon_An_can_only_follow_a_property_name_when_the_containing_object_literal_is_part_of_a_destructuring_pattern
      .code
];
codefix.registerCodeFix({
  errorCodes,
  fixIds: [fixId],
  getCodeActions: function(context) {
    const sourceFile = context.sourceFile, span = context.span;
    const property = getProperty(sourceFile, span.start);
    const changes = ts.textChanges.ChangeTracker.with(context, function(t) {
      return doChange(t, context.sourceFile, property);
    });
    return [codefix.createCodeFixAction(
        fixId, changes, [ts.Diagnostics.Change_0_to_1, '=', ':'], fixId,
        [ts.Diagnostics.Switch_each_misused_0_to_1, '=', ':'])];
  },
  getAllCodeActions: function(context) {
    return codefix.codeFixAll(context, errorCodes, function(changes, diag) {
      return doChange(changes, diag.file, getProperty(diag.file, diag.start));
    });
  }
});
function doChange(changes, sourceFile, node) {
  changes.replaceNode(
      sourceFile, node, ts.factory.createPropertyAssignment(node.name, node.objectAssignmentInitializer));
}
function getProperty(sourceFile, pos) {
  return ts.cast(ts.getTokenAtPosition(sourceFile, pos).parent, ts.isShorthandPropertyAssignment);
}
})(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let codefix;
(function(codefix) {
const fixId = 'extendsInterfaceBecomesImplements';
const errorCodes = [ts.Diagnostics.Cannot_extend_an_interface_0_Did_you_mean_implements.code];
codefix.registerCodeFix({
  errorCodes,
  getCodeActions: function(context) {
    const sourceFile = context.sourceFile;
    const nodes = getNodes(sourceFile, context.span.start);
    if (!nodes)
      {return undefined;}
    const extendsToken = nodes.extendsToken, heritageClauses = nodes.heritageClauses;
    const changes = ts.textChanges.ChangeTracker.with(context, function(t) {
      return doChanges(t, sourceFile, extendsToken, heritageClauses);
    });
    return [codefix.createCodeFixAction(
        fixId, changes, ts.Diagnostics.Change_extends_to_implements, fixId,
        ts.Diagnostics.Change_all_extended_interfaces_to_implements)];
  },
  fixIds: [fixId],
  getAllCodeActions: function(context) {
    return codefix.codeFixAll(context, errorCodes, function(changes, diag) {
      const nodes = getNodes(diag.file, diag.start);
      if (nodes)
        {doChanges(changes, diag.file, nodes.extendsToken, nodes.heritageClauses);}
    });
  },
});
function getNodes(sourceFile, pos) {
  const token = ts.getTokenAtPosition(sourceFile, pos);
  const heritageClauses = ts.getContainingClass(token).heritageClauses;
  const extendsToken = heritageClauses[0].getFirstToken();
  return extendsToken.kind === 94 /* SyntaxKind.ExtendsKeyword */ ?
      {extendsToken, heritageClauses} :
      undefined;
}
function doChanges(changes, sourceFile, extendsToken, heritageClauses) {
  changes.replaceNode(sourceFile, extendsToken, ts.factory.createToken(117 /* SyntaxKind.ImplementsKeyword */));
  // If there is already an implements clause, replace the implements keyword with a comma.
  if (heritageClauses.length === 2 && heritageClauses[0].token === 94 /* SyntaxKind.ExtendsKeyword */ &&
      heritageClauses[1].token === 117 /* SyntaxKind.ImplementsKeyword */) {
    const implementsToken = heritageClauses[1].getFirstToken();
    const implementsFullStart = implementsToken.getFullStart();
    changes.replaceRange(
        sourceFile, {pos: implementsFullStart, end: implementsFullStart},
        ts.factory.createToken(27 /* SyntaxKind.CommaToken */));
    // Rough heuristic: delete trailing whitespace after keyword so that it's not excessive.
    // (Trailing because leading might be indentation, which is more sensitive.)
    const text = sourceFile.text;
    let end = implementsToken.end;
    while (end < text.length && ts.isWhiteSpaceSingleLine(text.charCodeAt(end))) {
      end++;
    }
    changes.deleteRange(sourceFile, {pos: implementsToken.getStart(), end});
  }
}
})(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let codefix;
(function(codefix) {
const fixId = 'forgottenThisPropertyAccess';
const didYouMeanStaticMemberCode = ts.Diagnostics.Cannot_find_name_0_Did_you_mean_the_static_member_1_0.code;
const errorCodes = [
  ts.Diagnostics.Cannot_find_name_0_Did_you_mean_the_instance_member_this_0.code,
  ts.Diagnostics
      .Private_identifiers_are_only_allowed_in_class_bodies_and_may_only_be_used_as_part_of_a_class_member_declaration_property_access_or_on_the_left_hand_side_of_an_in_expression
      .code,
  didYouMeanStaticMemberCode,
];
codefix.registerCodeFix({
  errorCodes,
  getCodeActions: function(context) {
    const sourceFile = context.sourceFile;
    const info = getInfo(sourceFile, context.span.start, context.errorCode);
    if (!info) {
      return undefined;
    }
    const changes = ts.textChanges.ChangeTracker.with(context, function(t) {
      return doChange(t, sourceFile, info);
    });
    return [codefix.createCodeFixAction(
        fixId, changes, [ts.Diagnostics.Add_0_to_unresolved_variable, info.className || 'this'], fixId,
        ts.Diagnostics.Add_qualifier_to_all_unresolved_variables_matching_a_member_name)];
  },
  fixIds: [fixId],
  getAllCodeActions: function(context) {
    return codefix.codeFixAll(context, errorCodes, function(changes, diag) {
      const info = getInfo(diag.file, diag.start, diag.code);
      if (info)
        {doChange(changes, context.sourceFile, info);}
    });
  },
});
function getInfo(sourceFile, pos, diagCode) {
  const node = ts.getTokenAtPosition(sourceFile, pos);
  if (ts.isIdentifier(node) || ts.isPrivateIdentifier(node)) {
    return {
      node,
      className: diagCode === didYouMeanStaticMemberCode ? ts.getContainingClass(node).name.text : undefined
    };
  }
}
function doChange(changes, sourceFile, _a) {
  const node = _a.node, className = _a.className;
  // TODO (https://github.com/Microsoft/TypeScript/issues/21246): use shared helper
  ts.suppressLeadingAndTrailingTrivia(node);
  changes.replaceNode(
      sourceFile, node,
      ts.factory.createPropertyAccessExpression(
          className ? ts.factory.createIdentifier(className) : ts.factory.createThis(), node));
}
})(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let codefix;
(function(codefix) {
const fixIdExpression = 'fixInvalidJsxCharacters_expression';
const fixIdHtmlEntity = 'fixInvalidJsxCharacters_htmlEntity';
const errorCodes = [
  ts.Diagnostics.Unexpected_token_Did_you_mean_or_gt.code, ts.Diagnostics.Unexpected_token_Did_you_mean_or_rbrace.code
];
codefix.registerCodeFix({
  errorCodes,
  fixIds: [fixIdExpression, fixIdHtmlEntity],
  getCodeActions: function(context) {
    const sourceFile = context.sourceFile, preferences = context.preferences, span = context.span;
    const changeToExpression = ts.textChanges.ChangeTracker.with(context, function(t) {
      return doChange(t, preferences, sourceFile, span.start, /* useHtmlEntity */ false);
    });
    const changeToHtmlEntity = ts.textChanges.ChangeTracker.with(context, function(t) {
      return doChange(t, preferences, sourceFile, span.start, /* useHtmlEntity */ true);
    });
    return [
      codefix.createCodeFixAction(
          fixIdExpression, changeToExpression, ts.Diagnostics.Wrap_invalid_character_in_an_expression_container,
          fixIdExpression, ts.Diagnostics.Wrap_all_invalid_characters_in_an_expression_container),
      codefix.createCodeFixAction(
          fixIdHtmlEntity, changeToHtmlEntity, ts.Diagnostics.Convert_invalid_character_to_its_html_entity_code,
          fixIdHtmlEntity, ts.Diagnostics.Convert_all_invalid_characters_to_HTML_entity_code)
    ];
  },
  getAllCodeActions: function(context) {
    return codefix.codeFixAll(context, errorCodes, function(changes, diagnostic) {
      return doChange(
          changes, context.preferences, diagnostic.file, diagnostic.start, context.fixId === fixIdHtmlEntity);
    });
  }
});
const htmlEntity = {
  '>': '&gt;',
  '}': '&rbrace;',
};
function isValidCharacter(character) {
  return ts.hasProperty(htmlEntity, character);
}
function doChange(changes, preferences, sourceFile, start, useHtmlEntity) {
  const character = sourceFile.getText()[start];
  // sanity check
  if (!isValidCharacter(character)) {
    return;
  }
  const replacement =
      useHtmlEntity ? htmlEntity[character] : '{'.concat(ts.quote(sourceFile, preferences, character), '}');
  changes.replaceRangeWithText(sourceFile, {pos: start, end: start + 1}, replacement);
}
})(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let codefix;
(function(codefix) {
const deleteUnmatchedParameter = 'deleteUnmatchedParameter';
const renameUnmatchedParameter = 'renameUnmatchedParameter';
const errorCodes = [
  ts.Diagnostics.JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name.code,
];
codefix.registerCodeFix({
  fixIds: [deleteUnmatchedParameter, renameUnmatchedParameter],
  errorCodes,
  getCodeActions: function getCodeActionsToFixUnmatchedParameter(context) {
    const sourceFile = context.sourceFile, span = context.span;
    const actions = [];
    const info = getInfo(sourceFile, span.start);
    if (info) {
      ts.append(actions, getDeleteAction(context, info));
      ts.append(actions, getRenameAction(context, info));
      return actions;
    }
    return undefined;
  },
  getAllCodeActions: function getAllCodeActionsToFixUnmatchedParameter(context) {
    const tagsToSignature = new ts.Map();
    return codefix.createCombinedCodeActions(ts.textChanges.ChangeTracker.with(context, function(changes) {
      codefix.eachDiagnostic(context, errorCodes, function(_a) {
        const file = _a.file, start = _a.start;
        const info = getInfo(file, start);
        if (info) {
          tagsToSignature.set(info.signature, ts.append(tagsToSignature.get(info.signature), info.jsDocParameterTag));
        }
      });
      tagsToSignature.forEach(function(tags, signature) {
        if (context.fixId === deleteUnmatchedParameter) {
          const tagsSet_1 = new ts.Set(tags);
          changes.filterJSDocTags(signature.getSourceFile(), signature, function(t) {
            return !tagsSet_1.has(t);
          });
        }
      });
    }));
  }
});
function getDeleteAction(context, _a) {
  const name = _a.name, signature = _a.signature, jsDocParameterTag = _a.jsDocParameterTag;
  const changes = ts.textChanges.ChangeTracker.with(context, function(changeTracker) {
    return changeTracker.filterJSDocTags(context.sourceFile, signature, function(t) {
      return t !== jsDocParameterTag;
    });
  });
  return codefix.createCodeFixAction(
      deleteUnmatchedParameter, changes, [ts.Diagnostics.Delete_unused_param_tag_0, name.getText(context.sourceFile)],
      deleteUnmatchedParameter, ts.Diagnostics.Delete_all_unused_param_tags);
}
function getRenameAction(context, _a) {
  const name = _a.name, signature = _a.signature, jsDocParameterTag = _a.jsDocParameterTag;
  if (!ts.length(signature.parameters))
    {return undefined;}
  const sourceFile = context.sourceFile;
  const tags = ts.getJSDocTags(signature);
  const names = new ts.Set();
  for (let _i = 0, tags_2 = tags; _i < tags_2.length; _i++) {
    const tag = tags_2[_i];
    if (ts.isJSDocParameterTag(tag) && ts.isIdentifier(tag.name)) {
      names.add(tag.name.escapedText);
    }
  }
  // @todo - match to all available names instead to the first parameter name
  // @see /codeFixRenameUnmatchedParameter3.ts
  const parameterName = ts.firstDefined(signature.parameters, function(p) {
    return ts.isIdentifier(p.name) && !names.has(p.name.escapedText) ? p.name.getText(sourceFile) : undefined;
  });
  if (parameterName === undefined)
    {return undefined;}
  const newJSDocParameterTag = ts.factory.updateJSDocParameterTag(
      jsDocParameterTag, jsDocParameterTag.tagName, ts.factory.createIdentifier(parameterName),
      jsDocParameterTag.isBracketed, jsDocParameterTag.typeExpression, jsDocParameterTag.isNameFirst,
      jsDocParameterTag.comment);
  const changes = ts.textChanges.ChangeTracker.with(context, function(changeTracker) {
    return changeTracker.replaceJSDocComment(sourceFile, signature, ts.map(tags, function(t) {
      return t === jsDocParameterTag ? newJSDocParameterTag : t;
    }));
  });
  return codefix.createCodeFixActionWithoutFixAll(
      renameUnmatchedParameter, changes,
      [ts.Diagnostics.Rename_param_tag_name_0_to_1, name.getText(sourceFile), parameterName]);
}
function getInfo(sourceFile, pos) {
  const token = ts.getTokenAtPosition(sourceFile, pos);
  if (token.parent && ts.isJSDocParameterTag(token.parent) && ts.isIdentifier(token.parent.name)) {
    const jsDocParameterTag = token.parent;
    const signature = ts.getHostSignatureFromJSDoc(jsDocParameterTag);
    if (signature) {
      return {signature, name: token.parent.name, jsDocParameterTag};
    }
  }
  return undefined;
}
})(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let codefix;
(function(codefix) {
const fixId = 'fixUnreferenceableDecoratorMetadata';
const errorCodes = [
  ts.Diagnostics
      .A_type_referenced_in_a_decorated_signature_must_be_imported_with_import_type_or_a_namespace_import_when_isolatedModules_and_emitDecoratorMetadata_are_enabled
      .code
];
codefix.registerCodeFix({
  errorCodes,
  getCodeActions: function(context) {
    const importDeclaration = getImportDeclaration(context.sourceFile, context.program, context.span.start);
    if (!importDeclaration)
      {return;}
    const namespaceChanges = ts.textChanges.ChangeTracker.with(context, function(t) {
      return importDeclaration.kind === 273 /* SyntaxKind.ImportSpecifier */ &&
          doNamespaceImportChange(t, context.sourceFile, importDeclaration, context.program);
    });
    const typeOnlyChanges = ts.textChanges.ChangeTracker.with(context, function(t) {
      return doTypeOnlyImportChange(t, context.sourceFile, importDeclaration, context.program);
    });
    let actions;
    if (namespaceChanges.length) {
      actions = ts.append(
          actions,
          codefix.createCodeFixActionWithoutFixAll(
              fixId, namespaceChanges, ts.Diagnostics.Convert_named_imports_to_namespace_import));
    }
    if (typeOnlyChanges.length) {
      actions = ts.append(
          actions,
          codefix.createCodeFixActionWithoutFixAll(fixId, typeOnlyChanges, ts.Diagnostics.Convert_to_type_only_import));
    }
    return actions;
  },
  fixIds: [fixId],
});
function getImportDeclaration(sourceFile, program, start) {
  const identifier = ts.tryCast(ts.getTokenAtPosition(sourceFile, start), ts.isIdentifier);
  if (!identifier || identifier.parent.kind !== 180 /* SyntaxKind.TypeReference */)
    {return;}
  const checker = program.getTypeChecker();
  const symbol = checker.getSymbolAtLocation(identifier);
  return ts.find(
      (symbol === null || symbol === void 0 ? void 0 : symbol.declarations) || ts.emptyArray,
      ts.or(ts.isImportClause, ts.isImportSpecifier, ts.isImportEqualsDeclaration));
}
// Converts the import declaration of the offending import to a type-only import,
// only if it can be done without affecting other imported names. If the conversion
// cannot be done cleanly, we could offer to *extract* the offending import to a
// new type-only import declaration, but honestly I doubt anyone will ever use this
// codefix at all, so it's probably not worth the lines of code.
function doTypeOnlyImportChange(changes, sourceFile, importDeclaration, program) {
  if (importDeclaration.kind === 268 /* SyntaxKind.ImportEqualsDeclaration */) {
    changes.insertModifierBefore(sourceFile, 154 /* SyntaxKind.TypeKeyword */, importDeclaration.name);
    return;
  }
  const importClause = importDeclaration.kind === 270 /* SyntaxKind.ImportClause */ ? importDeclaration :
                                                                                    importDeclaration.parent.parent;
  if (importClause.name && importClause.namedBindings) {
    // Cannot convert an import with a default import and named bindings to type-only
    // (it's a grammar error).
    return;
  }
  const checker = program.getTypeChecker();
  const importsValue = !!ts.forEachImportClauseDeclaration(importClause, function(decl) {
    if (ts.skipAlias(decl.symbol, checker).flags & 111551 /* SymbolFlags.Value */)
      {return true;}
  });
  if (importsValue) {
    // Assume that if someone wrote a non-type-only import that includes some values,
    // they intend to use those values in value positions, even if they haven't yet.
    // Don't convert it to type-only.
    return;
  }
  changes.insertModifierBefore(sourceFile, 154 /* SyntaxKind.TypeKeyword */, importClause);
}
function doNamespaceImportChange(changes, sourceFile, importDeclaration, program) {
  ts.refactor.doChangeNamedToNamespaceOrDefault(sourceFile, program, changes, importDeclaration.parent);
}
})(codefix = ts.codefix || (ts.codefix = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function(ts) {
let codefix;
(function(codefix) {
const fixName = 'unusedIdentifier';
const fixIdPrefix = 'unusedIdentifier_prefix';
const fixIdDelete = 'unusedIdentifier_delete';
const fixIdDeleteImports = 'unusedIdentifier_deleteImports';
const fixIdInfer = 'unusedIdentifier_infer';
const errorCodes = [
  ts.Diagnostics._0_is_declared_but_its_value_is_never_read.code,
  ts.Diagnostics._0_is_declared_but_never_used.code,
  ts.Diagnostics.Property_0_is_declared_but_its_value_is_never_read.code,
  ts.Diagnostics.All_imports_in_import_declaration_are_unused.code,
  ts.Diagnostics.All_destructured_elements_are_unused.code,
  ts.Diagnostics.All_variables_are_unused.code,
  ts.Diagnostics.All_type_parameters_are_unused.code,
];
codefix.registerCodeFix({
  errorCodes,
  getCodeActions: function(context) {
    const errorCode = context.errorCode, sourceFile = context.sourceFile, program = context.program,
        cancellationToken = context.cancellationToken;
    const checker = program.getTypeChecker();
    const sourceFiles = program.getSourceFiles();
    const token = ts.getTokenAtPosition(sourceFile, context.span.start);
    if (ts.isJSDocTemplateTag(token)) {
      return [createDeleteFix(ts.textChanges.ChangeTracker.with(context, function(t) {
        return t.delete(sourceFile, token);
      }), ts.Diagnostics.Remove_template_tag)];
    }
    if (token.kind === 29 /* SyntaxKind.LessThanToken */) {
      var changes = ts.textChanges.ChangeTracker.with(context, function(t) {
        return deleteTypeParameters(t, sourceFile, token);
      });
      return [createDeleteFix(changes, ts.Diagnostics.Remove_type_parameters)];
    }
    const importDecl = tryGetFullImport(token);
    if (importDecl) {
      var changes = ts.textChanges.ChangeTracker.with(context, function(t) {
        return t.delete(sourceFile, importDecl);
      });
      return [codefix.createCodeFixAction(
          fixName, changes, [ts.Diagnostics.Remove_import_from_0, ts.showModuleSpecifier(importDecl)],
          fixIdDeleteImports, ts.Diagnostics.Delete_all_unused_imports)];
    } if (isImport(token)) {
      var deletion = ts.textChanges.ChangeTracker.with(context, function(t) {
        return tryDeleteDeclaration(
            sourceFile, token, t, checker, sourceFiles, program, cancellationToken, /* isFixAll*/ false);
      });
      if (deletion.length) {
        return [codefix.createCodeFixAction(
            fixName, deletion, [ts.Diagnostics.Remove_unused_declaration_for_Colon_0, token.getText(sourceFile)],
            fixIdDeleteImports, ts.Diagnostics.Delete_all_unused_imports)];
      }
    }
    if (ts.isObjectBindingPattern(token.parent) || ts.isArrayBindingPattern(token.parent)) {
      if (ts.isParameter(token.parent.parent)) {
        const elements = token.parent.elements;
        const diagnostic = [
          elements.length > 1 ? ts.Diagnostics.Remove_unused_declarations_for_Colon_0 :
                                ts.Diagnostics.Remove_unused_declaration_for_Colon_0,
          ts.map(
                elements,
                function(e) {
                  return e.getText(sourceFile);
                })
              .join(', ')
        ];
        return [createDeleteFix(ts.textChanges.ChangeTracker.with(context, function(t) {
          return deleteDestructuringElements(t, sourceFile, token.parent);
        }), diagnostic)];
      }
      return [createDeleteFix(ts.textChanges.ChangeTracker.with(context, function(t) {
        return t.delete(sourceFile, token.parent.parent);
      }), ts.Diagnostics.Remove_unused_destructuring_declaration)];
    }
    if (canDeleteEntireVariableStatement(sourceFile, token)) {
      return [createDeleteFix(ts.textChanges.ChangeTracker.with(context, function(t) {
        return deleteEntireVariableStatement(t, sourceFile, token.parent);
      }), ts.Diagnostics.Remove_variable_statement)];
    }
    const result = [];
    if (token.kind === 138 /* SyntaxKind.InferKeyword */) {
      var changes = ts.textChanges.ChangeTracker.with(context, function(t) {
        return changeInferToUnknown(t, sourceFile, token);
      });
      var name = ts.cast(token.parent, ts.isInferTypeNode).typeParameter.name.text;
      result.push(codefix.createCodeFixAction(
          fixName, changes, [ts.Diagnostics.Replace_infer_0_with_unknown, name], fixIdInfer,
          ts.Diagnostics.Replace_all_unused_infer_with_unknown));
    } else {
      var deletion = ts.textChanges.ChangeTracker.with(context, function(t) {
        return tryDeleteDeclaration(
            sourceFile, token, t, checker, sourceFiles, program, cancellationToken, /* isFixAll*/ false);
      });
      if (deletion.length) {
        var name = ts.isComputedPropertyName(token.parent) ? token.parent : token;
        result.push(createDeleteFix(
            deletion, [ts.Diagnostics.Remove_unused_declaration_for_Colon_0, name.getText(sourceFile)]));
      }
    }
    const prefix = ts.textChanges.ChangeTracker.with(context, function(t) {
      return tryPrefixDeclaration(t, errorCode, sourceFile, token);
    });
    if (prefix.length) {
      result.push(codefix.createCodeFixAction(
          fixName, prefix, [ts.Diagnostics.Prefix_0_with_an_underscore, token.getText(sourceFile)], fixIdPrefix,
          ts.Diagnostics.Prefix_all_unused_declarations_with_where_possible));
    }
    return result;
  },
  fixIds: [fixIdPrefix, fixIdDelete, fixIdDeleteImports, fixIdInfer],
  getAllCodeActions: function(context) {
    const sourceFile = context.sourceFile, program = context.program, cancellationToken = context.cancellationToken;
    const checker = program.getTypeChecker();
    const sourceFiles = program.getSourceFiles();
    return codefix.codeFixAll(context, errorCodes, function(changes, diag) {
      const token = ts.getTokenAtPosition(sourceFile, diag.start);
      switch (context.fixId) {
        case fixIdPrefix:
          tryPrefixDeclaration(changes, diag.code, sourceFile, token);
          break;
        case fixIdDeleteImports: {
          const importDecl = tryGetFullImport(token);
          if (importDecl) {
            changes.delete(sourceFile, importDecl);
          } else if (isImport(token)) {
            tryDeleteDeclaration(
                sourceFile, token, changes, checker, sourceFiles, program, cancellationToken, /* isFixAll*/ true);
          }
          break;
        }
        case fixIdDelete: {
          if (token.kind === 138 /* SyntaxKind.InferKeyword */ || isImport(token)) {
            break;  // Can't delete
          } else if (ts.isJSDocTemplateTag(token)) {
            changes.delete(sourceFile, token);
          } else if (token.kind === 29 /* SyntaxKind.LessThanToken */) {
            deleteTypeParameters(changes, sourceFile, token);
          } else if (ts.isObjectBindingPattern(token.parent)) {
            if (token.parent.parent.initializer) {
              break;
            } else if (
                !ts.isParameter(token.parent.parent) ||
                isNotProvidedArguments(token.parent.parent, checker, sourceFiles)) {
              changes.delete(sourceFile, token.parent.parent);
            }
          } else if (ts.isArrayBindingPattern(token.parent.parent) && token.parent.parent.parent.initializer) {
            break;
          } else if (canDeleteEntireVariableStatement(sourceFile, token)) {
            deleteEntireVariableStatement(changes, sourceFile, token.parent);
          } else {
            tryDeleteDeclaration(
                sourceFile, token, changes, checker, sourceFiles, program, cancellationToken, /* isFixAll*/ true);
          }
          break;
        }
        case fixIdInfer:
          if (token.kind === 138 /* SyntaxKind.InferKeyword */) {
            changeInferToUnknown(changes, sourceFile, token);
          }
          break;
        default:
          ts.Debug.fail(JSON.stringify(context.fixId));
      }
    });
  },
});
function changeInferToUnknown(changes, sourceFile, token) {
  changes.replaceNode(sourceFile, token.parent, ts.factory.createKeywordTypeNode(157 /* SyntaxKind.UnknownKeyword */));
}
function createDeleteFix(changes, diag) {
  return codefix.createCodeFixAction(
      fixName, changes, diag, fixIdDelete, ts.Diagnostics.Delete_all_unused_declarations);
}
function deleteTypeParameters(changes, sourceFile, token) {
  changes.delete(
      sourceFile,
      ts.Debug.checkDefined(
          ts.cast(token.parent, ts.isDeclarationWithTypeParameterChildren).typeParameters,
          'The type parameter to delete should exist'));
}
function isImport(token) {
  return token.kind === 100 /* SyntaxKind.ImportKeyword */
      || token.kind === 79 /* SyntaxKind.Identifier */ &&
      (token.parent.kind === 273 /* SyntaxKind.ImportSpecifier */ ||
       token.parent.kind === 270 /* SyntaxKind.ImportClause */);
}
/** Sometimes the diagnostic span is an entire ImportDeclaration, so we should remove the whole thing. */
function tryGetFullImport(token) {
  return token.kind === 100 /* SyntaxKind.ImportKeyword */ ? ts.tryCast(token.parent, ts.isImportDeclaration) :
                                                             undefined;
}
function canDeleteEntireVariableStatement(sourceFile, token) {
  return ts.isVariableDeclarationList(token.parent) && ts.first(token.parent.getChildren(sourceFile)) === token;
}
function deleteEntireVariableStatement(changes, sourceFile, node) {
  changes.delete(sourceFile, node.parent.kind === 240 /* SyntaxKind.VariableStatement */ ? node.parent : node);
}
function deleteDestructuringElements(changes, sourceFile, node) {
  ts.forEach(node.elements, function(n) {
    return changes.delete(sourceFile, n);
  });
}
function tryPrefixDeclaration(changes, errorCode, sourceFile, token) {
  // Don't offer to prefix a property.
  if (errorCode === ts.Diagnostics.Property_0_is_declared_but_its_value_is_never_read.code)
    {return;}
  if (token.kind === 138 /* SyntaxKind.InferKeyword */) {
    token = ts.cast(token.parent, ts.isInferTypeNode).typeParameter.name;
  }
  if (ts.isIdentifier(token) && canPrefix(token)) {
    changes.replaceNode(sourceFile, token, ts.factory.createIdentifier('_'.concat(token.text)));
    if (ts.isParameter(token.parent)) {
      ts.getJSDocParameterTags(token.parent).forEach(function(tag) {
        if (ts.isIdentifier(tag.name)) {
          changes.replaceNode(sourceFile, tag.name, ts.factory.createIdentifier('_'.concat(tag.name.text)));
        }
      });
    }
  }
}
function canPrefix(token) {
  switch (token.parent.kind) {
    case 166 /* SyntaxKind.Parameter */:
    case 165 /* SyntaxKind.TypeParameter */:
      return true;
    case 257 /* SyntaxKind.VariableDeclaration */: {
      const varDecl = token.parent;
      switch (varDecl.parent.parent.kind) {
        case 247 /* SyntaxKind.ForOfStatement */:
        case 246 /* SyntaxKind.ForInStatement */:
          return true;
      }
    }
  }
  return false;
}
function tryDeleteDeclaration(sourceFile, token, changes, checker, sourceFiles, program, cancellationToken, isFixAll) {
  tryDeleteDeclarationWorker(token, changes, sourceFile, checker, sourceFiles, program, cancellationToken, isFixAll);
  if (ts.isIdentifier(token)) {
    ts.FindAllReferences.Core.eachSymbolReferenceInFile(token, checker, sourceFile, function(ref) {
      if (ts.isPropertyAccessExpression(ref.parent) && ref.parent.name === ref)
        {ref = ref.parent;}
      if (!isFixAll && mayDeleteExpression(ref)) {
        changes.delete(sourceFile, ref.parent.parent);
      }
    });
  }
}
function tryDeleteDeclarationWorker(
    token, changes, sourceFile, checker, sourceFiles, program, cancellationToken, isFixAll) {
  const parent = token.parent;
  if (ts.isParameter(parent)) {
    tryDeleteParameter(changes, sourceFile, parent, checker, sourceFiles, program, cancellationToken, isFixAll);
  } else if (!(isFixAll && ts.isIdentifier(token) &&
               ts.FindAllReferences.Core.isSymbolReferencedInFile(token, checker, sourceFile))) {
    const node = ts.isImportClause(parent) ? token : ts.isComputedPropertyName(parent) ? parent.parent : parent;
    ts.Debug.assert(node !== sourceFile, 'should not delete whole source file');
    changes.delete(sourceFile, node);
  }
}
function tryDeleteParameter(
    changes, sourceFile, parameter, checker, sourceFiles, program, cancellationToken, isFixAll) {
  if (isFixAll === void 0) {
    isFixAll = false;
  }
  if (mayDeleteParameter(checker, sourceFile, parameter, sourceFiles, program, cancellationToken, isFixAll)) {
    if (parameter.modifiers && parameter.modifiers.length > 0 &&
        (!ts.isIdentifier(parameter.name) ||
         ts.FindAllReferences.Core.isSymbolReferencedInFile(parameter.name, checker, sourceFile))) {
      for (let _i = 0, _a = parameter.modifiers; _i < _a.length; _i++) {
        const modifier = _a[_i];
        if (ts.isModifier(modifier)) {
          changes.deleteModifier(sourceFile, modifier);
        }
      }
    } else if (!parameter.initializer && isNotProvidedArguments(parameter, checker, sourceFiles)) {
      changes.delete(sourceFile, parameter);
    }
  }
}
function isNotProvidedArguments(parameter, checker, sourceFiles) {
  const index = parameter.parent.parameters.indexOf(parameter);
  // Just in case the call didn't provide enough arguments.
  return !ts.FindAllReferences.Core.someSignatureUsage(parameter.parent, sourceFiles, checker, function(_, call) {
    return !call || call.arguments.length > index;
  });
}
function mayDeleteParameter(checker, sourceFile, parameter, sourceFiles, program, cancellationToken, isFixAll) {
  const parent = parameter.parent;
  switch (parent.kind) {
    case 171 /* SyntaxKind.MethodDeclaration */:
    case 173 /* SyntaxKind.Constructor */:
      var index = parent.parameters.indexOf(parameter);
      var referent = ts.isMethodDeclaration(parent) ? parent.name